<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>梦不成</title>
    <link>https://shulu520.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>君子生非异也，善假于物也.</description>
    <pubDate>Tue, 14 May 2019 15:01:06 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>nodejs-guigu-note</title>
      <link>https://shulu520.com/node/nodejs-guigu-note/</link>
      <guid>https://shulu520.com/node/nodejs-guigu-note/</guid>
      <pubDate>Tue, 14 May 2019 14:50:21 GMT</pubDate>
      <description>
      
        硅谷nodejs视频教程笔记
      
      </description>
      
      <content:encoded><![CDATA[<center><h2><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;">write to me</a></h2></center><hr><p>&emsp;&emsp;我期待有一天背着背包出现在你的城市。</p><hr><a id="more"></a><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul><li>小娜 输入 环境变量 进入环境变量/用户变量/path 点开 里面是一条条的文件路劲 可以新建一个文件的路劲</li><li>在这里配置了 相当于 声明了一个 类似于 js 中的全局变量 为作用域链的最高层</li><li>可以将一些常用的文件或程序的路劲添加到path下 这样我们就可以在任意的位置访问他们了</li></ul><h2 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程 线程"></a>进程 线程</h2><ul><li>进程<br>  负责为程序的运行提供必备的环境<br>  工厂的车间</li><li>线程<br>  负责执行进程中的程序<br>  车间工人</li><li>单线程<br>  一个人干活</li><li>多线程<br>  多人合作干一个活 </li></ul><h2 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h2><ul><li>事件驱动</li><li>非阻塞</li><li>异步I/O  (性能瓶颈阶段)  input写入操作  output读操作</li><li>版本 奇数为开发版  偶数为稳定版</li></ul><h2 id="node-js-模块化"><a href="#node-js-模块化" class="headerlink" title="node.js 模块化"></a>node.js 模块化</h2><ul><li>新建一个js文件就是一个模块</li><li>这个模块里面写的代码其实是包在一个函数里面的 即</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">funcyion (exports, require, module, _filename, _dirname) &#123;</span><br><span class="line">/*</span><br><span class="line">这里是我们写的代码 外面其实包了一层这个函数 默认不可见</span><br><span class="line">可以通过console.log(arguments.callee) 或</span><br><span class="line">  console.log(arguments.callee + &quot;&quot;) 将此函数打印出来 </span><br><span class="line">  该函数执行时传进了5个参数</span><br><span class="line">所以模块里面的代码是局部变量</span><br><span class="line">exports参数 用来将变量或函数暴露到外边</span><br><span class="line">require参数 用来引入外部的模块</span><br><span class="line">module参数 代表模块本身 exports是module的属性</span><br><span class="line">_filename 当前模块的完整路劲</span><br><span class="line">_dirname 当前模块所在文件夹的路劲</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>module.exports 与exports的区别<br>  module.exports == exports  true<br>  exports 只能使用.的方式向外暴露 若exports = {} 这样向外暴露的话就修改了exports的引用对象<br>  module.exports 既可以通过.的形式 也可以直接赋值 <code>推荐写法</code></li><li>核心模块<br>  由node 提供的模块 node_moudle中的 引入时直接写模块名字 不需要路劲 </li><li>文件模块<br>  由我们自己创建的模块   引入时添加./或../等路劲</li></ul><h2 id="包-package"><a href="#包-package" class="headerlink" title="包 package"></a>包 package</h2><ul><li>包实际上就是一个压缩文件 解压以后还原为目录</li><li>规范的目录包含以下文件：<br>  -package.json <code>包描述文件</code> (必须的) <code>里面不能写注释</code><br>  -bin 可执行二进制文件  binary 二进制<br>  -lib js代码 library 库 图书馆<br>  -doc 文档 document<br>  -test 单元测试</li></ul><h2 id="npm-即-Node-Package-Manager-node包管理器"><a href="#npm-即-Node-Package-Manager-node包管理器" class="headerlink" title="npm 即 (Node Package Manager) node包管理器"></a>npm 即 (Node Package Manager) node包管理器</h2><ul><li>commonjs包规范的是一种理论 npm是其中一种实践</li><li>对node而言 npm帮助其完成了第三方模块的发布安和依赖</li><li>借助npm 使得node与第三方模块之间形成一个生态系统</li><li>查看版本 npm version查看相关的版本 或npm -v</li><li>npm search 包名 搜索包</li><li>npm init 在某一文件夹下初始化该文件夹 帮助我们根据提示生成一个package.json的文件<br>  在初始化后的文件夹下 安装搜索的包 并新建一个index.js 入口文件在里面就可以直接引入math模块使用了</li><li>npm install 包名 安装 包 或npm i</li><li>npm remove 或 npm r  删除包 </li><li>npm install 包名 杠杠save  安装包并添加到依赖中</li><li>npm install 下载当前项目所依赖的包</li><li>npm install 包名 -g 全局安装包 一般是安装一些工具 如vue-cli </li><li>cnpm 也可以用 快速</li><li>node在使用下载的包时 会沿着作用域链一直往上找直到磁盘根目录找不到则报错 这就解释了某的包在删除之后依然能用的情况</li></ul><h2 id="Buffer-（缓冲区）"><a href="#Buffer-（缓冲区）" class="headerlink" title="Buffer （缓冲区）"></a>Buffer （缓冲区）</h2><ul><li>结构和数组很相似 方法也类似</li><li>补充了数组方法的不足 Buffer专门存贮二进制数据的</li><li>使用buffer无需引入模块 直接使用即可</li><li>Buffer.from(str) 将字符串str转为buffer二进制数据</li><li>在buffer中存贮的都是二进制数据 但在显示时都是以16进制的形式显示的<br>  二进制 00-255 或 00-ff</li><li>计算机 一个0或一个1 称为一位(bit)</li><li>8bit = 1byte(字节) 最小单位 中文一个汉字占用三个字节</li><li>创建一个制定大小的buffer<br>  Buffer.alloc(10) 10字节大小<br>  可通过索引来操作buffer中的元素</li><li>Buffer的大小一旦确定 不能再更该 因为存储空间是连续的 性能好</li><li>buf.toString() 将缓冲区buf中的数据转换为字符串</li></ul><h2 id="fs-文件系统"><a href="#fs-文件系统" class="headerlink" title="fs (文件系统)"></a>fs (文件系统)</h2><ul><li>核心模块 直接引入使用</li><li>const fs = require(‘fs’)</li><li>fs 模块中所有的操作都有两种形式 同步(会阻塞 带sync) 异步(不会阻塞 带回调函数)</li><li><p>同步文件的写入：<br>  1.打开文件<br>  操作方式为定为写 即<br>  var fd = fs.openSync(path, flags) 参数为字符串类型</p><pre><code>path即文件的路劲flags即 r表示读操作  w表示写入操作</code></pre><p>  通过返回的描述符fd对文件进行各种操作 </p><p>  2.写入内容数据<br>  fs.writeSync(fd, string)</p><pre><code>fd文件的描述符 需要传入文件的描述符string要写入的内容</code></pre><p>  3.关闭文件 考虑性能<br>  fs.closeSync(fd)</p></li><li><p>异步文件写入<br>  1.打开文件<br>  fs.open(path, flags, function (err, fd) {</p><pre><code>if (!err) {    2.在这里往文件写入内容 写操作    fs.write(fd, &apos;要异步写入的内容&apos;, function (err) {        if (!err) {            console.log(&apos;write success&apos;)        }        fs.close(fd, function (err) {            if (!err) {                console.log(&apos;close success&apos;)            }        })    })    console.log(fd)}else{    console.log(err)}</code></pre><p>  })<br>  返回值为 callback的参数</p></li><li><p>简单文件写入<br>  简单同步文件<br>  fs.write<br>  简单异步文案<br>  fs.writeFile(‘hello.txt’, ‘shulu520’, {flag: ‘a’} function (err) { //flag: ‘a’ 追加文件内容 不会覆盖原来的 如果文件不存在则创建 flag还有好多的模式</p><pre><code>if (!err) {    console.log(&apos;write success&apos;)}//文件路劲可以是F:\JSdownload\npm-test 这种 `但是要变为`F:\\JSdownload\\npm-test或F:/JSdownload/npm-test</code></pre><p>  })</p></li><li><p>同步 异步 简单文件 的写入都不适合大文件爱的写入 易导致内存溢出 性能差</p></li><li>流式文件写入<br>  创建流<br>  var ws = fs.createWriteStream(path)<br>  监听事件 once绑定一次性的事件<br>  ws.once(‘open’, function () { <pre><code>console.log(&apos;stream success&apos;)</code></pre>  })<br>  ws.once(‘close’, function () {<pre><code>console.log(&apos;stream close&apos;)</code></pre>  })<br>  写入内容 大量内容<br>  ws.write(‘写入内容1’)<br>  ws.write(‘写入内容2’)<br>  ws.write(‘写入内容3’)<br>  ws.write(‘写入内容4’)<br>  ……<br>  关闭流 在流开始的一方结束流<br>  ws.end()</li></ul><hr><p>&emsp;&emsp;未完待续……<br>&emsp;&emsp;</p><h2><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me</a></h2><p></p><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/node/nodejs-guigu-note/#disqus_thread</comments>
    </item>
    
    <item>
      <title>es6-zhuf-01.md</title>
      <link>https://shulu520.com/es6/es6-zhuf-01/</link>
      <guid>https://shulu520.com/es6/es6-zhuf-01/</guid>
      <pubDate>Mon, 13 May 2019 15:46:29 GMT</pubDate>
      <description>
      
        zhuf架构视频教程笔记
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;想要的东西，会以最快的速度来到你的身边。</p><hr><a id="more"></a><h2 id="var-与-let-和-const-的区别"><a href="#var-与-let-和-const-的区别" class="headerlink" title="var 与 let 和 const 的区别"></a>var 与 let 和 const 的区别</h2><p>新的方法解决了老方法遗留的问题</p><ul><li><p>var<br>  在同一作用域内可以对同一变量重复声明<br>  不能定义常量(控制不了，因为可以修改，写了等于没写)<br>  不支持块级作用域</p></li><li><p>let<br>  在同一作用域内不能对同一变量重复声明<br>  变量不会提升 变量定义之前使用会报错<br>  有块级作用域 {这里面为块级作用域}<br>  以前js只有两种作用域 一个是全局 一个是函数级<br>  作用域经典问题： for 循环里面套 定时器 当时的解决方法 给定时器包一层自执行的匿名函数并将循环变量传进去 本质上是作用域问题 现在用let声明变量就可以了</p></li><li><p>const<br>  在同一作用域内不能对同一变量重复声明<br>  专门声明常量 常量声明后不可修改<br>  但若此常量是一个引用类型的话(例如一个对象) 引用对象的属性还是可以改的 例如：定义 const USER = {name: ‘shulu’} 更改为 USER.name = ‘lqy’ 可以的</p></li></ul><h2 id="解构-分解一个对象的解构"><a href="#解构-分解一个对象的解构" class="headerlink" title="解构 分解一个对象的解构"></a>解构 分解一个对象的解构</h2><ul><li>解构的时候 等号的两边解构相似 右边必须是一个真实的值</li><li>数组的省略赋值<br>  let arr = [1, 2, 3]; let [,,x] = arr 则只拿到x=3的值</li></ul><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><ul><li>以前是字符串拼串 现在是这个符号  <code></code> 可以折行 换行</li><li>模板语言的原理 正则实现 面试</li><li>带参数的模板字符串</li><li>字符串的新方法 返回布尔值<br>  str.startWith(‘http’)<br>  str.endsWith(‘.com’)<br>  str.includes(‘shulu’) 以前 str.indexOf(‘shulu’) == -1  做判断<br>  str.repeat(10) 重复10次</li></ul><h2 id="es6-函数"><a href="#es6-函数" class="headerlink" title="es6 函数"></a>es6 函数</h2><ul><li></li></ul><hr><p>&emsp;&emsp;未完待续……</p><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/es6/es6-zhuf-01/#disqus_thread</comments>
    </item>
    
    <item>
      <title>git-guigu-note</title>
      <link>https://shulu520.com/git/git-guigu-note/</link>
      <guid>https://shulu520.com/git/git-guigu-note/</guid>
      <pubDate>Sun, 12 May 2019 15:21:02 GMT</pubDate>
      <description>
      
        尚硅谷git&amp;github视频学习笔记，超详细
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;在衰老到来之前，做一件值得做的事情。做这件事不是为了别的，而是为了证明自己是好样的。-《似水流年》</p><hr><a id="more"></a><h3 id="复制-选中后-Ctrl-ins-即键盘右上角的insert键"><a href="#复制-选中后-Ctrl-ins-即键盘右上角的insert键" class="headerlink" title="复制 选中后 Ctrl+ins  即键盘右上角的insert键"></a>复制 选中后 Ctrl+ins  即键盘右上角的insert键</h3><h3 id="粘贴-相应的位置-Shift-ins"><a href="#粘贴-相应的位置-Shift-ins" class="headerlink" title="粘贴 相应的位置 Shift+ins"></a>粘贴 相应的位置 Shift+ins</h3><h3 id="查看git-配置信息cat-gitconfig"><a href="#查看git-配置信息cat-gitconfig" class="headerlink" title="查看git 配置信息cat ~/.gitconfig"></a>查看git 配置信息cat ~/.gitconfig</h3><h3 id="状态查看-git-status-查看工作区、暂存区状态"><a href="#状态查看-git-status-查看工作区、暂存区状态" class="headerlink" title="状态查看 git status 查看工作区、暂存区状态"></a>状态查看 git status 查看工作区、暂存区状态</h3><h3 id="文件内容查看-cat-haha-txt"><a href="#文件内容查看-cat-haha-txt" class="headerlink" title="文件内容查看 cat haha.txt"></a>文件内容查看 cat haha.txt</h3><h3 id="添加操作-git-add-file-name"><a href="#添加操作-git-add-file-name" class="headerlink" title="添加操作 git add [file_name]"></a>添加操作 git add [file_name]</h3><h3 id="git-commit-m-‘说明信息’-file-name"><a href="#git-commit-m-‘说明信息’-file-name" class="headerlink" title="git commit -m ‘说明信息’ [file_name]"></a>git commit -m ‘说明信息’ [file_name]</h3><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><ul><li>touch haha.txt 或 vim good.txt </li><li>字母ll 列出本地库所有文件和文件总数，创建日期 时间 创建人 文件名 </li></ul><h3 id="git-add-haha-txt-后-若想返回add前的状态-根据提示-git-rm-–cached-haha-txt-即可返回，此删除只是从暂存区里面删除，工作区的文件还在"><a href="#git-add-haha-txt-后-若想返回add前的状态-根据提示-git-rm-–cached-haha-txt-即可返回，此删除只是从暂存区里面删除，工作区的文件还在" class="headerlink" title="git add haha.txt 后 若想返回add前的状态 根据提示 git rm –cached haha.txt 即可返回，此删除只是从暂存区里面删除，工作区的文件还在"></a>git add haha.txt 后 若想返回add前的状态 根据提示 git rm –cached haha.txt 即可返回，此删除只是从暂存区里面删除，工作区的文件还在</h3><h3 id="git-commit-haha-txt-这里没带-m-‘说明信息’-回车后会进入vim-编辑器-可以编写大量的说明信息"><a href="#git-commit-haha-txt-这里没带-m-‘说明信息’-回车后会进入vim-编辑器-可以编写大量的说明信息" class="headerlink" title="git commit haha.txt  这里没带-m ‘说明信息’  回车后会进入vim 编辑器 可以编写大量的说明信息"></a>git commit haha.txt  这里没带-m ‘说明信息’  回车后会进入vim 编辑器 可以编写大量的说明信息</h3><ul><li>首先 按a键 进入插入模式，之后就可以进行编辑了。</li><li>编辑完了就可以按Esc键退出插入模式，然后输出:wq即可退出vim编辑器，回到git bash界面。</li></ul><h3 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h3><ul><li>git log  打印的记录风格： 分散 有作者 邮箱 日期提示，显示内容详细，内容多了，多屏显示控制方式：桥空格为向下翻页，b键为向上翻页，q 键为退出查看</li><li>git log –oneline 打印效果为一行</li><li>git reflog  打印的记录风格： 紧凑 在一行显示并有提示版本回退数字提示</li></ul><h3 id="版本前进后退"><a href="#版本前进后退" class="headerlink" title="版本前进后退"></a>版本前进后退</h3><ul><li>基于索引值操作 任意版本穿梭 <code>推荐方法</code> git reset –hard alfe9cd  这里alfe9cd为某一版本的提交id值即索引值</li><li>基于符号 ^ 只能后退  返回上一个版本 git reset –hard HEAD^  版本倒退三个 git reset –hard HEAD^^^ </li><li>基于符号 ~ 只能后退  版本倒退三个 git reset –hard HEAD~3</li></ul><h3 id="reset-命令的三个参数对比"><a href="#reset-命令的三个参数对比" class="headerlink" title="reset 命令的三个参数对比"></a>reset 命令的三个参数对比</h3><ul><li>–soft 仅仅在本地库移动HEAD指针</li><li>–mixed 在本地库移动HEAD指针,重置暂存区</li><li>–hard 在本地库移动HEAD指针,重置暂存区,重置工作区，三个区位置保持一致</li></ul><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><ul><li>rm aaa.txt</li><li>git status 显示为 红色 deleted: aaa.txt</li><li>提示要add该文件 git add aaa.txt</li><li>git status  显示为 绿色 表示已添加到暂存区</li><li>git commit -m ‘deleted aaa.txt’ 将这次删除操作提交到本地库</li></ul><h3 id="删除文件并恢复"><a href="#删除文件并恢复" class="headerlink" title="删除文件并恢复"></a>删除文件并恢复</h3><ul><li>前提：删除前 文件的状态提交到了本地库</li><li>操作： git reset –hard [指针位置]<br>  删除操作已经提交到本地库：指针位置指向包含删除文件的历史纪录<br>  删除操作尚未提交到本地库：指针位置使用HEAD</li></ul><h3 id="比较文件差异"><a href="#比较文件差异" class="headerlink" title="比较文件差异"></a>比较文件差异</h3><ul><li>git diff [文件名] 将工作区的文件和暂存区进行比较</li><li>git diff [本地库中历史版本] [文件名] 将工作区的文件和本地历史记录比较</li><li>git diff 不带文件名 比较多个文件</li></ul><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><ul><li>热修复 主分支的bug 更改  分一个 hot_fix 分支</li><li>分支的好处：</li><li>查看分支 git branch -v</li><li>创建分支 git branch hot_fix</li><li>切换分支 git checkout hot_fix   切换到这个分支</li><li><p>合并分支<br>  第一步：切换到接受修改的分支(被合并，增加新内容)上 git checkout [接受修改的分支]<br>  第二步：在接受修改的分支上执行命令  git merge [有新内容的分支]</p></li><li><p>解决合并分支后产生的冲突<br>  分别在两个分支上修改内容 分别提交到本地库 比如都在haha.txt上做修改<br>  将两个分支合并到一个分支上 出现合并冲突<br>  vim haha.txt 查看合并后的状态<br>  HEAD 部分表示当前分支的修改<br>  在一行========之下为另一个分支上做的修改<br>  解决方法：</p><pre><code>一：删掉那些特殊符号 并手动将内容修改为满意的状态 期间可能与分支伙伴商量 保存退出二：git add [文件名]三：git commit -m &apos;日志说明&apos;  注意：此时commit `一定不能带 文件名`</code></pre></li></ul><h3 id="git-原理-哈希算法"><a href="#git-原理-哈希算法" class="headerlink" title="git 原理 哈希算法"></a>git 原理 哈希算法</h3><ul><li>明文 加密 得 密文</li><li>常见的 md5算法   git 底层 SHA-1算法</li></ul><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><h3 id="克隆的效果"><a href="#克隆的效果" class="headerlink" title="克隆的效果"></a>克隆的效果</h3><ul><li>完整的把远程库克隆到本地</li><li>初始化本地库</li></ul><h3 id="邀请队员加入"><a href="#邀请队员加入" class="headerlink" title="邀请队员加入"></a>邀请队员加入</h3><ul><li>github进入相应的项目 /settings/Collaborators/</li><li>在Search by username 之下 添加成员的github账号名  add collaborator</li><li>copy invite link </li><li>发送给队员（qq或邮箱等方式）等其他方式把邀请链接发送给队员</li><li>队员 登录github 后 Accepe invitation</li><li>队员拉取操作<br> pull=fetch+merge<br> git fetch [远程库地址别名] [远程分支名]<br> git merge [远程库地址别名/远程分支名]<br> git pull [远程库地址别名] [远程分支名]</li></ul><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ul><li>如果不是基于 GitHub 远程库的<code>最新版</code>所做的修改，则不能推送，必须先拉取。</li><li>拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即</li></ul><h3 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h3><ul><li>外团队人员fork 该项目</li></ul><h3 id="git-工作流"><a href="#git-工作流" class="headerlink" title="git 工作流"></a>git 工作流</h3><p>分支种类<br> 主干分支 master<br>主要负责管理正在运行的生产环境代码。永远保持与正在运行的生产环境<br>完全一致。<br> 开发分支 develop<br>主要负责管理正在开发过程中的代码。一般情况下应该是最新的代码。<br> bug 修理分支 hotfix<br>主要负责管理生产环境下出现的紧急修复的代码。 从主干分支分出，修<br>理完毕并测试上线后，并回主干分支。并回后，视情况可以删除该分支。<br> 准生产分支（预发布分支） release<br>较大的版本上线前，会从开发分支中分出准生产分支，进行最后阶段的集<br>成测试。该版本上线后，会合并到主干分支。生产环境运行一段阶段较稳定后<br>可以视情况删除。<br> 功能分支 feature<br>为了不影响较短周期的开发工作，一般把中长期开发模块，会从开发分支</p><h2 id="中独立出来。-开发完成后会合并到开发分支。"><a href="#中独立出来。-开发完成后会合并到开发分支。" class="headerlink" title="中独立出来。 开发完成后会合并到开发分支。"></a>中独立出来。 开发完成后会合并到开发分支。</h2><p>&emsp;&emsp;完 更多笔记看git&amp;github.pdf详细笔记</p><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/git/git-guigu-note/#disqus_thread</comments>
    </item>
    
    <item>
      <title>vue-tour</title>
      <link>https://shulu520.com/vue/vue-tour/</link>
      <guid>https://shulu520.com/vue/vue-tour/</guid>
      <pubDate>Fri, 10 May 2019 16:09:17 GMT</pubDate>
      <description>
      
        A vue.js project vue-tour 去哪儿(vue@2.5)
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;I love three things in this world. Sun, Moon, and You. Sun for morning, Moon for night, and You forever.浮世三千，吾爱有三，日、月与卿。日为朝，月为暮，卿为朝朝暮暮。</p><hr><a id="more"></a><blockquote><p>A Vue.js project-去哪儿旅行，vue学习练手小项目。</p></blockquote><h3 id="Build-Setup"><a href="#Build-Setup" class="headerlink" title="Build Setup"></a>Build Setup</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install dependencies</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># serve with hot reload at localhost:8080</span></span><br><span class="line">npm run dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># build for production with minification</span></span><br><span class="line">npm run build</span><br><span class="line"></span><br><span class="line"><span class="comment"># build for production and view the bundle analyzer report</span></span><br><span class="line">npm run build --report</span><br></pre></td></tr></table></figure><h3 id="css-省略号…"><a href="#css-省略号…" class="headerlink" title="css 省略号…"></a>css 省略号…</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">overflow hidden</span><br><span class="line">white-space nowrap</span><br><span class="line">text-overflow ellipsis</span><br></pre></td></tr></table></figure><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><ul><li>如果这个项目是从github 上克隆来的 初始化时直接   vue init  webpack     注意这里不用再加初始化的项目名称</li></ul><h3 id="修改-标签"><a href="#修改-标签" class="headerlink" title="修改 标签 "></a>修改 标签 <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"></h3><h3 id="路劲优化，简化-在webpack-中配置"><a href="#路劲优化，简化-在webpack-中配置" class="headerlink" title="路劲优化，简化 ,在webpack 中配置"></a>路劲优化，简化 ,在webpack 中配置</h3><ul><li>build/webpack.base.conf.js   的alias 下面是vue-cli 配置好的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;,</span><br><span class="line">  &apos;@&apos;: resolve(&apos;src&apos;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>import HelloWorld from ‘@/components/HelloWorld’ 其中的 @ 表示src目录</li><li>在css 样式中 import ‘~@/assets/styles/varibles.styl’ 其中的 ~@ 表示src目录</li></ul><h3 id="移动端快速点击"><a href="#移动端快速点击" class="headerlink" title="移动端快速点击"></a>移动端快速点击</h3><ul><li>npm i fastclick –save  解决300毫秒延迟</li><li>在main.js 中 </li><li>import fastClick from ‘fastclick’</li><li>fastClick.attach(document.body)</li></ul><h3 id="css代码编辑工具-stylus"><a href="#css代码编辑工具-stylus" class="headerlink" title="css代码编辑工具 stylus"></a>css代码编辑工具 stylus</h3><ul><li>npm i stylus –save</li><li>npm i stylus-loader –save</li></ul><h3 id="阿里图标-进入网站后-图标管理-我的项目-新建项目"><a href="#阿里图标-进入网站后-图标管理-我的项目-新建项目" class="headerlink" title="阿里图标 进入网站后 /图标管理/我的项目/新建项目"></a>阿里图标 进入网站后 /图标管理/我的项目/新建项目</h3><h3 id="1px-使用的是硅谷外卖-stylus-mixins-styl"><a href="#1px-使用的是硅谷外卖-stylus-mixins-styl" class="headerlink" title="1px 使用的是硅谷外卖 stylus/mixins.styl"></a>1px 使用的是硅谷外卖 stylus/mixins.styl</h3><ul><li>使用 @import ‘~@/assets/styles/border.styl’</li><li>某一个样式下 bottom-border-1px(#ccc) 自己传一个色值</li></ul><h3 id="github-创建新分支index-swiper"><a href="#github-创建新分支index-swiper" class="headerlink" title="github 创建新分支index-swiper"></a>github 创建新分支index-swiper</h3><h3 id="本地-git-pull-将分支拉到本地"><a href="#本地-git-pull-将分支拉到本地" class="headerlink" title="本地 git pull 将分支拉到本地"></a>本地 git pull 将分支拉到本地</h3><h3 id="切换到这个分支-git-checkout-index-swiper"><a href="#切换到这个分支-git-checkout-index-swiper" class="headerlink" title="切换到这个分支 git checkout index-swiper"></a>切换到这个分支 git checkout index-swiper</h3><h3 id="轮播图-npm-i-vue-awesome-swiper-2-6-7-–save"><a href="#轮播图-npm-i-vue-awesome-swiper-2-6-7-–save" class="headerlink" title="轮播图 npm i vue-awesome-swiper@2.6.7 –save"></a>轮播图 npm i <a href="mailto:vue-awesome-swiper@2.6.7" target="_blank" rel="noopener">vue-awesome-swiper@2.6.7</a> –save</h3><ul><li><a href="https://github.com/surmon-china/vue-awesome-swiper" target="_blank" rel="noopener">官网具体配置</a></li></ul><h3 id="轮播图-index-swiper-开发完成后"><a href="#轮播图-index-swiper-开发完成后" class="headerlink" title="轮播图 index-swiper 开发完成后"></a>轮播图 index-swiper 开发完成后</h3><ul><li>git add .</li><li>git commit -m ‘swiper finished’</li><li>git push  </li><li>git checkout master</li><li>git merge  index-swiper  将index-swiper 分支的文件 合并到master主分支</li><li>git push </li></ul><h3 id="在浏览器中自动打开"><a href="#在浏览器中自动打开" class="headerlink" title="在浏览器中自动打开"></a>在浏览器中自动打开</h3><ul><li>config/index.js </li><li>修改里面的配置，把autoOpenBrowser:false改为autoOpenBrowser:true即可</li></ul><h3 id="布局-高度"><a href="#布局-高度" class="headerlink" title="布局 高度"></a>布局 高度</h3><ul><li>height 0<br>padding-bottom 33.9% </li><li>用padding-bottom 的值撑开高度 即高宽比</li></ul><h3 id="Git出现-MERGING解决"><a href="#Git出现-MERGING解决" class="headerlink" title="Git出现|MERGING解决"></a>Git出现|MERGING解决</h3><ul><li>使用git上传或者下拉中出现MERGING，这是合并冲突了</li><li>输入命令可以正常跳转：git reset –hard head</li></ul><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><ul><li>npm install  axios –save</li><li><p>config/index.js中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">      &apos;/api&apos;: &#123;</span><br><span class="line">        target: &apos;http://localhost:8081&apos;,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &apos;^/api&apos;: &apos;/static/mock&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></li><li><p>vue 文件中</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&apos;/api/index.json&apos;)</span><br><span class="line">    .then(this.getHomeInfoSucc)</span><br></pre></td></tr></table></figure><h3 id="解决-swiper-初次显示时为最后一张图的情况"><a href="#解决-swiper-初次显示时为最后一张图的情况" class="headerlink" title="解决 swiper 初次显示时为最后一张图的情况"></a>解决 swiper 初次显示时为最后一张图的情况</h3><ul><li>是因为刚开始时是一个空数组</li><li>给swiper 加 v-if = “list.length” 即list 传过来有值的时候在加载。</li></ul><h3 id="页面滚动"><a href="#页面滚动" class="headerlink" title="页面滚动"></a>页面滚动</h3><ul><li>npm  install  better-scroll –save </li></ul><h3 id="ref-属性使用注意"><a href="#ref-属性使用注意" class="headerlink" title="ref 属性使用注意"></a>ref 属性使用注意</h3><ul><li>如果 ref 的值 是 v-for 循环产生的 </li><li>使用时 this.$refs[‘A’][0]    即第零相 才是真正的dom </li></ul><h3 id="使用函数截流-提示网站性能"><a href="#使用函数截流-提示网站性能" class="headerlink" title="使用函数截流  提示网站性能"></a>使用函数截流  提示网站性能</h3><ul><li>在 touchmove 事件中 使用 settimeout </li><li>即将一些触发特别快又频繁的代码放到 定时器里面 减少执行次数</li></ul><h3 id="vuex-状态管理"><a href="#vuex-状态管理" class="headerlink" title="vuex  状态管理"></a>vuex  状态管理</h3><ul><li>npm  install vuex  –save      安装</li><li><p>src/新建store/index.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    city: &apos;北京&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>main.js</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import store from &apos;./store&apos;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router,</span><br><span class="line">  store,       添加选项store </span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="城市选择后-直接跳转到-首页-显示相应的城市"><a href="#城市选择后-直接跳转到-首页-显示相应的城市" class="headerlink" title="城市选择后 直接跳转到 首页 显示相应的城市"></a>城市选择后 直接跳转到 首页 显示相应的城市</h3><ul><li>在事件处理 方法里面 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$store.dispatch(&apos;changeCity&apos;, city)</span><br><span class="line">this.$router.push(&apos;/&apos;)</span><br></pre></td></tr></table></figure><h3 id="localStorage-的使用"><a href="#localStorage-的使用" class="headerlink" title="localStorage 的使用"></a>localStorage 的使用</h3><ul><li>需要在外层加 tyr  catch  以防  某谢用户 避了本地存储功能 或浏览器使用隐身模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">let defaultCity = &apos;常州&apos;</span><br><span class="line">try &#123;</span><br><span class="line">  if (localStorage.city) &#123;</span><br><span class="line">    defaultCity = localStorage.city</span><br><span class="line">  &#125;</span><br><span class="line">&#125;catch (e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    city: defaultCity || &apos;常州&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    changeCity (ctx,city) &#123;</span><br><span class="line">      ctx.commit(&apos;changeCity&apos;, city)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    changeCity (state, city) &#123;</span><br><span class="line">      state.city = city</span><br><span class="line">      try &#123;</span><br><span class="line">        localStorage.city = city</span><br><span class="line">      &#125;catch (e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="mapState-的使用"><a href="#mapState-的使用" class="headerlink" title="mapState 的使用"></a>mapState 的使用</h3><ul><li>定义<br><code>import { mapState } from &#39;vuex&#39;</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapState([&apos;city&apos;])</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">也可以是</span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      currentCity: &apos;city&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><ul><li>使用   或  </li></ul><h3 id="keep-alike-的使用"><a href="#keep-alike-的使用" class="headerlink" title="keep-alike 的使用"></a>keep-alike 的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view/&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><ul><li><p>相应的组件 数据 加载一次后会保存到内存中 下次调用 直接取 提升性能</p></li><li><p>vue 实例 选项中多了一个生命  周期钩子函数 activated, 其在页面重新显示，有变动的时候触发</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">activated () &#123;</span><br><span class="line">    if (this.lastCity !== this.city) &#123;</span><br><span class="line">      this.getHomeInfo()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="及时解除全局事件"><a href="#及时解除全局事件" class="headerlink" title="及时解除全局事件"></a>及时解除全局事件</h3><ul><li>让其只在当前组件中触发</li><li>deactivated 在页面隐藏，页面被替换为新的页面 时触发</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">activated () &#123;</span><br><span class="line">    window.addEventListener(&apos;scroll&apos;, this.handleScroll)</span><br><span class="line">  &#125;,</span><br><span class="line"> deactivated () &#123;</span><br><span class="line">    window.removeEventListener(&apos;scroll&apos;,this.handleScroll)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="递归组件的使用"><a href="#递归组件的使用" class="headerlink" title="递归组件的使用"></a>递归组件的使用</h3><ul><li>在自己组件内部 通过name 选项 的名字 作为递归组件的标签名使用<br><code>&lt;detail-list :list=&quot;item.children&quot;&gt;&lt;/detail-list&gt;</code></li></ul><h3 id="缓存相关-App-vue-中"><a href="#缓存相关-App-vue-中" class="headerlink" title="缓存相关 App.vue 中"></a>缓存相关 App.vue 中</h3><ul><li>Detail 组件不缓存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive exclude=&quot;Detail&quot;&gt;</span><br><span class="line">    &lt;router-view/&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><h3 id="解决不同页面位置的相互影响问题"><a href="#解决不同页面位置的相互影响问题" class="headerlink" title="解决不同页面位置的相互影响问题"></a>解决不同页面位置的相互影响问题</h3><ul><li>router/index.js  中加入scrollBehavior选项</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      name: &apos;Home&apos;,</span><br><span class="line">      component: Home</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  scrollBehavior (to, from, savedPosition) &#123;</span><br><span class="line">    return &#123;x: 0, y: 0&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="解决某些手机浏览器-不支持-promise-的情况"><a href="#解决某些手机浏览器-不支持-promise-的情况" class="headerlink" title="解决某些手机浏览器 不支持 promise 的情况"></a>解决某些手机浏览器 不支持 promise 的情况</h3><ul><li>npm install babel-polyfill –save</li><li>main.js 中   <code>import &#39;babel-polyfill&#39;</code></li></ul><h3 id="项目优化-按需加载js-组件-此方法-只在打包生成的app-js文件特别大（1M左右）的时候使用，小的话，不宜，因为这样会增加http-请求"><a href="#项目优化-按需加载js-组件-此方法-只在打包生成的app-js文件特别大（1M左右）的时候使用，小的话，不宜，因为这样会增加http-请求" class="headerlink" title="项目优化 按需加载js 组件  此方法 只在打包生成的app.js文件特别大（1M左右）的时候使用，小的话，不宜，因为这样会增加http 请求"></a>项目优化 按需加载js 组件  此方法 只在打包生成的app.js文件特别大（1M左右）的时候使用，小的话，不宜，因为这样会增加http 请求</h3><ul><li>router/index.js  将<code>import Home from &#39;@/pages/home/Home.vue&#39;</code>引入组件的方式去掉，配置路由为 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      name: &apos;Home&apos;,</span><br><span class="line">      component: ( ) =&gt; import(&apos;@/pages/home/Home.vue&apos;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h3 id="项目上线"><a href="#项目上线" class="headerlink" title="项目上线"></a>项目上线</h3><ul><li>npm run build   生成dist 文件夹 将dist 给后端运行</li></ul><hr><p>&emsp;&emsp; 项目正在开发完毕。</p><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/vue/vue-tour/#disqus_thread</comments>
    </item>
    
    <item>
      <title>http</title>
      <link>https://shulu520.com/http/http/</link>
      <guid>https://shulu520.com/http/http/</guid>
      <pubDate>Mon, 06 May 2019 15:32:22 GMT</pubDate>
      <description>
      
        http学习笔记
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;</p><hr><a id="more"></a><h2 id="GET-POST-的区别-前提-web浏览器环境下的RFC规范GET-用来获取信息，POST用来发送信息"><a href="#GET-POST-的区别-前提-web浏览器环境下的RFC规范GET-用来获取信息，POST用来发送信息" class="headerlink" title="GET  POST 的区别 前提:web浏览器环境下的RFC规范GET 用来获取信息，POST用来发送信息"></a>GET  POST 的区别 前提:web浏览器环境下的RFC规范GET 用来获取信息，POST用来发送信息</h2><ul><li>可见性</li><li>安全性</li><li>数据大小</li><li>编码类型</li><li>能否收藏为书签，GET可以</li><li>刷新，后退按钮，GET无影响，POST重新提交</li><li>能否保留到浏览器历史，GET保留</li></ul><hr><p>&emsp;&emsp;</p><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/http/http/#disqus_thread</comments>
    </item>
    
    <item>
      <title>net-model</title>
      <link>https://shulu520.com/net/net-model/</link>
      <guid>https://shulu520.com/net/net-model/</guid>
      <pubDate>Mon, 06 May 2019 15:28:43 GMT</pubDate>
      <description>
      
        对五层网络模型的初步认识
      
      </description>
      
      <content:encoded><![CDATA[<hr><hr><a id="more"></a><h2 id="应用层-程序，软件，应用层协议，http协议，DNS协议-域名解析-，FTP协议-文件传输协议-，SMTP-邮件传输协议"><a href="#应用层-程序，软件，应用层协议，http协议，DNS协议-域名解析-，FTP协议-文件传输协议-，SMTP-邮件传输协议" class="headerlink" title="应用层:  程序，软件，应用层协议，http协议，DNS协议(域名解析)，FTP协议(文件传输协议)，SMTP(邮件传输协议)"></a>应用层:  程序，软件，应用层协议，http协议，DNS协议(域名解析)，FTP协议(文件传输协议)，SMTP(邮件传输协议)</h2><h2 id="传输层-对数据传输的建立和管理，传输层协议，UDP协议-有丢包的可能-，TCP-保证数据的正确性，顺序性"><a href="#传输层-对数据传输的建立和管理，传输层协议，UDP协议-有丢包的可能-，TCP-保证数据的正确性，顺序性" class="headerlink" title="传输层: 对数据传输的建立和管理，传输层协议，UDP协议(有丢包的可能)，TCP(保证数据的正确性，顺序性)"></a>传输层: 对数据传输的建立和管理，传输层协议，UDP协议(有丢包的可能)，TCP(保证数据的正确性，顺序性)</h2><h2 id="网络层-好比交通网络，IP协议-IP加端口号来确定一个程序的位置"><a href="#网络层-好比交通网络，IP协议-IP加端口号来确定一个程序的位置" class="headerlink" title="网络层: 好比交通网络，IP协议(IP加端口号来确定一个程序的位置)"></a>网络层: 好比交通网络，IP协议(IP加端口号来确定一个程序的位置)</h2><h2 id="数据链路层-两个子层，一个叫逻辑链路控制子层，另一个叫媒体访问控制子层-MAC地址"><a href="#数据链路层-两个子层，一个叫逻辑链路控制子层，另一个叫媒体访问控制子层-MAC地址" class="headerlink" title="数据链路层: 两个子层，一个叫逻辑链路控制子层，另一个叫媒体访问控制子层(MAC地址)"></a>数据链路层: 两个子层，一个叫逻辑链路控制子层，另一个叫媒体访问控制子层(MAC地址)</h2><h2 id="物理层-坐公交，扫码骑车。"><a href="#物理层-坐公交，扫码骑车。" class="headerlink" title="物理层: 坐公交，扫码骑车。"></a>物理层: 坐公交，扫码骑车。</h2><h2 id="除了五层网络模型之外还有七层网络模型，那么七层网络模型是什么呢？就是将应用层一分为三，分别为：应用层，表示层和会话层。新出来的表示层和会话层没有相应的协议。一般表示层做的是数据格式化，或者加密等操作。"><a href="#除了五层网络模型之外还有七层网络模型，那么七层网络模型是什么呢？就是将应用层一分为三，分别为：应用层，表示层和会话层。新出来的表示层和会话层没有相应的协议。一般表示层做的是数据格式化，或者加密等操作。" class="headerlink" title="除了五层网络模型之外还有七层网络模型，那么七层网络模型是什么呢？就是将应用层一分为三，分别为：应用层，表示层和会话层。新出来的表示层和会话层没有相应的协议。一般表示层做的是数据格式化，或者加密等操作。"></a>除了五层网络模型之外还有七层网络模型，那么七层网络模型是什么呢？就是将应用层一分为三，分别为：应用层，表示层和会话层。新出来的表示层和会话层没有相应的协议。一般表示层做的是数据格式化，或者加密等操作。</h2>]]></content:encoded>
      
      <comments>https://shulu520.com/net/net-model/#disqus_thread</comments>
    </item>
    
    <item>
      <title>xss</title>
      <link>https://shulu520.com/safe/xss/</link>
      <guid>https://shulu520.com/safe/xss/</guid>
      <pubDate>Mon, 06 May 2019 15:23:35 GMT</pubDate>
      <description>
      
        XSS攻击过程解析
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;让一个人变强大的最好方式是拥有一个想去保护的人。</p><hr><a id="more"></a><h2 id="XSS攻击究竟是如何一步一步的获取了别人的隐私呢？下面我们就来一步一步的来进行解析。"><a href="#XSS攻击究竟是如何一步一步的获取了别人的隐私呢？下面我们就来一步一步的来进行解析。" class="headerlink" title="XSS攻击究竟是如何一步一步的获取了别人的隐私呢？下面我们就来一步一步的来进行解析。"></a>XSS攻击究竟是如何一步一步的获取了别人的隐私呢？下面我们就来一步一步的来进行解析。</h2><h2 id="1-攻击者，上传一片文章或者博客，这边文章中带有一段JS代码，这段代码内容很简单，读取本地Cookie，发送给某个url。"><a href="#1-攻击者，上传一片文章或者博客，这边文章中带有一段JS代码，这段代码内容很简单，读取本地Cookie，发送给某个url。" class="headerlink" title="1. 攻击者，上传一片文章或者博客，这边文章中带有一段JS代码，这段代码内容很简单，读取本地Cookie，发送给某个url。"></a>1. 攻击者，上传一片文章或者博客，这边文章中带有一段JS代码，这段代码内容很简单，读取本地Cookie，发送给某个url。</h2><h2 id="2-XX微博的服务器没有对用户上传的内容进行审查，就将内容存储起来。"><a href="#2-XX微博的服务器没有对用户上传的内容进行审查，就将内容存储起来。" class="headerlink" title="2. XX微博的服务器没有对用户上传的内容进行审查，就将内容存储起来。"></a>2. XX微博的服务器没有对用户上传的内容进行审查，就将内容存储起来。</h2><h2 id="3-当正常用户访问XX微博的时候，服务器将有问题的文章推送给了这个正常用户。（因为服务器并没有检查哪篇文章有问题，所以它会认为这是一篇正常的文章，以正常的方式推送给用户。）"><a href="#3-当正常用户访问XX微博的时候，服务器将有问题的文章推送给了这个正常用户。（因为服务器并没有检查哪篇文章有问题，所以它会认为这是一篇正常的文章，以正常的方式推送给用户。）" class="headerlink" title="3. 当正常用户访问XX微博的时候，服务器将有问题的文章推送给了这个正常用户。（因为服务器并没有检查哪篇文章有问题，所以它会认为这是一篇正常的文章，以正常的方式推送给用户。）"></a>3. 当正常用户访问XX微博的时候，服务器将有问题的文章推送给了这个正常用户。（因为服务器并没有检查哪篇文章有问题，所以它会认为这是一篇正常的文章，以正常的方式推送给用户。）</h2><h2 id="4-当正常的用户点开这篇文章的时候，攻击者编写的脚本就会在正常的用户的电脑上执行。（因为攻击者的脚本就是在文章的内容中加入一段script代码，浏览器会将script标签中的内容当作js代码来看待，然后执行这段代码）"><a href="#4-当正常的用户点开这篇文章的时候，攻击者编写的脚本就会在正常的用户的电脑上执行。（因为攻击者的脚本就是在文章的内容中加入一段script代码，浏览器会将script标签中的内容当作js代码来看待，然后执行这段代码）" class="headerlink" title="4. 当正常的用户点开这篇文章的时候，攻击者编写的脚本就会在正常的用户的电脑上执行。（因为攻击者的脚本就是在文章的内容中加入一段script代码，浏览器会将script标签中的内容当作js代码来看待，然后执行这段代码）"></a>4. 当正常的用户点开这篇文章的时候，攻击者编写的脚本就会在正常的用户的电脑上执行。（因为攻击者的脚本就是在文章的内容中加入一段script代码，浏览器会将script标签中的内容当作js代码来看待，然后执行这段代码）</h2><h2 id="5-这段带有攻击性的代码可以读取用户本地的cookie内容，并将内容发送给攻击者事先准备好的url。（因为正常用户在本地打开，所以不存在跨域的问题）"><a href="#5-这段带有攻击性的代码可以读取用户本地的cookie内容，并将内容发送给攻击者事先准备好的url。（因为正常用户在本地打开，所以不存在跨域的问题）" class="headerlink" title="5. 这段带有攻击性的代码可以读取用户本地的cookie内容，并将内容发送给攻击者事先准备好的url。（因为正常用户在本地打开，所以不存在跨域的问题）"></a>5. 这段带有攻击性的代码可以读取用户本地的cookie内容，并将内容发送给攻击者事先准备好的url。（因为正常用户在本地打开，所以不存在跨域的问题）</h2><h2 id="6-攻击者收到了发送过来的cookie之后，就可以将cookie内容写入自己的浏览器里，然后就能登录这个正常用户的XX微博了。"><a href="#6-攻击者收到了发送过来的cookie之后，就可以将cookie内容写入自己的浏览器里，然后就能登录这个正常用户的XX微博了。" class="headerlink" title="6. 攻击者收到了发送过来的cookie之后，就可以将cookie内容写入自己的浏览器里，然后就能登录这个正常用户的XX微博了。"></a>6. 攻击者收到了发送过来的cookie之后，就可以将cookie内容写入自己的浏览器里，然后就能登录这个正常用户的XX微博了。</h2><h2 id="（因为现在很多网站都做了免登录功能，这个功能主要是依赖于种在浏览器里的cookie，这个cookie中会带有用户的部分信息，当用户在每次进入网站的时候，由于这些cookie的存在，就可以免登录了。我们这个例子中，XSS攻击就是获取到了用户的Cookie，从而在我们的本地来将这份cookie写入到我们的浏览器里，就能登录这个正常用户的帐号了-）"><a href="#（因为现在很多网站都做了免登录功能，这个功能主要是依赖于种在浏览器里的cookie，这个cookie中会带有用户的部分信息，当用户在每次进入网站的时候，由于这些cookie的存在，就可以免登录了。我们这个例子中，XSS攻击就是获取到了用户的Cookie，从而在我们的本地来将这份cookie写入到我们的浏览器里，就能登录这个正常用户的帐号了-）" class="headerlink" title="（因为现在很多网站都做了免登录功能，这个功能主要是依赖于种在浏览器里的cookie，这个cookie中会带有用户的部分信息，当用户在每次进入网站的时候，由于这些cookie的存在，就可以免登录了。我们这个例子中，XSS攻击就是获取到了用户的Cookie，从而在我们的本地来将这份cookie写入到我们的浏览器里，就能登录这个正常用户的帐号了~）"></a>（因为现在很多网站都做了免登录功能，这个功能主要是依赖于种在浏览器里的cookie，这个cookie中会带有用户的部分信息，当用户在每次进入网站的时候，由于这些cookie的存在，就可以免登录了。我们这个例子中，XSS攻击就是获取到了用户的Cookie，从而在我们的本地来将这份cookie写入到我们的浏览器里，就能登录这个正常用户的帐号了~）</h2><h2 id="我们会发现XSS攻击最大的问题在于，服务器端在用户上传文章内容的时候，没有进行内容审查。其实，我们只要将一些危险的符号进行HTML编码就可以了，比如将‘-lt-’替换为”-lt-”，将‘-gt-’替换为”-gt-”，这样攻击者就无法通过script标签的方式来进行攻击了"><a href="#我们会发现XSS攻击最大的问题在于，服务器端在用户上传文章内容的时候，没有进行内容审查。其实，我们只要将一些危险的符号进行HTML编码就可以了，比如将‘-lt-’替换为”-lt-”，将‘-gt-’替换为”-gt-”，这样攻击者就无法通过script标签的方式来进行攻击了" class="headerlink" title="我们会发现XSS攻击最大的问题在于，服务器端在用户上传文章内容的时候，没有进行内容审查。其实，我们只要将一些危险的符号进行HTML编码就可以了，比如将‘&lt;’替换为”&lt;”，将‘&gt;’替换为”&gt;”，这样攻击者就无法通过script标签的方式来进行攻击了~"></a>我们会发现XSS攻击最大的问题在于，服务器端在用户上传文章内容的时候，没有进行内容审查。其实，我们只要将一些危险的符号进行HTML编码就可以了，比如将‘&lt;’替换为”&lt;”，将‘&gt;’替换为”&gt;”，这样攻击者就无法通过script标签的方式来进行攻击了~</h2>]]></content:encoded>
      
      <comments>https://shulu520.com/safe/xss/#disqus_thread</comments>
    </item>
    
    <item>
      <title>shanjuan</title>
      <link>https://shulu520.com/friends/shanjuan/</link>
      <guid>https://shulu520.com/friends/shanjuan/</guid>
      <pubDate>Fri, 03 May 2019 06:18:17 GMT</pubDate>
      <description>
      
        &lt;hr&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;juan，我的好朋友，好久不见，今偶然间，美好的回忆又浮现眼前，于是赶紧记下那些美好。&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;juan，我的好朋友，好久不见，今偶然间，美好的回忆又浮现眼前，于是赶紧记下那些美好。</p><hr><a id="more"></a><h2 style="color:orange"><br>&emsp;&emsp;拿起雪糕想起了你。<br>&emsp;&emsp;雪糕这玩意和辣条一样是我小时候的最爱，只是随着年岁渐长，慢慢留在记忆里了。<br>昨晚室友叫我一起去超市，逛了一圈不知买点啥，看到有人买雪糕，心想，天气热了就买个尝尝吧。打开柜子，拿起雪糕，恍惚间，温暖的记忆又浮现在眼前。<br>&emsp;&emsp;juan，我的高中同学，朋友，那时经常作我的同桌，人美心善，跟同学关系都挺好。当然对我也很好。常给我糖果啊各种小吃的，我用的笔啊书和本子啊经常从juan那直接拿。<br>&emsp;&emsp;我对juan的第一印象：juan是一个可爱的小公主，而且很高洁。机缘巧合之下，我有幸认识了juan，而且常常作同桌。这让我们之间的距离又近了一点。juan是我去到十班最早认识的同学之一。<br>&emsp;&emsp;时间久了，发生过的好多事情我就不记得了。所以我此时此刻在努力的将往事回忆，我生怕等我老了的时候，年轻时的这些美好时光要是再也回想不起来了，那样想想多遗憾啊。<br>&emsp;&emsp;juan对我一直很好，就像对其他人一样。我们除了讨论学习，还聊小时候，聊未来。关于未来，其实都是我在表达对未来的迷惑，而juan一直在开导我。juan说我们可以永远做朋友。<br>&emsp;&emsp;一个雪糕，那是高三时的一天中午你送我的，当时教室里是有其同学的，但是你只送给了我。在高三那个本就燥热的季节，让我清凉了一整个夏天。<br>&emsp;&emsp;如今再拿起雪糕，眼前浮现出都是你对我的好。感谢那时的遇见，让我能有这么美好的回忆。juan，也愿你过得好，有个好对象。要是余生能再见，我想你还是那么的漂亮，那么温柔与大气。<br>&emsp;&emsp;朋友的友谊不是三言两语就道的尽的，但都是埋藏在我的心底里的。<br></h2><hr><p>&emsp;&emsp;刚刚看qq空间里你发的说说–有人拿走了你的外卖，🤣🤣🤣</p><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/friends/shanjuan/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Math-random</title>
      <link>https://shulu520.com/Math/Math-random/</link>
      <guid>https://shulu520.com/Math/Math-random/</guid>
      <pubDate>Tue, 30 Apr 2019 16:50:45 GMT</pubDate>
      <description>
      
        js常见的几种随机数，及常见用法。
      
      </description>
      
      <content:encoded><![CDATA[<center>引言：希望你睡不着时，想起的都是那些让你开心的事</center>                <p></p><h3 style="color:blue">常见的问题：如何生成一个区间[min,max]内的随机整数？</h3><br>答案很简单，即 <code>Math.random()*(max-min)+min</code><p></p><p>以下是一些其他的方法。<br><a id="more"></a></p><h2 id="new-Date-0"><a href="#new-Date-0" class="headerlink" title="new Date() - 0"></a>new Date() - 0</h2><ul><li>new Date() 日期函数 默认会显示年月日等字符，new Date() - 0 会得到数字“秒”</li><li>(new Date() - 0)%2239 ,得到取模数值分之一概率的随机数，即[0,2239]范围内一随机数</li></ul><h2 id="toString-指定进制-方法的调用"><a href="#toString-指定进制-方法的调用" class="headerlink" title="toString(指定进制) 方法的调用"></a>toString(指定进制) 方法的调用</h2><ul><li>与parseInt() 方法一样，进制区间为 [2,36]，取36得字母多一些</li><li>随便一个随机数.toString(36)得随机字符，但有数字，且长短不一</li></ul><h2 id="随机字符串函数，长度固定，且都是字母"><a href="#随机字符串函数，长度固定，且都是字母" class="headerlink" title="随机字符串函数，长度固定，且都是字母"></a>随机字符串函数，长度固定，且都是字母</h2><ul><li>从固定的字典中抽取字符构成随机字符串</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 在大小写字母之间随机生成 x 个字符</span><br><span class="line">function randStr(x)&#123;</span><br><span class="line">    var s = &apos;&apos;;</span><br><span class="line">    while(s.length &lt; x &amp;&amp; x &gt; 0)&#123;</span><br><span class="line">        var r = Math.random();</span><br><span class="line">        s += String.fromCharCode(Math.floor(r*26) + (r &gt; 0.5 ? 97 : 65))</span><br><span class="line">    &#125;;</span><br><span class="line">    return s;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(randStr(3)); //KzE 三个随机字符</span><br></pre></td></tr></table></figure><h2 id="颜色随机函数"><a href="#颜色随机函数" class="headerlink" title="颜色随机函数"></a>颜色随机函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function randomColor()&#123;  </span><br><span class="line">    var rand = &apos;#&apos;+(&apos;00000&apos;+(Math.random()*0x1000000&lt;&lt;0).toString(16)).slice(-6);</span><br><span class="line">    return rand;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>随机数相关得知识还又有很多，后面学到了再来补充笔记</li></ul>]]></content:encoded>
      
      <comments>https://shulu520.com/Math/Math-random/#disqus_thread</comments>
    </item>
    
    <item>
      <title>book-fengchuan</title>
      <link>https://shulu520.com/book-note/book-fengchuan/</link>
      <guid>https://shulu520.com/book-note/book-fengchuan/</guid>
      <pubDate>Tue, 30 Apr 2019 16:50:45 GMT</pubDate>
      <description>
      
        《疯传》读书笔记摘要
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>深夜时，人会更加容易情绪化，所以无论多难过，都要告诉自己，没有那麽糟糕，睡一觉就好了。</p><hr><a id="more"></a><h2 id="相比广告营销，口口相传更有效，分享能让我们感觉良好，因为他会让我们显得高大上。我们更愿意与人分享能提升个人形象的信息。"><a href="#相比广告营销，口口相传更有效，分享能让我们感觉良好，因为他会让我们显得高大上。我们更愿意与人分享能提升个人形象的信息。" class="headerlink" title="相比广告营销，口口相传更有效，分享能让我们感觉良好，因为他会让我们显得高大上。我们更愿意与人分享能提升个人形象的信息。"></a>相比广告营销，口口相传更有效，分享能让我们感觉良好，因为他会让我们显得高大上。我们更愿意与人分享能提升个人形象的信息。</h2><h2 id="某些产品，思想或行为，经常出现在我们眼前时，他们的影响力和传染力就会大大增加。"><a href="#某些产品，思想或行为，经常出现在我们眼前时，他们的影响力和传染力就会大大增加。" class="headerlink" title="某些产品，思想或行为，经常出现在我们眼前时，他们的影响力和传染力就会大大增加。"></a>某些产品，思想或行为，经常出现在我们眼前时，他们的影响力和传染力就会大大增加。</h2><h2 id="从古至今，故事一直都是人们分享信息的重要工具。"><a href="#从古至今，故事一直都是人们分享信息的重要工具。" class="headerlink" title="从古至今，故事一直都是人们分享信息的重要工具。"></a>从古至今，故事一直都是人们分享信息的重要工具。</h2><h2 id="诱因，让人产生联想，看到这个，就会想到那个。"><a href="#诱因，让人产生联想，看到这个，就会想到那个。" class="headerlink" title="诱因，让人产生联想，看到这个，就会想到那个。"></a>诱因，让人产生联想，看到这个，就会想到那个。</h2><h2 id="打折规则，100元以上，降价多少元，以下为打几折。"><a href="#打折规则，100元以上，降价多少元，以下为打几折。" class="headerlink" title="打折规则，100元以上，降价多少元，以下为打几折。"></a>打折规则，100元以上，降价多少元，以下为打几折。</h2><h2><br>&emsp;&emsp;那么如何打造-个疯传的产品呢?第一，让你的产品成为一种社交货币，也就是说人们会通过分享它来赢得别人的好感和兴趣;第二，要利用诱因引发消费者的联想;第三，要带动消费者的情绪，让他们不断频繁地分享;第四，让你的产品尽可能出现在大家眼前，让人们不看都不行;第五，记得，简单实用的东西自然会受人欢迎;最后，帮你的产品量身打造一一个足够有意思的故事。<br><br>&emsp;&emsp;两个可行的建议。首先，可以让你的产品带上点竞争元素。就是说利用人们的游戏心理，大家在玩游戏的时候都喜欢跟别人比赛，获得胜利之后，会得意地和别人分享自己的战绩，同时也就相当于告诉了别人某个产品。所以，如果你的产品有了游戏元素，就能鼓励消费者用你的产品进行某种互动，这样就提高了产品被分享的可能。<br></h2>]]></content:encoded>
      
      <comments>https://shulu520.com/book-note/book-fengchuan/#disqus_thread</comments>
    </item>
    
    <item>
      <title>git-liao-note</title>
      <link>https://shulu520.com/git/git-liao-note/</link>
      <guid>https://shulu520.com/git/git-liao-note/</guid>
      <pubDate>Tue, 30 Apr 2019 16:50:45 GMT</pubDate>
      <description>
      
        廖雪峰老师的git教程学习笔记总结
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;人是不能闲的，一闲就会想得太多，一闲就会感情泛滥，所谓矫情屁事多，空虚寂寞冷，都是因为懒散寂寞闲。</p><hr><a id="more"></a><p>git 的优秀之处 它跟踪并管理的是文件的修改，而非文件。<br>Git有不少命令中有“-”，有时候是“-”，有时候是“–”。<br>学过linux的命令行就懂了，单个”-“ 后面跟的是单个字母的参数，如-m， 两个”–”后面跟的是多个字母的参数，如–readme.txt  在大多数情况下成立的。<br>注意:我的博客页面上显示的效果都只有一个’-‘,若’-‘线条显示的比较细，则表示两个’-‘</p><h1 id="创建本地版本库"><a href="#创建本地版本库" class="headerlink" title="创建本地版本库"></a>创建本地版本库</h1><h2 id="cd-到目录文件夹下"><a href="#cd-到目录文件夹下" class="headerlink" title="cd 到目录文件夹下"></a>cd 到目录文件夹下</h2><h2 id="mkdir-learn-git-新建文件夹，即版本库（repository）"><a href="#mkdir-learn-git-新建文件夹，即版本库（repository）" class="headerlink" title="mkdir learn-git  新建文件夹，即版本库（repository）"></a>mkdir learn-git  新建文件夹，即版本库（repository）</h2><h2 id="git-init-初始化版本库-即把这个目录变成git-可以管理的仓库"><a href="#git-init-初始化版本库-即把这个目录变成git-可以管理的仓库" class="headerlink" title="git init  初始化版本库,即把这个目录变成git 可以管理的仓库"></a>git init  初始化版本库,即把这个目录变成git 可以管理的仓库</h2><h2 id="ctrl-l-清屏，以防代码太多看着难受"><a href="#ctrl-l-清屏，以防代码太多看着难受" class="headerlink" title="ctrl + l  清屏，以防代码太多看着难受"></a>ctrl + l  清屏，以防代码太多看着难受</h2><h2 id="ls-查看目录下的文件"><a href="#ls-查看目录下的文件" class="headerlink" title="ls 查看目录下的文件"></a>ls 查看目录下的文件</h2><h2 id="ls-a-查看不可见的文件"><a href="#ls-a-查看不可见的文件" class="headerlink" title="ls -a 查看不可见的文件"></a>ls -a 查看不可见的文件</h2><h2 id="touch-git-test-txt-创建-txt文件-或者用vscode编辑器创建，别用windows-自带的记事本，因为记事本在编码方面有弱智的行为，"><a href="#touch-git-test-txt-创建-txt文件-或者用vscode编辑器创建，别用windows-自带的记事本，因为记事本在编码方面有弱智的行为，" class="headerlink" title="touch git-test.txt 创建 txt文件 或者用vscode编辑器创建，别用windows 自带的记事本，因为记事本在编码方面有弱智的行为，"></a>touch git-test.txt 创建 txt文件 或者用vscode编辑器创建，别用windows 自带的记事本，因为记事本在编码方面有弱智的行为，</h2><h2 id="键盘上的上键-返回上一步命令"><a href="#键盘上的上键-返回上一步命令" class="headerlink" title="键盘上的上键  返回上一步命令"></a>键盘上的上键  返回上一步命令</h2><h2 id="git-add-git-test-txt-添加要提交的文件，可多次添加多个文件，将文件添加到暂存区（stage即阶段的意思）"><a href="#git-add-git-test-txt-添加要提交的文件，可多次添加多个文件，将文件添加到暂存区（stage即阶段的意思）" class="headerlink" title="git add  git-test.txt 添加要提交的文件，可多次添加多个文件，将文件添加到暂存区（stage即阶段的意思）"></a>git add  git-test.txt 添加要提交的文件，可多次添加多个文件，将文件添加到暂存区（stage即阶段的意思）</h2><h2 id="git-commit-m-“添加描述内容，如-这是第一次使用commit提交”-可以一次提交多个文件，默认提交到master-分支"><a href="#git-commit-m-“添加描述内容，如-这是第一次使用commit提交”-可以一次提交多个文件，默认提交到master-分支" class="headerlink" title="git commit -m “添加描述内容，如 这是第一次使用commit提交”   可以一次提交多个文件，默认提交到master 分支"></a>git commit -m “添加描述内容，如 这是第一次使用commit提交”   可以一次提交多个文件，默认提交到master 分支</h2><h1 id="时光穿梭机"><a href="#时光穿梭机" class="headerlink" title="时光穿梭机"></a>时光穿梭机</h1><h2 id="git-status-查看仓库当前的状态"><a href="#git-status-查看仓库当前的状态" class="headerlink" title="git status 查看仓库当前的状态"></a>git status 查看仓库当前的状态</h2><h2 id="git-diff-查看文件的具体修改的内容-输出变化前后的内容"><a href="#git-diff-查看文件的具体修改的内容-输出变化前后的内容" class="headerlink" title="git diff  查看文件的具体修改的内容 输出变化前后的内容"></a>git diff  查看文件的具体修改的内容 输出变化前后的内容</h2><h2 id="git-log-显示从最近到最远的提交日志"><a href="#git-log-显示从最近到最远的提交日志" class="headerlink" title="git log 显示从最近到最远的提交日志"></a>git log 显示从最近到最远的提交日志</h2><h2 id="git-reset-–hard-HEAD-回退到上一个版本，HEAD表示当前版本，HEAD-即上一个版本，往上100个版本为HEAD-100"><a href="#git-reset-–hard-HEAD-回退到上一个版本，HEAD表示当前版本，HEAD-即上一个版本，往上100个版本为HEAD-100" class="headerlink" title="git reset –hard HEAD^  回退到上一个版本，HEAD表示当前版本，HEAD^即上一个版本，往上100个版本为HEAD~100"></a>git reset –hard HEAD^  回退到上一个版本，HEAD表示当前版本，HEAD^即上一个版本，往上100个版本为HEAD~100</h2><h2 id="git-reflog-用来记录我们的每一次命令即commit-的id"><a href="#git-reflog-用来记录我们的每一次命令即commit-的id" class="headerlink" title="git reflog 用来记录我们的每一次命令即commit 的id"></a>git reflog 用来记录我们的每一次命令即commit 的id</h2><h2 id="git-reset-–hard-commit-id-commit-id-为某一版本提交的具体ID"><a href="#git-reset-–hard-commit-id-commit-id-为某一版本提交的具体ID" class="headerlink" title="git reset –hard  commit_id      commit_id 为某一版本提交的具体ID"></a>git reset –hard  commit_id      commit_id 为某一版本提交的具体ID</h2><h2 id="名词解释说明"><a href="#名词解释说明" class="headerlink" title="名词解释说明"></a>名词解释说明</h2><ul><li><p>工作区： 即我们电脑上的项目文件夹，<br>版本库 ：即工作区里面的一个叫 .git 的隐藏目录，版本库里面有暂存区，有git 为我们创建的master 分支，以及指向master的一个指针HEAD</p><h2 id="管理修改-每次修改，如果不用git-add-到暂存区，就不会加入到commit-中"><a href="#管理修改-每次修改，如果不用git-add-到暂存区，就不会加入到commit-中" class="headerlink" title="管理修改  每次修改，如果不用git add 到暂存区，就不会加入到commit 中"></a>管理修改  每次修改，如果不用git add 到暂存区，就不会加入到commit 中</h2><h2 id="git-checkout-–-git-test-txt-让这个文件回到最近一次git-commit-或-git-add-时的状态，注意–是单独的即后面有空格-，git-checkout-使用版本库里面的版本替换工作区的版本-，无论工作区是修改还是删除，都可以一键还原。-我测试时为什么不行呢"><a href="#git-checkout-–-git-test-txt-让这个文件回到最近一次git-commit-或-git-add-时的状态，注意–是单独的即后面有空格-，git-checkout-使用版本库里面的版本替换工作区的版本-，无论工作区是修改还是删除，都可以一键还原。-我测试时为什么不行呢" class="headerlink" title="git checkout –  git-test.txt 让这个文件回到最近一次git commit 或 git add 时的状态，注意–是单独的即后面有空格 ，git checkout 使用版本库里面的版本替换工作区的版本 ，无论工作区是修改还是删除，都可以一键还原。  我测试时为什么不行呢"></a>git checkout –  git-test.txt 让这个文件回到最近一次git commit 或 git add 时的状态，注意–是单独的即后面有空格 ，git checkout 使用版本库里面的版本替换工作区的版本 ，无论工作区是修改还是删除，都可以一键还原。  我测试时为什么不行呢</h2><h2 id="cat-git-test-txt-查看文件的内容"><a href="#cat-git-test-txt-查看文件的内容" class="headerlink" title="cat  git-test.txt  查看文件的内容"></a>cat  git-test.txt  查看文件的内容</h2></li></ul><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="github-上创建一个仓库就行了，最好与本地仓库同名"><a href="#github-上创建一个仓库就行了，最好与本地仓库同名" class="headerlink" title="github 上创建一个仓库就行了，最好与本地仓库同名"></a>github 上创建一个仓库就行了，最好与本地仓库同名</h2><h2 id="根据提示：将本地仓库与远程仓库关联并推送到远程"><a href="#根据提示：将本地仓库与远程仓库关联并推送到远程" class="headerlink" title="根据提示：将本地仓库与远程仓库关联并推送到远程"></a>根据提示：将本地仓库与远程仓库关联并推送到远程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">…or push an existing repository from the command line</span><br><span class="line">git remote add origin https://github.com/lqyasl/learn-git.git (关联)</span><br><span class="line">git push -u origin master  (本地推送到远程)</span><br></pre></td></tr></table></figure><h2 id="把本地库的内容推送到远程，用git-push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。"><a href="#把本地库的内容推送到远程，用git-push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。" class="headerlink" title="把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。"></a>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</h2><h2 id="一个项目库第一次推送成功后，后面-只要本地做了提交，就可以-git-push-origin-master-不用加参数-u"><a href="#一个项目库第一次推送成功后，后面-只要本地做了提交，就可以-git-push-origin-master-不用加参数-u" class="headerlink" title="一个项目库第一次推送成功后，后面 只要本地做了提交，就可以 git push origin master 不用加参数-u"></a>一个项目库第一次推送成功后，后面 只要本地做了提交，就可以 git push origin master 不用加参数-u</h2><h2 id="分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了。"><a href="#分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了。" class="headerlink" title="分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了。"></a>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了。</h2><h2 id="前面是先有本地仓库，再有远程库。如何关联远程库。现在，最好的方式是，先创建远程库，再从远程库里面克隆到本地。"><a href="#前面是先有本地仓库，再有远程库。如何关联远程库。现在，最好的方式是，先创建远程库，再从远程库里面克隆到本地。" class="headerlink" title="前面是先有本地仓库，再有远程库。如何关联远程库。现在，最好的方式是，先创建远程库，再从远程库里面克隆到本地。"></a>前面是先有本地仓库，再有远程库。如何关联远程库。现在，最好的方式是，先创建远程库，再从远程库里面克隆到本地。</h2><h2 id="首先在github上创建一个-仓库-并勾选Initialize-this-repository-with-a-README，这样GitHub会自动为我们创建一个README-md文件。我这里创建了一个gitskills的库。"><a href="#首先在github上创建一个-仓库-并勾选Initialize-this-repository-with-a-README，这样GitHub会自动为我们创建一个README-md文件。我这里创建了一个gitskills的库。" class="headerlink" title="首先在github上创建一个 仓库 并勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。我这里创建了一个gitskills的库。"></a>首先在github上创建一个 仓库 并勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。我这里创建了一个gitskills的库。</h2><h2 id="git-clone-git-github-com-lqyasl-gitskills-git-或-git-clone-https-github-com-lqyasl-gitskills-git-等多种方式，-推荐使用前一种，其速度最快。"><a href="#git-clone-git-github-com-lqyasl-gitskills-git-或-git-clone-https-github-com-lqyasl-gitskills-git-等多种方式，-推荐使用前一种，其速度最快。" class="headerlink" title="git clone git@github.com:lqyasl/gitskills.git 或 git clone https://github.com/lqyasl/gitskills.git  等多种方式， 推荐使用前一种，其速度最快。"></a>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:lqyasl/gitskills.git 或 git clone <a href="https://github.com/lqyasl/gitskills.git" target="_blank" rel="noopener">https://github.com/lqyasl/gitskills.git</a>  等多种方式， 推荐使用前一种，其速度最快。</h2><h2 id="cd-gitskills-进入克隆的库"><a href="#cd-gitskills-进入克隆的库" class="headerlink" title="cd gitskills  进入克隆的库"></a>cd gitskills  进入克隆的库</h2><h2 id="ls-展开文件列表-可以看到已经有一叫README-md-的文件了"><a href="#ls-展开文件列表-可以看到已经有一叫README-md-的文件了" class="headerlink" title="ls 展开文件列表 可以看到已经有一叫README.md 的文件了"></a>ls 展开文件列表 可以看到已经有一叫README.md 的文件了</h2><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h3 id="分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50-的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。-与其他svn-版本控制系统相比，-git-超级快。每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。"><a href="#分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50-的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。-与其他svn-版本控制系统相比，-git-超级快。每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。" class="headerlink" title="分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 与其他svn 版本控制系统相比， git 超级快。每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。"></a>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 与其他svn 版本控制系统相比， git 超级快。每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</h3><h3 id="一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点。每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。"><a href="#一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点。每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。" class="headerlink" title="一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点。每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。"></a>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点。每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。</h3><h3 id="当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上。"><a href="#当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上。" class="headerlink" title="当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上。"></a>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上。</h3><h3 id="从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变。"><a href="#从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变。" class="headerlink" title="从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变。"></a>从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变。</h3><h3 id="假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并。"><a href="#假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并。" class="headerlink" title="假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并。"></a>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并。</h3><h3 id="合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。"><a href="#合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。" class="headerlink" title="合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。"></a>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。</h3><h2 id="实战部分"><a href="#实战部分" class="headerlink" title="实战部分"></a>实战部分</h2><h2 id="git-checkout-b-dev-创建dev分支，然后切换到dev分支：-这里git-checkout命令加上-b参数表示创建一个分支并切换到这个分支。-checkout这里表示切换的意思。"><a href="#git-checkout-b-dev-创建dev分支，然后切换到dev分支：-这里git-checkout命令加上-b参数表示创建一个分支并切换到这个分支。-checkout这里表示切换的意思。" class="headerlink" title="git checkout -b dev 创建dev分支，然后切换到dev分支： 这里git checkout命令加上-b参数表示创建一个分支并切换到这个分支。 checkout这里表示切换的意思。"></a>git checkout -b dev 创建dev分支，然后切换到dev分支： 这里git checkout命令加上-b参数表示创建一个分支并切换到这个分支。 checkout这里表示切换的意思。</h2><h2 id="git-branch-查看当前分支，git-branch命令会列出所有分支，当前分支前面会标一个-号。"><a href="#git-branch-查看当前分支，git-branch命令会列出所有分支，当前分支前面会标一个-号。" class="headerlink" title="git branch  查看当前分支，git branch命令会列出所有分支，当前分支前面会标一个*号。"></a>git branch  查看当前分支，git branch命令会列出所有分支，当前分支前面会标一个*号。</h2><h2 id="对README-md-文件做修改，比如加一点内容。"><a href="#对README-md-文件做修改，比如加一点内容。" class="headerlink" title="对README.md 文件做修改，比如加一点内容。"></a>对README.md 文件做修改，比如加一点内容。</h2><h2 id="然后-git-add-README-md-以及-git-commit-m-‘分支测试’-，我们就可以在dev分支上正常提交"><a href="#然后-git-add-README-md-以及-git-commit-m-‘分支测试’-，我们就可以在dev分支上正常提交" class="headerlink" title="然后 git add README.md  以及 git commit -m ‘分支测试’   ，我们就可以在dev分支上正常提交"></a>然后 git add README.md  以及 git commit -m ‘分支测试’   ，我们就可以在dev分支上正常提交</h2><h2 id="现在，dev分支的工作完成，我们就可以切换回master分支-git-checkout-master"><a href="#现在，dev分支的工作完成，我们就可以切换回master分支-git-checkout-master" class="headerlink" title="现在，dev分支的工作完成，我们就可以切换回master分支  git checkout master"></a>现在，dev分支的工作完成，我们就可以切换回master分支  git checkout master</h2><h2 id="现在，我们把dev分支的工作成果合并到master分支上-git-merge-dev-这里git-merge命令用于合并指定分支到当前分支。"><a href="#现在，我们把dev分支的工作成果合并到master分支上-git-merge-dev-这里git-merge命令用于合并指定分支到当前分支。" class="headerlink" title="现在，我们把dev分支的工作成果合并到master分支上   git merge dev  这里git merge命令用于合并指定分支到当前分支。"></a>现在，我们把dev分支的工作成果合并到master分支上   git merge dev  这里git merge命令用于合并指定分支到当前分支。</h2><h2 id="注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。"><a href="#注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。" class="headerlink" title="注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。"></a>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</h2><h2 id="合并完成后，就可以放心地删除dev分支了。-git-branch-d-dev"><a href="#合并完成后，就可以放心地删除dev分支了。-git-branch-d-dev" class="headerlink" title="合并完成后，就可以放心地删除dev分支了。 git branch -d dev"></a>合并完成后，就可以放心地删除dev分支了。 git branch -d dev</h2><h2 id="因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。"><a href="#因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。" class="headerlink" title="因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。"></a>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</h2><h2 id="gti-branch-查看分支，可以看到只剩下一个master主分支了。"><a href="#gti-branch-查看分支，可以看到只剩下一个master主分支了。" class="headerlink" title="gti branch  查看分支，可以看到只剩下一个master主分支了。"></a>gti branch  查看分支，可以看到只剩下一个master主分支了。</h2><h2 id="创建分支与合并小结"><a href="#创建分支与合并小结" class="headerlink" title="创建分支与合并小结"></a>创建分支与合并小结</h2><ul><li><p>Git鼓励大量使用分支：</p></li><li><p>查看分支：git branch</p></li><li><p>创建分支：git branch <name></name></p></li><li><p>切换分支：git checkout <name></name></p></li><li><p>创建+切换分支：git checkout -b <name></name></p></li><li><p>合并某分支到当前分支：git merge <name></name></p></li><li><p>删除分支：git branch -d <name></name></p></li></ul><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><h2 id="创建新的feature1分支，继续我们的新分支开发-git-checkout-b-feature1"><a href="#创建新的feature1分支，继续我们的新分支开发-git-checkout-b-feature1" class="headerlink" title="创建新的feature1分支，继续我们的新分支开发 git checkout -b feature1"></a>创建新的feature1分支，继续我们的新分支开发 git checkout -b feature1</h2><h2 id="修改-README-md-文件的内容"><a href="#修改-README-md-文件的内容" class="headerlink" title="修改 README.md 文件的内容"></a>修改 README.md 文件的内容</h2><h2 id="在feature1分支上提交-git-add-README-md-以及-git-commit-m-‘AND-simple’"><a href="#在feature1分支上提交-git-add-README-md-以及-git-commit-m-‘AND-simple’" class="headerlink" title="在feature1分支上提交  git add README.md   以及 git commit -m ‘AND simple’"></a>在feature1分支上提交  git add README.md   以及 git commit -m ‘AND simple’</h2><h2 id="切换到master分支-git-checkout-master"><a href="#切换到master分支-git-checkout-master" class="headerlink" title="切换到master分支  git checkout master"></a>切换到master分支  git checkout master</h2><h2 id="Git还会自动提示我们当前master分支比远程的master分支要超前1个提交"><a href="#Git还会自动提示我们当前master分支比远程的master分支要超前1个提交" class="headerlink" title="Git还会自动提示我们当前master分支比远程的master分支要超前1个提交"></a>Git还会自动提示我们当前master分支比远程的master分支要超前1个提交</h2><h2 id="在master分支上把readme-txt文件的最后一行改为：Creating-a-new-branch-is-quick-amp-simple"><a href="#在master分支上把readme-txt文件的最后一行改为：Creating-a-new-branch-is-quick-amp-simple" class="headerlink" title="在master分支上把readme.txt文件的最后一行改为：Creating a new branch is quick &amp; simple."></a>在master分支上把readme.txt文件的最后一行改为：Creating a new branch is quick &amp; simple.</h2><h2 id="提交README-md-文件"><a href="#提交README-md-文件" class="headerlink" title="提交README.md 文件"></a>提交README.md 文件</h2><h2 id="现在，master分支和feature1分支各自都分别有新的提交"><a href="#现在，master分支和feature1分支各自都分别有新的提交" class="headerlink" title="现在，master分支和feature1分支各自都分别有新的提交"></a>现在，master分支和feature1分支各自都分别有新的提交</h2><h2 id="这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看-gti-merge-feature1-结果显示：-Automatic-merge-failed-fix-conflicts-and-then-commit-the-result"><a href="#这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看-gti-merge-feature1-结果显示：-Automatic-merge-failed-fix-conflicts-and-then-commit-the-result" class="headerlink" title="这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看 gti merge feature1  结果显示： Automatic merge failed; fix conflicts and then commit the result."></a>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看 gti merge feature1  结果显示： Automatic merge failed; fix conflicts and then commit the result.</h2><h2 id="果然冲突了！Git告诉我们，readme-txt文件存在冲突，必须手动解决冲突后再提交。git-status也可以告诉我们冲突的文件"><a href="#果然冲突了！Git告诉我们，readme-txt文件存在冲突，必须手动解决冲突后再提交。git-status也可以告诉我们冲突的文件" class="headerlink" title="果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件"></a>果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件</h2><h2 id="修改README-md-并提交-解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。"><a href="#修改README-md-并提交-解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。" class="headerlink" title="修改README.md 并提交  解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。"></a>修改README.md 并提交  解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</h2><h2 id="最后，删除feature1分支：-git-branch-d-feature1"><a href="#最后，删除feature1分支：-git-branch-d-feature1" class="headerlink" title="最后，删除feature1分支：  git branch -d feature1"></a>最后，删除feature1分支：  git branch -d feature1</h2><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><h2 id="通常，合并分支时，如果可能，Git会用Fast-forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast-forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。下面我们实战一下–no-ff方式的git-merge："><a href="#通常，合并分支时，如果可能，Git会用Fast-forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast-forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。下面我们实战一下–no-ff方式的git-merge：" class="headerlink" title="通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。下面我们实战一下–no-ff方式的git merge："></a>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。下面我们实战一下–no-ff方式的git merge：</h2><h2 id="首先，仍然创建并切换dev分支：git-checkout-b-dev"><a href="#首先，仍然创建并切换dev分支：git-checkout-b-dev" class="headerlink" title="首先，仍然创建并切换dev分支：git checkout -b dev"></a>首先，仍然创建并切换dev分支：git checkout -b dev</h2><p>## </p><hr><p>&emsp;&emsp;今晚到此为止，明天再写。</p><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/git/git-liao-note/#disqus_thread</comments>
    </item>
    
    <item>
      <title>search-skills</title>
      <link>https://shulu520.com/search/search-skills/</link>
      <guid>https://shulu520.com/search/search-skills/</guid>
      <pubDate>Tue, 30 Apr 2019 16:50:45 GMT</pubDate>
      <description>
      
        &lt;hr&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<hr><hr><a id="more"></a><h2 id="口语转变为关键词"><a href="#口语转变为关键词" class="headerlink" title="口语转变为关键词"></a>口语转变为关键词</h2><ul><li>关键词之间打上空格</li></ul><h2 id="限定在特定网站内"><a href="#限定在特定网站内" class="headerlink" title="限定在特定网站内"></a>限定在特定网站内</h2><ul><li>关键词 site:某一站点</li><li>注意：站点前不用加www或http</li></ul><h2 id="限定文件类型"><a href="#限定文件类型" class="headerlink" title="限定文件类型"></a>限定文件类型</h2><ul><li>关键词 filetype:文件格式</li></ul><h2 id="限定时间段"><a href="#限定时间段" class="headerlink" title="限定时间段"></a>限定时间段</h2><ul><li>关键词 20xx..20xx</li><li>注意：中间是两个英文句号</li></ul><h2 id="排除某个关键词"><a href="#排除某个关键词" class="headerlink" title="排除某个关键词"></a>排除某个关键词</h2><ul><li>关键词 -广告 -推广</li></ul><h2 id="将关键词限定在标题中"><a href="#将关键词限定在标题中" class="headerlink" title="将关键词限定在标题中"></a>将关键词限定在标题中</h2><ul><li>关键词 intitle:限定内容</li></ul><p>## </p>]]></content:encoded>
      
      <comments>https://shulu520.com/search/search-skills/#disqus_thread</comments>
    </item>
    
    <item>
      <title>win-vscode-hotkey</title>
      <link>https://shulu520.com/win-vscode/win-vscode-hotkey/</link>
      <guid>https://shulu520.com/win-vscode/win-vscode-hotkey/</guid>
      <pubDate>Tue, 30 Apr 2019 16:50:45 GMT</pubDate>
      <description>
      
        windows操作系统，vscode代码编辑器 常见的几种快捷键，及常见用法。
      
      </description>
      
      <content:encoded><![CDATA[<center>引言：如果你想要个和现在不同的人生，就必须去做你从未做过的事情。努力之后最坏的结果是失败，但不尝试的结果则是无止境的懊悔、怀疑和平庸。</center><a id="more"></a><h2 id="windows-最常用快捷键"><a href="#windows-最常用快捷键" class="headerlink" title="windows 最常用快捷键"></a>windows 最常用快捷键</h2><ul><li><p>ctrl  w  关闭当前网页</p></li><li><p>f2键 ：选中后按f2键即可重命名文件，另一种方法，点一下文件名，稍等，再点一下，即可重命名</p></li><li><p>f4: 重复上步操作</p></li><li><p>f5: 刷新桌面 刷新网页</p></li><li><p>f11: 全屏显示网页</p></li><li><p>shift :<br>  省略号    shift + 数字6  （表示六个点）    ……</p><p>  书名号     shift + &lt;&gt;   (小于大于）</p></li><li><p>分隔号   单独按 数字1 前面的键    《简 · 爱》</p></li><li><p>Alt + 单击拖动  为矩形选择</p></li><li><p>AlT + f4 关闭当前程序</p></li><li><p>删除  选中后 按delete </p></li><li><p>永久删除  选中后  shift +delete</p></li><li><p>截屏   PrtSc     截全屏<br>  Alt  +PrtSc  截当前窗口</p></li><li><p>ctrl alt delete 任务管理器</p></li><li><p>windows 打开开始菜单</p></li><li><p>ctrl shift n  新建文件夹</p></li><li><p>window e 打开文件资源管理器</p></li><li><p>alt tab 切换窗口 </p></li><li><p>window d 回到桌面</p></li></ul><h2 id="vscode-常用快捷键"><a href="#vscode-常用快捷键" class="headerlink" title="vscode 常用快捷键"></a>vscode 常用快捷键</h2><ul><li><p>上下移动一行： Alt+Up 或 Alt+Down</p></li><li><p>向上或向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down</p></li><li><p>同时选中所有匹配： Ctrl+Shift+L</p></li><li><p>Ctrl+D 下一个匹配的也被选中 </p></li><li><p>Alt + 单击  ：插入光标</p></li><li><p>Ctrl + F2    选择当前字的所有出现</p></li><li><p>ctrl  shift  k   删除整行</p></li><li><p>ctrl  shift  a   多行注释</p></li><li><p>ctrl  f     当前文件内搜索相关代码，终于找到这个功能了，哈哈，右上角会有弹框，其中有前后箭头，表示搜索的代码上一次、下一次出现的位置，点击直接会跳转到相应的位置，并且侧边上有相应的位置标识。</p></li></ul><center>后记：快捷键还有很多，学到了再来补充</center>]]></content:encoded>
      
      <comments>https://shulu520.com/win-vscode/win-vscode-hotkey/#disqus_thread</comments>
    </item>
    
    <item>
      <title>vue-source</title>
      <link>https://shulu520.com/vue-source/vue-source/</link>
      <guid>https://shulu520.com/vue-source/vue-source/</guid>
      <pubDate>Tue, 30 Apr 2019 10:49:43 GMT</pubDate>
      <description>
      
        vue 源码分析学习笔记
      
      </description>
      
      <content:encoded><![CDATA[<center>引言：read the fucking source code</center>                <a id="more"></a><h2 id="vue-源码分析知识点分析-vue-作为一个-MVVM-框架的基本实现原理"><a href="#vue-源码分析知识点分析-vue-作为一个-MVVM-框架的基本实现原理" class="headerlink" title="vue 源码分析知识点分析 vue 作为一个 MVVM 框架的基本实现原理"></a>vue 源码分析知识点分析 vue 作为一个 MVVM 框架的基本实现原理</h2><h2 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h2><ul><li>1  [].slice.call(lis): 将伪数组转换为真数组</li><li>slice 方法有浅拷贝的用法，表示截取一部分，不传参数的话就是拷贝原数组</li><li><em>这样更好</em> Array.prototype.slice.call(lis)</li><li>2  node.nodeType: 得到节点类型</li><li>节点类型：常用的<ul><li>document // 文档</li><li>Element //元素节点    节点类型 nodeType === 1;</li><li>Attr //属性</li><li>Text //文本</li><li>documentFragment // 文档碎片</li></ul></li></ul><ul><li>3 Object.defineProperty(obj, propName, {}):<ul><li>给对象添加/修改属性(指定描述符)</li><li>vue <em>数据代理的核心语法</em>，不支持ie8，面试题</li></ul></li><li>属性描述符：</li><li>数据描述符：<ul><li>configurable: true/false 是否可以重新 define</li><li>enumerable: true/false 是否可以枚举(for..in / keys())</li><li>value: 指定初始值</li><li>writable: true/false value 是否可以修改</li></ul></li><li>访问描述符：vue的<code>计算属性</code>就是利用get set 方法<ul><li>get: 回调函数, 根据其他相关的属性动态计算得到当前属性值，根据相关的属性更新（得到）当前的属性</li><li>set: 回调函数, <code>监视</code>当前属性值的变化，更新相关的属性值 ，根据当前的属性更新相关的属性 </li></ul></li><li>Object.keys(obj): 得到对象自身<code>可枚举</code>的属性名的数组</li><li>obj.hasOwnProperty(prop): 判断 prop 是否是 obj 自身的属性</li><li>DocumentFragment: <code>文档碎片</code>(高效批量更新多个节点)</li><li><p>传言啊  这个 childNodes是正统属性   亲生的  而这个children是野孩子   </p></li><li><p>这个野孩子比较随意   所以用它返回来的就只有DOM元素了  其他的文字啥的   都不返回   </p></li><li><p>而 childNodes比较讲究   事无巨细  都要返回来   </p></li><li><p>但是我还是觉得野孩子乖 所以也获得了几乎所有浏览器的支持 如果你想要DOM节点  直接用野孩子就可以了 </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">&lt;li&gt;test1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;test2&lt;/li&gt;</span><br><span class="line">&lt;li&gt;test3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let list = document.getElementById(&quot;list&quot;);</span><br><span class="line">// 1. 创建文档碎片</span><br><span class="line">let fragment = document.createDocumentFragment();</span><br><span class="line"></span><br><span class="line">// 2. 取出ul中 所有 子节点保存到fragment中</span><br><span class="line">//Array.prototype.slice.call(list.children).forEach(element =&gt; &#123;</span><br><span class="line">fragment.appendChild(element);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 3.修改fragment中的每一个子元素的内容</span><br><span class="line">Array.prototype.slice.call(fragment.children).forEach(element =&gt; &#123;</span><br><span class="line">element.textContent = &apos;舒璐&apos;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 4.将文档碎片插入到list中 </span><br><span class="line">list.appendChild(fragment);</span><br></pre></td></tr></table></figure><h2 id="数据代理的实现"><a href="#数据代理的实现" class="headerlink" title="数据代理的实现"></a>数据代理的实现</h2><h2 id="基本实现流程"><a href="#基本实现流程" class="headerlink" title="基本实现流程"></a>基本实现流程</h2><ul><li>通过 Object.defineProperty()给 vm 添加与 data 对象的属性对应的属性描述符</li><li>所有添加的属性都包含 getter/setter</li><li>getter/setter 内部去操作 data 中对应的属性数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">相当于Vue的构造函数</span><br><span class="line"></span><br><span class="line">function MVVM(options) &#123;</span><br><span class="line">  // 将选项对象保存到vm</span><br><span class="line">  this.$options = options;</span><br><span class="line"></span><br><span class="line">  // 将data对象保存到vm和datq变量中</span><br><span class="line">  var data = this._data = this.$options.data;</span><br><span class="line"></span><br><span class="line">  //将vm保存在me变量中</span><br><span class="line">  var me = this;</span><br><span class="line"></span><br><span class="line">  // 遍历data中所有属性</span><br><span class="line">  Object.keys(data).forEach(function (key) &#123; // 属性名: name</span><br><span class="line"></span><br><span class="line">    // 对指定属性实现代理</span><br><span class="line">    me._proxy(key);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 对data进行监视</span><br><span class="line">  observe(data, this);</span><br><span class="line"></span><br><span class="line">  // 创建一个用来编译模板的compile对象</span><br><span class="line">  this.$compile = new Compile(options.el || document.body, this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MVVM.prototype = &#123;</span><br><span class="line">  $watch: function (key, cb, options) &#123;</span><br><span class="line">    new Watcher(this, key, cb);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 对指定属性实现代理</span><br><span class="line">  _proxy: function (key) &#123;</span><br><span class="line">    // 保存vm</span><br><span class="line">    var me = this;</span><br><span class="line">    // 给vm添加指定属性名的属性(使用属性描述)</span><br><span class="line">    Object.defineProperty(me, key, &#123;</span><br><span class="line">      configurable: false, // 不能再重新定义</span><br><span class="line">      enumerable: true, // 可以枚举</span><br><span class="line">      // 当通过vm.name读取属性值时自动调用</span><br><span class="line">      get: function proxyGetter() &#123;</span><br><span class="line">        // 读取data中对应属性值返回(实现代理读操作)</span><br><span class="line">        return me._data[key];</span><br><span class="line">      &#125;,</span><br><span class="line">      // 当通过vm.name = &apos;xxx&apos;时自动调用</span><br><span class="line">      set: function proxySetter(newVal) &#123;</span><br><span class="line">        // 将最新的值保存到data中对应的属性上(实现代理写操作)</span><br><span class="line">        me._data[key] = newVal;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>其中最关键的部分为</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(me, key, &#123;</span><br><span class="line">   configurable: false, // 不能再重新定义</span><br><span class="line">   enumerable: true, // 可以枚举</span><br><span class="line">   // 当通过vm.name读取属性值时自动调用</span><br><span class="line">   get: function proxyGetter() &#123;</span><br><span class="line">     // 读取data中对应属性值返回(实现代理读操作)</span><br><span class="line">     return me._data[key];</span><br><span class="line">   &#125;,</span><br><span class="line">   // 当通过vm.name = &apos;xxx&apos;时自动调用</span><br><span class="line">   set: function proxySetter(newVal) &#123;</span><br><span class="line">     // 将最新的值保存到data中对应的属性上(实现代理写操作)</span><br><span class="line">     me._data[key] = newVal;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h2 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h2><ol><li>嵌套调用: a里面调用b,b里面调用c</li><li>递归: a 里面调用 a ,a继续调用a即特殊的嵌套调用</li><li>模板解析的基本流程</li></ol><ul><li>1)将 el 的所有子节点取出, 添加到一个新建的文档 fragment 对象中</li><li>2)对 fragment 中的<code>所有层次子节点</code>递归进行编译解析处理<ul><li>对大括号表达式文本节点进行解析</li><li>对元素节点的指令属性进行解析</li><li>事件指令解析</li><li>一般指令解析</li></ul></li><li>3) 将解析后的 fragment 添加到 el 中显示</li><li>模板解析(1): 大括号表达式解析<br><code>&lt;p&gt;&lt;/p&gt;</code></li></ul><ul><li>根据正则对象得到匹配出的表达式字符串: 子匹配/RegExp.$1   name</li><li>从 data 中取出表达式对应的属性值</li><li>将属性值设置为文本节点的 textContent</li></ul><ul><li>模板解析(2): 事件指令解析<pre><code>从指令名中取出事件名根据指令的值(表达式)从 methods 中得到对应的事件处理函数对象给当前元素节点绑定指定事件名和回调函数的 dom 事件监听指令解析完后, 移除此指令属性</code></pre></li><li>模板解析(3): 一般指令解析<pre><code>得到指令名和指令值(表达式) text/html/class msg/myClass从 data 中根据表达式得到对应的值根据指令名确定需要操作元素节点的什么属性</code></pre><ul><li>v-text—textContent 属性</li><li>v-html—innerHTML 属性</li><li>v-class–className 属性</li><li>4) 将得到的表达式的值设置到对应的属性上</li><li>5) 移除元素的指令属性</li></ul></li></ul><h2 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call   apply bind"></a>call   apply bind</h2><ul><li>JavaScript 的一大特点是，</li><li>函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念<br>  apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；<br>  apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；<br>  apply 、 call 、bind 三者都可以利用后续参数传参；</li><li>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。</li><li>call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里</li><li>bind()最简单的用法是创建一个函数，使这个函数<code>不论怎么调用都有同样的this值</code>。</li><li>常见的错误就像，将方法从对象中拿出来，然后调用，并且希望this指向原来的对象。</li><li>如果不做特殊处理，一般会丢失原来的对象。用bind方法可以</li></ul><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><ul><li>简单地说，就是数据更新，界面改变。</li><li>一旦更新了 data 中的某个属性数据, 所有界面上直接使用或间接使用了此属性的节点+更新</li><li>数据劫持<br>   数据劫持是 vue 中用来实现数据绑定的一种技术<br>   基本思想: 通过 defineProperty()来监视 data 中所有属性(任意层次)数据的变化, </li><li>一旦变化就去更新界面</li><li>初始化显示：页面（表达式/指令）能从data中读取数据显示（编译/解析）<br> 更新显示：更新data中的属性数据，.&gt;&gt;&gt; 页面更新<br> <img src="/vue-source/vue-source/vuenote/1.jpg" alt><br> 图中黑线表示初始化，红线表示更新时触发</li></ul><h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><ul><li>双向数据绑定是建立在单向数据绑定(model==&gt;View)的基础之上的</li><li>双向数据绑定的实现流程:<br>   在解析 v-model 指令时, 给当前元素添加 input 监听(input事件会在value属性值发生改变时触发，<pre><code>通过js改变value属性值不会触发此事件。只有IE8以上或者谷歌火狐等标准浏览器支持。)</code></pre>   当 input 的 value 发生改变时, 将最新的值赋值给当前表达式所对应的 data 属性</li></ul><h2 id="vuex-是vue-的一个插件"><a href="#vuex-是vue-的一个插件" class="headerlink" title="vuex 是vue 的一个插件"></a>vuex 是vue 的一个插件</h2><ul><li>简单来说: 对 vue 应用中多个组件的共享状态进行集中式的管理(读/写)</li><li><p>状态自管理应用<br>   state: 驱动应用的数据源（data）<br>   view: 以声明方式将 state 映射到视图(模板界面)<br>   actions:（在vue中是函数） 响应在 view 上的用户输入导致的状态变化</p><pre><code>(包含 n 个*更新状态的方法*)![](vuenote/2.jpg)多组件共享状态的问题     多个视图依赖于同一状态     来自不同视图的行为需要变更同一状态     以前的解决办         将数据以及操作数据的行为都定义在父组件         将数据以及操作数据的行为传递给需要的各个子组件(有可能需要多级传递)     vuex 就是用来解决这个问题的vuex 核心概念和 API    state         vuex 管理的状态对象,它应该是唯一的    mutations         包含多个直接更新 state 的方法(回调函数)的对象         谁来触发: action 中的 commit(&apos;mutation 名称&apos;)         只能包含同步的代码, 不能写异步代码    const mutations = {        yyy (state, {data1}) {        // 更新 state 的某个属性        }    }</code></pre></li><li><p>vuex  人生管理哲学，哈哈<br>State:想一想，你现在心里在意哪些事？</p></li><li><p>Mutation目标导向:  写下目标，直接改变State</p></li><li><p>Action阶段性执行： 写下行动 ，执行一个个Matation、异步函数、和其它阶段性执行。</p></li><li><p>Getters: 写下其它指标，根据现有的state得到其他的指标</p></li><li><p>mapState和mapGetters必须在computed中访问，因为它们返回的是对象，所以需要用拓展符…进行展开。</p></li><li><p>mapActions则是将Action挂载到methods上，也需要用拓展符…进行展开。</p></li><li><p>组件中的mapActions([“increment”])与<br>actions 中  increment 函数名一样<br>actions 中  commit(“INCREMENT”)与<br>mutations 中 INCREMENT函数名一样<br>大写的函数名只是为了区分各个函数 可以定义一个mutation-type.js </p></li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1>]]></content:encoded>
      
      <comments>https://shulu520.com/vue-source/vue-source/#disqus_thread</comments>
    </item>
    
    <item>
      <title>friends</title>
      <link>https://shulu520.com/start/friends/</link>
      <guid>https://shulu520.com/start/friends/</guid>
      <pubDate>Tue, 23 Apr 2019 15:03:21 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=LEBdVU1fQGxdXQJPQ0E&quot; style=&quot;text-decoration:none;&quot;&gt;来撩我啊&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt; &amp;emsp;&amp;emsp;终于等到你，还好我没放弃：来了就好好逛逛，这里既是我的学习园地，也是我的精神家园，欢迎常来看看。在手机上一些效果表现不出来，双击试试看。欢迎匿名来撩，无需登录，及时互动。快点击右下角聊天按钮，说点什么吧。&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;">来撩我啊</a></p><hr><p> &emsp;&emsp;终于等到你，还好我没放弃：来了就好好逛逛，这里既是我的学习园地，也是我的精神家园，欢迎常来看看。在手机上一些效果表现不出来，双击试试看。欢迎匿名来撩，无需登录，及时互动。快点击右下角聊天按钮，说点什么吧。</p><hr><a id="more"></a><center>将进酒<center><br><br>    <center>李白</center><h2 id="君不见，黄河之水天上来，奔流到海不复回。"><a href="#君不见，黄河之水天上来，奔流到海不复回。" class="headerlink" title="君不见，黄河之水天上来，奔流到海不复回。"></a>君不见，黄河之水天上来，奔流到海不复回。</h2><h2 id="君不见，高堂明镜悲白发，朝如青丝暮成雪。"><a href="#君不见，高堂明镜悲白发，朝如青丝暮成雪。" class="headerlink" title="君不见，高堂明镜悲白发，朝如青丝暮成雪。"></a>君不见，高堂明镜悲白发，朝如青丝暮成雪。</h2><h2 id="人生得意须尽欢，莫使金樽空对月。"><a href="#人生得意须尽欢，莫使金樽空对月。" class="headerlink" title="人生得意须尽欢，莫使金樽空对月。"></a>人生得意须尽欢，莫使金樽空对月。</h2><h2 id="天生我材必有用，千金散尽还复来。"><a href="#天生我材必有用，千金散尽还复来。" class="headerlink" title="天生我材必有用，千金散尽还复来。"></a>天生我材必有用，千金散尽还复来。</h2><h2 id="烹羊宰牛且为乐，会须一饮三百杯。"><a href="#烹羊宰牛且为乐，会须一饮三百杯。" class="headerlink" title="烹羊宰牛且为乐，会须一饮三百杯。"></a>烹羊宰牛且为乐，会须一饮三百杯。</h2><h2 id="岑夫子，丹丘生，将进酒，杯莫停。"><a href="#岑夫子，丹丘生，将进酒，杯莫停。" class="headerlink" title="岑夫子，丹丘生，将进酒，杯莫停。"></a>岑夫子，丹丘生，将进酒，杯莫停。</h2><h2 id="与君歌一曲，请君为我倾耳听。"><a href="#与君歌一曲，请君为我倾耳听。" class="headerlink" title="与君歌一曲，请君为我倾耳听。"></a>与君歌一曲，请君为我倾耳听。</h2><h2 id="钟鼓馔玉不足贵，但愿长醉不复醒。"><a href="#钟鼓馔玉不足贵，但愿长醉不复醒。" class="headerlink" title="钟鼓馔玉不足贵，但愿长醉不复醒。"></a>钟鼓馔玉不足贵，但愿长醉不复醒。</h2><h2 id="古来圣贤皆寂寞，惟有饮者留其名。"><a href="#古来圣贤皆寂寞，惟有饮者留其名。" class="headerlink" title="古来圣贤皆寂寞，惟有饮者留其名。"></a>古来圣贤皆寂寞，惟有饮者留其名。</h2><h2 id="陈王昔时宴平乐，斗酒十千恣欢谑。"><a href="#陈王昔时宴平乐，斗酒十千恣欢谑。" class="headerlink" title="陈王昔时宴平乐，斗酒十千恣欢谑。"></a>陈王昔时宴平乐，斗酒十千恣欢谑。</h2><h2 id="主人何为言少钱，径须沽取对君酌。"><a href="#主人何为言少钱，径须沽取对君酌。" class="headerlink" title="主人何为言少钱，径须沽取对君酌。"></a>主人何为言少钱，径须沽取对君酌。</h2><h2 id="五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。"><a href="#五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。" class="headerlink" title="五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。"></a>五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。</h2><h3 id="‘Everything-will-be-okay-in-the-end-If-it’s-not-okay-it’s-not-the-end-’"><a href="#‘Everything-will-be-okay-in-the-end-If-it’s-not-okay-it’s-not-the-end-’" class="headerlink" title="‘Everything will be okay in the end.  If it’s not okay, it’s not the end.’"></a>‘Everything will be okay in the end.  If it’s not okay, it’s not the end.’</h3></center></center>]]></content:encoded>
      
      <comments>https://shulu520.com/start/friends/#disqus_thread</comments>
    </item>
    
    <item>
      <title>h5-guigu-music</title>
      <link>https://shulu520.com/H5/h5-guigu-music/</link>
      <guid>https://shulu520.com/H5/h5-guigu-music/</guid>
      <pubDate>Mon, 22 Apr 2019 14:19:33 GMT</pubDate>
      <description>
      
        &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;面向对象面向君，不负代码不负卿。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<hr><p><strong>面向对象面向君，不负代码不负卿。</strong></p><hr> <a id="more"></a><h4 id="第一天-像素-适配"><a href="#第一天-像素-适配" class="headerlink" title="第一天 像素 适配"></a>第一天 像素 适配</h4><ul><li>图片加载太慢，后面要用纯文字代替，记得更新</li><li>rem最终适配代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;(function()&#123;</span><br><span class="line">var styleNode = document.createElement(&quot;style&quot;);</span><br><span class="line">var w = document.documentElement.clientWidth/16;</span><br><span class="line">styleNode.innerHTML=&quot;html&#123;font-size:&quot;+w+&quot;px!important&#125;&quot;</span><br><span class="line">document.head.appendChild(styleNode);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><ul><li>1物理像素的实现 用媒体查询的方法  一般用伪元素来做<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;/&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">*&#123;</span><br><span class="line">margin: 0;</span><br><span class="line">padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">#test:before&#123;</span><br><span class="line">position: absolute;</span><br><span class="line">bottom: 0px;</span><br><span class="line">content: &quot;&quot;;</span><br><span class="line">display: block;</span><br><span class="line">width: 100%;</span><br><span class="line">height: 1px;</span><br><span class="line">background: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media only screen and (-webkit-device-pixel-ratio:2 ) &#123;</span><br><span class="line">#test:before&#123;</span><br><span class="line">transform: scaleY(.5);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (-webkit-device-pixel-ratio:3 ) &#123;</span><br><span class="line">#test:before&#123;</span><br><span class="line">transform: scaleY(.33333333333);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="第二天-移动端基础事件"><a href="#第二天-移动端基础事件" class="headerlink" title="第二天 移动端基础事件"></a>第二天 移动端基础事件</h4><ul><li>querySelectorAll() 匹配满足选择器的所有元素</li><li><p>改变dom结构后一定得再次获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.onload=function()&#123;</span><br><span class="line">//querySelectorAll:获取静态列表</span><br><span class="line">var itemNodes  = document.querySelectorAll(&quot;.item&quot;); // 第一次获取</span><br><span class="line">console.log(itemNodes.length)</span><br><span class="line">document.body.innerHTML+=&quot;&lt;div class=&apos;item&apos;&gt;&lt;/div&gt;&quot;;</span><br><span class="line">itemNodes  = document.querySelectorAll(&quot;.item&quot;);  // 改变dom结构后一定得再次获取</span><br><span class="line">console.log(itemNodes)</span><br><span class="line">for(var i=0;i&lt;itemNodes.length;i++)&#123;</span><br><span class="line">itemNodes[i].style.background=&quot;pink&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>querySelector 获取 querySelectorAll 匹配到的第一个</p><h4 id="触屏事件-监听用-addEventListener"><a href="#触屏事件-监听用-addEventListener" class="headerlink" title="触屏事件 监听用 addEventListener"></a>触屏事件 监听用 addEventListener</h4><figure class="highlight plain"><figcaption><span>pc端</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">touchstartmousedown</span><br><span class="line">touchmovemousemove</span><br><span class="line">不可能单独触发可以单独触发</span><br><span class="line">touchendmouseup</span><br><span class="line">window.onload=function()&#123;</span><br><span class="line">var item = document.querySelector(&quot;.item&quot;);</span><br><span class="line">item.addEventListener(&quot;touchstart&quot;,function()&#123;</span><br><span class="line">console.log(&quot;touchstart&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>移动端事件默认行为 长按选中，橡皮筋效果（下拉）等</p></li><li><p>全面禁止事件默认行为 在 touchstart事件上，即手指触摸上去的时候就开始禁止</p><figure class="highlight plain"><figcaption><span>一上来就这段代码，全面禁止事件默认行为</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.onload=function()&#123;</span><br><span class="line">document.addEventListener(&quot;touchstart&quot;,function(ev)&#123;</span><br><span class="line">ev=ev||event;</span><br><span class="line">ev.preventDefault();</span><br><span class="line">&#125;)</span><br><span class="line">// 单独按需开启 </span><br><span class="line">item.addEventListener(&quot;touchstart&quot;,function(ev)&#123;</span><br><span class="line">ev=ev||event;</span><br><span class="line">ev.stopPropagation();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>右键菜单的阻止与开启 与自定义右键</p><figure class="highlight plain"><figcaption><span>全局阻止右键</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">document.oncontextmenu=function()&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">// 单独按需开启浏览器的右键菜单</span><br><span class="line">var inner = document.querySelector(&quot;#inner&quot;);</span><br><span class="line">inner.oncontextmenu=function(ev)&#123;</span><br><span class="line">ev.stopPropagation();</span><br><span class="line">&#125;</span><br><span class="line">// 也可以自定义右键菜单</span><br><span class="line"></span><br><span class="line">window.onload=function()&#123;</span><br><span class="line">document.oncontextmenu=function(ev)&#123;</span><br><span class="line">ev = ev||event;</span><br><span class="line">var x = ev.clientX;</span><br><span class="line">var y = ev.clientY;</span><br><span class="line"></span><br><span class="line">var wrap =document.querySelector(&quot;#wrap&quot;);</span><br><span class="line">wrap.style.display=&quot;block&quot;;</span><br><span class="line">wrap.style.left = x+&quot;px&quot;;</span><br><span class="line">wrap.style.top = y+&quot;px&quot;;</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">// 单击消失</span><br><span class="line">document.onclick=function()&#123;</span><br><span class="line">var wrap =document.querySelector(&quot;#wrap&quot;);</span><br><span class="line">wrap.style.display=&quot;none&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>事件点透<br>  pc端的事件可以在移动端触发<br>  PC端事件有300毫秒延迟<br>  移动端事件不会有延迟</p></li><li><p>移动端 a 标签跳转方案 并解决误触</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 阻止事件默认行为</span><br><span class="line">document.addEventListener(&quot;touchstart&quot;,function(ev)&#123;</span><br><span class="line">ev=ev||event;</span><br><span class="line">ev.preventDefault();</span><br><span class="line">&#125;)</span><br><span class="line">//移动端a标签的跳转方案  解决误触</span><br><span class="line">var aNodes = document.querySelectorAll(&quot;a&quot;);</span><br><span class="line">for(var i=0;i&lt;aNodes.length;i++)&#123;</span><br><span class="line">aNodes[i].addEventListener(&quot;touchstart&quot;,function()&#123;</span><br><span class="line">this.isMoved=false;</span><br><span class="line">&#125;)</span><br><span class="line">aNodes[i].addEventListener(&quot;touchmove&quot;,function()&#123;</span><br><span class="line">this.isMoved=true;</span><br><span class="line">&#125;)</span><br><span class="line">aNodes[i].addEventListener(&quot;touchend&quot;,function()&#123;</span><br><span class="line">if(!this.isMoved)&#123;</span><br><span class="line">location.href=this.href;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>event :</p></li><li>//changedTouches: 触发当前事件的手指列表,  <em>最常用</em><br>//targetTouches: 触发当前事件时元素上的手指列表<br>//touches: 触发当前事件时屏幕上的手指列表<h4 id="常见问题-及解决方法"><a href="#常见问题-及解决方法" class="headerlink" title="常见问题 及解决方法"></a>常见问题 及解决方法</h4></li><li><p>禁止电话与邮箱,添加标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>按需开启 电话与邮箱</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   &lt;a href=&quot;tel:1383838438&quot;&gt;1383838438&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;mailto:2642816105@qq.com&quot;&gt;2642816105&lt;/a&gt;</span><br></pre></td></tr></table></figure><ul><li><p>解决连接按钮高亮问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">text-decoration:none; // 去下划线</span><br><span class="line">webkit-tap-highlight-color:rgba(0,0,0,0); // 去背景高亮，只需字体高亮</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解决圆角过圆的问题 加属性 webkit-appearance:none 即可</p></li><li>fontboosting 的问题 及显示的字体与设置的大小不一致的现象，加属性 max-height:999999px;即可</li><li>无缝华屏</li><li>移动端清除浮动：父元素ul元素上加 overflow:hidden 即可</li><li>表单：<pre><code>表单高亮：outline:none;表单内阴影：boder:none;</code></pre><h4 id="划屏相关"><a href="#划屏相关" class="headerlink" title="划屏相关"></a>划屏相关</h4></li><li>在谁上面划，即划屏包裹slide-wrapper</li><li>划的内容 即slide-content</li></ul><h4 id="元素排到一行的方法"><a href="#元素排到一行的方法" class="headerlink" title="元素排到一行的方法"></a>元素排到一行的方法</h4><ul><li>浮动 父容器宽度不够会自动换行</li><li>另一种技巧<br>  父容器white-space :nowrap;<br>  子元素: display: inline-block;<h4 id="橡皮筋效果"><a href="#橡皮筋效果" class="headerlink" title="橡皮筋效果"></a>橡皮筋效果</h4></li><li>减少每次move 的有效距离，最终的有效距离还是一直在增大</li></ul><h4 id="混合-继承"><a href="#混合-继承" class="headerlink" title="混合  继承"></a>混合  继承</h4><ul><li>可以单独定义一系列通用的样式，在需要的时候进行调用。从而减少代码的重复</li><li><p>混合：简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 定义混合 --&gt;</span><br><span class="line">.mixin()&#123;</span><br><span class="line">&lt;!-- 规则集 --&gt;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 使用混合 --&gt;</span><br><span class="line">#text1&#123;</span><br><span class="line">&lt;!-- 相当于将规则集里面的代码cv到这里 --&gt;</span><br><span class="line">&lt;!-- 每次使用都是将代码复制到相应位置 --&gt;</span><br><span class="line">&lt;!-- 使用几次就有几处相同的代码 --&gt;</span><br><span class="line">.mixin();</span><br><span class="line">&#125;#text2&#123;</span><br><span class="line">.mixin();</span><br><span class="line">&#125;#text3&#123;</span><br><span class="line">.mixin();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 多处使用相同的混合 这样写好一点-（手动写）-&gt;</span><br><span class="line">#text1,#text2,#text3&#123;</span><br><span class="line">.mixin() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继承：性能好一点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 定义继承 --&gt;</span><br><span class="line">.extend&#123;</span><br><span class="line">&lt;!-- 规则集 --&gt;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 使用继承 --&gt;</span><br><span class="line">#text1&#123;</span><br><span class="line">&amp;::extend(.extend);</span><br><span class="line">&#125;#text2&#123;</span><br><span class="line">&amp;::extend(.extend);</span><br><span class="line">&#125;#text3&#123;</span><br><span class="line">&amp;::extend(.extend);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 最终编译为 --&gt;</span><br><span class="line">#text1,#text2,#text3&#123;</span><br><span class="line">&lt;!-- 规则集 ，相当于将规则集里面的代码cv到这里--&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content:encoded>
      
      <comments>https://shulu520.com/H5/h5-guigu-music/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hello-World</title>
      <link>https://shulu520.com/start/hello-world/</link>
      <guid>https://shulu520.com/start/hello-world/</guid>
      <pubDate>Sat, 20 Apr 2019 14:23:44 GMT</pubDate>
      <description>
      
        移动端双击页面试试看。 本文为markdown语法测试篇。
      
      </description>
      
      <content:encoded><![CDATA[<hr><blockquote><p>故事的开头，多是惊魂一瞥，然后一眼万年。故事的结局，多是渐行渐远，江湖不见。</p></blockquote><hr><a id="more"></a><h4 id="在-xxx-md文件插入html效果"><a href="#在-xxx-md文件插入html效果" class="headerlink" title="在 xxx.md文件插入html效果"></a>在 xxx.md文件插入html效果</h4><ul><li>直接写html 即可 内联样式也直接写</li></ul><font size="4"> 这里输入文字，自定义字体大小 </font><br><font color="#FF0000"> 这里输入文字，自定义字体颜色</font><br><span style="background-color: #ff6600;">这里输入文字，自定义字体背景色</span><br><font color="#000000" size="4"><span style="background-color: #ADFF2F;">这是综合起来的效果 </span></font><br><font color="#FFFFFF" size="4"><span style="background-color: #68228B;">这是综合起来的效果2 </span></font><h4 id="首行缩进效果"><a href="#首行缩进效果" class="headerlink" title="首行缩进效果"></a>首行缩进效果</h4><ul><li>其中的 <code>&amp;emsp;&amp;emsp;</code> 即缩进两个字<code>最常见</code></li></ul><p>人们常觉得准备的阶段是在浪费时间，只有当真正机会来临，而自己没有能力把握的时候，才能觉悟自己平时没有准备才是浪费了时间。———罗曼·罗兰</p><ul><li>全方大的空白 <code>&amp;emsp;</code></li></ul><p>&emsp;内容充实的生命就是长久的生命。我们要以行为而不是以时间来衡量生命。 ——小塞涅卡</p><p>&emsp;&emsp;内容充实的生命就是长久的生命。我们要以行为而不是以时间来衡量生命。 ——小塞涅卡</p><ul><li>不断行的空白格<code>&amp;nbsp;</code></li></ul><p>&nbsp;以后无论我去哪我都把你带着我看账你帮我打算盘我谈生意你帮我出主意一起把吴家东院发扬光大做到陕西第一天下第一。———那年花开月正圆周莹经典台词</p><h4 id="md-语法常用语法总结"><a href="#md-语法常用语法总结" class="headerlink" title="md 语法常用语法总结"></a>md 语法常用语法总结</h4><h5 id="倾斜-单层"><a href="#倾斜-单层" class="headerlink" title="倾斜    单层*"></a>倾斜    单层*</h5><p>示例：<em>倾斜字体</em></p><h5 id="加粗-双层"><a href="#加粗-双层" class="headerlink" title="加粗   双层*"></a>加粗   双层*</h5><p>示例：<strong>加粗字体</strong></p><h5 id="加粗倾斜-三层"><a href="#加粗倾斜-三层" class="headerlink" title="加粗倾斜   三层*"></a>加粗倾斜   三层*</h5><p>示例：<strong><em>加粗倾斜</em></strong></p><h5 id="删除线-双层"><a href="#删除线-双层" class="headerlink" title="删除线  双层~~"></a>删除线  双层~~</h5><p>示例：<del>删除线</del></p><h5 id="单层引用-gt-加内容"><a href="#单层引用-gt-加内容" class="headerlink" title="单层引用  &gt;加内容"></a>单层引用  &gt;加内容</h5><p>示例：</p><blockquote><p>这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容</p></blockquote><h5 id="分割线-三个或者三个以上的-或者-都可以"><a href="#分割线-三个或者三个以上的-或者-都可以" class="headerlink" title="分割线  三个或者三个以上的 - 或者 * 都可以"></a>分割线  三个或者三个以上的 - 或者 * 都可以</h5><p>示例：</p><hr><pre><code>分割线分割线分割线分割线分割线1</code></pre><hr><hr><pre><code>分割线分割线分割线分割线分割线2</code></pre><hr><h5 id="无序列表-用-任何一种都可以"><a href="#无序列表-用-任何一种都可以" class="headerlink" title="无序列表  用 - + * 任何一种都可以"></a>无序列表  用 - + * 任何一种都可以</h5><p>示例：</p><ul><li>无序列表1</li></ul><ul><li>无序列表2</li></ul><ul><li>无序列表3</li></ul><h5 id="有序列表-数字加点"><a href="#有序列表-数字加点" class="headerlink" title="有序列表  数字加点"></a>有序列表  数字加点</h5><h5 id="表格"><a href="#表格" class="headerlink" title="表格 :"></a>表格 :</h5><p>示例：</p><table><thead><tr><th>表头</th><th style="text-align:center">表头</th><th style="text-align:right">表头</th></tr></thead><tbody><tr><td>内容</td><td style="text-align:center">内容</td><td style="text-align:right">内容</td></tr></tbody></table><p>注：第二行分割表头和内容。<br>-有一个就行，为了对齐，多加了几个<br> 文字默认居左<br>-两边加：表示文字居中<br>-右边加：表示文字居右</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h5><p>示例：<br>单行:</p><p>  <code>javascriptvuenodeajax</code></p><p>代码块  :</p><p>、、、<br>.b{<br>    background: red;<br>}<br>、、、</p>]]></content:encoded>
      
      <comments>https://shulu520.com/start/hello-world/#disqus_thread</comments>
    </item>
    
    <item>
      <title>vue-note</title>
      <link>https://shulu520.com/vue/vue-note/</link>
      <guid>https://shulu520.com/vue/vue-note/</guid>
      <pubDate>Wed, 17 Apr 2019 12:00:21 GMT</pubDate>
      <description>
      
        &lt;hr&gt;
&lt;p&gt; &lt;strong&gt;人生即在于体验，而体验源于去尝试，去折腾，去改变，去塑新。&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;要知道：过一个平凡无趣的人生实在太容易了，你可以不读书，不冒险，不运动，不写作，不外出，不折腾……&lt;/strong&gt;&lt;br&gt; &lt;strong&gt;但是，人生最后悔的事情就是：我本可以。生活也好，职场也罢，亦同此理；编程则更如其是&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<hr><p> <strong>人生即在于体验，而体验源于去尝试，去折腾，去改变，去塑新。</strong><br> <strong>要知道：过一个平凡无趣的人生实在太容易了，你可以不读书，不冒险，不运动，不写作，不外出，不折腾……</strong><br> <strong>但是，人生最后悔的事情就是：我本可以。生活也好，职场也罢，亦同此理；编程则更如其是</strong></p><hr><a id="more"></a><h4 id="Vue-的特点"><a href="#Vue-的特点" class="headerlink" title="Vue 的特点"></a>Vue 的特点</h4><ul><li>遵循 MVVM 模式  即MVVM 模式的一种实现</li><li>编码简洁, 体积小, 运行效率高, 适合移动/PC 端开发</li><li>它本身只关注 UI, 可以轻松引入 vue 插件（依赖vue）或其它第三库(不依赖vue)开发项目</li></ul><h4 id="MVVM-的理解"><a href="#MVVM-的理解" class="headerlink" title="MVVM  的理解"></a>MVVM  的理解</h4><ul><li>M 即 model 模型,  数据对象（data）</li><li>V 即 view 视图，模板页面</li><li>VM 即 viewModel 视图模型  是vue的实例  dom监听  数据绑定<br>  <img src="/vue/vue-note/vuenote/3.jpg" alt="图"></li></ul><h4 id="组件-即-局部功能界面-，是提供某一完整功能的模块"><a href="#组件-即-局部功能界面-，是提供某一完整功能的模块" class="headerlink" title="组件 即 局部功能界面  ，是提供某一完整功能的模块"></a>组件 即 局部功能界面  ，是提供某一完整功能的模块</h4><h4 id="模板的理解：动态的html页面，包含了一些js语法代码"><a href="#模板的理解：动态的html页面，包含了一些js语法代码" class="headerlink" title="模板的理解：动态的html页面，包含了一些js语法代码"></a>模板的理解：动态的html页面，包含了一些js语法代码</h4><h4 id="vue-扩展组件"><a href="#vue-扩展组件" class="headerlink" title="vue 扩展组件"></a>vue 扩展组件</h4><ul><li>vue-cli: vue 脚手架</li><li>axios: ajax 请求</li><li>vue-router: 路由</li><li>vuex: 状态管</li><li>vue-lazyload: 图片懒加载</li><li>vue-scroller: 页面滑动相关</li><li>mint-ui: 基于 vue 的 UI 组件库(移动端)</li><li>element-ui: 基于 vue 的 UI 组件库(PC 端)</li></ul><h4 id="编程方式"><a href="#编程方式" class="headerlink" title="编程方式"></a>编程方式</h4><ul><li>命令式 如 jquery </li><li>声明式 如 vue<h4 id="数组的扩展-array-some-和array-every-区别"><a href="#数组的扩展-array-some-和array-every-区别" class="headerlink" title="数组的扩展-array.some()和array.every()区别"></a>数组的扩展-array.some()和array.every()区别</h4></li><li>some():方法用于检测数组中的元素是否有满足指定条件的，若满足返回true，否则返回false；</li><li>every():方法用于检测数组中所有元素是否都符合指定条件，若符合返回true，否则返回false；<h4 id="挂载元素app"><a href="#挂载元素app" class="headerlink" title="挂载元素app"></a>挂载元素app</h4></li><li>new Vue({<br>  el :’#app’<br>  });<br> new vue({}).$moute(‘#app’) 用于单元测试<h4 id="vue-指令"><a href="#vue-指令" class="headerlink" title="vue 指令"></a>vue 指令</h4></li><li>v-bind  即 :   强制 动态 数据绑定（属性）</li><li>v-on    即 @   绑定事件监听</li><li>v-html  内部innerHTML    XSS攻击  内容必须是可信赖的</li></ul><h4 id="vue-计算属性-computed"><a href="#vue-计算属性-computed" class="headerlink" title="vue 计算属性 computed"></a>vue 计算属性 computed</h4><ul><li>什么时候执行 ： 初始化显示，/ 相关的data 数据属性发生变化时触发</li><li>各个方法的返回值作为相关的属性值</li><li>get 回调函数，当需要读取当前属性值的时候回调，计算并返回当前属性的值</li><li>set 回调函数，<code>监视</code>当前属性值的变化，当属性值变化时回调，更新相关的属性数据</li><li>计算属性，<code>存在缓存</code>，多次读取，只调用一次getter计算，<code>性能好</code>,</li><li>全选时可用计算属性</li></ul><h4 id="vue-的方法-methods"><a href="#vue-的方法-methods" class="headerlink" title="vue 的方法 methods"></a>vue 的方法 methods</h4><ul><li>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。</li><li>然而，不同的是计算属性是基于它们的依赖进行缓存的。只在相关依赖发生改变时它们才会重新求值</li><li>相比之下，每当触发重新渲染时，调用方法将<em>总会再次执行函数</em></li><li>如果你不希望有缓存，请用方法来替代</li></ul><h4 id="vue-的watch"><a href="#vue-的watch" class="headerlink" title="vue 的watch"></a>vue 的watch</h4><ul><li>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器</li><li>当需要在数据变化时<em>执行异步或开销较大</em>的操作时，这个方式是最有用的</li><li><img src="/vue/vue-note/vuenote/4.jpg" alt></li></ul><h4 id="绑定-style-class"><a href="#绑定-style-class" class="headerlink" title="绑定 style class"></a>绑定 style class</h4><ul><li>:class=”xxx”   xxx是字符串或对象</li><li>:style=”xxx”   xxx是对象</li></ul><h4 id="对象更新-数组更新"><a href="#对象更新-数组更新" class="headerlink" title="对象更新,数组更新"></a>对象更新,数组更新</h4><ul><li>完全跟新 即重新写这个对象</li><li>补充更新 vm.$set(要跟新的对象名,补充的属性名,属性值)</li><li>数组更新 vm.$set(要跟新的数组名,更新的下标,具体值)</li></ul><h4 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h4><ul><li>变异方法（vue重写原生的方法）即以下这些方法已不再是原生的方法</li><li>push  pop  shift unshift splice sort reverse 使用它们会触发视图更新</li><li><em>注意事项</em>： 利用索引直接设置一个项时/修改数组的长度时 vue不能检测到数组变化</li></ul><h4 id="常用事件修饰符"><a href="#常用事件修饰符" class="headerlink" title="常用事件修饰符"></a>常用事件修饰符</h4><ul><li>阻止事件冒泡 如@click.stop=”XXX”   传统方法 e.stopPropagation</li><li>取消事件默认行为 如 @click.prevent=”xxx”  传统方法 e.preventDefault</li><li>@click.once=”xxx”   点击事件将只会触发一次</li></ul><h4 id="常用按键修饰符"><a href="#常用按键修饰符" class="headerlink" title="常用按键修饰符"></a>常用按键修饰符</h4><ul><li>抬起某键时，执行操作 如按回车  @keyup.enter=”xxx” <h4 id="鼠标修饰符"><a href="#鼠标修饰符" class="headerlink" title="鼠标修饰符"></a>鼠标修饰符</h4></li><li>left   right    middle</li></ul><h4 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h4><ul><li>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</li><li>ctrl  alt shift   meta</li></ul><h4 id="表单数据的自动收集"><a href="#表单数据的自动收集" class="headerlink" title="表单数据的自动收集"></a>表单数据的自动收集</h4><ul><li>使用 v-model</li></ul><h4 id="vue实例的-生命周期（钩子函数）-大致有三个阶段"><a href="#vue实例的-生命周期（钩子函数）-大致有三个阶段" class="headerlink" title="vue实例的 生命周期（钩子函数） 大致有三个阶段"></a>vue实例的 生命周期（钩子函数） 大致有三个阶段</h4><ul><li>初始化阶段 beforeCreate created beforeMount mounted  只执行一次</li><li>更新阶段 beforeUpdate  updated  执行N次</li><li>销毁阶段 beforeDestory   destoryed</li><li>常用的有<pre><code>1：`mounted` （挂载方法） 发送*Ajax* 请求,获取真实dom ，执行定时器等异步任务2：`beforeDestory`  收尾工作，如清除定时器，解绑操作等</code></pre></li></ul><h4 id="vue-过渡-amp-动画"><a href="#vue-过渡-amp-动画" class="headerlink" title="vue 过渡&amp;动画"></a>vue 过渡&amp;动画</h4><ul><li>过渡 ：transition</li><li>显示时的效果：xxx-enter-active{…}</li><li>隐藏时的效果 ：xxx-leave-active{…} </li><li>其中xxx表示 transition元素的name 属性值</li><li>动画 ：animation</li></ul><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><ul><li>vue.filter(‘自定义函数名’，() =&gt; {…})</li></ul><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><ul><li>ref 为某个元素指定一个唯一的标识，vue对象通过$refs属性访问这个元素对象</li><li>v-cloak 防止闪现表达式 与css属性选择器配合 </li></ul><p><code>[v-cloak] {display:none}</code></p><h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><ul><li>全局指令：</li><li>vue.directive(‘指令名’，function(el,binding){…})</li><li>参数el指属性所在的标签对象  binding包含指令相关的数据对象</li><li>局部指令：<br>  在vue实例选项中配置directives:{‘指令名’，(el,binding) =&gt; {…},others}</li></ul><h4 id="vue-自定义插件-plugin"><a href="#vue-自定义插件-plugin" class="headerlink" title="vue 自定义插件 plugin"></a>vue 自定义插件 plugin</h4><ul><li>Vue 插件是一个包含 install 方法的对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> 自定义 Vue 插件 包在匿名函数自执行里面</span><br><span class="line"></span><br><span class="line">(function () &#123;</span><br><span class="line">const MyPlugin = &#123;&#125;;</span><br><span class="line">MyPlugin.install = function (Vue, options) &#123;</span><br><span class="line">// 1. 添加全局方法或属性</span><br><span class="line">Vue.myGlobalMethod = function () &#123;</span><br><span class="line">    alert(&apos;Vue 函数对象方法执行&apos;)</span><br><span class="line">&#125;;</span><br><span class="line">// 2. 添加全局资源</span><br><span class="line">Vue.directive(&apos;my-directive&apos;, function (el, binding) &#123;</span><br><span class="line">el.innerHTML = &quot;MyPlugin my-directive &quot; + binding.value</span><br><span class="line">&#125;);</span><br><span class="line">// 3. 添加实例方法</span><br><span class="line">Vue.prototype.$myMethod = function () &#123;</span><br><span class="line">alert(&apos;vue 实例对象方法执行&apos;)</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">window.MyPlugin = MyPlugin;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><ul><li>页面使用插件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">&lt;!--使用自定义指令--&gt;</span><br><span class="line">&lt;p v-my-directive=&quot;msg&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;vue-myPlugin.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">//声明使用自定义插件</span><br><span class="line">Vue.use(MyPlugin)</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">el: &apos;#demo&apos;,</span><br><span class="line">data: &#123;</span><br><span class="line">msg: &apos;atguigu&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">//调用自定义的静态方法</span><br><span class="line"></span><br><span class="line">Vue.myGlobalMethod()</span><br><span class="line">//调用自定义的对象方法</span><br><span class="line"></span><br><span class="line">vm.$myMethod()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="vue-组件"><a href="#vue-组件" class="headerlink" title="vue 组件"></a>vue 组件</h4><ul><li>全局组件<br><img src="/vue/vue-note/vuenote/6.jpg" alt><br><img src="/vue/vue-note/vuenote/5.jpg" alt></li><li>局部组件<h4 id="vue-组件间通信"><a href="#vue-组件间通信" class="headerlink" title="vue 组件间通信"></a>vue 组件间通信</h4></li><li><img src="/vue/vue-note/vuenote/7.jpg" alt></li><li><code>父传向子</code> props<ol><li>在组件内声明所有的 props</li><li>方式一: 只指定名称<br>props: [‘name’, ‘age’, ‘setName’]</li><li>方式二: 指定名称和类型<br>props: {<br> name: String, age: Number, setNmae: Function<br>}</li><li>方式三: 指定名称/类型/必要性/默认值<br>props: {<br> name: {type: String, required: true, default:xxx},<br>}<br><em>问题</em>:</li></ol></li></ul><ul><li>a. 如果需要向非子后代传递数据必须多层逐层传递</li><li>b. 兄弟组件间也不能直接 props 通信, 必须借助父组件才可以</li></ul><ol start="11"><li><em>属性校验</em></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 要校验的 props : &#123;</span><br><span class="line">msg :&#123;</span><br><span class="line">type :Number,</span><br><span class="line">validator (value)&#123; //validator 属性校验器，可以自定义属性校验</span><br><span class="line">return value &gt; 3;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr :&#123;</span><br><span class="line">type :Array,</span><br><span class="line">default :() =&gt; ([1,2,3]) // 属性校验中，如果是`数组/对象` 需要将默认值返回</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>子传向父</code> 通过自定义事件</li><li>绑定事件监听     </li></ol><ul><li>// 方式一: 通过 v-on 绑定</li><li>@delete_todo=”deleteTodo”</li><li>// 方式二: 通过$on()</li><li>this.$refs.xxx.$on(‘delete_todo’, function (todo) {</li><li>this.deleteTodo(todo)</li><li>})</li></ul><ol start="22"><li>触发事件     </li></ol><ul><li>// 触发事件(只能在父组件中接收)</li><li>this.$emit(eventName, data)</li><li><em>问题</em>: 隔代组件或兄弟组件间通信此种方式不合适</li><li>vue 自定义事件 我的理解</li><li><p>子组件中<br>  @click=”add”<br>  methods 里面 是具体的add方法干的事情<br>  add里面最终 通过this.$emit(“add”,this.msg)通知父级我触发了此事件<br>  并传值给父组件</p></li><li><p>父组件中<br>  监听@add=”addCounter”<br>methods里面定义addCounter要干啥事，用一个形参接收子组件传来的值</p></li></ul><ol start="3"><li><code>消息订阅与发布(PubSubJS 库)</code> </li><li>订阅消息   —-&gt;事件监听</li></ol><ul><li>PubSub.subscribe(‘msg’, function(msg, data){})</li></ul><ol start="32"><li>发布消息  —–&gt;触发事件</li></ol><ul><li>PubSub.publish(‘msg’, data)</li><li><em>优点</em>: 此方式可实现任意关系组件间通信(数据)</li></ul><ol start="4"><li><code>slot(插槽，占位的)</code></li><li>此方式用于父组件向子组件传递<em>标签数据</em><br>4.2 复用性          </li><li>使用</li><li>父组件中 使用子组件，slot属性 ：<div slot="xxx">xxx 对应的标签结构</div></li><li>子组件中 定义插槽，slot元素 name属性：<slot name="xxx">不确定的标签结构 1</slot> </li><li>插槽对应的方法属性等定义在父组件中，</li></ol><h4 id="模块导出为函数还是对象的依据"><a href="#模块导出为函数还是对象的依据" class="headerlink" title="模块导出为函数还是对象的依据"></a>模块导出为函数还是对象的依据</h4><p><code>要看模块向外暴露一个功能还是多个功能</code></p><ul><li>一个功能即函数</li><li>多个功能则对象 ，因为对象可以包含多个方法</li></ul><h4 id="ajax-插件相关知识"><a href="#ajax-插件相关知识" class="headerlink" title="ajax 插件相关知识"></a>ajax 插件相关知识</h4><ul><li>下载插件</li><li>引入插件</li><li>声明使用插件  即 Vue.use(名字)</li><li><code>方式一</code>：vue-resource 内部会给vm对象和组件对象添加一个属性：$http </li><li>$http 有两个方法 get() ,post()</li><li><code>方式二</code>：axios    vue.2.X   </li><li>下载 npm install axios –save</li></ul><ul><li>// 直接引入模块使用，不用声明  <code>在哪里使用在哪里引入</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import axios from &apos;axios&apos; // 发送 ajax 请求</span><br><span class="line">axios.get(url)</span><br><span class="line">.then(response =&gt; &#123;</span><br><span class="line">    console.log(response.data) // 得到返回结果数据</span><br><span class="line">&#125;)</span><br><span class="line">.catch(error =&gt; &#123;</span><br><span class="line">    console.log(error.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="数组方法之map方法的特点：数组里面的对象变，但数组对象的个数不变"><a href="#数组方法之map方法的特点：数组里面的对象变，但数组对象的个数不变" class="headerlink" title="数组方法之map方法的特点：数组里面的对象变，但数组对象的个数不变"></a>数组方法之map方法的特点：数组里面的对象变，但数组对象的个数不变</h4><h4 id="组件名称-路由相关"><a href="#组件名称-路由相关" class="headerlink" title="组件名称 路由相关"></a>组件名称 路由相关</h4><ul><li>开发中分为路由组件和非路由组件</li><li>路由组件 名称为 views 或 pages</li><li><p>非路由组件 名称为 components </p></li><li><p><code>路由器</code>模块命名为router建立index.js文件 </p></li><li>路由器模块: src/router/index.js</li><li>引入vue     import Vue from ‘vue’</li><li>引入VueRouter     import VueRouter from ‘vue-router’</li><li>注册使用VueRouter     Vue.use(VueRouter) </li><li><p>导出一个VueRouter实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> export default new VueRouter(&#123;</span><br><span class="line">routes 数组，</span><br><span class="line">routes: [  // 路由配置  k即（path） 和value即（component）</span><br><span class="line">&#123;</span><br><span class="line">path: &apos;/&apos;, redirect: &apos;/about&apos; </span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">path: &apos;/about&apos;, component: About</span><br><span class="line">&#125;,</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>注册路由器: main.js</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> import Vue from &apos;vue&apos; </span><br><span class="line"> import router from &apos;./router&apos; // 创建 vue 配置路由器</span><br><span class="line">new Vue(&#123;</span><br><span class="line">el: &apos;#app&apos;,</span><br><span class="line">router, </span><br><span class="line">render: h =&gt; h(app)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>使用路由组件标签</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--路由链接--&gt;</span><br><span class="line">&lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;</span><br><span class="line">&lt;!--用于渲染当前路由组件--&gt;</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><ul><li>子路由 children   path可以写全或 直接写当前的路由名字（简化写法）</li></ul><h4 id="缓存路由组件对象"><a href="#缓存路由组件对象" class="headerlink" title="缓存路由组件对象"></a>缓存路由组件对象</h4><ul><li>默认情况下, 被切换的路由组件对象会死亡释放, 再次回来时是重新创建的</li><li>如果可以缓存路由组件对象, 可以提高用户体验</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><h4 id="向路由组件传递数据"><a href="#向路由组件传递数据" class="headerlink" title="向路由组件传递数据"></a>向路由组件传递数据</h4><ul><li>方式 1: 路由路径携带参数(param/query)</li></ul><ul><li>配置路由</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">children: [</span><br><span class="line">&#123;</span><br><span class="line">path: &apos;mdetail/:id&apos;, component: MessageDetail</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>路由路径</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&apos;/home/message/mdetail/&apos;+m.id&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><ul><li>路由组件中读取请求参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$route.params.id</span><br></pre></td></tr></table></figure><ul><li>方式 2: <router-view>属性携带数据</router-view></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view :msg=&quot;msg&quot;&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><h4 id="编程式路由导航-即用js-的方法实现而非-标签方式"><a href="#编程式路由导航-即用js-的方法实现而非-标签方式" class="headerlink" title="编程式路由导航 即用js 的方法实现而非 标签方式"></a>编程式路由导航 即用js 的方法实现而非 标签方式</h4><ul><li>相关 API  栈的结构</li><li>this.$router.push(path): 相当于点击路由链接(可以返回到当前路由界面)</li><li>this.$router.replace(path): 用新路由替换当前路由(不可以返回到当前路由界面)</li><li>this.$router.back(): 请求(返回)上一个记录路由</li><li>this.$router.go(-1): 请求(返回)上一个记录路由</li><li>this.$router.go(1): 请求下一个记录路由</li></ul><h4 id="栈-队列"><a href="#栈-队列" class="headerlink" title="栈 队列"></a>栈 队列</h4><ul><li>例子 ： 喝醉酒后<em>站</em>着从上面出来即为<em>栈</em> </li></ul><h4 id="call-方法调用"><a href="#call-方法调用" class="headerlink" title="call 方法调用"></a>call 方法调用</h4><ul><li>让一个函数成为指定对象的方法进行调用 slice.call(lis)</li><li>即让slice函数成为lis的方法进行调用</li></ul>]]></content:encoded>
      
      <comments>https://shulu520.com/vue/vue-note/#disqus_thread</comments>
    </item>
    
    <item>
      <title>less-note</title>
      <link>https://shulu520.com/less/less/</link>
      <guid>https://shulu520.com/less/less/</guid>
      <pubDate>Wed, 17 Apr 2019 12:00:21 GMT</pubDate>
      <description>
      
        &lt;hr&gt;
&lt;p&gt; &lt;strong&gt;君子生非异也，善假于物也.&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<hr><p> <strong>君子生非异也，善假于物也.</strong></p><hr><a id="more"></a><h4 id="less-即css预处理器"><a href="#less-即css预处理器" class="headerlink" title="less 即css预处理器"></a>less 即css预处理器</h4><ul><li>vscode 编辑器 下载插件 easy less</li><li>声明编码集  @charset “utf-8”<h4 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h4></li><li><p>声明变量(原始值类型) @bb:#ff0000;<br>  使用变量    color:@bb;</p></li><li><p>声明变量（路劲类型） @img:”../images”;<br>  使用变量    background-image:url(“@{img}/1.jpg”)</p></li><li><p>声明变量(属性类型)   @ww:width;<br>  使用变量    @{ww}:100px;</p></li></ul><h4 id="混合方式"><a href="#混合方式" class="headerlink" title="混合方式"></a>混合方式</h4><ul><li><p>带默认参数     </p><pre><code>定义 .border-r(@radius:5px){                    border-radiis:@radius;                         }使用 .box{                .border-r; 传参即.border-r(10px);        }</code></pre></li><li><p>接收多个参数</p><pre><code>定义 .box-s(@x, @y, @blur, @color){                        box-shadow:@arguments;                                 }    使用 .box{                .box-s(3px,4px,5px,red)            }</code></pre><h4 id="color-函数-了解就行"><a href="#color-函数-了解就行" class="headerlink" title="color 函数 了解就行"></a>color 函数 了解就行</h4></li></ul><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><ul><li>各种可以计算的都可以计算 包括颜色值</li><li>支持运算符 +  -  *  /   即加减乘除<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4></li><li>它用于将mixins分组在通用名称下。 </li><li>使用命名空间可以避免名称冲突，并从外部封装mixin组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">定义：</span><br><span class="line">#bgcolor()&#123; // 加 () 默认不输出</span><br><span class="line">background: #ffffff;</span><br><span class="line">    .a&#123;</span><br><span class="line">        color: #888888;</span><br><span class="line">        &amp;:hover&#123;</span><br><span class="line">          color: green;</span><br><span class="line">        &#125;</span><br><span class="line">        .b&#123;</span><br><span class="line">          background: red;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">使用：</span><br><span class="line">.bgcolor1&#123;</span><br><span class="line">  background: yellow;</span><br><span class="line">  #bgcolor&gt;.a;    // &gt;符号表示选中混合中的每一个样式</span><br><span class="line">&#125;</span><br><span class="line">.bgcolor2&#123;</span><br><span class="line">  // #bgcolor&gt;.a&gt;.b;</span><br><span class="line">  #bgcolor .a .b;  // 省略写法：将&gt;换成空格即可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="避免编译"><a href="#避免编译" class="headerlink" title="避免编译"></a>避免编译</h4><ul><li>我们能在编译后的css文件中看到 它 编译计算之前的样子</li><li>最终的编译计算由浏览器来完成</li><li>css3中有这样一个函数calc()</li><li><p>less里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">width:~&apos;calc(300px - 10px)&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译完的 css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">width:calc(300px - 10px)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="important"><a href="#important" class="headerlink" title="!important"></a>!important</h4><ul><li>css 样式中 用来提升优先级（最高）</li><li>less 中 一样 常用来调试代码</li><li>比如 某一段样式不起作用，不知道是继承还是覆盖等造成的</li><li>给他加上 !important 还不起作用的话 就说明代码书写有误</li></ul>]]></content:encoded>
      
      <comments>https://shulu520.com/less/less/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>

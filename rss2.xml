<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>梦不成</title>
    <link>https://shulu520.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>君子生非异也，善假于物也.</description>
    <pubDate>Thu, 30 May 2019 15:43:30 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>js-advance-three</title>
      <link>https://shulu520.com/js-advance/js-advance-three/</link>
      <guid>https://shulu520.com/js-advance/js-advance-three/</guid>
      <pubDate>Thu, 30 May 2019 10:42:14 GMT</pubDate>
      <description>
      
        guigu js 高级教程笔记③——对象高级
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;想起你，内心充满欢喜O(∩_∩)O</p><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><br><a id="more"></a></p><h2 id="对象的创建模式"><a href="#对象的创建模式" class="headerlink" title="对象的创建模式"></a>对象的创建模式</h2><ul><li><p>Object构造函数模式</p><ul><li>套路: 先创建空Object对象, 再动态添加属性/方法</li><li>适用场景: 起始时不确定对象内部数据</li><li>问题: 语句太多</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object()</span><br><span class="line">obj.name = &apos;Tom&apos;</span><br><span class="line">obj.setName = function(name)&#123;this.name=name&#125;</span><br></pre></td></tr></table></figure></li><li><p>对象字面量模式</p><ul><li>套路: 使用{}创建对象, 同时指定属性/方法</li><li>适用场景: 起始时对象内部数据是确定的</li><li>问题: 如果创建多个对象, 有重复代码</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name : &apos;Tom&apos;,</span><br><span class="line">  setName : function(name)&#123;this.name = name&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>工厂函数模式 <ul><li>套路: 通过工厂函数动态创建对象并返回</li><li>适用场景: 需要创建多个对象</li><li>问题: 对象没有一个具体的类型, 都是Object类型<br>  即通过instanceof判断得到的都是Object类型<br>  类型不够具体 人和🐶均为同一类型</li><li>用的不多 只是比较经典</li><li>返回一个对象的函数===&gt;工厂函数 联系真实工厂</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name, age) &#123; </span><br><span class="line">  var obj = &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    age: age,</span><br><span class="line">    setName: function (name) &#123;</span><br><span class="line">      this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造函数模式<ul><li>套路: 自定义构造函数, 通过new创建实例对象</li><li>适用场景: 需要创建多个类型确定的对象</li><li>问题: 每个对象都有相同的数据, 浪费内存</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.setName = function(name)&#123;this.name=name;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">new Person(&apos;tom&apos;, 12);</span><br></pre></td></tr></table></figure><ul><li>组合模式 (构造函数+原型)<ul><li>套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上</li><li>适用场景: 需要创建多个类型确定的对象</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = function(name)&#123;this.name=name;&#125;;</span><br><span class="line">new Person(&apos;tom&apos;, 12);</span><br></pre></td></tr></table></figure><h2 id="继承模式"><a href="#继承模式" class="headerlink" title="继承模式"></a>继承模式</h2><ul><li>原型链继承 : 得到方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;&#125;</span><br><span class="line">Parent.prototype.test = function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">function Child() &#123;&#125;</span><br><span class="line">Child.prototype = new Parent(); //子类型的原型指向父类型实例</span><br><span class="line">Child.prototype.constructor = Child //修正constructor属性重新指向子构造函数</span><br><span class="line"></span><br><span class="line">var child = new Child(); //有test()</span><br></pre></td></tr></table></figure><ul><li>借用构造函数 : 得到属性<br>(假继承)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Parent(xxx)&#123;this.xxx = xxx&#125;</span><br><span class="line">Parent.prototype.test = function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">function Child(xxx,yyy)&#123;</span><br><span class="line">  Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)</span><br><span class="line">&#125;</span><br><span class="line">var child = new Child(&apos;a&apos;, &apos;b&apos;);  //child.xxx为&apos;a&apos;, 但child没有test()</span><br></pre></td></tr></table></figure><ul><li>组合继承 (原型链继承+构造函数)<ul><li>利用原型链实现对父类型对象的方法继承</li><li>利用call()借用父类型构建函数初始化相同属性</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Parent(xxx)&#123;this.xxx = xxx&#125;</span><br><span class="line">Parent.prototype.test = function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">function Child(xxx,yyy)&#123;</span><br><span class="line">  Parent.call(this, xxx)//借用构造函数   this.Parent(xxx)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = new Parent() //得到test()</span><br><span class="line">Child.prototype.constructor = Child //修正constructor属性</span><br><span class="line"></span><br><span class="line">var child = new Child(); //child.xxx为&apos;a&apos;, 也有test()</span><br></pre></td></tr></table></figure><ul><li>new一个对象背后做了些什么?<ul><li>创建一个空对象</li><li>给对象设置<strong>proto</strong>, 值为构造函数对象的prototype属性值   this.<strong>proto</strong> = Fn.prototype</li><li>执行构造函数体(给对象添加属性/方法)</li></ul></li></ul><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div></p><center><img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:skyblue;font-weight:bold;" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">来我QQ撩我哦👇</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/js-advance/js-advance-three/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hotkey-listary</title>
      <link>https://shulu520.com/hotkey/hotkey-listary/</link>
      <guid>https://shulu520.com/hotkey/hotkey-listary/</guid>
      <pubDate>Tue, 28 May 2019 15:21:39 GMT</pubDate>
      <description>
      
        listary最常用的快捷键
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;人生如逆旅，我亦是行人。</p><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><br><a id="more"></a></p><h2 id="listary-最常用的快捷键"><a href="#listary-最常用的快捷键" class="headerlink" title="listary 最常用的快捷键"></a>listary 最常用的快捷键</h2><ul><li>alt A 打开listary</li><li><p>双击 ctrl 打开listary</p></li><li><p>bing 必应搜索</p></li><li>bd 百度一下 百度网盘</li><li><p>zh 知乎搜索</p></li><li><p>ctrl N 向下切换选中的目录</p></li><li><p>ctrl P 向上切换选中的目录</p></li><li><p>双击桌面 打开listary选项</p></li><li>在任意文件夹/目录下双击 打开listary选项 可以选命令打开cmd</li></ul><p><div style="width:100%;height:1px;background-color:pink"></div><br>&emsp;&emsp;未完待续……</p><center><img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:skyblue;font-weight:bold;" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">来我QQ撩我哦👇</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/hotkey/hotkey-listary/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hotkey-windows</title>
      <link>https://shulu520.com/hotkey/hotkey-windows/</link>
      <guid>https://shulu520.com/hotkey/hotkey-windows/</guid>
      <pubDate>Mon, 27 May 2019 04:24:05 GMT</pubDate>
      <description>
      
        windows 最常用快捷键总结
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;</p><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decoration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">Q我吧</a></center><a id="more"></a><h2 id="windows-最常用快捷键"><a href="#windows-最常用快捷键" class="headerlink" title="windows 最常用快捷键"></a>windows 最常用快捷键</h2><ul><li><p>ctrl  w  关闭当前网页</p></li><li><p>f2键 ：选中后按f2键即可重命名文件，另一种方法，点一下文件名，稍等，再点一下，即可重命名</p></li><li><p>f4: 重复上步操作</p></li><li><p>f5: 刷新桌面 刷新网页</p></li><li><p>f11: 全屏显示网页</p></li><li><p>shift :<br>  省略号    shift + 数字6  （表示六个点）    ……</p><p>  书名号     shift + &lt;&gt;   (小于大于）</p></li><li><p>分隔号   单独按 数字1 前面的键    《简 · 爱》</p></li><li><p>Alt + 单击拖动  为矩形选择</p></li><li><p>AlT + f4 关闭当前程序</p></li><li><p>删除  选中后 按delete </p></li><li><p>永久删除  选中后  shift +delete</p></li><li><p>截屏   PrtSc     截全屏<br>  Alt  +PrtSc  截当前窗口</p></li><li><p>ctrl alt delete 任务管理器</p></li><li><p>windows 打开开始菜单</p></li><li><p>ctrl shift n  新建文件夹</p></li><li><p>window e 打开文件资源管理器</p></li><li><p>alt tab 切换窗口 </p></li><li><p>window d 回到桌面</p></li></ul><hr><p>&emsp;&emsp;学到了再来补充😝</p><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decoration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">点这里，进入QQ交流</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/hotkey/hotkey-windows/#disqus_thread</comments>
    </item>
    
    <item>
      <title>js-advance-two</title>
      <link>https://shulu520.com/js-advance/js-advance-two/</link>
      <guid>https://shulu520.com/js-advance/js-advance-two/</guid>
      <pubDate>Sat, 25 May 2019 15:06:08 GMT</pubDate>
      <description>
      
        guigu js 高级教程笔记②——函数高级
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;又是元气满满的一天😝,文章链接失效，又好了。有惊无险</p><center><img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:skyblue;font-weight:bold;" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">来我QQ撩我哦👇</a></center><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div></p><h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><ul><li>所有函数都有一个特别的属性:<ul><li><strong>prototype</strong> : 显式原型属性</li></ul></li><li>所有实例对象都有一个特别的属性:<ul><li><strong><strong>proto</strong></strong> : 隐式原型属性</li></ul></li></ul><p><img src="https://www.z4a.net/images/2019/05/27/20190526235616.png" alt="原型链图"></p><ul><li>当然所有函数也都有一个特别的属性：<ul><li><strong><strong>proto</strong></strong> : 隐式原型属性</li></ul></li><li>且所有函数的 隐式原型 都一样 都等于Function的显式原型 </li><li>函数的显式原型指向的对象默认是空Object实例对象(但Object不满足)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(Fn.prototype instanceof Object) // true</span><br><span class="line">console.log(Object.prototype instanceof Object) // false</span><br><span class="line">console.log(Function.prototype instanceof Object) // true</span><br></pre></td></tr></table></figure><ul><li>所有函数都是Function的实例(包含Function自身)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Function.__proto__===Function.prototype)</span><br></pre></td></tr></table></figure><ul><li>Object的原型对象是原型链尽头</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.__proto__) // null</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)</span><br><span class="line">console.log(Date.prototype, typeof Date.prototype)</span><br><span class="line">function Fun () &#123;//alt + shift +r(重命名rename)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(Fun.prototype)  // 默认指向一个Object空对象(没有我们的属性)</span><br><span class="line"></span><br><span class="line">// 原型对象中有一个属性constructor, 它指向函数对象</span><br><span class="line">console.log(Date.prototype.constructor===Date)</span><br><span class="line">console.log(Fun.prototype.constructor===Fun)</span><br><span class="line"></span><br><span class="line">//给原型对象添加属性(一般是方法) ===&gt;实例对象可以访问</span><br><span class="line">Fun.prototype.test = function () &#123;</span><br><span class="line">  console.log(&apos;test()&apos;)</span><br><span class="line">&#125;</span><br><span class="line">var fun = new Fun()</span><br><span class="line">fun.test()</span><br></pre></td></tr></table></figure><ul><li>显式原型与隐式原型的关系<ul><li>函数的prototype: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象</li><li>实例对象的<strong>proto</strong>: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值</li><li>原型对象即为当前实例对象的父对象</li></ul></li><li><p>原型链</p><ul><li>所有的实例对象都有<strong>proto</strong>属性, 它指向的就是原型对象</li><li>这样通过<strong>proto</strong>属性就形成了一个链的结构—-&gt;原型链</li><li>当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找</li><li>当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作,如果当前对象中没有此属性, 直接添加此属性并设置其值</li><li>方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上</li></ul></li><li><p>面试题1</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function A () &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.n = 1</span><br><span class="line"></span><br><span class="line">var b = new A()</span><br><span class="line"></span><br><span class="line">A.prototype = &#123;</span><br><span class="line">  n: 2,</span><br><span class="line">  m: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c = new A()</span><br><span class="line">console.log(b.n, b.m, c.n, c.m) // 1  undifind  2  3</span><br></pre></td></tr></table></figure><ul><li>面试题2</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function F ()&#123;&#125;</span><br><span class="line">  Object.prototype.a = function()&#123;</span><br><span class="line">    console.log(&apos;a()&apos;)</span><br><span class="line">&#125;</span><br><span class="line">Function.prototype.b = function()&#123;</span><br><span class="line">  console.log(&apos;b()&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f = new F()</span><br><span class="line"></span><br><span class="line">f.a()</span><br><span class="line"></span><br><span class="line">f.b() // 找不到,可以看原型链图进行分析</span><br><span class="line"></span><br><span class="line">F.a()</span><br><span class="line">F.b()</span><br></pre></td></tr></table></figure><ul><li>instanceof是如何判断的?<ul><li>表达式: A instanceof B</li><li>如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false</li></ul></li><li>Function是通过new自己产生的实例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">案例1</span><br><span class="line"> */</span><br><span class="line">function Foo() &#123;  &#125;</span><br><span class="line">var f1 = new Foo()</span><br><span class="line">console.log(f1 instanceof Foo) // true</span><br><span class="line">console.log(f1 instanceof Object) // true</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">案例2</span><br><span class="line"> */</span><br><span class="line">console.log(Object instanceof Function) // true</span><br><span class="line">console.log(Object instanceof Object) // true</span><br><span class="line">console.log(Function instanceof Function) // true</span><br><span class="line">console.log(Function instanceof Object) // true</span><br><span class="line"></span><br><span class="line">function Foo() &#123;&#125;</span><br><span class="line">console.log(Object instanceof  Foo) // false</span><br></pre></td></tr></table></figure><h2 id="执行上下文与执行上下文栈"><a href="#执行上下文与执行上下文栈" class="headerlink" title="执行上下文与执行上下文栈"></a>执行上下文与执行上下文栈</h2><ul><li>变量提升与函数提升<ul><li>变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined)</li><li>函数提升: 在函数定义语句之前, 就执行该函数</li><li><strong>先执行变量提升, 再执行函数提升</strong></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;&#125;</span><br><span class="line">var a</span><br><span class="line">console.log(typeof a) // &apos;function&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var c = 1</span><br><span class="line">function c(c) &#123;</span><br><span class="line">  console.log(c)</span><br><span class="line">  var c = 3</span><br><span class="line">&#125;</span><br><span class="line">c(2) // 报错 c is not a function</span><br><span class="line"></span><br><span class="line">过程解析：</span><br><span class="line">  var c</span><br><span class="line">  fun c</span><br><span class="line">  c = 1</span><br><span class="line">  c(2)</span><br></pre></td></tr></table></figure><ul><li>理解<ul><li>执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性</li><li>执行上下文栈: 用来管理产生的多个执行上下文</li></ul></li><li>分类:<ul><li>全局: window</li><li>函数: 对程序员来说是透明的</li></ul></li><li>生命周期<ul><li>全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡</li><li>函数 : 调用函数时产生, 函数执行完时死亡</li></ul></li><li>包含哪些属性:<ul><li>全局 : <ul><li>用var定义的全局变量  ==&gt;undefined</li><li>使用function声明的函数   ===&gt;function</li><li>this   ===&gt;window</li></ul></li><li>函数<ul><li>用var定义的局部变量  ==&gt;undefined</li><li>使用function声明的函数   ===&gt;function</li><li>this   ===&gt; 调用函数的对象, 如果没有指定就是window </li><li>形参变量   ===&gt;对应实参值</li><li>arguments ===&gt;实参列表的伪数组</li></ul></li></ul></li><li>执行上下文 创建和初始化的过程</li><li>全局执行上下文:<ul><li>在全局代码执行前最先创建一个全局执行上下文(window)</li><li>收集一些全局变量, 并初始化<ul><li>var定义的全局变量==&gt;undefined, 添加为window的属性</li><li>function声明的全局函数==&gt;赋值(fun), 添加为window的方法</li></ul></li><li>this==&gt;赋值(<strong>window</strong>)</li><li>开始执行全局代码</li></ul></li><li>函数执行上下文:<ul><li>在调用函数时, 在执行函数体之前，先创建一个函数执行上下文对象(虚拟的, 存在于栈中)</li><li>收集一些局部变量, 并初始化<ul><li>形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性</li><li>arguments==&gt;赋值(实参列表), 添加为执行上下文的属性</li><li>var定义的局部变量==&gt;undefined, 添加为执行上下文的属性</li><li>function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法</li></ul></li><li>this==&gt;赋值(<strong>调用函数的对象</strong>)</li><li>开始执行函数体代码</li></ul></li><li>执行上下文栈<ul><li>在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象</li><li>在全局执行上下文(window)确定后, 将其添加到栈中(压栈)</li><li>在函数执行上下文创建后, 将其添加到栈中(压栈)</li><li>在当前函数执行完后,将栈顶的对象移除(出栈)</li><li>当所有的代码执行完后, 栈中只剩下window</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = 10</span><br><span class="line">var bar = function (x) &#123;</span><br><span class="line">  var b = 5</span><br><span class="line">  foo(x + b)</span><br><span class="line">&#125;</span><br><span class="line">var foo = function (y) &#123;</span><br><span class="line">  var c = 5</span><br><span class="line">  console.log(a + c + y)</span><br><span class="line">&#125;</span><br><span class="line">bar(10)</span><br></pre></td></tr></table></figure><p><img src="https://www.z4a.net/images/2019/05/27/20190527165142.md.png" alt="执行上下文栈图"></p><ul><li><p><strong>产生执行上下文的个数</strong> = (N)函数调用次数 + 1</p></li><li><p>面试题</p></li><li>整个过程中产生了几个执行上下文?  5</li><li>依次输出什么?<br>  gb: undefined<br>  fb: 1<br>  fb: 2<br>  fb: 3<br>  fe: 3<br>  fe: 2<br>  fe: 1<br>  ge: 1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;gb: &apos;+ i)</span><br><span class="line">var i = 1</span><br><span class="line">foo(1)</span><br><span class="line">function foo(i) &#123;</span><br><span class="line">  if (i == 4) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&apos;fb:&apos; + i)</span><br><span class="line">  foo(i + 1) // 递归调用: 在函数内部调用自己</span><br><span class="line">  console.log(&apos;fe:&apos; + i)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&apos;ge: &apos; + i)</span><br></pre></td></tr></table></figure><h2 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h2><ul><li>理解:<ul><li>作用域: 一块代码区域, 在编码时就确定了, 不会再变化</li><li>作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量</li><li><strong>产生作用域的个数</strong> = (N)定义函数的个数 + 1</li></ul></li><li>分类:<ul><li>全局</li><li>函数</li><li>js没有块作用域(在ES6之前)</li></ul></li><li>作用<ul><li>作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突</li><li>作用域链: 查找变量</li></ul></li><li><p>区别作用域与执行上下文</p><ul><li>作用域: <strong>静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了</strong></li><li>执行上下文: <strong>动态的, 执行代码时动态创建, 当执行结束消失</strong></li><li>联系: 执行上下文环境是在对应的作用域中的</li></ul></li><li><p>面试题</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var x = 10;</span><br><span class="line"></span><br><span class="line">  function fn() &#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function show(f) &#123;</span><br><span class="line">    var x = 20;</span><br><span class="line">    f();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  show(fn); // 10 </span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">    解析：作用域在函数创建的时候就确定了，一旦确定就不会变化了</span><br><span class="line">  */</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var fn = function () &#123;</span><br><span class="line">    console.log(fn)</span><br><span class="line">  &#125;</span><br><span class="line">  fn() // fn函数体</span><br><span class="line"></span><br><span class="line">  var obj = &#123;</span><br><span class="line">    fn2: function () &#123;</span><br><span class="line">     console.log(fn2)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  obj.fn2() // fn2 is not defind</span><br><span class="line">  /*</span><br><span class="line">    解析：</span><br><span class="line">      首先在fn2函数作用域里面找fn2 没有  </span><br><span class="line">      然后再全局作用域找 也没有 故报错</span><br><span class="line">      若为this.fn2 则可以</span><br><span class="line">  */</span><br></pre></td></tr></table></figure><h2 id="作用域链和原型链的用处"><a href="#作用域链和原型链的用处" class="headerlink" title="作用域链和原型链的用处"></a>作用域链和原型链的用处</h2><ul><li>作用域链用来找变量</li><li><p>原型链用来找方法</p></li><li><p>在全局直接找一个不存在的方法 a is not defined</p></li><li>而通过window.a 则为undifind</li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul><li><p>如何产生闭包?</p><ul><li>当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包</li></ul></li><li><p><strong>闭包到底是什么</strong>?</p><ul><li>使用chrome调试查看 会调试的程序员至少不是初级程序员</li><li>理解一: 闭包是嵌套的内部函数(绝大部分人) 初步认识</li><li>理解二: <strong>包含被引用变量(函数)的对象</strong>(极少数人) 高级认识</li><li>注意: 闭包存在于嵌套的内部函数中</li></ul></li><li><p>产生闭包的条件</p><ul><li>函数嵌套</li><li>内部函数引用了外部函数的数据(变量/函数)</li></ul></li><li><p>产生闭包的个数</p><ul><li>等于外部函数调用的次数</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//三个button按钮</span><br><span class="line">for (var i = 0,length=btns.length; i &lt; length; i++) &#123;</span><br><span class="line">    (function (j) &#123;</span><br><span class="line">      var btn = btns[j]</span><br><span class="line">      btn.onclick = function () &#123;</span><br><span class="line">        alert(&apos;第&apos;+(j+1)+&apos;个&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">  &#125;</span><br><span class="line">// 共产生三个闭包 因为外部函数共调用了三次，每一闭包内部都保存了各自的变量</span><br></pre></td></tr></table></figure><ul><li><p>常见的闭包</p><ul><li>将函数作为另一个函数的返回值</li><li>将函数作为实参传递给另一个函数调用</li></ul></li><li><p>闭包生命周期</p><ul><li>产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)</li><li>死亡: 在嵌套的内部函数成为垃圾对象时</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fn1() &#123;</span><br><span class="line">  //此时闭包就已经产生了(函数提升, 内部函数对象已经创建了)</span><br><span class="line">  var a = 2</span><br><span class="line">  function fn2 () &#123;</span><br><span class="line">    a++</span><br><span class="line">    console.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  return fn2</span><br><span class="line">&#125;</span><br><span class="line">var f = fn1() //f来接收fn2</span><br><span class="line">f() // 3</span><br><span class="line">f() // 4</span><br><span class="line">f = null //闭包死亡(包含闭包的函数对象成为垃圾对象)</span><br></pre></td></tr></table></figure><ul><li>作用:<ul><li>延长局部变量的生命周期</li><li>让函数外部能操作内部的局部变量</li></ul></li><li>写一个闭包程序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function fn1() &#123;</span><br><span class="line">  var a = 2</span><br><span class="line">  function fn2() &#123;</span><br><span class="line">    a++</span><br><span class="line">    console.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  return fn2</span><br><span class="line">&#125;</span><br><span class="line">var f = fn1()</span><br><span class="line">f()</span><br><span class="line">f()</span><br></pre></td></tr></table></figure><ul><li>闭包应用:<ul><li>模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为</li><li>循环遍历加监听</li><li>JS框架(jQuery)大量使用了闭包</li></ul></li><li>缺点:<ul><li>变量占用内存的时间可能会过长</li><li>可能导致内存泄露</li><li>解决:<ul><li><strong>及时释放</strong> : f = null; //让内部函数对象成为垃圾对象</li></ul></li></ul></li></ul><ul><li>面试题1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//代码片段一</span><br><span class="line">var name = &quot;The Window&quot;;</span><br><span class="line">var object = &#123;</span><br><span class="line">  name : &quot;My Object&quot;,</span><br><span class="line">  getNameFunc : function()&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">      return this.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()());  // the window</span><br><span class="line"></span><br><span class="line">//代码片段二</span><br><span class="line">var name2 = &quot;The Window&quot;;</span><br><span class="line">var object2 = &#123;</span><br><span class="line">  name2 : &quot;My Object&quot;,</span><br><span class="line">  getNameFunc : function()&#123;</span><br><span class="line">    var that = this;</span><br><span class="line">    return function()&#123;</span><br><span class="line">      return that.name2;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object2.getNameFunc()()); // my object</span><br></pre></td></tr></table></figure><h2 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h2><ul><li>内存溢出<ul><li>一种程序运行出现的错误</li><li>当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误</li></ul></li><li>内存泄露<ul><li>占用的内存没有及时释放</li><li><strong>内存泄露积累多了就容易导致内存溢出</strong></li></ul></li><li>常见的内存泄露:<ul><li>意外的全局变量</li><li>没有及时清理的计时器或回调函数</li><li>闭包</li></ul></li></ul><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div>  </p><center>&gt;<img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:hotpink;font-weight:bold;text-decoration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">👉点这里，进入QQ交流</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/js-advance/js-advance-two/#disqus_thread</comments>
    </item>
    
    <item>
      <title>js-advance-one</title>
      <link>https://shulu520.com/js-advance/js-advance-one/</link>
      <guid>https://shulu520.com/js-advance/js-advance-one/</guid>
      <pubDate>Fri, 24 May 2019 06:13:53 GMT</pubDate>
      <description>
      
        guigu js 高级教程笔记①——基础总结深入
      
      </description>
      
      <content:encoded><![CDATA[<center>能够让你后悔的<br><br><center>从来不是你做过的事<br><br><center>而是你想做却没有去做的事<br><br><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decoration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">Q我吧</a></center><a id="more"></a><h2 id="数据类型的分类和判断"><a href="#数据类型的分类和判断" class="headerlink" title="数据类型的分类和判断"></a>数据类型的分类和判断</h2><ul><li>基本(值)类型<ul><li>Number —– 任意数值 ——– typeof</li><li>String —– 任意字符串 —— typeof</li><li>Boolean —- true/false —– typeof</li><li>undefined — undefined —– typeof/===</li><li>null ——– null ———- ===</li></ul></li><li>对象(引用)类型<ul><li>Object  —– 任意对象  —– typeof/instanceof</li><li>Array —— 一种特别的对象(数值下标)—– instanceof</li><li>Function —- 一种特别的对象(可以执行，内部数据是有序的) —– typeof</li></ul></li><li>判断 <ul><li>typeof ——– 返回数据类型的<code>字符串表达</code><ul><li><code>不能判断</code> null和object ， object和array</li></ul></li><li>instanceof —- 判断<code>对象的具体类型</code><ul><li>a instanceof b 即a是否是b构造函数的一个实例</li></ul></li><li>=== ———— <code>可以判断</code> undefined 和 null</li></ul></li><li>名词解释<ul><li>实例 实例对象</li><li>类型 类型对象 即构造函数</li></ul></li><li>undefined与null的区别?<ul><li>undefined代表定义未赋值</li><li>nulll定义并赋值了, 只是值为null</li></ul></li><li>什么时候给变量赋值为null呢?<ul><li>初始赋值, 表明将要赋值为对象</li><li>结束前, 让对象成为垃圾对象(被垃圾回收器回收)</li></ul></li><li>严格区别变量类型与数据类型?<ul><li>数据的类型<ul><li>基本类型</li><li>对象类型</li></ul></li><li>变量的类型(变量内存值的类型)<ul><li>基本类型: 保存就是基本类型的数据</li><li>引用类型: 保存的是地址值</li></ul></li></ul></li></ul><h2 id="数据-变量-内存的理解"><a href="#数据-变量-内存的理解" class="headerlink" title="数据,变量, 内存的理解"></a>数据,变量, 内存的理解</h2><ul><li>什么是数据?<ul><li>在内存中可读的, 可传递的保存了特定信息的’东东’</li><li>一切皆数据, 函数也是数据</li><li>在内存中的所有操作的目标: 数据</li></ul></li><li>什么是变量?<ul><li>在程序运行过程中它的值是允许改变的量</li><li>一个变量对应一块小内存, 它的值保存在此内存中  </li></ul></li><li>什么是内存?<ul><li>内存条通电后产生的存储空间(临时的)</li><li>一块内存包含2个方面的数据<ul><li>内部存储的数据</li><li>地址值数据</li></ul></li><li>内存空间的分类<ul><li>栈空间: 全局变量和局部变量</li><li>堆空间: 对象 </li></ul></li></ul></li><li>内存,数据, 变量三者之间的关系<ul><li>内存是容器, 用来存储不同数据</li><li>变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据  </li></ul></li><li>问题: var a = xxx, a内存中到底保存的是什么?<ul><li>xxx是基本数据, 保存的就是这个数据</li><li>xxx是对象, 保存的是对象的地址值</li><li>xxx是一个变量, 保存的xxx的内存内容(可能是基本数据, 也可能是地址值)</li></ul></li><li>关于引用变量赋值问题<ul><li>2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据</li><li>2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象 </li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123; name: &apos;lqy&apos; &#125;</span><br><span class="line"></span><br><span class="line">情形一</span><br><span class="line">function fn1(obj) &#123;</span><br><span class="line">  obj.name = &apos;shulu&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1(obj1)</span><br><span class="line">console.log(obj1.name) // shulu</span><br><span class="line"></span><br><span class="line">情形二</span><br><span class="line">funtion fn2(obj) &#123;</span><br><span class="line">  obj = &#123;name: &apos;shulu&apos;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn2(obj1)</span><br><span class="line">console.log(obj1.name) // lqy</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">解析：</span><br><span class="line">形参obj 在函数内部为 var obj变量</span><br><span class="line">执行fn( ) 传入实参obj1 即将obj1的值(这里是地址值)复制一份给obj变量</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><ul><li>问题: 在js调用函数时传递变量参数时, 是值传递还是引用传递<ul><li>理解1: 都是值(基本值/地址值)传递 <code>推荐</code></li><li>理解2: 可能是值传递, 也可能是引用传递(地址值)</li></ul></li><li>问题: JS引擎如何管理内存?<ul><li>内存生命周期<ul><li>分配小内存空间, 得到它的使用权</li><li>存储数据, 可以反复进行操作</li><li>释放小内存空间</li></ul></li><li>释放内存<ul><li>局部变量: 函数执行完自动释放</li><li>对象: 成为垃圾对象==&gt;垃圾回收器回收</li></ul></li></ul></li></ul><h2 id="对象的理解和使用"><a href="#对象的理解和使用" class="headerlink" title="对象的理解和使用"></a>对象的理解和使用</h2><ul><li>什么是对象?<ul><li>多个数据(属性)的集合</li><li>用来保存多个数据(属性)的容器</li></ul></li><li>属性组成:<ul><li>属性名 : 字符串(标识)</li><li>属性值 : 任意类型</li></ul></li><li>属性的分类:<ul><li>一般 : 属性值不是function  描述对象的状态</li><li>方法 : 属性值为function的属性  描述对象的行为</li></ul></li><li>特别的对象<ul><li>数组: 属性名是0,1,2,3之类的索引</li><li>函数: 可以执行的</li></ul></li><li>如何操作内部属性(方法)<ul><li>.属性名</li><li>[‘属性名’]: 属性名有特殊字符/属性名是一个变量</li></ul></li><li>问题: 什么时候必须使用[‘属性名’]的方式?<ol><li>属性名包含特殊字符: - 空格</li><li>属性名不确定</li></ol></li></ul><h2 id="函数的理解和使用"><a href="#函数的理解和使用" class="headerlink" title="函数的理解和使用"></a>函数的理解和使用</h2><ul><li>什么是函数?<ul><li>用来实现特定功能的, n条语句的封装体</li><li>只有函数类型的数据是可以执行的, 其它的都不可以</li></ul></li><li>为什么要用函数?<ul><li>提高复用性</li><li>便于阅读交流</li></ul></li><li>函数也是对象<ul><li>instanceof Object===true</li><li>函数有属性: prototype</li><li>函数有方法: call()/apply()</li><li>可以添加新的属性/方法</li></ul></li><li>如何调用(执行)函数?<ul><li>test(): 直接调用</li><li>obj.test(): 通过对象调用</li><li>new test(): new调用</li><li>test.call/apply(obj): 临时让test成为obj的方法进行调用</li></ul></li><li>函数中的this是什么?<ul><li>任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window</li><li>所有函数内部都有一个变量this</li><li>它的值是调用函数的当前对象</li></ul></li><li>如何确定this的值?<ul><li>test(): window</li><li>p.test(): p</li><li>var p = new test(): 新创建的对象p</li><li>p.call(obj): obj</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function Person(color) &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line"></span><br><span class="line">    this.color = color;</span><br><span class="line">    this.getColor = function () &#123;</span><br><span class="line">      console.log(this)</span><br><span class="line">      return this.color;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.setColor = function (color) &#123;</span><br><span class="line">      console.log(this)</span><br><span class="line">      this.color = color;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Person(&quot;red&quot;); //this是谁? window</span><br><span class="line"></span><br><span class="line">  var p = new Person(&quot;yello&quot;); //this是谁? p</span><br><span class="line"></span><br><span class="line">  p.getColor(); //this是谁? p</span><br><span class="line"></span><br><span class="line">  var obj = &#123;&#125;;</span><br><span class="line">  p.setColor.call(obj, &quot;black&quot;); //this是谁? obj</span><br><span class="line"></span><br><span class="line">  var test = p.setColor;</span><br><span class="line">  test(); //this是谁? window</span><br><span class="line"></span><br><span class="line">  function fun1() &#123;</span><br><span class="line">    function fun2() &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun2(); //this是谁? window</span><br><span class="line">  &#125;</span><br><span class="line">  fun1();</span><br></pre></td></tr></table></figure><ul><li><p>匿名函数自调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function(w, obj)&#123;</span><br><span class="line">  //实现代码</span><br><span class="line">&#125;)(window, obj)</span><br></pre></td></tr></table></figure><ul><li>专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式 </li><li>作用<ul><li>隐藏实现</li><li>不会污染外部(全局)命名空间</li><li>用它来编码js模块</li></ul></li></ul></li><li><p>回调函数的理解</p><ul><li>什么函数才是回调函数?<ul><li>你定义的</li><li>你没有调用</li><li>但它最终执行了(在一定条件下或某个时刻)</li></ul></li><li>常用的回调函数<ul><li>dom事件回调函数</li><li>定时器回调函数</li><li>ajax请求回调函数(后面讲解)</li><li>生命周期回调函数(后面讲解)</li></ul></li></ul></li><li><p>问题 js一条语句的后面是否应该加分号？</p><ul><li>是否加分号是编码风格问题，没有应不应该，只有喜不喜欢——尤雨溪</li><li>必须加分号的情况：<ul><li>小括号开头的语句 ;(function () {…})()</li><li>方括号的开头 ;[1, 2, 3].forEach(() =&gt; {})</li></ul></li></ul></li></ul><hr><p>&emsp;&emsp;本篇笔记到此完结。</p><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decoration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">点这里，进入QQ交流</a></center></center></center></center>]]></content:encoded>
      
      <comments>https://shulu520.com/js-advance/js-advance-one/#disqus_thread</comments>
    </item>
    
    <item>
      <title>js-modularize</title>
      <link>https://shulu520.com/js-modularize/js-modularize/</link>
      <guid>https://shulu520.com/js-modularize/js-modularize/</guid>
      <pubDate>Thu, 23 May 2019 14:17:24 GMT</pubDate>
      <description>
      
        modularize js模块化历程，硅谷教程总结
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;</p><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">来QQ撩我啊</a></center><a id="more"></a><h2 id="modularize"><a href="#modularize" class="headerlink" title="modularize"></a>modularize</h2><ul><li>一阶段 所有的代码都写在一个文件下 即暴露在全局环境下 污染环境</li><li>二阶段 将某些api 放到一个对象之中 使用时通过obj.xxx来调用 不安全 因为在别处同样可以通过obj.xxx来将其修改掉</li><li>三阶段 匿名函数自执行(闭包)  安全 JQuery 就是这么做的 引入js文件太多 请求过多 依赖模糊</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(function( window )&#123;</span><br><span class="line">  function foo () &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  // 将foo方法挂载到window上的xxx属性对象上</span><br><span class="line">  // 调用时xxx.foo()即可</span><br><span class="line">  window.xxx = &#123; foo &#125;</span><br><span class="line"></span><br><span class="line">  // 或将foo方法挂载到window上的xxx属性对象上，作为一个函数</span><br><span class="line">  // 调用时直接foo()执行即可</span><br><span class="line">  window.xxx = foo </span><br><span class="line">&#125;)( window )</span><br></pre></td></tr></table></figure><h2 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h2><h3 id="commonJs"><a href="#commonJs" class="headerlink" title="commonJs"></a>commonJs</h3><ul><li>一个js文件就是一个模块</li><li>向外暴露1 module.exports = value  value可以是任意值</li><li>向外暴露2 exports.xxx = value  value可以是任意值</li><li>引入模块 require(‘包名’) 自己写的文件要相对路劲</li></ul><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><ul><li>define</li></ul><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><ul><li>阿里大牛结合commonjs和AMD写的 卖给老外了</li></ul><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><ul><li>安装编译转化工具 npm i babel-cli browserify -g</li><li>npm babel-preset-es2015 –save-dev</li><li>创建.babelrc 文件 并配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;preset&quot;: [&quot;es2015&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>分别暴露 即常规暴露<br>相当于一个模块中有许多个变量<br>export xxx = …<br>export yyy = …<br>export zzz = …</p></li><li><p>引入时要解构赋值 指名道姓拿到相应的变量<br>import { xxx, yyy, zzz } from ‘路劲’</p></li><li><p>统一暴露 默认暴露<br>export default {…}</p></li><li><p>引入时 import xxx from ‘路劲’</p></li></ul><hr><p>&emsp;&emsp;未完待续……</p><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">点这里，跟我聊QQ</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/js-modularize/js-modularize/#disqus_thread</comments>
    </item>
    
    <item>
      <title>IT-proper-nouns</title>
      <link>https://shulu520.com/IT/IT-proper-nouns/</link>
      <guid>https://shulu520.com/IT/IT-proper-nouns/</guid>
      <pubDate>Thu, 23 May 2019 14:02:57 GMT</pubDate>
      <description>
      
        IT-proper-nouns it编程专有名词解释
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;</p><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decoration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">来QQ撩我啊</a></center><a id="more"></a><h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><ul><li>应用程序接口(Application Programming Interface)</li></ul><h2 id="cli"><a href="#cli" class="headerlink" title="cli"></a>cli</h2><ul><li>命令行界面(Command Line Interface)</li></ul><h2 id="sdk"><a href="#sdk" class="headerlink" title="sdk"></a>sdk</h2><ul><li>软件开发工具包(Software Development Kit)</li></ul><h2 id="rc-结尾的文件"><a href="#rc-结尾的文件" class="headerlink" title="rc 结尾的文件"></a>rc 结尾的文件</h2><ul><li>run control 运行时控制文件</li></ul><hr><p>&emsp;&emsp;未完待续……</p><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decoration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">点这里，跟我QQ聊天呗</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/IT/IT-proper-nouns/#disqus_thread</comments>
    </item>
    
    <item>
      <title>node-koa2</title>
      <link>https://shulu520.com/node/node-koa2/</link>
      <guid>https://shulu520.com/node/node-koa2/</guid>
      <pubDate>Tue, 21 May 2019 17:54:24 GMT</pubDate>
      <description>
      
        nodejs+koa2电影预告片
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;hello my world<br><a id="more"></a></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ul><li>github创建仓库</li><li>本地git clone 仓库</li><li>项目目录下 初始化 npm init<h2 id="npm-start-启动快捷方法"><a href="#npm-start-启动快捷方法" class="headerlink" title="npm start 启动快捷方法"></a>npm start 启动快捷方法</h2></li><li>在package.json 中添加配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;node server/index.js&quot;,</span><br></pre></td></tr></table></figure><ul><li>添加 .gitignore 文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># dependencies</span><br><span class="line">node_modules</span><br><span class="line"></span><br><span class="line"># logs</span><br><span class="line">npm-debug.log</span><br><span class="line"></span><br><span class="line"># System</span><br><span class="line">.DS_Store</span><br><span class="line"></span><br><span class="line">#Generate</span><br><span class="line">dist</span><br><span class="line"></span><br><span class="line"># Build</span><br><span class="line">bulid</span><br></pre></td></tr></table></figure><h2 id="pug-模板引擎"><a href="#pug-模板引擎" class="headerlink" title="pug 模板引擎"></a>pug 模板引擎</h2><p>npm i pug -S</p><hr><p>&emsp;&emsp;未完待续……</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/node/node-koa2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>async-fn-note</title>
      <link>https://shulu520.com/uncategorized/async-fn-note/</link>
      <guid>https://shulu520.com/uncategorized/async-fn-note/</guid>
      <pubDate>Mon, 20 May 2019 02:00:01 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp;&amp;emsp;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;</p><a id="more"></a><p>正文：</p><hr><p>&emsp;&emsp;</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/uncategorized/async-fn-note/#disqus_thread</comments>
    </item>
    
    <item>
      <title>arrow-js-note</title>
      <link>https://shulu520.com/arrowjs/arrow-js-note/</link>
      <guid>https://shulu520.com/arrowjs/arrow-js-note/</guid>
      <pubDate>Sun, 19 May 2019 16:11:45 GMT</pubDate>
      <description>
      
        箭头函数相关知识总结
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;今天是2019年，520，在这特殊的一天我面对的依然是code, but no Object, 我希望有一天能美梦成真——面向对象面向君，不负代码不负卿。</p><a id="more"></a><h2 id="箭头函数的经典题型"><a href="#箭头函数的经典题型" class="headerlink" title="箭头函数的经典题型"></a>箭头函数的经典题型</h2><ul><li>有关 this</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  id: 01,</span><br><span class="line">  say: function () &#123;</span><br><span class="line">    // 这里的this为obj</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      // 这里是匿名函数的this默认为window</span><br><span class="line">      console.log(&apos;arrow id:&apos;, this.id); // undifind</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;,</span><br><span class="line">  sayWithThis: function () &#123;</span><br><span class="line">    // 这里将this的值当成变量存起来</span><br><span class="line">    let that = this;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(&apos;arrow id:&apos;, that.id); // 01</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;,</span><br><span class="line">  sayWithArrow: function () &#123;</span><br><span class="line">    // 这里的this为obj</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(&apos;arrow id:&apos;, this.id); // 01</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;,</span><br><span class="line">  sayWithGlobalArrow: () =&gt; &#123;</span><br><span class="line">    // 这里的this已经为全局的this了</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(&apos;arrow id:&apos;, this.id); // undifind</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>&emsp;&emsp;未完待续……</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/arrowjs/arrow-js-note/#disqus_thread</comments>
    </item>
    
    <item>
      <title>git-qa-note</title>
      <link>https://shulu520.com/git/git-qa-note/</link>
      <guid>https://shulu520.com/git/git-qa-note/</guid>
      <pubDate>Sat, 18 May 2019 04:11:06 GMT</pubDate>
      <description>
      
        在git的使用中遇到的问题&amp;解决方法
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;<br><a id="more"></a></p><h2 id="科学上网之后，git-报错"><a href="#科学上网之后，git-报错" class="headerlink" title="科学上网之后，git 报错"></a>科学上网之后，git 报错</h2><ul><li>如下错误：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh: Could not resolve hostname github.com: Name or service not known</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure><ul><li>解决方法<br>1、找到本机的 host 文件，一般位置是进入 C:\Windows\System32\drivers\etc</li></ul><p>2、在host文件的最后一行加上，如果之前已经设置过，可以将ip地址更改为最新的正确的ip地址</p><p>192.30.255.112  github.com git<br>185.31.16.184   github.global.ssl.fastly.net</p><hr><p>&emsp;&emsp;遇到后继续补充……</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/git/git-qa-note/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Array-note</title>
      <link>https://shulu520.com/Array/Array-note/</link>
      <guid>https://shulu520.com/Array/Array-note/</guid>
      <pubDate>Fri, 17 May 2019 16:41:04 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp;&amp;emsp;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;</p><a id="more"></a><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><ul><li>计算数组成员的个数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const countOccurrences = (arr,val) =&gt; arr.reduce((a,v) =&gt; (v === val ? a + 1 : a), 0)</span><br><span class="line"></span><br><span class="line">alert(countOccurrences([1,111,2,2,2,3,4], 2)); // 3</span><br></pre></td></tr></table></figure><h2 id="max"><a href="#max" class="headerlink" title="max"></a>max</h2><ul><li>Math.max.apply(null, arr)</li><li>Math.max(…arr)</li></ul><p>&emsp;&emsp;未完待续……</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/Array/Array-note/#disqus_thread</comments>
    </item>
    
    <item>
      <title>node-blue-note</title>
      <link>https://shulu520.com/node/node-blue-note-md/</link>
      <guid>https://shulu520.com/node/node-blue-note-md/</guid>
      <pubDate>Thu, 16 May 2019 13:44:45 GMT</pubDate>
      <description>
      
        taobao前端工程师石川(blue)视频教程笔记
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;我本来要忘记你了，可我又做梦了。<br><a id="more"></a></p><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><ul><li>http 模块 GET方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http);</span><br><span class="line">  //创建一个服务器</span><br><span class="line">var server = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">  /*</span><br><span class="line">    给这个地址随便提交一个表单 http://localhost:8080/aaa</span><br><span class="line">    其中 req.url = &apos;/aaa?user=shulu&amp;pass=123&apos;</span><br><span class="line">    运用字符串的切割数组的拼接就可以拿到用户名与密码</span><br><span class="line">  */</span><br><span class="line">&#125;).listen(8080);</span><br></pre></td></tr></table></figure><ul><li>queryString 模块 GET方式<br>争对这种数据 xxx=…&amp;yyy=…&amp;zzz=…</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const querystring = require(&apos;queryString&apos;);</span><br><span class="line">var json = querystring.parse(&apos;user=shulu&amp;pass=123&amp;age=18&apos;);</span><br><span class="line">console.log(json) // &#123;&quot;user&quot;: &quot;shulu&quot;, &quot;pass&quot;: &quot;123&quot;, &quot;age&quot;: &quot;18&quot;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>url 模块 GET方式<br>争对这种数据 整个url部分 参数为true效果更好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http);</span><br><span class="line">const _url = require(&apos;url&apos;);</span><br><span class="line">var server = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">  var obj = _url.parse(req.url, true);</span><br><span class="line">  var url = obj.pathname;</span><br><span class="line">  const GET = obj.query;</span><br><span class="line">&#125;).listen(8080);</span><br></pre></td></tr></table></figure></li><li><p>http 模块 POST方式</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">const querystring = require(&apos;querystring&apos;);</span><br><span class="line">var server = http.createServer((req, res) =&gt;&#123;</span><br><span class="line">  //请求数据一样在req中</span><br><span class="line">  var str = &apos;&apos;;</span><br><span class="line">  //data数据大 分多次到达</span><br><span class="line">  req.on(&apos;data&apos;, (data) =&gt; &#123; //data事件</span><br><span class="line">    str += data;</span><br><span class="line">  &#125;);</span><br><span class="line">  req.on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">    var POST = querystring.parse(str)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).listen(8888);</span><br></pre></td></tr></table></figure><h2 id="express-框架"><a href="#express-框架" class="headerlink" title="express 框架"></a>express 框架</h2><ul><li>express保留了原生的功能，增加了一些自己的功能</li><li>基本使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">var server = express();</span><br><span class="line">server.use(&apos;/a.html&apos;, function (req, res) &#123;</span><br><span class="line">  //res.send() 方法参数可以是json等</span><br><span class="line">  //res.write() 参数只能是字符串或buffer</span><br><span class="line">  res.send(&apos;aaaa&apos;);</span><br><span class="line">  res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(8080);</span><br></pre></td></tr></table></figure><ul><li>三种接收处理请求的方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.get()</span><br><span class="line">server.post()</span><br><span class="line">server.use()</span><br></pre></td></tr></table></figure><ul><li>express-static 插件 处理静态文件的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const expresStatic = require(&apos;express-static&apos;);</span><br><span class="line"></span><br><span class="line">var server = express();</span><br><span class="line">server.listen(8888);</span><br><span class="line"></span><br><span class="line">server.use(expresStatic(&apos;./www&apos;));</span><br></pre></td></tr></table></figure><ul><li>中间件 body-parser 解析POST数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.use(bodyParser.urlencode(&#123;</span><br><span class="line">  extend: false, //扩展模式</span><br><span class="line">  limit: 1024*1024 //限制1M</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><ul><li><p>multer 解析post文件<br> multipart/form-data 格式的表单数据</p></li><li><p>链式操作 next</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server.use(&apos;/&apos;, function (req, res, next) &#123;</span><br><span class="line">  console.log(&apos;aaa&apos;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line">server.use(&apos;/&apos;, function (req, res, next) &#123;</span><br><span class="line">  console.log(&apos;bbb&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="模板引擎-ejs"><a href="#模板引擎-ejs" class="headerlink" title="模板引擎 ejs"></a>模板引擎 ejs</h2><h2 id="path-模块"><a href="#path-模块" class="headerlink" title="path 模块"></a>path 模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">var str = &apos;c:\\user\\www\\a.html&apos;;</span><br><span class="line">var obj = path.parse(str);</span><br><span class="line">console.log(obj);</span><br><span class="line"></span><br><span class="line">//base: 文件名部分 如a.html</span><br><span class="line">//ext: 扩展名 如.html</span><br><span class="line">//dir: 文件路劲 如c:\\user\\www</span><br></pre></td></tr></table></figure><p><hr><br>&emsp;&emsp;未完待续……</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/node/node-blue-note-md/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hotkey-vim</title>
      <link>https://shulu520.com/hotkey/hotkey-vim/</link>
      <guid>https://shulu520.com/hotkey/hotkey-vim/</guid>
      <pubDate>Wed, 15 May 2019 15:34:56 GMT</pubDate>
      <description>
      
        vim的封号为&quot;编辑器之神&quot;, 学会了vimium也就掌握vim的核心用法, 一举两得!
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;You only live on this earth once.<br><a id="more"></a></p><h2 id="快捷强大的vim"><a href="#快捷强大的vim" class="headerlink" title="快捷强大的vim"></a>快捷强大的vim</h2><ul><li><p>vimium能提升我们的浏览速度, 鼠标比键盘简单, 键盘比鼠标快!</p></li><li><p>快速向下滚动d </p></li><li>快速向上滚动u</li><li>滚动到页面顶部gg </li><li><p>滚动到页面底部G</p></li><li><p>神技! 快速搜索 (相当于浏览器顶部搜索框), 并在新标签打开 大写的O</p></li><li>关闭页面x  恢复页面X</li><li>主动脱离焦点esc 比如按下o搜索退出时按esc</li><li>shift+/,查看所有快捷键</li></ul><p>&emsp;&emsp;如果你想要个和现在不同的人生，就必须去做你从未做过的事情。努力之后最坏的结果是失败，但不尝试的结果则是无止境的懊悔、怀疑和平庸。<br><!--more--></p><h2 id="vscode-常用快捷键"><a href="#vscode-常用快捷键" class="headerlink" title="vscode 常用快捷键"></a>vscode 常用快捷键</h2><ul><li><p>上下移动一行： Alt+Up 或 Alt+Down</p></li><li><p>向上或向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down</p></li><li><p>同时选中所有匹配： Ctrl+Shift+L</p></li><li><p>Ctrl+D 下一个匹配的也被选中 </p></li><li><p>Alt + 单击  ：插入光标</p></li><li><p>Ctrl + F2    选择当前字的所有出现</p></li><li><p>ctrl  shift  k   删除整行</p></li><li><p>ctrl  shift  a   多行注释</p></li><li><p>ctrl  f     当前文件内搜索相关代码，终于找到这个功能了，哈哈，右上角会有弹框，其中有前后箭头，表示搜索的代码上一次、下一次出现的位置，点击直接会跳转到相应的位置，并且侧边上有相应的位置标识。</p></li><li><p>ctrl - 整体缩小</p></li><li><p>ctrl = 整体放大</p></li><li><p>文件/首选项/设置 搜索zoom 根据配置 可以更精细的对大小进行操作 ctrl 加滚轮</p></li></ul><hr><p>&emsp;&emsp;未完待续……</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/hotkey/hotkey-vim/#disqus_thread</comments>
    </item>
    
    <item>
      <title>nodejs-guigu</title>
      <link>https://shulu520.com/node/nodejs-guigu/</link>
      <guid>https://shulu520.com/node/nodejs-guigu/</guid>
      <pubDate>Tue, 14 May 2019 14:50:21 GMT</pubDate>
      <description>
      
        硅谷nodejs视频教程笔记
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;我期待有一天背着背包出现在你的城市。<br><a id="more"></a></p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul><li>小娜 输入 环境变量 进入环境变量/用户变量/path 点开 里面是一条条的文件路劲 可以新建一个文件的路劲</li><li>在这里配置了 相当于 声明了一个 类似于 js 中的全局变量 为作用域链的最高层</li><li>可以将一些常用的文件或程序的路劲添加到path下 这样我们就可以在任意的位置访问他们了</li></ul><h2 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程 线程"></a>进程 线程</h2><ul><li>进程<br>  负责为程序的运行提供必备的环境<br>  工厂的车间</li><li>线程<br>  负责执行进程中的程序<br>  车间工人</li><li>单线程<br>  一个人干活</li><li>多线程<br>  多人合作干一个活 </li></ul><h2 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h2><ul><li>事件驱动</li><li>非阻塞</li><li>异步I/O  (性能瓶颈阶段)  input写入操作  output读操作</li><li>版本 奇数为开发版  偶数为稳定版</li><li>在Node中，模块分为三类：一类是底层由C++编写的内建模块，一类是Node提供的核心模块；还有一类是用户编写的模块，称为文件模块。<h2 id="node-js-模块化"><a href="#node-js-模块化" class="headerlink" title="node.js 模块化"></a>node.js 模块化</h2></li><li>新建一个js文件就是一个模块</li><li>这个模块里面写的代码其实是包在一个函数里面的 即</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">funcyion (exports, require, module, _filename, _dirname) &#123;</span><br><span class="line">/*</span><br><span class="line">这里是我们写的代码 外面其实包了一层这个函数 默认不可见</span><br><span class="line">可以通过console.log(arguments.callee) 或</span><br><span class="line">  console.log(arguments.callee + &quot;&quot;) 将此函数打印出来 </span><br><span class="line">  该函数执行时传进了5个参数</span><br><span class="line">所以模块里面的代码是局部变量</span><br><span class="line">exports参数 用来将变量或函数暴露到外边</span><br><span class="line">require参数 用来引入外部的模块</span><br><span class="line">module参数 代表模块本身 exports是module的属性</span><br><span class="line">_filename 当前模块的完整路劲</span><br><span class="line">_dirname 当前模块所在文件夹的路劲</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>module.exports 与exports的区别<br>  module.exports == exports  true<br>  exports 只能使用.的方式向外暴露 若exports = {} 这样向外暴露的话就修改了exports的引用对象<br>  module.exports 既可以通过.的形式 也可以直接赋值 <code>推荐写法</code></li><li>核心模块<br>  由node 提供的模块 node_moudle中的 引入时直接写模块名字 不需要路劲 </li><li>文件模块<br>  由我们自己创建的模块   引入时添加./或../等路劲</li></ul><h2 id="包-package"><a href="#包-package" class="headerlink" title="包 package"></a>包 package</h2><ul><li>包实际上就是一个压缩文件 解压以后还原为目录</li><li>规范的目录包含以下文件：<br>  -package.json <code>包描述文件</code> (必须的) <code>里面不能写注释</code><br>  -bin 可执行二进制文件  binary 二进制<br>  -lib js代码 library 库 图书馆<br>  -doc 文档 document<br>  -test 单元测试</li></ul><h2 id="npm-即-Node-Package-Manager-node包管理器"><a href="#npm-即-Node-Package-Manager-node包管理器" class="headerlink" title="npm 即 (Node Package Manager) node包管理器"></a>npm 即 (Node Package Manager) node包管理器</h2><ul><li>commonjs包规范的是一种理论 npm是其中一种实践</li><li>对node而言 npm帮助其完成了第三方模块的发布安和依赖</li><li>借助npm 使得node与第三方模块之间形成一个生态系统</li><li>查看版本 npm version查看相关的版本 或npm -v</li><li>npm search 包名 搜索包</li><li>npm init 在某一文件夹下初始化该文件夹 帮助我们根据提示生成一个package.json的文件<br>  在初始化后的文件夹下 安装搜索的包 并新建一个index.js 入口文件在里面就可以直接引入math模块使用了</li><li>npm install 包名 安装 包 或npm i</li><li>npm remove 或 npm r  删除包 </li><li>npm install 包名 杠杠save  安装包并添加到依赖中</li><li>npm install 下载当前项目所依赖的包</li><li>npm install 包名 -g 全局安装包 一般是安装一些工具 如vue-cli </li><li>cnpm 也可以用 快速</li><li>node在使用下载的包时 会沿着作用域链一直往上找直到磁盘根目录找不到则报错 这就解释了某的包在删除之后依然能用的情况</li></ul><h2 id="Buffer-（缓冲区）"><a href="#Buffer-（缓冲区）" class="headerlink" title="Buffer （缓冲区）"></a>Buffer （缓冲区）</h2><ul><li>结构和数组很相似 方法也类似</li><li>补充了数组方法的不足 Buffer专门存贮二进制数据的</li><li>实际上Buffer中的内存不是通过JavaScript分配的，而是在底层通过C++申请的。也就是我们可以直接通过Buffer来创建内存中的空间。</li><li>使用buffer无需引入模块 直接使用即可</li><li>Buffer.from(str) 将字符串str转为buffer二进制数据</li><li>在buffer中存贮的都是二进制数据 但在显示时都是以16进制的形式显示的<br>  二进制 00-255 或 00-ff</li><li>计算机 一个0或一个1 称为一位(bit)</li><li>8bit = 1byte(字节) 最小单位 中文一个汉字占用三个字节</li><li>创建一个制定大小的buffer<br>  Buffer.alloc(10) 10字节大小<br>  可通过索引来操作buffer中的元素</li><li>Buffer的大小一旦确定 不能再更该 因为存储空间是连续的 性能好</li><li>Buffer与字符串间的转换</li><li>支持的编码:<br>   ASCII、UTF-8、UTF-16LE/UCS-2、Base64、Binary、Hex</li><li>字符串转Buffer<br>   Buffer.from(str , [encoding]); </li><li>Buffer转字符串 buf.toString()<br>   buf.toString([encoding] , [start] , [end]);</li><li>复制缓冲区<br>   buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])</li><li>对缓冲区切片<br> buf.slice([start[, end]])</li><li>拼接缓冲区<br>   Buffer.concat(list[, totalLength])     <h2 id="fs-文件系统"><a href="#fs-文件系统" class="headerlink" title="fs (文件系统)"></a>fs (文件系统)</h2></li><li>在Node中，与文件系统的交互是非常重要的，服务器的本质就将本地的文件发送给远程的客户端</li><li>核心模块 直接引入使用</li><li>const fs = require(‘fs’)</li><li>fs 模块中所有的操作都有两种形式 同步(会阻塞 带sync) 异步(不会阻塞 带回调函数)</li><li>fs模块中所有的操作都有两种形式可供选择同步和异步</li><li>同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码。异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。</li><li>打开文件<br>   fs.open(path, flags[, mode], callback)<br>   fs.openSync(path, flags[, mode])</li><li>关闭文件<br>   fs.close(fd, callback)<br>   fs.closeSync(fd)</li><li>fs中提供了四种不同的方式将数据写入文件<br>   简单文件写入<br>   同步文件写入<br>   异步文件写入<br>   流式文件写入</li><li><p>同步文件的写入：<br>  1.打开文件<br>  操作方式为定为写 即<br>  var fd = fs.openSync(path, flags) 参数为字符串类型</p><pre><code>path即文件的路劲flags即 r表示读操作  w表示写入操作</code></pre><p>  通过返回的描述符fd对文件进行各种操作 </p><p>  2.写入内容数据<br>  fs.writeSync(fd, string)</p><pre><code>fd文件的描述符 需要传入文件的描述符string要写入的内容</code></pre><p>  3.关闭文件 考虑性能<br>  fs.closeSync(fd)</p></li><li><p>异步文件写入<br>  1.打开文件</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fs.open(path, flags, function (err, fd) &#123;</span><br><span class="line">if (!err) &#123;</span><br><span class="line">2.在这里往文件写入内容 写操作</span><br><span class="line">fs.write(fd, &apos;要异步写入的内容&apos;, function (err) &#123;</span><br><span class="line">if (!err) &#123;</span><br><span class="line">console.log(&apos;write success&apos;)</span><br><span class="line">&#125;</span><br><span class="line">fs.close(fd, function (err) &#123;</span><br><span class="line">if (!err) &#123;</span><br><span class="line">console.log(&apos;close success&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(fd)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">console.log(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>返回值为 callback的参数</p><ul><li>简单文件写入<br>  简单同步文件<br>  fs.write<br>  简单异步文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(&apos;hello.txt&apos;, &apos;shulu520&apos;, &#123;flag: &apos;a&apos;&#125; function (err) &#123; //flag: &apos;a&apos; 追加文件内容 不会覆盖原来的 如果文件不存在则创建 flag还有好多的模式</span><br><span class="line">if (!err) &#123;</span><br><span class="line">console.log(&apos;write success&apos;)</span><br><span class="line">&#125;</span><br><span class="line">//文件路劲可以是F:\JSdownload\npm-test 这种 `但是要变为`F:\\JSdownload\\npm-test或F:/JSdownload/npm-test</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>同步 异步 简单文件 的写入都不适合大文件爱的写入 易导致内存溢出 性能差</li><li>流式文件写入</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">创建流</span><br><span class="line">var ws = fs.createWriteStream(path)</span><br><span class="line">监听事件 once绑定一次性的事件</span><br><span class="line">ws.once(&apos;open&apos;, function () &#123; </span><br><span class="line">console.log(&apos;stream success&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">ws.once(&apos;close&apos;, function () &#123;</span><br><span class="line">console.log(&apos;stream close&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">写入内容 大量内容</span><br><span class="line">ws.write(&apos;写入内容1&apos;)</span><br><span class="line">ws.write(&apos;写入内容2&apos;)</span><br><span class="line">ws.write(&apos;写入内容3&apos;)</span><br><span class="line">ws.write(&apos;写入内容4&apos;)</span><br><span class="line">……</span><br><span class="line">关闭流 在流开始的一方结束流</span><br><span class="line">ws.end()</span><br><span class="line">```</span><br><span class="line">+ fs中提供了四种读取文件的方式</span><br><span class="line"> 简单文件读取</span><br><span class="line"> 同步文件读取</span><br><span class="line"> 异步文件读取</span><br><span class="line"> 流式文件读取</span><br><span class="line">+ 简单文件读取</span><br><span class="line">  简单异步文件读取</span><br></pre></td></tr></table></figure><p>const fs = require(‘fs’);<br>fs.readFile(‘shulu.jpg’, (err, data) =&gt; {<br>    if(!err) {<br>        fs.writeFile(‘桌面路劲/lqy.jpg’, data, () =&gt; {<br>            if(!err) {<br>                console.log(‘文件写入成功 ‘)<br>            }<br>        })<br>    }<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 流式文件读取 适用于大文件</span><br></pre></td></tr></table></figure></p><p>const fs = require(‘fs’);<br>1.创建读取流<br>const rs = fs.createReadStream(‘shulu.jpg’);<br>2.监听流的开启和关闭<br>rs.once(‘open’, () =&gt; {<br>    console.log(‘流打开成功了’)<br>})<br>rs.once(‘close’, () =&gt; {<br>    console.log(‘流关闭了’)<br>})<br>3.读取数据<br>rs.on(‘data’, (data) =&gt; {<br>    console.log(data) //多次分批读取大数据<br>})</p><ul><li>pipe 流方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>const fs = require(‘fs’);<br>const rs = fs.createReadStream(‘shulu.mp3’);<br>const ws = fs.createWriteStrem(‘lqy.mp3’);<br>rs.pipe(ws); 读取后直接流入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ fs 模块其他操作</span><br><span class="line">检查一个文件是否存在</span><br><span class="line">+ 列出文件</span><br><span class="line"> fs.readdir(path[, options], callback)</span><br><span class="line"> fs.readdirSync(path[, options])</span><br><span class="line">+ 截断文件</span><br><span class="line"> fs.truncate(path, len, callback)</span><br><span class="line"> fs.truncateSync(path, len)</span><br><span class="line">+ 建立目录</span><br><span class="line"> fs.mkdir(path[, mode], callback)</span><br><span class="line"> fs.mkdirSync(path[, mode])</span><br><span class="line">+ 验证路径是否存在</span><br><span class="line"> fs.existsSync(path)</span><br><span class="line">+ 获取文件信息</span><br><span class="line"> fs.stat(path, callback)</span><br><span class="line"> fs.statSync(path)</span><br><span class="line">+ 删除文件</span><br><span class="line"> fs.unlink(path, callback)</span><br><span class="line"> fs.unlinkSync(path)</span><br><span class="line"></span><br><span class="line">+ 删除目录</span><br><span class="line"> fs.rmdir(path, callback)</span><br><span class="line"> fs.rmdirSync(path)</span><br><span class="line">+ 重命名文件和目录</span><br><span class="line"> fs.rename(oldPath, newPath, callback)</span><br><span class="line"> fs.renameSync(oldPath, newPath)</span><br><span class="line">+ 监视文件更改写入</span><br><span class="line"> fs.watchFile(filename[, options], listener)</span><br></pre></td></tr></table></figure><p>const fs = require(‘fs’);<br>const isExists = fs.existsSync(‘shulu.mp3’);<br>console.log(isExists);<br><code>`</code></p><hr><p>&emsp;&emsp;未完待续……<br>&emsp;&emsp;</p><h2><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me</a></h2><p></p><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/node/nodejs-guigu/#disqus_thread</comments>
    </item>
    
    <item>
      <title>es6-zhuf-01.md</title>
      <link>https://shulu520.com/es6/es6-zhuf-01/</link>
      <guid>https://shulu520.com/es6/es6-zhuf-01/</guid>
      <pubDate>Mon, 13 May 2019 15:46:29 GMT</pubDate>
      <description>
      
        zhuf架构视频教程笔记
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;想要的东西，会以最快的速度来到你的身边。</p><hr><a id="more"></a><h2 id="var-与-let-和-const-的区别"><a href="#var-与-let-和-const-的区别" class="headerlink" title="var 与 let 和 const 的区别"></a>var 与 let 和 const 的区别</h2><p>新的方法解决了老方法遗留的问题</p><ul><li><p>var<br>  在同一作用域内可以对同一变量重复声明<br>  不能定义常量(控制不了，因为可以修改，写了等于没写)<br>  不支持块级作用域</p></li><li><p>let<br>  在同一作用域内不能对同一变量重复声明<br>  变量不会提升 变量定义之前使用会报错<br>  有块级作用域 {这里面为块级作用域}<br>  以前js只有两种作用域 一个是全局 一个是函数级<br>  作用域经典问题： for 循环里面套 定时器 当时的解决方法 给定时器包一层自执行的匿名函数并将循环变量传进去 本质上是作用域问题 现在用let声明变量就可以了</p></li><li><p>const<br>  在同一作用域内不能对同一变量重复声明<br>  专门声明常量 常量声明后不可修改<br>  但若此常量是一个引用类型的话(例如一个对象) 引用对象的属性还是可以改的 例如：定义 const USER = {name: ‘shulu’} 更改为 USER.name = ‘lqy’ 可以的</p></li></ul><h2 id="解构-分解一个对象的解构"><a href="#解构-分解一个对象的解构" class="headerlink" title="解构 分解一个对象的解构"></a>解构 分解一个对象的解构</h2><ul><li>解构的时候 等号的两边解构相似 右边必须是一个真实的值</li><li>数组的省略赋值<br>  let arr = [1, 2, 3]; let [,,x] = arr 则只拿到x=3的值</li></ul><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><ul><li>以前是字符串拼串 现在是这个符号  <code></code> 可以折行 换行</li><li>模板语言的原理 正则实现 面试</li><li>带参数的模板字符串</li><li><p>字符串的新方法 返回布尔值<br>  str.startWith(‘http’)<br>  str.endsWith(‘.com’)<br>  str.includes(‘shulu’) 以前 str.indexOf(‘shulu’) == -1  做判断<br>  str.repeat(10) 重复10次</p></li><li><p>展开运算符 …<br>   对象合并：<br>   Object.assign(obj3, obj2, obj1); 将对象1，2合并为3<br>   obj3 = {…obj1, …obj2} 更简洁</p></li><li><p>对象的深拷贝</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let obj2 = JSON.parse(JSON.stringify(obj1))</span><br></pre></td></tr></table></figure><ul><li>递归实现对象深拷贝</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//对象深拷贝</span><br><span class="line">function deepClone(origin,target)&#123;</span><br><span class="line"></span><br><span class="line">//target是否存在如果不存在创建空对象</span><br><span class="line">let tar = target || &#123;&#125;,</span><br><span class="line"></span><br><span class="line">//判断是否为引用数据类型</span><br><span class="line">toStr = Object.prototype.toString,</span><br><span class="line">arrType=&apos;[object Array]&apos;;</span><br><span class="line"></span><br><span class="line">for(let key in origin)&#123;</span><br><span class="line">//剥离原型链的数据</span><br><span class="line">if(origin.hasOwnProperty(key))&#123;</span><br><span class="line">//判断是否为引用数据类型 对象或数组</span><br><span class="line">if(typeof(origin[key]) === &apos;object&apos; &amp;&amp; origin[key] !== null)&#123;</span><br><span class="line">if(toStr.call(origin[key]) === arrType )&#123;</span><br><span class="line">tar[key] = [];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">tar[key] = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">deepClone(origin[key],tar[key]);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">tar[key] = origin[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return tar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>箭头函数<br>箭头函数this 继承自父级，自己本身没有this</li></ul><hr><p>&emsp;&emsp;未完待续……</p><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/es6/es6-zhuf-01/#disqus_thread</comments>
    </item>
    
    <item>
      <title>git-guigu-note</title>
      <link>https://shulu520.com/git/git-guigu-note/</link>
      <guid>https://shulu520.com/git/git-guigu-note/</guid>
      <pubDate>Sun, 12 May 2019 15:21:02 GMT</pubDate>
      <description>
      
        尚硅谷git&amp;github视频学习笔记，超详细
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;在衰老到来之前，做一件值得做的事情。做这件事不是为了别的，而是为了证明自己是好样的。-《似水流年》</p><hr><a id="more"></a><h3 id="复制-选中后-Ctrl-ins-即键盘右上角的insert键"><a href="#复制-选中后-Ctrl-ins-即键盘右上角的insert键" class="headerlink" title="复制 选中后 Ctrl+ins  即键盘右上角的insert键"></a>复制 选中后 Ctrl+ins  即键盘右上角的insert键</h3><h3 id="粘贴-相应的位置-Shift-ins"><a href="#粘贴-相应的位置-Shift-ins" class="headerlink" title="粘贴 相应的位置 Shift+ins"></a>粘贴 相应的位置 Shift+ins</h3><h3 id="查看git-配置信息cat-gitconfig"><a href="#查看git-配置信息cat-gitconfig" class="headerlink" title="查看git 配置信息cat ~/.gitconfig"></a>查看git 配置信息cat ~/.gitconfig</h3><h3 id="状态查看-git-status-查看工作区、暂存区状态"><a href="#状态查看-git-status-查看工作区、暂存区状态" class="headerlink" title="状态查看 git status 查看工作区、暂存区状态"></a>状态查看 git status 查看工作区、暂存区状态</h3><h3 id="文件内容查看-cat-haha-txt"><a href="#文件内容查看-cat-haha-txt" class="headerlink" title="文件内容查看 cat haha.txt"></a>文件内容查看 cat haha.txt</h3><h3 id="添加操作-git-add-file-name"><a href="#添加操作-git-add-file-name" class="headerlink" title="添加操作 git add [file_name]"></a>添加操作 git add [file_name]</h3><h3 id="git-commit-m-‘说明信息’-file-name"><a href="#git-commit-m-‘说明信息’-file-name" class="headerlink" title="git commit -m ‘说明信息’ [file_name]"></a>git commit -m ‘说明信息’ [file_name]</h3><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><ul><li>touch haha.txt 或 vim good.txt </li><li>字母ll 列出本地库所有文件和文件总数，创建日期 时间 创建人 文件名 </li></ul><h3 id="git-add-haha-txt-后-若想返回add前的状态-根据提示-git-rm-–cached-haha-txt-即可返回，此删除只是从暂存区里面删除，工作区的文件还在"><a href="#git-add-haha-txt-后-若想返回add前的状态-根据提示-git-rm-–cached-haha-txt-即可返回，此删除只是从暂存区里面删除，工作区的文件还在" class="headerlink" title="git add haha.txt 后 若想返回add前的状态 根据提示 git rm –cached haha.txt 即可返回，此删除只是从暂存区里面删除，工作区的文件还在"></a>git add haha.txt 后 若想返回add前的状态 根据提示 git rm –cached haha.txt 即可返回，此删除只是从暂存区里面删除，工作区的文件还在</h3><h3 id="git-commit-haha-txt-这里没带-m-‘说明信息’-回车后会进入vim-编辑器-可以编写大量的说明信息"><a href="#git-commit-haha-txt-这里没带-m-‘说明信息’-回车后会进入vim-编辑器-可以编写大量的说明信息" class="headerlink" title="git commit haha.txt  这里没带-m ‘说明信息’  回车后会进入vim 编辑器 可以编写大量的说明信息"></a>git commit haha.txt  这里没带-m ‘说明信息’  回车后会进入vim 编辑器 可以编写大量的说明信息</h3><ul><li>首先 按a键 进入插入模式，之后就可以进行编辑了。</li><li>编辑完了就可以按Esc键退出插入模式，然后输出:wq即可退出vim编辑器，回到git bash界面。</li></ul><h3 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h3><ul><li>git log  打印的记录风格： 分散 有作者 邮箱 日期提示，显示内容详细，内容多了，多屏显示控制方式：桥空格为向下翻页，b键为向上翻页，q 键为退出查看</li><li>git log –oneline 打印效果为一行</li><li>git reflog  打印的记录风格： 紧凑 在一行显示并有提示版本回退数字提示</li></ul><h3 id="版本前进后退"><a href="#版本前进后退" class="headerlink" title="版本前进后退"></a>版本前进后退</h3><ul><li>基于索引值操作 任意版本穿梭 <code>推荐方法</code> git reset –hard alfe9cd  这里alfe9cd为某一版本的提交id值即索引值</li><li>基于符号 ^ 只能后退  返回上一个版本 git reset –hard HEAD^  版本倒退三个 git reset –hard HEAD^^^ </li><li>基于符号 ~ 只能后退  版本倒退三个 git reset –hard HEAD~3</li></ul><h3 id="reset-命令的三个参数对比"><a href="#reset-命令的三个参数对比" class="headerlink" title="reset 命令的三个参数对比"></a>reset 命令的三个参数对比</h3><ul><li>–soft 仅仅在本地库移动HEAD指针</li><li>–mixed 在本地库移动HEAD指针,重置暂存区</li><li>–hard 在本地库移动HEAD指针,重置暂存区,重置工作区，三个区位置保持一致</li></ul><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><ul><li>rm aaa.txt</li><li>git status 显示为 红色 deleted: aaa.txt</li><li>提示要add该文件 git add aaa.txt</li><li>git status  显示为 绿色 表示已添加到暂存区</li><li>git commit -m ‘deleted aaa.txt’ 将这次删除操作提交到本地库</li></ul><h3 id="删除文件并恢复"><a href="#删除文件并恢复" class="headerlink" title="删除文件并恢复"></a>删除文件并恢复</h3><ul><li>前提：删除前 文件的状态提交到了本地库</li><li>操作： git reset –hard [指针位置]<br>  删除操作已经提交到本地库：指针位置指向包含删除文件的历史纪录<br>  删除操作尚未提交到本地库：指针位置使用HEAD</li></ul><h3 id="比较文件差异"><a href="#比较文件差异" class="headerlink" title="比较文件差异"></a>比较文件差异</h3><ul><li>git diff [文件名] 将工作区的文件和暂存区进行比较</li><li>git diff [本地库中历史版本] [文件名] 将工作区的文件和本地历史记录比较</li><li>git diff 不带文件名 比较多个文件</li></ul><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><ul><li>热修复 主分支的bug 更改  分一个 hot_fix 分支</li><li>分支的好处：</li><li>查看分支 git branch -v</li><li>创建分支 git branch hot_fix</li><li>切换分支 git checkout hot_fix   切换到这个分支</li><li><p>合并分支<br>  第一步：切换到接受修改的分支(被合并，增加新内容)上 git checkout [接受修改的分支]<br>  第二步：在接受修改的分支上执行命令  git merge [有新内容的分支]</p></li><li><p>解决合并分支后产生的冲突<br>  分别在两个分支上修改内容 分别提交到本地库 比如都在haha.txt上做修改<br>  将两个分支合并到一个分支上 出现合并冲突<br>  vim haha.txt 查看合并后的状态<br>  HEAD 部分表示当前分支的修改<br>  在一行========之下为另一个分支上做的修改<br>  解决方法：</p><pre><code>一：删掉那些特殊符号 并手动将内容修改为满意的状态 期间可能与分支伙伴商量 保存退出二：git add [文件名]三：git commit -m &apos;日志说明&apos;  注意：此时commit `一定不能带 文件名`</code></pre></li></ul><h3 id="git-原理-哈希算法"><a href="#git-原理-哈希算法" class="headerlink" title="git 原理 哈希算法"></a>git 原理 哈希算法</h3><ul><li>明文 加密 得 密文</li><li>常见的 md5算法   git 底层 SHA-1算法</li></ul><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><h3 id="克隆的效果"><a href="#克隆的效果" class="headerlink" title="克隆的效果"></a>克隆的效果</h3><ul><li>完整的把远程库克隆到本地</li><li>初始化本地库</li></ul><h3 id="邀请队员加入"><a href="#邀请队员加入" class="headerlink" title="邀请队员加入"></a>邀请队员加入</h3><ul><li>github进入相应的项目 /settings/Collaborators/</li><li>在Search by username 之下 添加成员的github账号名  add collaborator</li><li>copy invite link </li><li>发送给队员（qq或邮箱等方式）等其他方式把邀请链接发送给队员</li><li>队员 登录github 后 Accepe invitation</li><li>队员拉取操作<br> pull=fetch+merge<br> git fetch [远程库地址别名] [远程分支名]<br> git merge [远程库地址别名/远程分支名]<br> git pull [远程库地址别名] [远程分支名]</li></ul><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ul><li>如果不是基于 GitHub 远程库的<code>最新版</code>所做的修改，则不能推送，必须先拉取。</li><li>拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即</li></ul><h3 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h3><ul><li>外团队人员fork 该项目</li></ul><h3 id="git-工作流"><a href="#git-工作流" class="headerlink" title="git 工作流"></a>git 工作流</h3><p>分支种类<br> 主干分支 master<br>主要负责管理正在运行的生产环境代码。永远保持与正在运行的生产环境<br>完全一致。<br> 开发分支 develop<br>主要负责管理正在开发过程中的代码。一般情况下应该是最新的代码。<br> bug 修理分支 hotfix<br>主要负责管理生产环境下出现的紧急修复的代码。 从主干分支分出，修<br>理完毕并测试上线后，并回主干分支。并回后，视情况可以删除该分支。<br> 准生产分支（预发布分支） release<br>较大的版本上线前，会从开发分支中分出准生产分支，进行最后阶段的集<br>成测试。该版本上线后，会合并到主干分支。生产环境运行一段阶段较稳定后<br>可以视情况删除。<br> 功能分支 feature<br>为了不影响较短周期的开发工作，一般把中长期开发模块，会从开发分支</p><h2 id="中独立出来。-开发完成后会合并到开发分支。"><a href="#中独立出来。-开发完成后会合并到开发分支。" class="headerlink" title="中独立出来。 开发完成后会合并到开发分支。"></a>中独立出来。 开发完成后会合并到开发分支。</h2><p>&emsp;&emsp;完 更多笔记看git&amp;github.pdf详细笔记</p><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/git/git-guigu-note/#disqus_thread</comments>
    </item>
    
    <item>
      <title>vue-tour</title>
      <link>https://shulu520.com/vue/vue-tour/</link>
      <guid>https://shulu520.com/vue/vue-tour/</guid>
      <pubDate>Fri, 10 May 2019 16:09:17 GMT</pubDate>
      <description>
      
        A vue.js project vue-tour 去哪儿(vue@2.5)
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;I love three things in this world. Sun, Moon, and You. Sun for morning, Moon for night, and You forever.浮世三千，吾爱有三，日、月与卿。日为朝，月为暮，卿为朝朝暮暮。</p><hr><a id="more"></a><blockquote><p>A Vue.js project-去哪儿旅行，vue学习练手小项目。</p></blockquote><h3 id="Build-Setup"><a href="#Build-Setup" class="headerlink" title="Build Setup"></a>Build Setup</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install dependencies</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># serve with hot reload at localhost:8080</span></span><br><span class="line">npm run dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># build for production with minification</span></span><br><span class="line">npm run build</span><br><span class="line"></span><br><span class="line"><span class="comment"># build for production and view the bundle analyzer report</span></span><br><span class="line">npm run build --report</span><br></pre></td></tr></table></figure><h3 id="css-省略号…"><a href="#css-省略号…" class="headerlink" title="css 省略号…"></a>css 省略号…</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">overflow hidden</span><br><span class="line">white-space nowrap</span><br><span class="line">text-overflow ellipsis</span><br></pre></td></tr></table></figure><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><ul><li>如果这个项目是从github 上克隆来的 初始化时直接   vue init  webpack     注意这里不用再加初始化的项目名称</li></ul><h3 id="修改-标签"><a href="#修改-标签" class="headerlink" title="修改 标签 "></a>修改 标签 <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"></h3><h3 id="路劲优化，简化-在webpack-中配置"><a href="#路劲优化，简化-在webpack-中配置" class="headerlink" title="路劲优化，简化 ,在webpack 中配置"></a>路劲优化，简化 ,在webpack 中配置</h3><ul><li>build/webpack.base.conf.js   的alias 下面是vue-cli 配置好的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;,</span><br><span class="line">  &apos;@&apos;: resolve(&apos;src&apos;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>import HelloWorld from ‘@/components/HelloWorld’ 其中的 @ 表示src目录</li><li>在css 样式中 import ‘~@/assets/styles/varibles.styl’ 其中的 ~@ 表示src目录</li></ul><h3 id="移动端快速点击"><a href="#移动端快速点击" class="headerlink" title="移动端快速点击"></a>移动端快速点击</h3><ul><li>npm i fastclick –save  解决300毫秒延迟</li><li>在main.js 中 </li><li>import fastClick from ‘fastclick’</li><li>fastClick.attach(document.body)</li></ul><h3 id="css代码编辑工具-stylus"><a href="#css代码编辑工具-stylus" class="headerlink" title="css代码编辑工具 stylus"></a>css代码编辑工具 stylus</h3><ul><li>npm i stylus –save</li><li>npm i stylus-loader –save</li></ul><h3 id="阿里图标-进入网站后-图标管理-我的项目-新建项目"><a href="#阿里图标-进入网站后-图标管理-我的项目-新建项目" class="headerlink" title="阿里图标 进入网站后 /图标管理/我的项目/新建项目"></a>阿里图标 进入网站后 /图标管理/我的项目/新建项目</h3><h3 id="1px-使用的是硅谷外卖-stylus-mixins-styl"><a href="#1px-使用的是硅谷外卖-stylus-mixins-styl" class="headerlink" title="1px 使用的是硅谷外卖 stylus/mixins.styl"></a>1px 使用的是硅谷外卖 stylus/mixins.styl</h3><ul><li>使用 @import ‘~@/assets/styles/border.styl’</li><li>某一个样式下 bottom-border-1px(#ccc) 自己传一个色值</li></ul><h3 id="github-创建新分支index-swiper"><a href="#github-创建新分支index-swiper" class="headerlink" title="github 创建新分支index-swiper"></a>github 创建新分支index-swiper</h3><h3 id="本地-git-pull-将分支拉到本地"><a href="#本地-git-pull-将分支拉到本地" class="headerlink" title="本地 git pull 将分支拉到本地"></a>本地 git pull 将分支拉到本地</h3><h3 id="切换到这个分支-git-checkout-index-swiper"><a href="#切换到这个分支-git-checkout-index-swiper" class="headerlink" title="切换到这个分支 git checkout index-swiper"></a>切换到这个分支 git checkout index-swiper</h3><h3 id="轮播图-npm-i-vue-awesome-swiper-2-6-7-–save"><a href="#轮播图-npm-i-vue-awesome-swiper-2-6-7-–save" class="headerlink" title="轮播图 npm i vue-awesome-swiper@2.6.7 –save"></a>轮播图 npm i <a href="mailto:vue-awesome-swiper@2.6.7" target="_blank" rel="noopener">vue-awesome-swiper@2.6.7</a> –save</h3><ul><li><a href="https://github.com/surmon-china/vue-awesome-swiper" target="_blank" rel="noopener">官网具体配置</a></li></ul><h3 id="轮播图-index-swiper-开发完成后"><a href="#轮播图-index-swiper-开发完成后" class="headerlink" title="轮播图 index-swiper 开发完成后"></a>轮播图 index-swiper 开发完成后</h3><ul><li>git add .</li><li>git commit -m ‘swiper finished’</li><li>git push  </li><li>git checkout master</li><li>git merge  index-swiper  将index-swiper 分支的文件 合并到master主分支</li><li>git push </li></ul><h3 id="在浏览器中自动打开"><a href="#在浏览器中自动打开" class="headerlink" title="在浏览器中自动打开"></a>在浏览器中自动打开</h3><ul><li>config/index.js </li><li>修改里面的配置，把autoOpenBrowser:false改为autoOpenBrowser:true即可</li></ul><h3 id="布局-高度"><a href="#布局-高度" class="headerlink" title="布局 高度"></a>布局 高度</h3><ul><li>height 0<br>padding-bottom 33.9% </li><li>用padding-bottom 的值撑开高度 即高宽比</li></ul><h3 id="Git出现-MERGING解决"><a href="#Git出现-MERGING解决" class="headerlink" title="Git出现|MERGING解决"></a>Git出现|MERGING解决</h3><ul><li>使用git上传或者下拉中出现MERGING，这是合并冲突了</li><li>输入命令可以正常跳转：git reset –hard head</li></ul><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><ul><li>npm install  axios –save</li><li><p>config/index.js中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">      &apos;/api&apos;: &#123;</span><br><span class="line">        target: &apos;http://localhost:8081&apos;,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &apos;^/api&apos;: &apos;/static/mock&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></li><li><p>vue 文件中</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&apos;/api/index.json&apos;)</span><br><span class="line">    .then(this.getHomeInfoSucc)</span><br></pre></td></tr></table></figure><h3 id="解决-swiper-初次显示时为最后一张图的情况"><a href="#解决-swiper-初次显示时为最后一张图的情况" class="headerlink" title="解决 swiper 初次显示时为最后一张图的情况"></a>解决 swiper 初次显示时为最后一张图的情况</h3><ul><li>是因为刚开始时是一个空数组</li><li>给swiper 加 v-if = “list.length” 即list 传过来有值的时候在加载。</li></ul><h3 id="页面滚动"><a href="#页面滚动" class="headerlink" title="页面滚动"></a>页面滚动</h3><ul><li>npm  install  better-scroll –save </li></ul><h3 id="ref-属性使用注意"><a href="#ref-属性使用注意" class="headerlink" title="ref 属性使用注意"></a>ref 属性使用注意</h3><ul><li>如果 ref 的值 是 v-for 循环产生的 </li><li>使用时 this.$refs[‘A’][0]    即第零相 才是真正的dom </li></ul><h3 id="使用函数截流-提示网站性能"><a href="#使用函数截流-提示网站性能" class="headerlink" title="使用函数截流  提示网站性能"></a>使用函数截流  提示网站性能</h3><ul><li>在 touchmove 事件中 使用 settimeout </li><li>即将一些触发特别快又频繁的代码放到 定时器里面 减少执行次数</li></ul><h3 id="vuex-状态管理"><a href="#vuex-状态管理" class="headerlink" title="vuex  状态管理"></a>vuex  状态管理</h3><ul><li>npm  install vuex  –save      安装</li><li><p>src/新建store/index.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    city: &apos;北京&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>main.js</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import store from &apos;./store&apos;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router,</span><br><span class="line">  store,       添加选项store </span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="城市选择后-直接跳转到-首页-显示相应的城市"><a href="#城市选择后-直接跳转到-首页-显示相应的城市" class="headerlink" title="城市选择后 直接跳转到 首页 显示相应的城市"></a>城市选择后 直接跳转到 首页 显示相应的城市</h3><ul><li>在事件处理 方法里面 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$store.dispatch(&apos;changeCity&apos;, city)</span><br><span class="line">this.$router.push(&apos;/&apos;)</span><br></pre></td></tr></table></figure><h3 id="localStorage-的使用"><a href="#localStorage-的使用" class="headerlink" title="localStorage 的使用"></a>localStorage 的使用</h3><ul><li>需要在外层加 tyr  catch  以防  某谢用户 避了本地存储功能 或浏览器使用隐身模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">let defaultCity = &apos;常州&apos;</span><br><span class="line">try &#123;</span><br><span class="line">  if (localStorage.city) &#123;</span><br><span class="line">    defaultCity = localStorage.city</span><br><span class="line">  &#125;</span><br><span class="line">&#125;catch (e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    city: defaultCity || &apos;常州&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    changeCity (ctx,city) &#123;</span><br><span class="line">      ctx.commit(&apos;changeCity&apos;, city)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    changeCity (state, city) &#123;</span><br><span class="line">      state.city = city</span><br><span class="line">      try &#123;</span><br><span class="line">        localStorage.city = city</span><br><span class="line">      &#125;catch (e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="mapState-的使用"><a href="#mapState-的使用" class="headerlink" title="mapState 的使用"></a>mapState 的使用</h3><ul><li>定义<br><code>import { mapState } from &#39;vuex&#39;</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapState([&apos;city&apos;])</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">也可以是</span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      currentCity: &apos;city&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><ul><li>使用   或  </li></ul><h3 id="keep-alike-的使用"><a href="#keep-alike-的使用" class="headerlink" title="keep-alike 的使用"></a>keep-alike 的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view/&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><ul><li><p>相应的组件 数据 加载一次后会保存到内存中 下次调用 直接取 提升性能</p></li><li><p>vue 实例 选项中多了一个生命  周期钩子函数 activated, 其在页面重新显示，有变动的时候触发</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">activated () &#123;</span><br><span class="line">    if (this.lastCity !== this.city) &#123;</span><br><span class="line">      this.getHomeInfo()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="及时解除全局事件"><a href="#及时解除全局事件" class="headerlink" title="及时解除全局事件"></a>及时解除全局事件</h3><ul><li>让其只在当前组件中触发</li><li>deactivated 在页面隐藏，页面被替换为新的页面 时触发</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">activated () &#123;</span><br><span class="line">    window.addEventListener(&apos;scroll&apos;, this.handleScroll)</span><br><span class="line">  &#125;,</span><br><span class="line"> deactivated () &#123;</span><br><span class="line">    window.removeEventListener(&apos;scroll&apos;,this.handleScroll)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="递归组件的使用"><a href="#递归组件的使用" class="headerlink" title="递归组件的使用"></a>递归组件的使用</h3><ul><li>在自己组件内部 通过name 选项 的名字 作为递归组件的标签名使用<br><code>&lt;detail-list :list=&quot;item.children&quot;&gt;&lt;/detail-list&gt;</code></li></ul><h3 id="缓存相关-App-vue-中"><a href="#缓存相关-App-vue-中" class="headerlink" title="缓存相关 App.vue 中"></a>缓存相关 App.vue 中</h3><ul><li>Detail 组件不缓存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive exclude=&quot;Detail&quot;&gt;</span><br><span class="line">    &lt;router-view/&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><h3 id="解决不同页面位置的相互影响问题"><a href="#解决不同页面位置的相互影响问题" class="headerlink" title="解决不同页面位置的相互影响问题"></a>解决不同页面位置的相互影响问题</h3><ul><li>router/index.js  中加入scrollBehavior选项</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      name: &apos;Home&apos;,</span><br><span class="line">      component: Home</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  scrollBehavior (to, from, savedPosition) &#123;</span><br><span class="line">    return &#123;x: 0, y: 0&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="解决某些手机浏览器-不支持-promise-的情况"><a href="#解决某些手机浏览器-不支持-promise-的情况" class="headerlink" title="解决某些手机浏览器 不支持 promise 的情况"></a>解决某些手机浏览器 不支持 promise 的情况</h3><ul><li>npm install babel-polyfill –save</li><li>main.js 中   <code>import &#39;babel-polyfill&#39;</code></li></ul><h3 id="项目优化-按需加载js-组件-此方法-只在打包生成的app-js文件特别大（1M左右）的时候使用，小的话，不宜，因为这样会增加http-请求"><a href="#项目优化-按需加载js-组件-此方法-只在打包生成的app-js文件特别大（1M左右）的时候使用，小的话，不宜，因为这样会增加http-请求" class="headerlink" title="项目优化 按需加载js 组件  此方法 只在打包生成的app.js文件特别大（1M左右）的时候使用，小的话，不宜，因为这样会增加http 请求"></a>项目优化 按需加载js 组件  此方法 只在打包生成的app.js文件特别大（1M左右）的时候使用，小的话，不宜，因为这样会增加http 请求</h3><ul><li>router/index.js  将<code>import Home from &#39;@/pages/home/Home.vue&#39;</code>引入组件的方式去掉，配置路由为 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      name: &apos;Home&apos;,</span><br><span class="line">      component: ( ) =&gt; import(&apos;@/pages/home/Home.vue&apos;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h3 id="项目上线"><a href="#项目上线" class="headerlink" title="项目上线"></a>项目上线</h3><ul><li>npm run build   生成dist 文件夹 将dist 给后端运行</li></ul><hr><p>&emsp;&emsp; 项目正在开发完毕。</p><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/vue/vue-tour/#disqus_thread</comments>
    </item>
    
    <item>
      <title>http</title>
      <link>https://shulu520.com/http/http/</link>
      <guid>https://shulu520.com/http/http/</guid>
      <pubDate>Mon, 06 May 2019 15:32:22 GMT</pubDate>
      <description>
      
        http学习笔记
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;</p><hr><a id="more"></a><h2 id="GET-POST-的区别-前提-web浏览器环境下的RFC规范GET-用来获取信息，POST用来发送信息"><a href="#GET-POST-的区别-前提-web浏览器环境下的RFC规范GET-用来获取信息，POST用来发送信息" class="headerlink" title="GET  POST 的区别 前提:web浏览器环境下的RFC规范GET 用来获取信息，POST用来发送信息"></a>GET  POST 的区别 前提:web浏览器环境下的RFC规范GET 用来获取信息，POST用来发送信息</h2><ul><li>可见性</li><li>安全性</li><li>数据大小</li><li>编码类型</li><li>能否收藏为书签，GET可以</li><li>刷新，后退按钮，GET无影响，POST重新提交</li><li>能否保留到浏览器历史，GET保留</li></ul><hr><p>&emsp;&emsp;</p><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/http/http/#disqus_thread</comments>
    </item>
    
    <item>
      <title>net-model</title>
      <link>https://shulu520.com/net/net-model/</link>
      <guid>https://shulu520.com/net/net-model/</guid>
      <pubDate>Mon, 06 May 2019 15:28:43 GMT</pubDate>
      <description>
      
        对五层网络模型的初步认识
      
      </description>
      
      <content:encoded><![CDATA[<hr><hr><a id="more"></a><h2 id="应用层-程序，软件，应用层协议，http协议，DNS协议-域名解析-，FTP协议-文件传输协议-，SMTP-邮件传输协议"><a href="#应用层-程序，软件，应用层协议，http协议，DNS协议-域名解析-，FTP协议-文件传输协议-，SMTP-邮件传输协议" class="headerlink" title="应用层:  程序，软件，应用层协议，http协议，DNS协议(域名解析)，FTP协议(文件传输协议)，SMTP(邮件传输协议)"></a>应用层:  程序，软件，应用层协议，http协议，DNS协议(域名解析)，FTP协议(文件传输协议)，SMTP(邮件传输协议)</h2><h2 id="传输层-对数据传输的建立和管理，传输层协议，UDP协议-有丢包的可能-，TCP-保证数据的正确性，顺序性"><a href="#传输层-对数据传输的建立和管理，传输层协议，UDP协议-有丢包的可能-，TCP-保证数据的正确性，顺序性" class="headerlink" title="传输层: 对数据传输的建立和管理，传输层协议，UDP协议(有丢包的可能)，TCP(保证数据的正确性，顺序性)"></a>传输层: 对数据传输的建立和管理，传输层协议，UDP协议(有丢包的可能)，TCP(保证数据的正确性，顺序性)</h2><h2 id="网络层-好比交通网络，IP协议-IP加端口号来确定一个程序的位置"><a href="#网络层-好比交通网络，IP协议-IP加端口号来确定一个程序的位置" class="headerlink" title="网络层: 好比交通网络，IP协议(IP加端口号来确定一个程序的位置)"></a>网络层: 好比交通网络，IP协议(IP加端口号来确定一个程序的位置)</h2><h2 id="数据链路层-两个子层，一个叫逻辑链路控制子层，另一个叫媒体访问控制子层-MAC地址"><a href="#数据链路层-两个子层，一个叫逻辑链路控制子层，另一个叫媒体访问控制子层-MAC地址" class="headerlink" title="数据链路层: 两个子层，一个叫逻辑链路控制子层，另一个叫媒体访问控制子层(MAC地址)"></a>数据链路层: 两个子层，一个叫逻辑链路控制子层，另一个叫媒体访问控制子层(MAC地址)</h2><h2 id="物理层-坐公交，扫码骑车。"><a href="#物理层-坐公交，扫码骑车。" class="headerlink" title="物理层: 坐公交，扫码骑车。"></a>物理层: 坐公交，扫码骑车。</h2><h2 id="除了五层网络模型之外还有七层网络模型，那么七层网络模型是什么呢？就是将应用层一分为三，分别为：应用层，表示层和会话层。新出来的表示层和会话层没有相应的协议。一般表示层做的是数据格式化，或者加密等操作。"><a href="#除了五层网络模型之外还有七层网络模型，那么七层网络模型是什么呢？就是将应用层一分为三，分别为：应用层，表示层和会话层。新出来的表示层和会话层没有相应的协议。一般表示层做的是数据格式化，或者加密等操作。" class="headerlink" title="除了五层网络模型之外还有七层网络模型，那么七层网络模型是什么呢？就是将应用层一分为三，分别为：应用层，表示层和会话层。新出来的表示层和会话层没有相应的协议。一般表示层做的是数据格式化，或者加密等操作。"></a>除了五层网络模型之外还有七层网络模型，那么七层网络模型是什么呢？就是将应用层一分为三，分别为：应用层，表示层和会话层。新出来的表示层和会话层没有相应的协议。一般表示层做的是数据格式化，或者加密等操作。</h2>]]></content:encoded>
      
      <comments>https://shulu520.com/net/net-model/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>

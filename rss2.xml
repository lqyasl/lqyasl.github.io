<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>梦不成</title>
    <link>https://shulu520.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>君子生非异也，善假于物也.</description>
    <pubDate>Sun, 19 May 2019 16:39:42 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title></title>
      <link>https://shulu520.com/uncategorized/arrow-js-note/text/</link>
      <guid>https://shulu520.com/uncategorized/arrow-js-note/text/</guid>
      <pubDate>Sun, 19 May 2019 16:16:06 GMT</pubDate>
      <description>
      
        
        
          &lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;&lt;meta name=&quot;generator&quot; content=&quot;Hexo 3.8.0&quot;&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;heloword&lt;/title&gt;
  &lt;st
        
      
      </description>
      
      <content:encoded><![CDATA[<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0">  <meta charset="UTF-8">  <title>heloword</title>  <style>    *{margin:0;padding:0;}    li{list-style:none;}    a{text-decoration: none;}  </style></head><body>  <div id="app">      </div>  <script>      </script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"superSample":2,"width":160,"height":320,"position":"left","hOffset":-12,"vOffset":-43},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body></html>]]></content:encoded>
      
      <comments>https://shulu520.com/uncategorized/arrow-js-note/text/#disqus_thread</comments>
    </item>
    
    <item>
      <title>arrow-js-note</title>
      <link>https://shulu520.com/arrowjs/arrow-js-note/</link>
      <guid>https://shulu520.com/arrowjs/arrow-js-note/</guid>
      <pubDate>Sun, 19 May 2019 16:11:45 GMT</pubDate>
      <description>
      
        箭头函数相关知识总结
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;今天是2019年，520，在这特殊的一天我面对的依然是code, but no Object, 我希望有一天能美梦成真——面向对象面向君，不负代码不负卿。</p><a id="more"></a><h2 id="箭头函数的经典题型"><a href="#箭头函数的经典题型" class="headerlink" title="箭头函数的经典题型"></a>箭头函数的经典题型</h2><ul><li>有关 this</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  id: 01,</span><br><span class="line">  say: function () &#123;</span><br><span class="line">    // 这里的this为obj</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      // 这里是匿名函数的this默认为window</span><br><span class="line">      console.log(&apos;arrow id:&apos;, this.id); // undifind</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;,</span><br><span class="line">  sayWithThis: function () &#123;</span><br><span class="line">    // 这里将this的值当成变量存起来</span><br><span class="line">    let that = this;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(&apos;arrow id:&apos;, that.id); // 01</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;,</span><br><span class="line">  sayWithArrow: function () &#123;</span><br><span class="line">    // 这里的this为obj</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(&apos;arrow id:&apos;, this.id); // 01</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;,</span><br><span class="line">  sayWithGlobalArrow: () =&gt; &#123;</span><br><span class="line">    // 这里的this已经为全局的this了</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(&apos;arrow id:&apos;, this.id); // undifind</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>&emsp;&emsp;</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/arrowjs/arrow-js-note/#disqus_thread</comments>
    </item>
    
    <item>
      <title>git-qa-note</title>
      <link>https://shulu520.com/git/git-qa-note/</link>
      <guid>https://shulu520.com/git/git-qa-note/</guid>
      <pubDate>Sat, 18 May 2019 04:11:06 GMT</pubDate>
      <description>
      
        在git的使用中遇到的问题&amp;解决方法
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;<br><a id="more"></a></p><h2 id="科学上网之后，git-报错"><a href="#科学上网之后，git-报错" class="headerlink" title="科学上网之后，git 报错"></a>科学上网之后，git 报错</h2><ul><li>如下错误：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh: Could not resolve hostname github.com: Name or service not known</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure><ul><li>解决方法<br>1、找到本机的 host 文件，一般位置是进入 C:\Windows\System32\drivers\etc</li></ul><p>2、在host文件的最后一行加上，如果之前已经设置过，可以将ip地址更改为最新的正确的ip地址</p><p>192.30.255.112  github.com git<br>185.31.16.184   github.global.ssl.fastly.net</p><hr><p>&emsp;&emsp;遇到后继续补充……</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/git/git-qa-note/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Array-note</title>
      <link>https://shulu520.com/Array/Array-note-md/</link>
      <guid>https://shulu520.com/Array/Array-note-md/</guid>
      <pubDate>Fri, 17 May 2019 16:41:04 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp;&amp;emsp;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;</p><a id="more"></a><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><ul><li>计算数组成员的个数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const countOccurrences = (arr,val) =&gt; arr.reduce((a,v) =&gt; (v === val ? a + 1 : a), 0)</span><br><span class="line"></span><br><span class="line">alert(countOccurrences([1,111,2,2,2,3,4], 2)); // 3</span><br></pre></td></tr></table></figure><h2 id="max"><a href="#max" class="headerlink" title="max"></a>max</h2><ul><li>Math.max.apply(null, arr)</li><li>Math.max(…arr)</li></ul><hr><p>&emsp;&emsp;</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/Array/Array-note-md/#disqus_thread</comments>
    </item>
    
    <item>
      <title>node-blue-note</title>
      <link>https://shulu520.com/node/node-blue-note-md/</link>
      <guid>https://shulu520.com/node/node-blue-note-md/</guid>
      <pubDate>Thu, 16 May 2019 13:44:45 GMT</pubDate>
      <description>
      
        taobao前端工程师石川(blue)视频教程笔记
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;我本来要忘记你了，可我又做梦了。<br><a id="more"></a></p><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><ul><li>http 模块 GET方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http);</span><br><span class="line">  //创建一个服务器</span><br><span class="line">var server = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">  /*</span><br><span class="line">    给这个地址随便提交一个表单 http://localhost:8080/aaa</span><br><span class="line">    其中 req.url = &apos;/aaa?user=shulu&amp;pass=123&apos;</span><br><span class="line">    运用字符串的切割数组的拼接就可以拿到用户名与密码</span><br><span class="line">  */</span><br><span class="line">&#125;).listen(8080);</span><br></pre></td></tr></table></figure><ul><li>queryString 模块 GET方式<br>争对这种数据 xxx=…&amp;yyy=…&amp;zzz=…</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const querystring = require(&apos;queryString&apos;);</span><br><span class="line">var json = querystring.parse(&apos;user=shulu&amp;pass=123&amp;age=18&apos;);</span><br><span class="line">console.log(json) // &#123;&quot;user&quot;: &quot;shulu&quot;, &quot;pass&quot;: &quot;123&quot;, &quot;age&quot;: &quot;18&quot;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>url 模块 GET方式<br>争对这种数据 整个url部分 参数为true效果更好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http);</span><br><span class="line">const _url = require(&apos;url&apos;);</span><br><span class="line">var server = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">  var obj = _url.parse(req.url, true);</span><br><span class="line">  var url = obj.pathname;</span><br><span class="line">  const GET = obj.query;</span><br><span class="line">&#125;).listen(8080);</span><br></pre></td></tr></table></figure></li><li><p>http 模块 POST方式</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">const querystring = require(&apos;querystring&apos;);</span><br><span class="line">var server = http.createServer((req, res) =&gt;&#123;</span><br><span class="line">  //请求数据一样在req中</span><br><span class="line">  var str = &apos;&apos;;</span><br><span class="line">  //data数据大 分多次到达</span><br><span class="line">  req.on(&apos;data&apos;, (data) =&gt; &#123; //data事件</span><br><span class="line">    str += data;</span><br><span class="line">  &#125;);</span><br><span class="line">  req.on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">    var POST = querystring.parse(str)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).listen(8888);</span><br></pre></td></tr></table></figure><h2 id="express-框架"><a href="#express-框架" class="headerlink" title="express 框架"></a>express 框架</h2><ul><li>express保留了原生的功能，增加了一些自己的功能</li><li>基本使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">var server = express();</span><br><span class="line">server.use(&apos;/a.html&apos;, function (req, res) &#123;</span><br><span class="line">  //res.send() 方法参数可以是json等</span><br><span class="line">  //res.write() 参数只能是字符串或buffer</span><br><span class="line">  res.send(&apos;aaaa&apos;);</span><br><span class="line">  res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(8080);</span><br></pre></td></tr></table></figure><ul><li>三种接收处理请求的方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.get()</span><br><span class="line">server.post()</span><br><span class="line">server.use()</span><br></pre></td></tr></table></figure><ul><li>express-static 插件 处理静态文件的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const expresStatic = require(&apos;express-static&apos;);</span><br><span class="line"></span><br><span class="line">var server = express();</span><br><span class="line">server.listen(8888);</span><br><span class="line"></span><br><span class="line">server.use(expresStatic(&apos;./www&apos;));</span><br></pre></td></tr></table></figure><ul><li>中间件 body-parser 解析POST数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.use(bodyParser.urlencode(&#123;</span><br><span class="line">  extend: false, //扩展模式</span><br><span class="line">  limit: 1024*1024 //限制1M</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><ul><li><p>multer 解析post文件<br> multipart/form-data 格式的表单数据</p></li><li><p>链式操作 next</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server.use(&apos;/&apos;, function (req, res, next) &#123;</span><br><span class="line">  console.log(&apos;aaa&apos;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line">server.use(&apos;/&apos;, function (req, res, next) &#123;</span><br><span class="line">  console.log(&apos;bbb&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="模板引擎-ejs"><a href="#模板引擎-ejs" class="headerlink" title="模板引擎 ejs"></a>模板引擎 ejs</h2><h2 id="path-模块"><a href="#path-模块" class="headerlink" title="path 模块"></a>path 模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">var str = &apos;c:\\user\\www\\a.html&apos;;</span><br><span class="line">var obj = path.parse(str);</span><br><span class="line">console.log(obj);</span><br><span class="line"></span><br><span class="line">//base: 文件名部分 如a.html</span><br><span class="line">//ext: 扩展名 如.html</span><br><span class="line">//dir: 文件路劲 如c:\\user\\www</span><br></pre></td></tr></table></figure><p><hr><br>&emsp;&emsp;未完待续……</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/node/node-blue-note-md/#disqus_thread</comments>
    </item>
    
    <item>
      <title>vim-note.md</title>
      <link>https://shulu520.com/vim/vim-note-md/</link>
      <guid>https://shulu520.com/vim/vim-note-md/</guid>
      <pubDate>Wed, 15 May 2019 15:34:56 GMT</pubDate>
      <description>
      
        vim的封号为&quot;编辑器之神&quot;, 学会了vimium也就掌握vim的核心用法, 一举两得!,vimium的用法真的很酷, 如果喜欢表演的话, 这是一个很好的工具!
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;You only live on this earth once.</p><hr><a id="more"></a><h2 id="快捷强大的vim"><a href="#快捷强大的vim" class="headerlink" title="快捷强大的vim"></a>快捷强大的vim</h2><ul><li><p>vimium能提升我们的浏览速度, 鼠标比键盘简单, 键盘比鼠标快!</p></li><li><p>快速向下滚动d </p></li><li>快速向上滚动u</li><li>滚动到页面顶部gg </li><li><p>滚动到页面底部G</p></li><li><p>神技! 快速搜索 (相当于浏览器顶部搜索框), 并在新标签打开 大写的O</p></li><li>关闭页面x  恢复页面X</li><li>主动脱离焦点esc 比如按下o搜索退出时按esc</li><li>shift+/,查看所有快捷键</li></ul><hr><p>&emsp;&emsp;未完待续……</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/vim/vim-note-md/#disqus_thread</comments>
    </item>
    
    <item>
      <title>nodejs-guigu-note</title>
      <link>https://shulu520.com/node/nodejs-guigu-note/</link>
      <guid>https://shulu520.com/node/nodejs-guigu-note/</guid>
      <pubDate>Tue, 14 May 2019 14:50:21 GMT</pubDate>
      <description>
      
        硅谷nodejs视频教程笔记
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;我期待有一天背着背包出现在你的城市。</p><hr><a id="more"></a><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul><li>小娜 输入 环境变量 进入环境变量/用户变量/path 点开 里面是一条条的文件路劲 可以新建一个文件的路劲</li><li>在这里配置了 相当于 声明了一个 类似于 js 中的全局变量 为作用域链的最高层</li><li>可以将一些常用的文件或程序的路劲添加到path下 这样我们就可以在任意的位置访问他们了</li></ul><h2 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程 线程"></a>进程 线程</h2><ul><li>进程<br>  负责为程序的运行提供必备的环境<br>  工厂的车间</li><li>线程<br>  负责执行进程中的程序<br>  车间工人</li><li>单线程<br>  一个人干活</li><li>多线程<br>  多人合作干一个活 </li></ul><h2 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h2><ul><li>事件驱动</li><li>非阻塞</li><li>异步I/O  (性能瓶颈阶段)  input写入操作  output读操作</li><li>版本 奇数为开发版  偶数为稳定版</li><li>在Node中，模块分为三类：一类是底层由C++编写的内建模块，一类是Node提供的核心模块；还有一类是用户编写的模块，称为文件模块。<h2 id="node-js-模块化"><a href="#node-js-模块化" class="headerlink" title="node.js 模块化"></a>node.js 模块化</h2></li><li>新建一个js文件就是一个模块</li><li>这个模块里面写的代码其实是包在一个函数里面的 即</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">funcyion (exports, require, module, _filename, _dirname) &#123;</span><br><span class="line">/*</span><br><span class="line">这里是我们写的代码 外面其实包了一层这个函数 默认不可见</span><br><span class="line">可以通过console.log(arguments.callee) 或</span><br><span class="line">  console.log(arguments.callee + &quot;&quot;) 将此函数打印出来 </span><br><span class="line">  该函数执行时传进了5个参数</span><br><span class="line">所以模块里面的代码是局部变量</span><br><span class="line">exports参数 用来将变量或函数暴露到外边</span><br><span class="line">require参数 用来引入外部的模块</span><br><span class="line">module参数 代表模块本身 exports是module的属性</span><br><span class="line">_filename 当前模块的完整路劲</span><br><span class="line">_dirname 当前模块所在文件夹的路劲</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>module.exports 与exports的区别<br>  module.exports == exports  true<br>  exports 只能使用.的方式向外暴露 若exports = {} 这样向外暴露的话就修改了exports的引用对象<br>  module.exports 既可以通过.的形式 也可以直接赋值 <code>推荐写法</code></li><li>核心模块<br>  由node 提供的模块 node_moudle中的 引入时直接写模块名字 不需要路劲 </li><li>文件模块<br>  由我们自己创建的模块   引入时添加./或../等路劲</li></ul><h2 id="包-package"><a href="#包-package" class="headerlink" title="包 package"></a>包 package</h2><ul><li>包实际上就是一个压缩文件 解压以后还原为目录</li><li>规范的目录包含以下文件：<br>  -package.json <code>包描述文件</code> (必须的) <code>里面不能写注释</code><br>  -bin 可执行二进制文件  binary 二进制<br>  -lib js代码 library 库 图书馆<br>  -doc 文档 document<br>  -test 单元测试</li></ul><h2 id="npm-即-Node-Package-Manager-node包管理器"><a href="#npm-即-Node-Package-Manager-node包管理器" class="headerlink" title="npm 即 (Node Package Manager) node包管理器"></a>npm 即 (Node Package Manager) node包管理器</h2><ul><li>commonjs包规范的是一种理论 npm是其中一种实践</li><li>对node而言 npm帮助其完成了第三方模块的发布安和依赖</li><li>借助npm 使得node与第三方模块之间形成一个生态系统</li><li>查看版本 npm version查看相关的版本 或npm -v</li><li>npm search 包名 搜索包</li><li>npm init 在某一文件夹下初始化该文件夹 帮助我们根据提示生成一个package.json的文件<br>  在初始化后的文件夹下 安装搜索的包 并新建一个index.js 入口文件在里面就可以直接引入math模块使用了</li><li>npm install 包名 安装 包 或npm i</li><li>npm remove 或 npm r  删除包 </li><li>npm install 包名 杠杠save  安装包并添加到依赖中</li><li>npm install 下载当前项目所依赖的包</li><li>npm install 包名 -g 全局安装包 一般是安装一些工具 如vue-cli </li><li>cnpm 也可以用 快速</li><li>node在使用下载的包时 会沿着作用域链一直往上找直到磁盘根目录找不到则报错 这就解释了某的包在删除之后依然能用的情况</li></ul><h2 id="Buffer-（缓冲区）"><a href="#Buffer-（缓冲区）" class="headerlink" title="Buffer （缓冲区）"></a>Buffer （缓冲区）</h2><ul><li>结构和数组很相似 方法也类似</li><li>补充了数组方法的不足 Buffer专门存贮二进制数据的</li><li>实际上Buffer中的内存不是通过JavaScript分配的，而是在底层通过C++申请的。也就是我们可以直接通过Buffer来创建内存中的空间。</li><li>使用buffer无需引入模块 直接使用即可</li><li>Buffer.from(str) 将字符串str转为buffer二进制数据</li><li>在buffer中存贮的都是二进制数据 但在显示时都是以16进制的形式显示的<br>  二进制 00-255 或 00-ff</li><li>计算机 一个0或一个1 称为一位(bit)</li><li>8bit = 1byte(字节) 最小单位 中文一个汉字占用三个字节</li><li>创建一个制定大小的buffer<br>  Buffer.alloc(10) 10字节大小<br>  可通过索引来操作buffer中的元素</li><li>Buffer的大小一旦确定 不能再更该 因为存储空间是连续的 性能好</li><li>Buffer与字符串间的转换</li><li>支持的编码:<br>   ASCII、UTF-8、UTF-16LE/UCS-2、Base64、Binary、Hex</li><li>字符串转Buffer<br>   Buffer.from(str , [encoding]); </li><li>Buffer转字符串 buf.toString()<br>   buf.toString([encoding] , [start] , [end]);</li><li>复制缓冲区<br>   buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])</li><li>对缓冲区切片<br> buf.slice([start[, end]])</li><li>拼接缓冲区<br>   Buffer.concat(list[, totalLength])     <h2 id="fs-文件系统"><a href="#fs-文件系统" class="headerlink" title="fs (文件系统)"></a>fs (文件系统)</h2></li><li>在Node中，与文件系统的交互是非常重要的，服务器的本质就将本地的文件发送给远程的客户端</li><li>核心模块 直接引入使用</li><li>const fs = require(‘fs’)</li><li>fs 模块中所有的操作都有两种形式 同步(会阻塞 带sync) 异步(不会阻塞 带回调函数)</li><li>fs模块中所有的操作都有两种形式可供选择同步和异步</li><li>同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码。异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。</li><li>打开文件<br>   fs.open(path, flags[, mode], callback)<br>   fs.openSync(path, flags[, mode])</li><li>关闭文件<br>   fs.close(fd, callback)<br>   fs.closeSync(fd)</li><li>fs中提供了四种不同的方式将数据写入文件<br>   简单文件写入<br>   同步文件写入<br>   异步文件写入<br>   流式文件写入</li><li><p>同步文件的写入：<br>  1.打开文件<br>  操作方式为定为写 即<br>  var fd = fs.openSync(path, flags) 参数为字符串类型</p><pre><code>path即文件的路劲flags即 r表示读操作  w表示写入操作</code></pre><p>  通过返回的描述符fd对文件进行各种操作 </p><p>  2.写入内容数据<br>  fs.writeSync(fd, string)</p><pre><code>fd文件的描述符 需要传入文件的描述符string要写入的内容</code></pre><p>  3.关闭文件 考虑性能<br>  fs.closeSync(fd)</p></li><li><p>异步文件写入<br>  1.打开文件</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fs.open(path, flags, function (err, fd) &#123;</span><br><span class="line">if (!err) &#123;</span><br><span class="line">2.在这里往文件写入内容 写操作</span><br><span class="line">fs.write(fd, &apos;要异步写入的内容&apos;, function (err) &#123;</span><br><span class="line">if (!err) &#123;</span><br><span class="line">console.log(&apos;write success&apos;)</span><br><span class="line">&#125;</span><br><span class="line">fs.close(fd, function (err) &#123;</span><br><span class="line">if (!err) &#123;</span><br><span class="line">console.log(&apos;close success&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(fd)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">console.log(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>返回值为 callback的参数</p><ul><li>简单文件写入<br>  简单同步文件<br>  fs.write<br>  简单异步文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(&apos;hello.txt&apos;, &apos;shulu520&apos;, &#123;flag: &apos;a&apos;&#125; function (err) &#123; //flag: &apos;a&apos; 追加文件内容 不会覆盖原来的 如果文件不存在则创建 flag还有好多的模式</span><br><span class="line">if (!err) &#123;</span><br><span class="line">console.log(&apos;write success&apos;)</span><br><span class="line">&#125;</span><br><span class="line">//文件路劲可以是F:\JSdownload\npm-test 这种 `但是要变为`F:\\JSdownload\\npm-test或F:/JSdownload/npm-test</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>同步 异步 简单文件 的写入都不适合大文件爱的写入 易导致内存溢出 性能差</li><li>流式文件写入</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">创建流</span><br><span class="line">var ws = fs.createWriteStream(path)</span><br><span class="line">监听事件 once绑定一次性的事件</span><br><span class="line">ws.once(&apos;open&apos;, function () &#123; </span><br><span class="line">console.log(&apos;stream success&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">ws.once(&apos;close&apos;, function () &#123;</span><br><span class="line">console.log(&apos;stream close&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">写入内容 大量内容</span><br><span class="line">ws.write(&apos;写入内容1&apos;)</span><br><span class="line">ws.write(&apos;写入内容2&apos;)</span><br><span class="line">ws.write(&apos;写入内容3&apos;)</span><br><span class="line">ws.write(&apos;写入内容4&apos;)</span><br><span class="line">……</span><br><span class="line">关闭流 在流开始的一方结束流</span><br><span class="line">ws.end()</span><br><span class="line">```</span><br><span class="line">+ fs中提供了四种读取文件的方式</span><br><span class="line"> 简单文件读取</span><br><span class="line"> 同步文件读取</span><br><span class="line"> 异步文件读取</span><br><span class="line"> 流式文件读取</span><br><span class="line">+ 简单文件读取</span><br><span class="line">  简单异步文件读取</span><br></pre></td></tr></table></figure><p>const fs = require(‘fs’);<br>fs.readFile(‘shulu.jpg’, (err, data) =&gt; {<br>    if(!err) {<br>        fs.writeFile(‘桌面路劲/lqy.jpg’, data, () =&gt; {<br>            if(!err) {<br>                console.log(‘文件写入成功 ‘)<br>            }<br>        })<br>    }<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 流式文件读取 适用于大文件</span><br></pre></td></tr></table></figure></p><p>const fs = require(‘fs’);<br>1.创建读取流<br>const rs = fs.createReadStream(‘shulu.jpg’);<br>2.监听流的开启和关闭<br>rs.once(‘open’, () =&gt; {<br>    console.log(‘流打开成功了’)<br>})<br>rs.once(‘close’, () =&gt; {<br>    console.log(‘流关闭了’)<br>})<br>3.读取数据<br>rs.on(‘data’, (data) =&gt; {<br>    console.log(data) //多次分批读取大数据<br>})</p><ul><li>pipe 流方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>const fs = require(‘fs’);<br>const rs = fs.createReadStream(‘shulu.mp3’);<br>const ws = fs.createWriteStrem(‘lqy.mp3’);<br>rs.pipe(ws); 读取后直接流入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ fs 模块其他操作</span><br><span class="line">检查一个文件是否存在</span><br><span class="line">+ 列出文件</span><br><span class="line"> fs.readdir(path[, options], callback)</span><br><span class="line"> fs.readdirSync(path[, options])</span><br><span class="line">+ 截断文件</span><br><span class="line"> fs.truncate(path, len, callback)</span><br><span class="line"> fs.truncateSync(path, len)</span><br><span class="line">+ 建立目录</span><br><span class="line"> fs.mkdir(path[, mode], callback)</span><br><span class="line"> fs.mkdirSync(path[, mode])</span><br><span class="line">+ 验证路径是否存在</span><br><span class="line"> fs.existsSync(path)</span><br><span class="line">+ 获取文件信息</span><br><span class="line"> fs.stat(path, callback)</span><br><span class="line"> fs.statSync(path)</span><br><span class="line">+ 删除文件</span><br><span class="line"> fs.unlink(path, callback)</span><br><span class="line"> fs.unlinkSync(path)</span><br><span class="line"></span><br><span class="line">+ 删除目录</span><br><span class="line"> fs.rmdir(path, callback)</span><br><span class="line"> fs.rmdirSync(path)</span><br><span class="line">+ 重命名文件和目录</span><br><span class="line"> fs.rename(oldPath, newPath, callback)</span><br><span class="line"> fs.renameSync(oldPath, newPath)</span><br><span class="line">+ 监视文件更改写入</span><br><span class="line"> fs.watchFile(filename[, options], listener)</span><br></pre></td></tr></table></figure><p>const fs = require(‘fs’);<br>const isExists = fs.existsSync(‘shulu.mp3’);<br>console.log(isExists);<br><code>`</code></p><hr><p>&emsp;&emsp;未完待续……<br>&emsp;&emsp;</p><h2><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me</a></h2><p></p><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/node/nodejs-guigu-note/#disqus_thread</comments>
    </item>
    
    <item>
      <title>es6-zhuf-01.md</title>
      <link>https://shulu520.com/es6/es6-zhuf-01/</link>
      <guid>https://shulu520.com/es6/es6-zhuf-01/</guid>
      <pubDate>Mon, 13 May 2019 15:46:29 GMT</pubDate>
      <description>
      
        zhuf架构视频教程笔记
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;想要的东西，会以最快的速度来到你的身边。</p><hr><a id="more"></a><h2 id="var-与-let-和-const-的区别"><a href="#var-与-let-和-const-的区别" class="headerlink" title="var 与 let 和 const 的区别"></a>var 与 let 和 const 的区别</h2><p>新的方法解决了老方法遗留的问题</p><ul><li><p>var<br>  在同一作用域内可以对同一变量重复声明<br>  不能定义常量(控制不了，因为可以修改，写了等于没写)<br>  不支持块级作用域</p></li><li><p>let<br>  在同一作用域内不能对同一变量重复声明<br>  变量不会提升 变量定义之前使用会报错<br>  有块级作用域 {这里面为块级作用域}<br>  以前js只有两种作用域 一个是全局 一个是函数级<br>  作用域经典问题： for 循环里面套 定时器 当时的解决方法 给定时器包一层自执行的匿名函数并将循环变量传进去 本质上是作用域问题 现在用let声明变量就可以了</p></li><li><p>const<br>  在同一作用域内不能对同一变量重复声明<br>  专门声明常量 常量声明后不可修改<br>  但若此常量是一个引用类型的话(例如一个对象) 引用对象的属性还是可以改的 例如：定义 const USER = {name: ‘shulu’} 更改为 USER.name = ‘lqy’ 可以的</p></li></ul><h2 id="解构-分解一个对象的解构"><a href="#解构-分解一个对象的解构" class="headerlink" title="解构 分解一个对象的解构"></a>解构 分解一个对象的解构</h2><ul><li>解构的时候 等号的两边解构相似 右边必须是一个真实的值</li><li>数组的省略赋值<br>  let arr = [1, 2, 3]; let [,,x] = arr 则只拿到x=3的值</li></ul><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><ul><li>以前是字符串拼串 现在是这个符号  <code></code> 可以折行 换行</li><li>模板语言的原理 正则实现 面试</li><li>带参数的模板字符串</li><li><p>字符串的新方法 返回布尔值<br>  str.startWith(‘http’)<br>  str.endsWith(‘.com’)<br>  str.includes(‘shulu’) 以前 str.indexOf(‘shulu’) == -1  做判断<br>  str.repeat(10) 重复10次</p></li><li><p>展开运算符 …<br>   对象合并：<br>   Object.assign(obj3, obj2, obj1); 将对象1，2合并为3<br>   obj3 = {…obj1, …obj2} 更简洁</p></li><li><p>对象的深拷贝</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let obj2 = JSON.parse(JSON.stringify(obj1))</span><br></pre></td></tr></table></figure><ul><li>递归实现对象深拷贝</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//对象深拷贝</span><br><span class="line">function deepClone(origin,target)&#123;</span><br><span class="line"></span><br><span class="line">//target是否存在如果不存在创建空对象</span><br><span class="line">let tar = target || &#123;&#125;,</span><br><span class="line"></span><br><span class="line">//判断是否为引用数据类型</span><br><span class="line">toStr = Object.prototype.toString,</span><br><span class="line">arrType=&apos;[object Array]&apos;;</span><br><span class="line"></span><br><span class="line">for(let key in origin)&#123;</span><br><span class="line">//剥离原型链的数据</span><br><span class="line">if(origin.hasOwnProperty(key))&#123;</span><br><span class="line">//判断是否为引用数据类型 对象或数组</span><br><span class="line">if(typeof(origin[key]) === &apos;object&apos; &amp;&amp; origin[key] !== null)&#123;</span><br><span class="line">if(toStr.call(origin[key]) === arrType )&#123;</span><br><span class="line">tar[key] = [];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">tar[key] = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">deepClone(origin[key],tar[key]);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">tar[key] = origin[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return tar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>箭头函数<br>箭头函数this 继承自父级，自己本身没有this</li></ul><hr><p>&emsp;&emsp;未完待续……</p><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/es6/es6-zhuf-01/#disqus_thread</comments>
    </item>
    
    <item>
      <title>git-guigu-note</title>
      <link>https://shulu520.com/git/git-guigu-note/</link>
      <guid>https://shulu520.com/git/git-guigu-note/</guid>
      <pubDate>Sun, 12 May 2019 15:21:02 GMT</pubDate>
      <description>
      
        尚硅谷git&amp;github视频学习笔记，超详细
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;在衰老到来之前，做一件值得做的事情。做这件事不是为了别的，而是为了证明自己是好样的。-《似水流年》</p><hr><a id="more"></a><h3 id="复制-选中后-Ctrl-ins-即键盘右上角的insert键"><a href="#复制-选中后-Ctrl-ins-即键盘右上角的insert键" class="headerlink" title="复制 选中后 Ctrl+ins  即键盘右上角的insert键"></a>复制 选中后 Ctrl+ins  即键盘右上角的insert键</h3><h3 id="粘贴-相应的位置-Shift-ins"><a href="#粘贴-相应的位置-Shift-ins" class="headerlink" title="粘贴 相应的位置 Shift+ins"></a>粘贴 相应的位置 Shift+ins</h3><h3 id="查看git-配置信息cat-gitconfig"><a href="#查看git-配置信息cat-gitconfig" class="headerlink" title="查看git 配置信息cat ~/.gitconfig"></a>查看git 配置信息cat ~/.gitconfig</h3><h3 id="状态查看-git-status-查看工作区、暂存区状态"><a href="#状态查看-git-status-查看工作区、暂存区状态" class="headerlink" title="状态查看 git status 查看工作区、暂存区状态"></a>状态查看 git status 查看工作区、暂存区状态</h3><h3 id="文件内容查看-cat-haha-txt"><a href="#文件内容查看-cat-haha-txt" class="headerlink" title="文件内容查看 cat haha.txt"></a>文件内容查看 cat haha.txt</h3><h3 id="添加操作-git-add-file-name"><a href="#添加操作-git-add-file-name" class="headerlink" title="添加操作 git add [file_name]"></a>添加操作 git add [file_name]</h3><h3 id="git-commit-m-‘说明信息’-file-name"><a href="#git-commit-m-‘说明信息’-file-name" class="headerlink" title="git commit -m ‘说明信息’ [file_name]"></a>git commit -m ‘说明信息’ [file_name]</h3><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><ul><li>touch haha.txt 或 vim good.txt </li><li>字母ll 列出本地库所有文件和文件总数，创建日期 时间 创建人 文件名 </li></ul><h3 id="git-add-haha-txt-后-若想返回add前的状态-根据提示-git-rm-–cached-haha-txt-即可返回，此删除只是从暂存区里面删除，工作区的文件还在"><a href="#git-add-haha-txt-后-若想返回add前的状态-根据提示-git-rm-–cached-haha-txt-即可返回，此删除只是从暂存区里面删除，工作区的文件还在" class="headerlink" title="git add haha.txt 后 若想返回add前的状态 根据提示 git rm –cached haha.txt 即可返回，此删除只是从暂存区里面删除，工作区的文件还在"></a>git add haha.txt 后 若想返回add前的状态 根据提示 git rm –cached haha.txt 即可返回，此删除只是从暂存区里面删除，工作区的文件还在</h3><h3 id="git-commit-haha-txt-这里没带-m-‘说明信息’-回车后会进入vim-编辑器-可以编写大量的说明信息"><a href="#git-commit-haha-txt-这里没带-m-‘说明信息’-回车后会进入vim-编辑器-可以编写大量的说明信息" class="headerlink" title="git commit haha.txt  这里没带-m ‘说明信息’  回车后会进入vim 编辑器 可以编写大量的说明信息"></a>git commit haha.txt  这里没带-m ‘说明信息’  回车后会进入vim 编辑器 可以编写大量的说明信息</h3><ul><li>首先 按a键 进入插入模式，之后就可以进行编辑了。</li><li>编辑完了就可以按Esc键退出插入模式，然后输出:wq即可退出vim编辑器，回到git bash界面。</li></ul><h3 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h3><ul><li>git log  打印的记录风格： 分散 有作者 邮箱 日期提示，显示内容详细，内容多了，多屏显示控制方式：桥空格为向下翻页，b键为向上翻页，q 键为退出查看</li><li>git log –oneline 打印效果为一行</li><li>git reflog  打印的记录风格： 紧凑 在一行显示并有提示版本回退数字提示</li></ul><h3 id="版本前进后退"><a href="#版本前进后退" class="headerlink" title="版本前进后退"></a>版本前进后退</h3><ul><li>基于索引值操作 任意版本穿梭 <code>推荐方法</code> git reset –hard alfe9cd  这里alfe9cd为某一版本的提交id值即索引值</li><li>基于符号 ^ 只能后退  返回上一个版本 git reset –hard HEAD^  版本倒退三个 git reset –hard HEAD^^^ </li><li>基于符号 ~ 只能后退  版本倒退三个 git reset –hard HEAD~3</li></ul><h3 id="reset-命令的三个参数对比"><a href="#reset-命令的三个参数对比" class="headerlink" title="reset 命令的三个参数对比"></a>reset 命令的三个参数对比</h3><ul><li>–soft 仅仅在本地库移动HEAD指针</li><li>–mixed 在本地库移动HEAD指针,重置暂存区</li><li>–hard 在本地库移动HEAD指针,重置暂存区,重置工作区，三个区位置保持一致</li></ul><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><ul><li>rm aaa.txt</li><li>git status 显示为 红色 deleted: aaa.txt</li><li>提示要add该文件 git add aaa.txt</li><li>git status  显示为 绿色 表示已添加到暂存区</li><li>git commit -m ‘deleted aaa.txt’ 将这次删除操作提交到本地库</li></ul><h3 id="删除文件并恢复"><a href="#删除文件并恢复" class="headerlink" title="删除文件并恢复"></a>删除文件并恢复</h3><ul><li>前提：删除前 文件的状态提交到了本地库</li><li>操作： git reset –hard [指针位置]<br>  删除操作已经提交到本地库：指针位置指向包含删除文件的历史纪录<br>  删除操作尚未提交到本地库：指针位置使用HEAD</li></ul><h3 id="比较文件差异"><a href="#比较文件差异" class="headerlink" title="比较文件差异"></a>比较文件差异</h3><ul><li>git diff [文件名] 将工作区的文件和暂存区进行比较</li><li>git diff [本地库中历史版本] [文件名] 将工作区的文件和本地历史记录比较</li><li>git diff 不带文件名 比较多个文件</li></ul><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><ul><li>热修复 主分支的bug 更改  分一个 hot_fix 分支</li><li>分支的好处：</li><li>查看分支 git branch -v</li><li>创建分支 git branch hot_fix</li><li>切换分支 git checkout hot_fix   切换到这个分支</li><li><p>合并分支<br>  第一步：切换到接受修改的分支(被合并，增加新内容)上 git checkout [接受修改的分支]<br>  第二步：在接受修改的分支上执行命令  git merge [有新内容的分支]</p></li><li><p>解决合并分支后产生的冲突<br>  分别在两个分支上修改内容 分别提交到本地库 比如都在haha.txt上做修改<br>  将两个分支合并到一个分支上 出现合并冲突<br>  vim haha.txt 查看合并后的状态<br>  HEAD 部分表示当前分支的修改<br>  在一行========之下为另一个分支上做的修改<br>  解决方法：</p><pre><code>一：删掉那些特殊符号 并手动将内容修改为满意的状态 期间可能与分支伙伴商量 保存退出二：git add [文件名]三：git commit -m &apos;日志说明&apos;  注意：此时commit `一定不能带 文件名`</code></pre></li></ul><h3 id="git-原理-哈希算法"><a href="#git-原理-哈希算法" class="headerlink" title="git 原理 哈希算法"></a>git 原理 哈希算法</h3><ul><li>明文 加密 得 密文</li><li>常见的 md5算法   git 底层 SHA-1算法</li></ul><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><h3 id="克隆的效果"><a href="#克隆的效果" class="headerlink" title="克隆的效果"></a>克隆的效果</h3><ul><li>完整的把远程库克隆到本地</li><li>初始化本地库</li></ul><h3 id="邀请队员加入"><a href="#邀请队员加入" class="headerlink" title="邀请队员加入"></a>邀请队员加入</h3><ul><li>github进入相应的项目 /settings/Collaborators/</li><li>在Search by username 之下 添加成员的github账号名  add collaborator</li><li>copy invite link </li><li>发送给队员（qq或邮箱等方式）等其他方式把邀请链接发送给队员</li><li>队员 登录github 后 Accepe invitation</li><li>队员拉取操作<br> pull=fetch+merge<br> git fetch [远程库地址别名] [远程分支名]<br> git merge [远程库地址别名/远程分支名]<br> git pull [远程库地址别名] [远程分支名]</li></ul><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ul><li>如果不是基于 GitHub 远程库的<code>最新版</code>所做的修改，则不能推送，必须先拉取。</li><li>拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即</li></ul><h3 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h3><ul><li>外团队人员fork 该项目</li></ul><h3 id="git-工作流"><a href="#git-工作流" class="headerlink" title="git 工作流"></a>git 工作流</h3><p>分支种类<br> 主干分支 master<br>主要负责管理正在运行的生产环境代码。永远保持与正在运行的生产环境<br>完全一致。<br> 开发分支 develop<br>主要负责管理正在开发过程中的代码。一般情况下应该是最新的代码。<br> bug 修理分支 hotfix<br>主要负责管理生产环境下出现的紧急修复的代码。 从主干分支分出，修<br>理完毕并测试上线后，并回主干分支。并回后，视情况可以删除该分支。<br> 准生产分支（预发布分支） release<br>较大的版本上线前，会从开发分支中分出准生产分支，进行最后阶段的集<br>成测试。该版本上线后，会合并到主干分支。生产环境运行一段阶段较稳定后<br>可以视情况删除。<br> 功能分支 feature<br>为了不影响较短周期的开发工作，一般把中长期开发模块，会从开发分支</p><h2 id="中独立出来。-开发完成后会合并到开发分支。"><a href="#中独立出来。-开发完成后会合并到开发分支。" class="headerlink" title="中独立出来。 开发完成后会合并到开发分支。"></a>中独立出来。 开发完成后会合并到开发分支。</h2><p>&emsp;&emsp;完 更多笔记看git&amp;github.pdf详细笔记</p><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/git/git-guigu-note/#disqus_thread</comments>
    </item>
    
    <item>
      <title>vue-tour</title>
      <link>https://shulu520.com/vue/vue-tour/</link>
      <guid>https://shulu520.com/vue/vue-tour/</guid>
      <pubDate>Fri, 10 May 2019 16:09:17 GMT</pubDate>
      <description>
      
        A vue.js project vue-tour 去哪儿(vue@2.5)
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;I love three things in this world. Sun, Moon, and You. Sun for morning, Moon for night, and You forever.浮世三千，吾爱有三，日、月与卿。日为朝，月为暮，卿为朝朝暮暮。</p><hr><a id="more"></a><blockquote><p>A Vue.js project-去哪儿旅行，vue学习练手小项目。</p></blockquote><h3 id="Build-Setup"><a href="#Build-Setup" class="headerlink" title="Build Setup"></a>Build Setup</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install dependencies</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># serve with hot reload at localhost:8080</span></span><br><span class="line">npm run dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># build for production with minification</span></span><br><span class="line">npm run build</span><br><span class="line"></span><br><span class="line"><span class="comment"># build for production and view the bundle analyzer report</span></span><br><span class="line">npm run build --report</span><br></pre></td></tr></table></figure><h3 id="css-省略号…"><a href="#css-省略号…" class="headerlink" title="css 省略号…"></a>css 省略号…</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">overflow hidden</span><br><span class="line">white-space nowrap</span><br><span class="line">text-overflow ellipsis</span><br></pre></td></tr></table></figure><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><ul><li>如果这个项目是从github 上克隆来的 初始化时直接   vue init  webpack     注意这里不用再加初始化的项目名称</li></ul><h3 id="修改-标签"><a href="#修改-标签" class="headerlink" title="修改 标签 "></a>修改 标签 <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"></h3><h3 id="路劲优化，简化-在webpack-中配置"><a href="#路劲优化，简化-在webpack-中配置" class="headerlink" title="路劲优化，简化 ,在webpack 中配置"></a>路劲优化，简化 ,在webpack 中配置</h3><ul><li>build/webpack.base.conf.js   的alias 下面是vue-cli 配置好的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;,</span><br><span class="line">  &apos;@&apos;: resolve(&apos;src&apos;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>import HelloWorld from ‘@/components/HelloWorld’ 其中的 @ 表示src目录</li><li>在css 样式中 import ‘~@/assets/styles/varibles.styl’ 其中的 ~@ 表示src目录</li></ul><h3 id="移动端快速点击"><a href="#移动端快速点击" class="headerlink" title="移动端快速点击"></a>移动端快速点击</h3><ul><li>npm i fastclick –save  解决300毫秒延迟</li><li>在main.js 中 </li><li>import fastClick from ‘fastclick’</li><li>fastClick.attach(document.body)</li></ul><h3 id="css代码编辑工具-stylus"><a href="#css代码编辑工具-stylus" class="headerlink" title="css代码编辑工具 stylus"></a>css代码编辑工具 stylus</h3><ul><li>npm i stylus –save</li><li>npm i stylus-loader –save</li></ul><h3 id="阿里图标-进入网站后-图标管理-我的项目-新建项目"><a href="#阿里图标-进入网站后-图标管理-我的项目-新建项目" class="headerlink" title="阿里图标 进入网站后 /图标管理/我的项目/新建项目"></a>阿里图标 进入网站后 /图标管理/我的项目/新建项目</h3><h3 id="1px-使用的是硅谷外卖-stylus-mixins-styl"><a href="#1px-使用的是硅谷外卖-stylus-mixins-styl" class="headerlink" title="1px 使用的是硅谷外卖 stylus/mixins.styl"></a>1px 使用的是硅谷外卖 stylus/mixins.styl</h3><ul><li>使用 @import ‘~@/assets/styles/border.styl’</li><li>某一个样式下 bottom-border-1px(#ccc) 自己传一个色值</li></ul><h3 id="github-创建新分支index-swiper"><a href="#github-创建新分支index-swiper" class="headerlink" title="github 创建新分支index-swiper"></a>github 创建新分支index-swiper</h3><h3 id="本地-git-pull-将分支拉到本地"><a href="#本地-git-pull-将分支拉到本地" class="headerlink" title="本地 git pull 将分支拉到本地"></a>本地 git pull 将分支拉到本地</h3><h3 id="切换到这个分支-git-checkout-index-swiper"><a href="#切换到这个分支-git-checkout-index-swiper" class="headerlink" title="切换到这个分支 git checkout index-swiper"></a>切换到这个分支 git checkout index-swiper</h3><h3 id="轮播图-npm-i-vue-awesome-swiper-2-6-7-–save"><a href="#轮播图-npm-i-vue-awesome-swiper-2-6-7-–save" class="headerlink" title="轮播图 npm i vue-awesome-swiper@2.6.7 –save"></a>轮播图 npm i <a href="mailto:vue-awesome-swiper@2.6.7" target="_blank" rel="noopener">vue-awesome-swiper@2.6.7</a> –save</h3><ul><li><a href="https://github.com/surmon-china/vue-awesome-swiper" target="_blank" rel="noopener">官网具体配置</a></li></ul><h3 id="轮播图-index-swiper-开发完成后"><a href="#轮播图-index-swiper-开发完成后" class="headerlink" title="轮播图 index-swiper 开发完成后"></a>轮播图 index-swiper 开发完成后</h3><ul><li>git add .</li><li>git commit -m ‘swiper finished’</li><li>git push  </li><li>git checkout master</li><li>git merge  index-swiper  将index-swiper 分支的文件 合并到master主分支</li><li>git push </li></ul><h3 id="在浏览器中自动打开"><a href="#在浏览器中自动打开" class="headerlink" title="在浏览器中自动打开"></a>在浏览器中自动打开</h3><ul><li>config/index.js </li><li>修改里面的配置，把autoOpenBrowser:false改为autoOpenBrowser:true即可</li></ul><h3 id="布局-高度"><a href="#布局-高度" class="headerlink" title="布局 高度"></a>布局 高度</h3><ul><li>height 0<br>padding-bottom 33.9% </li><li>用padding-bottom 的值撑开高度 即高宽比</li></ul><h3 id="Git出现-MERGING解决"><a href="#Git出现-MERGING解决" class="headerlink" title="Git出现|MERGING解决"></a>Git出现|MERGING解决</h3><ul><li>使用git上传或者下拉中出现MERGING，这是合并冲突了</li><li>输入命令可以正常跳转：git reset –hard head</li></ul><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><ul><li>npm install  axios –save</li><li><p>config/index.js中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">      &apos;/api&apos;: &#123;</span><br><span class="line">        target: &apos;http://localhost:8081&apos;,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &apos;^/api&apos;: &apos;/static/mock&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></li><li><p>vue 文件中</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&apos;/api/index.json&apos;)</span><br><span class="line">    .then(this.getHomeInfoSucc)</span><br></pre></td></tr></table></figure><h3 id="解决-swiper-初次显示时为最后一张图的情况"><a href="#解决-swiper-初次显示时为最后一张图的情况" class="headerlink" title="解决 swiper 初次显示时为最后一张图的情况"></a>解决 swiper 初次显示时为最后一张图的情况</h3><ul><li>是因为刚开始时是一个空数组</li><li>给swiper 加 v-if = “list.length” 即list 传过来有值的时候在加载。</li></ul><h3 id="页面滚动"><a href="#页面滚动" class="headerlink" title="页面滚动"></a>页面滚动</h3><ul><li>npm  install  better-scroll –save </li></ul><h3 id="ref-属性使用注意"><a href="#ref-属性使用注意" class="headerlink" title="ref 属性使用注意"></a>ref 属性使用注意</h3><ul><li>如果 ref 的值 是 v-for 循环产生的 </li><li>使用时 this.$refs[‘A’][0]    即第零相 才是真正的dom </li></ul><h3 id="使用函数截流-提示网站性能"><a href="#使用函数截流-提示网站性能" class="headerlink" title="使用函数截流  提示网站性能"></a>使用函数截流  提示网站性能</h3><ul><li>在 touchmove 事件中 使用 settimeout </li><li>即将一些触发特别快又频繁的代码放到 定时器里面 减少执行次数</li></ul><h3 id="vuex-状态管理"><a href="#vuex-状态管理" class="headerlink" title="vuex  状态管理"></a>vuex  状态管理</h3><ul><li>npm  install vuex  –save      安装</li><li><p>src/新建store/index.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    city: &apos;北京&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>main.js</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import store from &apos;./store&apos;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router,</span><br><span class="line">  store,       添加选项store </span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="城市选择后-直接跳转到-首页-显示相应的城市"><a href="#城市选择后-直接跳转到-首页-显示相应的城市" class="headerlink" title="城市选择后 直接跳转到 首页 显示相应的城市"></a>城市选择后 直接跳转到 首页 显示相应的城市</h3><ul><li>在事件处理 方法里面 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$store.dispatch(&apos;changeCity&apos;, city)</span><br><span class="line">this.$router.push(&apos;/&apos;)</span><br></pre></td></tr></table></figure><h3 id="localStorage-的使用"><a href="#localStorage-的使用" class="headerlink" title="localStorage 的使用"></a>localStorage 的使用</h3><ul><li>需要在外层加 tyr  catch  以防  某谢用户 避了本地存储功能 或浏览器使用隐身模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">let defaultCity = &apos;常州&apos;</span><br><span class="line">try &#123;</span><br><span class="line">  if (localStorage.city) &#123;</span><br><span class="line">    defaultCity = localStorage.city</span><br><span class="line">  &#125;</span><br><span class="line">&#125;catch (e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    city: defaultCity || &apos;常州&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    changeCity (ctx,city) &#123;</span><br><span class="line">      ctx.commit(&apos;changeCity&apos;, city)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    changeCity (state, city) &#123;</span><br><span class="line">      state.city = city</span><br><span class="line">      try &#123;</span><br><span class="line">        localStorage.city = city</span><br><span class="line">      &#125;catch (e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="mapState-的使用"><a href="#mapState-的使用" class="headerlink" title="mapState 的使用"></a>mapState 的使用</h3><ul><li>定义<br><code>import { mapState } from &#39;vuex&#39;</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapState([&apos;city&apos;])</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">也可以是</span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      currentCity: &apos;city&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><ul><li>使用   或  </li></ul><h3 id="keep-alike-的使用"><a href="#keep-alike-的使用" class="headerlink" title="keep-alike 的使用"></a>keep-alike 的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view/&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><ul><li><p>相应的组件 数据 加载一次后会保存到内存中 下次调用 直接取 提升性能</p></li><li><p>vue 实例 选项中多了一个生命  周期钩子函数 activated, 其在页面重新显示，有变动的时候触发</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">activated () &#123;</span><br><span class="line">    if (this.lastCity !== this.city) &#123;</span><br><span class="line">      this.getHomeInfo()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="及时解除全局事件"><a href="#及时解除全局事件" class="headerlink" title="及时解除全局事件"></a>及时解除全局事件</h3><ul><li>让其只在当前组件中触发</li><li>deactivated 在页面隐藏，页面被替换为新的页面 时触发</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">activated () &#123;</span><br><span class="line">    window.addEventListener(&apos;scroll&apos;, this.handleScroll)</span><br><span class="line">  &#125;,</span><br><span class="line"> deactivated () &#123;</span><br><span class="line">    window.removeEventListener(&apos;scroll&apos;,this.handleScroll)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="递归组件的使用"><a href="#递归组件的使用" class="headerlink" title="递归组件的使用"></a>递归组件的使用</h3><ul><li>在自己组件内部 通过name 选项 的名字 作为递归组件的标签名使用<br><code>&lt;detail-list :list=&quot;item.children&quot;&gt;&lt;/detail-list&gt;</code></li></ul><h3 id="缓存相关-App-vue-中"><a href="#缓存相关-App-vue-中" class="headerlink" title="缓存相关 App.vue 中"></a>缓存相关 App.vue 中</h3><ul><li>Detail 组件不缓存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive exclude=&quot;Detail&quot;&gt;</span><br><span class="line">    &lt;router-view/&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><h3 id="解决不同页面位置的相互影响问题"><a href="#解决不同页面位置的相互影响问题" class="headerlink" title="解决不同页面位置的相互影响问题"></a>解决不同页面位置的相互影响问题</h3><ul><li>router/index.js  中加入scrollBehavior选项</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      name: &apos;Home&apos;,</span><br><span class="line">      component: Home</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  scrollBehavior (to, from, savedPosition) &#123;</span><br><span class="line">    return &#123;x: 0, y: 0&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="解决某些手机浏览器-不支持-promise-的情况"><a href="#解决某些手机浏览器-不支持-promise-的情况" class="headerlink" title="解决某些手机浏览器 不支持 promise 的情况"></a>解决某些手机浏览器 不支持 promise 的情况</h3><ul><li>npm install babel-polyfill –save</li><li>main.js 中   <code>import &#39;babel-polyfill&#39;</code></li></ul><h3 id="项目优化-按需加载js-组件-此方法-只在打包生成的app-js文件特别大（1M左右）的时候使用，小的话，不宜，因为这样会增加http-请求"><a href="#项目优化-按需加载js-组件-此方法-只在打包生成的app-js文件特别大（1M左右）的时候使用，小的话，不宜，因为这样会增加http-请求" class="headerlink" title="项目优化 按需加载js 组件  此方法 只在打包生成的app.js文件特别大（1M左右）的时候使用，小的话，不宜，因为这样会增加http 请求"></a>项目优化 按需加载js 组件  此方法 只在打包生成的app.js文件特别大（1M左右）的时候使用，小的话，不宜，因为这样会增加http 请求</h3><ul><li>router/index.js  将<code>import Home from &#39;@/pages/home/Home.vue&#39;</code>引入组件的方式去掉，配置路由为 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      name: &apos;Home&apos;,</span><br><span class="line">      component: ( ) =&gt; import(&apos;@/pages/home/Home.vue&apos;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h3 id="项目上线"><a href="#项目上线" class="headerlink" title="项目上线"></a>项目上线</h3><ul><li>npm run build   生成dist 文件夹 将dist 给后端运行</li></ul><hr><p>&emsp;&emsp; 项目正在开发完毕。</p><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/vue/vue-tour/#disqus_thread</comments>
    </item>
    
    <item>
      <title>http</title>
      <link>https://shulu520.com/http/http/</link>
      <guid>https://shulu520.com/http/http/</guid>
      <pubDate>Mon, 06 May 2019 15:32:22 GMT</pubDate>
      <description>
      
        http学习笔记
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;</p><hr><a id="more"></a><h2 id="GET-POST-的区别-前提-web浏览器环境下的RFC规范GET-用来获取信息，POST用来发送信息"><a href="#GET-POST-的区别-前提-web浏览器环境下的RFC规范GET-用来获取信息，POST用来发送信息" class="headerlink" title="GET  POST 的区别 前提:web浏览器环境下的RFC规范GET 用来获取信息，POST用来发送信息"></a>GET  POST 的区别 前提:web浏览器环境下的RFC规范GET 用来获取信息，POST用来发送信息</h2><ul><li>可见性</li><li>安全性</li><li>数据大小</li><li>编码类型</li><li>能否收藏为书签，GET可以</li><li>刷新，后退按钮，GET无影响，POST重新提交</li><li>能否保留到浏览器历史，GET保留</li></ul><hr><p>&emsp;&emsp;</p><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/http/http/#disqus_thread</comments>
    </item>
    
    <item>
      <title>net-model</title>
      <link>https://shulu520.com/net/net-model/</link>
      <guid>https://shulu520.com/net/net-model/</guid>
      <pubDate>Mon, 06 May 2019 15:28:43 GMT</pubDate>
      <description>
      
        对五层网络模型的初步认识
      
      </description>
      
      <content:encoded><![CDATA[<hr><hr><a id="more"></a><h2 id="应用层-程序，软件，应用层协议，http协议，DNS协议-域名解析-，FTP协议-文件传输协议-，SMTP-邮件传输协议"><a href="#应用层-程序，软件，应用层协议，http协议，DNS协议-域名解析-，FTP协议-文件传输协议-，SMTP-邮件传输协议" class="headerlink" title="应用层:  程序，软件，应用层协议，http协议，DNS协议(域名解析)，FTP协议(文件传输协议)，SMTP(邮件传输协议)"></a>应用层:  程序，软件，应用层协议，http协议，DNS协议(域名解析)，FTP协议(文件传输协议)，SMTP(邮件传输协议)</h2><h2 id="传输层-对数据传输的建立和管理，传输层协议，UDP协议-有丢包的可能-，TCP-保证数据的正确性，顺序性"><a href="#传输层-对数据传输的建立和管理，传输层协议，UDP协议-有丢包的可能-，TCP-保证数据的正确性，顺序性" class="headerlink" title="传输层: 对数据传输的建立和管理，传输层协议，UDP协议(有丢包的可能)，TCP(保证数据的正确性，顺序性)"></a>传输层: 对数据传输的建立和管理，传输层协议，UDP协议(有丢包的可能)，TCP(保证数据的正确性，顺序性)</h2><h2 id="网络层-好比交通网络，IP协议-IP加端口号来确定一个程序的位置"><a href="#网络层-好比交通网络，IP协议-IP加端口号来确定一个程序的位置" class="headerlink" title="网络层: 好比交通网络，IP协议(IP加端口号来确定一个程序的位置)"></a>网络层: 好比交通网络，IP协议(IP加端口号来确定一个程序的位置)</h2><h2 id="数据链路层-两个子层，一个叫逻辑链路控制子层，另一个叫媒体访问控制子层-MAC地址"><a href="#数据链路层-两个子层，一个叫逻辑链路控制子层，另一个叫媒体访问控制子层-MAC地址" class="headerlink" title="数据链路层: 两个子层，一个叫逻辑链路控制子层，另一个叫媒体访问控制子层(MAC地址)"></a>数据链路层: 两个子层，一个叫逻辑链路控制子层，另一个叫媒体访问控制子层(MAC地址)</h2><h2 id="物理层-坐公交，扫码骑车。"><a href="#物理层-坐公交，扫码骑车。" class="headerlink" title="物理层: 坐公交，扫码骑车。"></a>物理层: 坐公交，扫码骑车。</h2><h2 id="除了五层网络模型之外还有七层网络模型，那么七层网络模型是什么呢？就是将应用层一分为三，分别为：应用层，表示层和会话层。新出来的表示层和会话层没有相应的协议。一般表示层做的是数据格式化，或者加密等操作。"><a href="#除了五层网络模型之外还有七层网络模型，那么七层网络模型是什么呢？就是将应用层一分为三，分别为：应用层，表示层和会话层。新出来的表示层和会话层没有相应的协议。一般表示层做的是数据格式化，或者加密等操作。" class="headerlink" title="除了五层网络模型之外还有七层网络模型，那么七层网络模型是什么呢？就是将应用层一分为三，分别为：应用层，表示层和会话层。新出来的表示层和会话层没有相应的协议。一般表示层做的是数据格式化，或者加密等操作。"></a>除了五层网络模型之外还有七层网络模型，那么七层网络模型是什么呢？就是将应用层一分为三，分别为：应用层，表示层和会话层。新出来的表示层和会话层没有相应的协议。一般表示层做的是数据格式化，或者加密等操作。</h2>]]></content:encoded>
      
      <comments>https://shulu520.com/net/net-model/#disqus_thread</comments>
    </item>
    
    <item>
      <title>xss</title>
      <link>https://shulu520.com/safe/xss/</link>
      <guid>https://shulu520.com/safe/xss/</guid>
      <pubDate>Mon, 06 May 2019 15:23:35 GMT</pubDate>
      <description>
      
        XSS攻击过程解析
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;让一个人变强大的最好方式是拥有一个想去保护的人。</p><hr><a id="more"></a><h2 id="XSS攻击究竟是如何一步一步的获取了别人的隐私呢？下面我们就来一步一步的来进行解析。"><a href="#XSS攻击究竟是如何一步一步的获取了别人的隐私呢？下面我们就来一步一步的来进行解析。" class="headerlink" title="XSS攻击究竟是如何一步一步的获取了别人的隐私呢？下面我们就来一步一步的来进行解析。"></a>XSS攻击究竟是如何一步一步的获取了别人的隐私呢？下面我们就来一步一步的来进行解析。</h2><h2 id="1-攻击者，上传一片文章或者博客，这边文章中带有一段JS代码，这段代码内容很简单，读取本地Cookie，发送给某个url。"><a href="#1-攻击者，上传一片文章或者博客，这边文章中带有一段JS代码，这段代码内容很简单，读取本地Cookie，发送给某个url。" class="headerlink" title="1. 攻击者，上传一片文章或者博客，这边文章中带有一段JS代码，这段代码内容很简单，读取本地Cookie，发送给某个url。"></a>1. 攻击者，上传一片文章或者博客，这边文章中带有一段JS代码，这段代码内容很简单，读取本地Cookie，发送给某个url。</h2><h2 id="2-XX微博的服务器没有对用户上传的内容进行审查，就将内容存储起来。"><a href="#2-XX微博的服务器没有对用户上传的内容进行审查，就将内容存储起来。" class="headerlink" title="2. XX微博的服务器没有对用户上传的内容进行审查，就将内容存储起来。"></a>2. XX微博的服务器没有对用户上传的内容进行审查，就将内容存储起来。</h2><h2 id="3-当正常用户访问XX微博的时候，服务器将有问题的文章推送给了这个正常用户。（因为服务器并没有检查哪篇文章有问题，所以它会认为这是一篇正常的文章，以正常的方式推送给用户。）"><a href="#3-当正常用户访问XX微博的时候，服务器将有问题的文章推送给了这个正常用户。（因为服务器并没有检查哪篇文章有问题，所以它会认为这是一篇正常的文章，以正常的方式推送给用户。）" class="headerlink" title="3. 当正常用户访问XX微博的时候，服务器将有问题的文章推送给了这个正常用户。（因为服务器并没有检查哪篇文章有问题，所以它会认为这是一篇正常的文章，以正常的方式推送给用户。）"></a>3. 当正常用户访问XX微博的时候，服务器将有问题的文章推送给了这个正常用户。（因为服务器并没有检查哪篇文章有问题，所以它会认为这是一篇正常的文章，以正常的方式推送给用户。）</h2><h2 id="4-当正常的用户点开这篇文章的时候，攻击者编写的脚本就会在正常的用户的电脑上执行。（因为攻击者的脚本就是在文章的内容中加入一段script代码，浏览器会将script标签中的内容当作js代码来看待，然后执行这段代码）"><a href="#4-当正常的用户点开这篇文章的时候，攻击者编写的脚本就会在正常的用户的电脑上执行。（因为攻击者的脚本就是在文章的内容中加入一段script代码，浏览器会将script标签中的内容当作js代码来看待，然后执行这段代码）" class="headerlink" title="4. 当正常的用户点开这篇文章的时候，攻击者编写的脚本就会在正常的用户的电脑上执行。（因为攻击者的脚本就是在文章的内容中加入一段script代码，浏览器会将script标签中的内容当作js代码来看待，然后执行这段代码）"></a>4. 当正常的用户点开这篇文章的时候，攻击者编写的脚本就会在正常的用户的电脑上执行。（因为攻击者的脚本就是在文章的内容中加入一段script代码，浏览器会将script标签中的内容当作js代码来看待，然后执行这段代码）</h2><h2 id="5-这段带有攻击性的代码可以读取用户本地的cookie内容，并将内容发送给攻击者事先准备好的url。（因为正常用户在本地打开，所以不存在跨域的问题）"><a href="#5-这段带有攻击性的代码可以读取用户本地的cookie内容，并将内容发送给攻击者事先准备好的url。（因为正常用户在本地打开，所以不存在跨域的问题）" class="headerlink" title="5. 这段带有攻击性的代码可以读取用户本地的cookie内容，并将内容发送给攻击者事先准备好的url。（因为正常用户在本地打开，所以不存在跨域的问题）"></a>5. 这段带有攻击性的代码可以读取用户本地的cookie内容，并将内容发送给攻击者事先准备好的url。（因为正常用户在本地打开，所以不存在跨域的问题）</h2><h2 id="6-攻击者收到了发送过来的cookie之后，就可以将cookie内容写入自己的浏览器里，然后就能登录这个正常用户的XX微博了。"><a href="#6-攻击者收到了发送过来的cookie之后，就可以将cookie内容写入自己的浏览器里，然后就能登录这个正常用户的XX微博了。" class="headerlink" title="6. 攻击者收到了发送过来的cookie之后，就可以将cookie内容写入自己的浏览器里，然后就能登录这个正常用户的XX微博了。"></a>6. 攻击者收到了发送过来的cookie之后，就可以将cookie内容写入自己的浏览器里，然后就能登录这个正常用户的XX微博了。</h2><h2 id="（因为现在很多网站都做了免登录功能，这个功能主要是依赖于种在浏览器里的cookie，这个cookie中会带有用户的部分信息，当用户在每次进入网站的时候，由于这些cookie的存在，就可以免登录了。我们这个例子中，XSS攻击就是获取到了用户的Cookie，从而在我们的本地来将这份cookie写入到我们的浏览器里，就能登录这个正常用户的帐号了-）"><a href="#（因为现在很多网站都做了免登录功能，这个功能主要是依赖于种在浏览器里的cookie，这个cookie中会带有用户的部分信息，当用户在每次进入网站的时候，由于这些cookie的存在，就可以免登录了。我们这个例子中，XSS攻击就是获取到了用户的Cookie，从而在我们的本地来将这份cookie写入到我们的浏览器里，就能登录这个正常用户的帐号了-）" class="headerlink" title="（因为现在很多网站都做了免登录功能，这个功能主要是依赖于种在浏览器里的cookie，这个cookie中会带有用户的部分信息，当用户在每次进入网站的时候，由于这些cookie的存在，就可以免登录了。我们这个例子中，XSS攻击就是获取到了用户的Cookie，从而在我们的本地来将这份cookie写入到我们的浏览器里，就能登录这个正常用户的帐号了~）"></a>（因为现在很多网站都做了免登录功能，这个功能主要是依赖于种在浏览器里的cookie，这个cookie中会带有用户的部分信息，当用户在每次进入网站的时候，由于这些cookie的存在，就可以免登录了。我们这个例子中，XSS攻击就是获取到了用户的Cookie，从而在我们的本地来将这份cookie写入到我们的浏览器里，就能登录这个正常用户的帐号了~）</h2><h2 id="我们会发现XSS攻击最大的问题在于，服务器端在用户上传文章内容的时候，没有进行内容审查。其实，我们只要将一些危险的符号进行HTML编码就可以了，比如将‘-lt-’替换为”-lt-”，将‘-gt-’替换为”-gt-”，这样攻击者就无法通过script标签的方式来进行攻击了"><a href="#我们会发现XSS攻击最大的问题在于，服务器端在用户上传文章内容的时候，没有进行内容审查。其实，我们只要将一些危险的符号进行HTML编码就可以了，比如将‘-lt-’替换为”-lt-”，将‘-gt-’替换为”-gt-”，这样攻击者就无法通过script标签的方式来进行攻击了" class="headerlink" title="我们会发现XSS攻击最大的问题在于，服务器端在用户上传文章内容的时候，没有进行内容审查。其实，我们只要将一些危险的符号进行HTML编码就可以了，比如将‘&lt;’替换为”&lt;”，将‘&gt;’替换为”&gt;”，这样攻击者就无法通过script标签的方式来进行攻击了~"></a>我们会发现XSS攻击最大的问题在于，服务器端在用户上传文章内容的时候，没有进行内容审查。其实，我们只要将一些危险的符号进行HTML编码就可以了，比如将‘&lt;’替换为”&lt;”，将‘&gt;’替换为”&gt;”，这样攻击者就无法通过script标签的方式来进行攻击了~</h2>]]></content:encoded>
      
      <comments>https://shulu520.com/safe/xss/#disqus_thread</comments>
    </item>
    
    <item>
      <title>shanjuan</title>
      <link>https://shulu520.com/friends/shanjuan/</link>
      <guid>https://shulu520.com/friends/shanjuan/</guid>
      <pubDate>Fri, 03 May 2019 06:18:17 GMT</pubDate>
      <description>
      
        &lt;hr&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;juan，我的好朋友，好久不见，今偶然间，美好的回忆又浮现眼前，于是赶紧记下那些美好。&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;juan，我的好朋友，好久不见，今偶然间，美好的回忆又浮现眼前，于是赶紧记下那些美好。</p><hr><a id="more"></a><h2 style="color:orange"><br>&emsp;&emsp;拿起雪糕想起了你。<br>&emsp;&emsp;雪糕这玩意和辣条一样是我小时候的最爱，只是随着年岁渐长，慢慢留在记忆里了。<br>昨晚室友叫我一起去超市，逛了一圈不知买点啥，看到有人买雪糕，心想，天气热了就买个尝尝吧。打开柜子，拿起雪糕，恍惚间，温暖的记忆又浮现在眼前。<br>&emsp;&emsp;juan，我的高中同学，朋友，那时经常作我的同桌，人美心善，跟同学关系都挺好。当然对我也很好。常给我糖果啊各种小吃的，我用的笔啊书和本子啊经常从juan那直接拿。<br>&emsp;&emsp;我对juan的第一印象：juan是一个可爱的小公主，而且很高洁。机缘巧合之下，我有幸认识了juan，而且常常作同桌。这让我们之间的距离又近了一点。juan是我去到十班最早认识的同学之一。<br>&emsp;&emsp;时间久了，发生过的好多事情我就不记得了。所以我此时此刻在努力的将往事回忆，我生怕等我老了的时候，年轻时的这些美好时光要是再也回想不起来了，那样想想多遗憾啊。<br>&emsp;&emsp;juan对我一直很好，就像对其他人一样。我们除了讨论学习，还聊小时候，聊未来。关于未来，其实都是我在表达对未来的迷惑，而juan一直在开导我。juan说我们可以永远做朋友。<br>&emsp;&emsp;一个雪糕，那是高三时的一天中午你送我的，当时教室里是有其同学的，但是你只送给了我。在高三那个本就燥热的季节，让我清凉了一整个夏天。<br>&emsp;&emsp;如今再拿起雪糕，眼前浮现出都是你对我的好。感谢那时的遇见，让我能有这么美好的回忆。juan，也愿你过得好，有个好对象。要是余生能再见，我想你还是那么的漂亮，那么温柔与大气。<br>&emsp;&emsp;朋友的友谊不是三言两语就道的尽的，但都是埋藏在我的心底里的。<br></h2><hr><p>&emsp;&emsp;刚刚看qq空间里你发的说说–有人拿走了你的外卖，🤣🤣🤣</p><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/friends/shanjuan/#disqus_thread</comments>
    </item>
    
    <item>
      <title>book-fengchuan</title>
      <link>https://shulu520.com/book-note/book-fengchuan/</link>
      <guid>https://shulu520.com/book-note/book-fengchuan/</guid>
      <pubDate>Tue, 30 Apr 2019 16:50:45 GMT</pubDate>
      <description>
      
        《疯传》读书笔记摘要
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;深夜时，人会更加容易情绪化，所以无论多难过，都要告诉自己，没有那麽糟糕，睡一觉就好了。</p><hr><a id="more"></a><h2 id="相比广告营销，口口相传更有效，分享能让我们感觉良好，因为他会让我们显得高大上。我们更愿意与人分享能提升个人形象的信息。"><a href="#相比广告营销，口口相传更有效，分享能让我们感觉良好，因为他会让我们显得高大上。我们更愿意与人分享能提升个人形象的信息。" class="headerlink" title="相比广告营销，口口相传更有效，分享能让我们感觉良好，因为他会让我们显得高大上。我们更愿意与人分享能提升个人形象的信息。"></a>相比广告营销，口口相传更有效，分享能让我们感觉良好，因为他会让我们显得高大上。我们更愿意与人分享能提升个人形象的信息。</h2><h2 id="某些产品，思想或行为，经常出现在我们眼前时，他们的影响力和传染力就会大大增加。"><a href="#某些产品，思想或行为，经常出现在我们眼前时，他们的影响力和传染力就会大大增加。" class="headerlink" title="某些产品，思想或行为，经常出现在我们眼前时，他们的影响力和传染力就会大大增加。"></a>某些产品，思想或行为，经常出现在我们眼前时，他们的影响力和传染力就会大大增加。</h2><h2 id="从古至今，故事一直都是人们分享信息的重要工具。"><a href="#从古至今，故事一直都是人们分享信息的重要工具。" class="headerlink" title="从古至今，故事一直都是人们分享信息的重要工具。"></a>从古至今，故事一直都是人们分享信息的重要工具。</h2><h2 id="诱因，让人产生联想，看到这个，就会想到那个。"><a href="#诱因，让人产生联想，看到这个，就会想到那个。" class="headerlink" title="诱因，让人产生联想，看到这个，就会想到那个。"></a>诱因，让人产生联想，看到这个，就会想到那个。</h2><h2 id="打折规则，100元以上，降价多少元，以下为打几折。"><a href="#打折规则，100元以上，降价多少元，以下为打几折。" class="headerlink" title="打折规则，100元以上，降价多少元，以下为打几折。"></a>打折规则，100元以上，降价多少元，以下为打几折。</h2><h2><br>&emsp;&emsp;那么如何打造-个疯传的产品呢?第一，让你的产品成为一种社交货币，也就是说人们会通过分享它来赢得别人的好感和兴趣;第二，要利用诱因引发消费者的联想;第三，要带动消费者的情绪，让他们不断频繁地分享;第四，让你的产品尽可能出现在大家眼前，让人们不看都不行;第五，记得，简单实用的东西自然会受人欢迎;最后，帮你的产品量身打造一一个足够有意思的故事。<br><br>&emsp;&emsp;两个可行的建议。首先，可以让你的产品带上点竞争元素。就是说利用人们的游戏心理，大家在玩游戏的时候都喜欢跟别人比赛，获得胜利之后，会得意地和别人分享自己的战绩，同时也就相当于告诉了别人某个产品。所以，如果你的产品有了游戏元素，就能鼓励消费者用你的产品进行某种互动，这样就提高了产品被分享的可能。<br></h2>]]></content:encoded>
      
      <comments>https://shulu520.com/book-note/book-fengchuan/#disqus_thread</comments>
    </item>
    
    <item>
      <title>search-skills</title>
      <link>https://shulu520.com/search/search-skills/</link>
      <guid>https://shulu520.com/search/search-skills/</guid>
      <pubDate>Tue, 30 Apr 2019 16:50:45 GMT</pubDate>
      <description>
      
        &lt;hr&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<hr><hr><a id="more"></a><h2 id="口语转变为关键词"><a href="#口语转变为关键词" class="headerlink" title="口语转变为关键词"></a>口语转变为关键词</h2><ul><li>关键词之间打上空格</li></ul><h2 id="限定在特定网站内"><a href="#限定在特定网站内" class="headerlink" title="限定在特定网站内"></a>限定在特定网站内</h2><ul><li>关键词 site:某一站点</li><li>注意：站点前不用加www或http</li></ul><h2 id="限定文件类型"><a href="#限定文件类型" class="headerlink" title="限定文件类型"></a>限定文件类型</h2><ul><li>关键词 filetype:文件格式</li></ul><h2 id="限定时间段"><a href="#限定时间段" class="headerlink" title="限定时间段"></a>限定时间段</h2><ul><li>关键词 20xx..20xx</li><li>注意：中间是两个英文句号</li></ul><h2 id="排除某个关键词"><a href="#排除某个关键词" class="headerlink" title="排除某个关键词"></a>排除某个关键词</h2><ul><li>关键词 -广告 -推广</li></ul><h2 id="将关键词限定在标题中"><a href="#将关键词限定在标题中" class="headerlink" title="将关键词限定在标题中"></a>将关键词限定在标题中</h2><ul><li>关键词 intitle:限定内容</li></ul><p>## </p>]]></content:encoded>
      
      <comments>https://shulu520.com/search/search-skills/#disqus_thread</comments>
    </item>
    
    <item>
      <title>git-liao-note</title>
      <link>https://shulu520.com/git/git-liao-note/</link>
      <guid>https://shulu520.com/git/git-liao-note/</guid>
      <pubDate>Tue, 30 Apr 2019 16:50:45 GMT</pubDate>
      <description>
      
        廖雪峰老师的git教程学习笔记总结
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;人是不能闲的，一闲就会想得太多，一闲就会感情泛滥，所谓矫情屁事多，空虚寂寞冷，都是因为懒散寂寞闲。</p><hr><a id="more"></a><p>git 的优秀之处 它跟踪并管理的是文件的修改，而非文件。<br>Git有不少命令中有“-”，有时候是“-”，有时候是“–”。<br>学过linux的命令行就懂了，单个”-“ 后面跟的是单个字母的参数，如-m， 两个”–”后面跟的是多个字母的参数，如–readme.txt  在大多数情况下成立的。<br>注意:我的博客页面上显示的效果都只有一个’-‘,若’-‘线条显示的比较细，则表示两个’-‘</p><h1 id="创建本地版本库"><a href="#创建本地版本库" class="headerlink" title="创建本地版本库"></a>创建本地版本库</h1><h2 id="cd-到目录文件夹下"><a href="#cd-到目录文件夹下" class="headerlink" title="cd 到目录文件夹下"></a>cd 到目录文件夹下</h2><h2 id="mkdir-learn-git-新建文件夹，即版本库（repository）"><a href="#mkdir-learn-git-新建文件夹，即版本库（repository）" class="headerlink" title="mkdir learn-git  新建文件夹，即版本库（repository）"></a>mkdir learn-git  新建文件夹，即版本库（repository）</h2><h2 id="git-init-初始化版本库-即把这个目录变成git-可以管理的仓库"><a href="#git-init-初始化版本库-即把这个目录变成git-可以管理的仓库" class="headerlink" title="git init  初始化版本库,即把这个目录变成git 可以管理的仓库"></a>git init  初始化版本库,即把这个目录变成git 可以管理的仓库</h2><h2 id="ctrl-l-清屏，以防代码太多看着难受"><a href="#ctrl-l-清屏，以防代码太多看着难受" class="headerlink" title="ctrl + l  清屏，以防代码太多看着难受"></a>ctrl + l  清屏，以防代码太多看着难受</h2><h2 id="ls-查看目录下的文件"><a href="#ls-查看目录下的文件" class="headerlink" title="ls 查看目录下的文件"></a>ls 查看目录下的文件</h2><h2 id="ls-a-查看不可见的文件"><a href="#ls-a-查看不可见的文件" class="headerlink" title="ls -a 查看不可见的文件"></a>ls -a 查看不可见的文件</h2><h2 id="touch-git-test-txt-创建-txt文件-或者用vscode编辑器创建，别用windows-自带的记事本，因为记事本在编码方面有弱智的行为，"><a href="#touch-git-test-txt-创建-txt文件-或者用vscode编辑器创建，别用windows-自带的记事本，因为记事本在编码方面有弱智的行为，" class="headerlink" title="touch git-test.txt 创建 txt文件 或者用vscode编辑器创建，别用windows 自带的记事本，因为记事本在编码方面有弱智的行为，"></a>touch git-test.txt 创建 txt文件 或者用vscode编辑器创建，别用windows 自带的记事本，因为记事本在编码方面有弱智的行为，</h2><h2 id="键盘上的上键-返回上一步命令"><a href="#键盘上的上键-返回上一步命令" class="headerlink" title="键盘上的上键  返回上一步命令"></a>键盘上的上键  返回上一步命令</h2><h2 id="git-add-git-test-txt-添加要提交的文件，可多次添加多个文件，将文件添加到暂存区（stage即阶段的意思）"><a href="#git-add-git-test-txt-添加要提交的文件，可多次添加多个文件，将文件添加到暂存区（stage即阶段的意思）" class="headerlink" title="git add  git-test.txt 添加要提交的文件，可多次添加多个文件，将文件添加到暂存区（stage即阶段的意思）"></a>git add  git-test.txt 添加要提交的文件，可多次添加多个文件，将文件添加到暂存区（stage即阶段的意思）</h2><h2 id="git-commit-m-“添加描述内容，如-这是第一次使用commit提交”-可以一次提交多个文件，默认提交到master-分支"><a href="#git-commit-m-“添加描述内容，如-这是第一次使用commit提交”-可以一次提交多个文件，默认提交到master-分支" class="headerlink" title="git commit -m “添加描述内容，如 这是第一次使用commit提交”   可以一次提交多个文件，默认提交到master 分支"></a>git commit -m “添加描述内容，如 这是第一次使用commit提交”   可以一次提交多个文件，默认提交到master 分支</h2><h1 id="时光穿梭机"><a href="#时光穿梭机" class="headerlink" title="时光穿梭机"></a>时光穿梭机</h1><h2 id="git-status-查看仓库当前的状态"><a href="#git-status-查看仓库当前的状态" class="headerlink" title="git status 查看仓库当前的状态"></a>git status 查看仓库当前的状态</h2><h2 id="git-diff-查看文件的具体修改的内容-输出变化前后的内容"><a href="#git-diff-查看文件的具体修改的内容-输出变化前后的内容" class="headerlink" title="git diff  查看文件的具体修改的内容 输出变化前后的内容"></a>git diff  查看文件的具体修改的内容 输出变化前后的内容</h2><h2 id="git-log-显示从最近到最远的提交日志"><a href="#git-log-显示从最近到最远的提交日志" class="headerlink" title="git log 显示从最近到最远的提交日志"></a>git log 显示从最近到最远的提交日志</h2><h2 id="git-reset-–hard-HEAD-回退到上一个版本，HEAD表示当前版本，HEAD-即上一个版本，往上100个版本为HEAD-100"><a href="#git-reset-–hard-HEAD-回退到上一个版本，HEAD表示当前版本，HEAD-即上一个版本，往上100个版本为HEAD-100" class="headerlink" title="git reset –hard HEAD^  回退到上一个版本，HEAD表示当前版本，HEAD^即上一个版本，往上100个版本为HEAD~100"></a>git reset –hard HEAD^  回退到上一个版本，HEAD表示当前版本，HEAD^即上一个版本，往上100个版本为HEAD~100</h2><h2 id="git-reflog-用来记录我们的每一次命令即commit-的id"><a href="#git-reflog-用来记录我们的每一次命令即commit-的id" class="headerlink" title="git reflog 用来记录我们的每一次命令即commit 的id"></a>git reflog 用来记录我们的每一次命令即commit 的id</h2><h2 id="git-reset-–hard-commit-id-commit-id-为某一版本提交的具体ID"><a href="#git-reset-–hard-commit-id-commit-id-为某一版本提交的具体ID" class="headerlink" title="git reset –hard  commit_id      commit_id 为某一版本提交的具体ID"></a>git reset –hard  commit_id      commit_id 为某一版本提交的具体ID</h2><h2 id="名词解释说明"><a href="#名词解释说明" class="headerlink" title="名词解释说明"></a>名词解释说明</h2><ul><li><p>工作区： 即我们电脑上的项目文件夹，<br>版本库 ：即工作区里面的一个叫 .git 的隐藏目录，版本库里面有暂存区，有git 为我们创建的master 分支，以及指向master的一个指针HEAD</p><h2 id="管理修改-每次修改，如果不用git-add-到暂存区，就不会加入到commit-中"><a href="#管理修改-每次修改，如果不用git-add-到暂存区，就不会加入到commit-中" class="headerlink" title="管理修改  每次修改，如果不用git add 到暂存区，就不会加入到commit 中"></a>管理修改  每次修改，如果不用git add 到暂存区，就不会加入到commit 中</h2><h2 id="git-checkout-–-git-test-txt-让这个文件回到最近一次git-commit-或-git-add-时的状态，注意–是单独的即后面有空格-，git-checkout-使用版本库里面的版本替换工作区的版本-，无论工作区是修改还是删除，都可以一键还原。-我测试时为什么不行呢"><a href="#git-checkout-–-git-test-txt-让这个文件回到最近一次git-commit-或-git-add-时的状态，注意–是单独的即后面有空格-，git-checkout-使用版本库里面的版本替换工作区的版本-，无论工作区是修改还是删除，都可以一键还原。-我测试时为什么不行呢" class="headerlink" title="git checkout –  git-test.txt 让这个文件回到最近一次git commit 或 git add 时的状态，注意–是单独的即后面有空格 ，git checkout 使用版本库里面的版本替换工作区的版本 ，无论工作区是修改还是删除，都可以一键还原。  我测试时为什么不行呢"></a>git checkout –  git-test.txt 让这个文件回到最近一次git commit 或 git add 时的状态，注意–是单独的即后面有空格 ，git checkout 使用版本库里面的版本替换工作区的版本 ，无论工作区是修改还是删除，都可以一键还原。  我测试时为什么不行呢</h2><h2 id="cat-git-test-txt-查看文件的内容"><a href="#cat-git-test-txt-查看文件的内容" class="headerlink" title="cat  git-test.txt  查看文件的内容"></a>cat  git-test.txt  查看文件的内容</h2></li></ul><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="github-上创建一个仓库就行了，最好与本地仓库同名"><a href="#github-上创建一个仓库就行了，最好与本地仓库同名" class="headerlink" title="github 上创建一个仓库就行了，最好与本地仓库同名"></a>github 上创建一个仓库就行了，最好与本地仓库同名</h2><h2 id="根据提示：将本地仓库与远程仓库关联并推送到远程"><a href="#根据提示：将本地仓库与远程仓库关联并推送到远程" class="headerlink" title="根据提示：将本地仓库与远程仓库关联并推送到远程"></a>根据提示：将本地仓库与远程仓库关联并推送到远程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">…or push an existing repository from the command line</span><br><span class="line">git remote add origin https://github.com/lqyasl/learn-git.git (关联)</span><br><span class="line">git push -u origin master  (本地推送到远程)</span><br></pre></td></tr></table></figure><h2 id="把本地库的内容推送到远程，用git-push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。"><a href="#把本地库的内容推送到远程，用git-push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。" class="headerlink" title="把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。"></a>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</h2><h2 id="一个项目库第一次推送成功后，后面-只要本地做了提交，就可以-git-push-origin-master-不用加参数-u"><a href="#一个项目库第一次推送成功后，后面-只要本地做了提交，就可以-git-push-origin-master-不用加参数-u" class="headerlink" title="一个项目库第一次推送成功后，后面 只要本地做了提交，就可以 git push origin master 不用加参数-u"></a>一个项目库第一次推送成功后，后面 只要本地做了提交，就可以 git push origin master 不用加参数-u</h2><h2 id="分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了。"><a href="#分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了。" class="headerlink" title="分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了。"></a>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了。</h2><h2 id="前面是先有本地仓库，再有远程库。如何关联远程库。现在，最好的方式是，先创建远程库，再从远程库里面克隆到本地。"><a href="#前面是先有本地仓库，再有远程库。如何关联远程库。现在，最好的方式是，先创建远程库，再从远程库里面克隆到本地。" class="headerlink" title="前面是先有本地仓库，再有远程库。如何关联远程库。现在，最好的方式是，先创建远程库，再从远程库里面克隆到本地。"></a>前面是先有本地仓库，再有远程库。如何关联远程库。现在，最好的方式是，先创建远程库，再从远程库里面克隆到本地。</h2><h2 id="首先在github上创建一个-仓库-并勾选Initialize-this-repository-with-a-README，这样GitHub会自动为我们创建一个README-md文件。我这里创建了一个gitskills的库。"><a href="#首先在github上创建一个-仓库-并勾选Initialize-this-repository-with-a-README，这样GitHub会自动为我们创建一个README-md文件。我这里创建了一个gitskills的库。" class="headerlink" title="首先在github上创建一个 仓库 并勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。我这里创建了一个gitskills的库。"></a>首先在github上创建一个 仓库 并勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。我这里创建了一个gitskills的库。</h2><h2 id="git-clone-git-github-com-lqyasl-gitskills-git-或-git-clone-https-github-com-lqyasl-gitskills-git-等多种方式，-推荐使用前一种，其速度最快。"><a href="#git-clone-git-github-com-lqyasl-gitskills-git-或-git-clone-https-github-com-lqyasl-gitskills-git-等多种方式，-推荐使用前一种，其速度最快。" class="headerlink" title="git clone git@github.com:lqyasl/gitskills.git 或 git clone https://github.com/lqyasl/gitskills.git  等多种方式， 推荐使用前一种，其速度最快。"></a>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:lqyasl/gitskills.git 或 git clone <a href="https://github.com/lqyasl/gitskills.git" target="_blank" rel="noopener">https://github.com/lqyasl/gitskills.git</a>  等多种方式， 推荐使用前一种，其速度最快。</h2><h2 id="cd-gitskills-进入克隆的库"><a href="#cd-gitskills-进入克隆的库" class="headerlink" title="cd gitskills  进入克隆的库"></a>cd gitskills  进入克隆的库</h2><h2 id="ls-展开文件列表-可以看到已经有一叫README-md-的文件了"><a href="#ls-展开文件列表-可以看到已经有一叫README-md-的文件了" class="headerlink" title="ls 展开文件列表 可以看到已经有一叫README.md 的文件了"></a>ls 展开文件列表 可以看到已经有一叫README.md 的文件了</h2><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h3 id="分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50-的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。-与其他svn-版本控制系统相比，-git-超级快。每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。"><a href="#分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50-的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。-与其他svn-版本控制系统相比，-git-超级快。每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。" class="headerlink" title="分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 与其他svn 版本控制系统相比， git 超级快。每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。"></a>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 与其他svn 版本控制系统相比， git 超级快。每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</h3><h3 id="一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点。每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。"><a href="#一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点。每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。" class="headerlink" title="一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点。每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。"></a>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点。每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。</h3><h3 id="当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上。"><a href="#当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上。" class="headerlink" title="当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上。"></a>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上。</h3><h3 id="从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变。"><a href="#从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变。" class="headerlink" title="从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变。"></a>从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变。</h3><h3 id="假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并。"><a href="#假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并。" class="headerlink" title="假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并。"></a>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并。</h3><h3 id="合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。"><a href="#合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。" class="headerlink" title="合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。"></a>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。</h3><h2 id="实战部分"><a href="#实战部分" class="headerlink" title="实战部分"></a>实战部分</h2><h2 id="git-checkout-b-dev-创建dev分支，然后切换到dev分支：-这里git-checkout命令加上-b参数表示创建一个分支并切换到这个分支。-checkout这里表示切换的意思。"><a href="#git-checkout-b-dev-创建dev分支，然后切换到dev分支：-这里git-checkout命令加上-b参数表示创建一个分支并切换到这个分支。-checkout这里表示切换的意思。" class="headerlink" title="git checkout -b dev 创建dev分支，然后切换到dev分支： 这里git checkout命令加上-b参数表示创建一个分支并切换到这个分支。 checkout这里表示切换的意思。"></a>git checkout -b dev 创建dev分支，然后切换到dev分支： 这里git checkout命令加上-b参数表示创建一个分支并切换到这个分支。 checkout这里表示切换的意思。</h2><h2 id="git-branch-查看当前分支，git-branch命令会列出所有分支，当前分支前面会标一个-号。"><a href="#git-branch-查看当前分支，git-branch命令会列出所有分支，当前分支前面会标一个-号。" class="headerlink" title="git branch  查看当前分支，git branch命令会列出所有分支，当前分支前面会标一个*号。"></a>git branch  查看当前分支，git branch命令会列出所有分支，当前分支前面会标一个*号。</h2><h2 id="对README-md-文件做修改，比如加一点内容。"><a href="#对README-md-文件做修改，比如加一点内容。" class="headerlink" title="对README.md 文件做修改，比如加一点内容。"></a>对README.md 文件做修改，比如加一点内容。</h2><h2 id="然后-git-add-README-md-以及-git-commit-m-‘分支测试’-，我们就可以在dev分支上正常提交"><a href="#然后-git-add-README-md-以及-git-commit-m-‘分支测试’-，我们就可以在dev分支上正常提交" class="headerlink" title="然后 git add README.md  以及 git commit -m ‘分支测试’   ，我们就可以在dev分支上正常提交"></a>然后 git add README.md  以及 git commit -m ‘分支测试’   ，我们就可以在dev分支上正常提交</h2><h2 id="现在，dev分支的工作完成，我们就可以切换回master分支-git-checkout-master"><a href="#现在，dev分支的工作完成，我们就可以切换回master分支-git-checkout-master" class="headerlink" title="现在，dev分支的工作完成，我们就可以切换回master分支  git checkout master"></a>现在，dev分支的工作完成，我们就可以切换回master分支  git checkout master</h2><h2 id="现在，我们把dev分支的工作成果合并到master分支上-git-merge-dev-这里git-merge命令用于合并指定分支到当前分支。"><a href="#现在，我们把dev分支的工作成果合并到master分支上-git-merge-dev-这里git-merge命令用于合并指定分支到当前分支。" class="headerlink" title="现在，我们把dev分支的工作成果合并到master分支上   git merge dev  这里git merge命令用于合并指定分支到当前分支。"></a>现在，我们把dev分支的工作成果合并到master分支上   git merge dev  这里git merge命令用于合并指定分支到当前分支。</h2><h2 id="注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。"><a href="#注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。" class="headerlink" title="注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。"></a>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</h2><h2 id="合并完成后，就可以放心地删除dev分支了。-git-branch-d-dev"><a href="#合并完成后，就可以放心地删除dev分支了。-git-branch-d-dev" class="headerlink" title="合并完成后，就可以放心地删除dev分支了。 git branch -d dev"></a>合并完成后，就可以放心地删除dev分支了。 git branch -d dev</h2><h2 id="因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。"><a href="#因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。" class="headerlink" title="因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。"></a>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</h2><h2 id="gti-branch-查看分支，可以看到只剩下一个master主分支了。"><a href="#gti-branch-查看分支，可以看到只剩下一个master主分支了。" class="headerlink" title="gti branch  查看分支，可以看到只剩下一个master主分支了。"></a>gti branch  查看分支，可以看到只剩下一个master主分支了。</h2><h2 id="创建分支与合并小结"><a href="#创建分支与合并小结" class="headerlink" title="创建分支与合并小结"></a>创建分支与合并小结</h2><ul><li><p>Git鼓励大量使用分支：</p></li><li><p>查看分支：git branch</p></li><li><p>创建分支：git branch <name></name></p></li><li><p>切换分支：git checkout <name></name></p></li><li><p>创建+切换分支：git checkout -b <name></name></p></li><li><p>合并某分支到当前分支：git merge <name></name></p></li><li><p>删除分支：git branch -d <name></name></p></li></ul><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><h2 id="创建新的feature1分支，继续我们的新分支开发-git-checkout-b-feature1"><a href="#创建新的feature1分支，继续我们的新分支开发-git-checkout-b-feature1" class="headerlink" title="创建新的feature1分支，继续我们的新分支开发 git checkout -b feature1"></a>创建新的feature1分支，继续我们的新分支开发 git checkout -b feature1</h2><h2 id="修改-README-md-文件的内容"><a href="#修改-README-md-文件的内容" class="headerlink" title="修改 README.md 文件的内容"></a>修改 README.md 文件的内容</h2><h2 id="在feature1分支上提交-git-add-README-md-以及-git-commit-m-‘AND-simple’"><a href="#在feature1分支上提交-git-add-README-md-以及-git-commit-m-‘AND-simple’" class="headerlink" title="在feature1分支上提交  git add README.md   以及 git commit -m ‘AND simple’"></a>在feature1分支上提交  git add README.md   以及 git commit -m ‘AND simple’</h2><h2 id="切换到master分支-git-checkout-master"><a href="#切换到master分支-git-checkout-master" class="headerlink" title="切换到master分支  git checkout master"></a>切换到master分支  git checkout master</h2><h2 id="Git还会自动提示我们当前master分支比远程的master分支要超前1个提交"><a href="#Git还会自动提示我们当前master分支比远程的master分支要超前1个提交" class="headerlink" title="Git还会自动提示我们当前master分支比远程的master分支要超前1个提交"></a>Git还会自动提示我们当前master分支比远程的master分支要超前1个提交</h2><h2 id="在master分支上把readme-txt文件的最后一行改为：Creating-a-new-branch-is-quick-amp-simple"><a href="#在master分支上把readme-txt文件的最后一行改为：Creating-a-new-branch-is-quick-amp-simple" class="headerlink" title="在master分支上把readme.txt文件的最后一行改为：Creating a new branch is quick &amp; simple."></a>在master分支上把readme.txt文件的最后一行改为：Creating a new branch is quick &amp; simple.</h2><h2 id="提交README-md-文件"><a href="#提交README-md-文件" class="headerlink" title="提交README.md 文件"></a>提交README.md 文件</h2><h2 id="现在，master分支和feature1分支各自都分别有新的提交"><a href="#现在，master分支和feature1分支各自都分别有新的提交" class="headerlink" title="现在，master分支和feature1分支各自都分别有新的提交"></a>现在，master分支和feature1分支各自都分别有新的提交</h2><h2 id="这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看-gti-merge-feature1-结果显示：-Automatic-merge-failed-fix-conflicts-and-then-commit-the-result"><a href="#这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看-gti-merge-feature1-结果显示：-Automatic-merge-failed-fix-conflicts-and-then-commit-the-result" class="headerlink" title="这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看 gti merge feature1  结果显示： Automatic merge failed; fix conflicts and then commit the result."></a>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看 gti merge feature1  结果显示： Automatic merge failed; fix conflicts and then commit the result.</h2><h2 id="果然冲突了！Git告诉我们，readme-txt文件存在冲突，必须手动解决冲突后再提交。git-status也可以告诉我们冲突的文件"><a href="#果然冲突了！Git告诉我们，readme-txt文件存在冲突，必须手动解决冲突后再提交。git-status也可以告诉我们冲突的文件" class="headerlink" title="果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件"></a>果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件</h2><h2 id="修改README-md-并提交-解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。"><a href="#修改README-md-并提交-解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。" class="headerlink" title="修改README.md 并提交  解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。"></a>修改README.md 并提交  解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</h2><h2 id="最后，删除feature1分支：-git-branch-d-feature1"><a href="#最后，删除feature1分支：-git-branch-d-feature1" class="headerlink" title="最后，删除feature1分支：  git branch -d feature1"></a>最后，删除feature1分支：  git branch -d feature1</h2><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><h2 id="通常，合并分支时，如果可能，Git会用Fast-forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast-forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。下面我们实战一下–no-ff方式的git-merge："><a href="#通常，合并分支时，如果可能，Git会用Fast-forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast-forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。下面我们实战一下–no-ff方式的git-merge：" class="headerlink" title="通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。下面我们实战一下–no-ff方式的git merge："></a>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。下面我们实战一下–no-ff方式的git merge：</h2><h2 id="首先，仍然创建并切换dev分支：git-checkout-b-dev"><a href="#首先，仍然创建并切换dev分支：git-checkout-b-dev" class="headerlink" title="首先，仍然创建并切换dev分支：git checkout -b dev"></a>首先，仍然创建并切换dev分支：git checkout -b dev</h2><p>## </p><hr><p>&emsp;&emsp;今晚到此为止，明天再写。</p><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/git/git-liao-note/#disqus_thread</comments>
    </item>
    
    <item>
      <title>win-vscode-hotkey</title>
      <link>https://shulu520.com/win-vscode/win-vscode-hotkey/</link>
      <guid>https://shulu520.com/win-vscode/win-vscode-hotkey/</guid>
      <pubDate>Tue, 30 Apr 2019 16:50:45 GMT</pubDate>
      <description>
      
        windows操作系统，vscode代码编辑器 常见的几种快捷键，及常见用法。
      
      </description>
      
      <content:encoded><![CDATA[<center>引言：如果你想要个和现在不同的人生，就必须去做你从未做过的事情。努力之后最坏的结果是失败，但不尝试的结果则是无止境的懊悔、怀疑和平庸。</center><br><a id="more"></a><br><br>## windows 最常用快捷键<br>+ ctrl  w  关闭当前网页<br><br>+ f2键 ：选中后按f2键即可重命名文件，另一种方法，点一下文件名，稍等，再点一下，即可重命名<br><br>+ f4: 重复上步操作<br><br>+ f5: 刷新桌面 刷新网页<br><br>+ f11: 全屏显示网页<br><br>+ shift :<br>    省略号    shift + 数字6  （表示六个点）    ……<br><br>    书名号     shift + &lt;&gt;   (小于大于）<br><br>+ 分隔号   单独按 数字1 前面的键    《简 · 爱》<br><br>+ Alt + 单击拖动  为矩形选择<br><br>+ AlT + f4 关闭当前程序<br><br>+ 删除  选中后 按delete<br>+ 永久删除  选中后  shift +delete<br><br>+ 截屏   PrtSc     截全屏<br>    Alt  +PrtSc  截当前窗口<br><br>+ ctrl alt delete 任务管理器<br><br>+ windows 打开开始菜单<br><br>+ ctrl shift n  新建文件夹<br><br>+ window e 打开文件资源管理器<br><br>+ alt tab 切换窗口<br><br>+ window d 回到桌面<br><br>## vscode 常用快捷键<br><br>+ 上下移动一行： Alt+Up 或 Alt+Down<br><br>+ 向上或向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down<br><br>+ 同时选中所有匹配： Ctrl+Shift+L<br><br>+ Ctrl+D 下一个匹配的也被选中<br><br>+ Alt + 单击  ：插入光标<br><br>+ Ctrl + F2    选择当前字的所有出现<br><br>+ ctrl  shift  k   删除整行<br><br>+ ctrl  shift  a   多行注释<br><br>+ ctrl  f     当前文件内搜索相关代码，终于找到这个功能了，哈哈，右上角会有弹框，其中有前后箭头，表示搜索的代码上一次、下一次出现的位置，点击直接会跳转到相应的位置，并且侧边上有相应的位置标识。<br><br>+ ctrl - 整体缩小<br><br>+ ctrl = 整体放大<br><br>+ 文件/首选项/设置 搜索zoom 根据配置 可以更精细的对大小进行操作 ctrl 加滚轮<br><center>后记：快捷键还有很多，学到了再来补充</center>]]></content:encoded>
      
      <comments>https://shulu520.com/win-vscode/win-vscode-hotkey/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Math-random</title>
      <link>https://shulu520.com/Math/Math-random/</link>
      <guid>https://shulu520.com/Math/Math-random/</guid>
      <pubDate>Tue, 30 Apr 2019 16:50:45 GMT</pubDate>
      <description>
      
        js常见的几种随机数，及常见用法。
      
      </description>
      
      <content:encoded><![CDATA[<center>引言：希望你睡不着时，想起的都是那些让你开心的事</center>                <p></p><h3 style="color:blue">常见的问题：如何生成一个区间[min,max]内的随机整数？</h3><br>答案很简单，即 <code>Math.random()*(max-min)+min</code><p></p><p>以下是一些其他的方法。<br><a id="more"></a></p><h2 id="new-Date-0"><a href="#new-Date-0" class="headerlink" title="new Date() - 0"></a>new Date() - 0</h2><ul><li>new Date() 日期函数 默认会显示年月日等字符，new Date() - 0 会得到数字“秒”</li><li>(new Date() - 0)%2239 ,得到取模数值分之一概率的随机数，即[0,2239]范围内一随机数</li></ul><h2 id="toString-指定进制-方法的调用"><a href="#toString-指定进制-方法的调用" class="headerlink" title="toString(指定进制) 方法的调用"></a>toString(指定进制) 方法的调用</h2><ul><li>与parseInt() 方法一样，进制区间为 [2,36]，取36得字母多一些</li><li>随便一个随机数.toString(36)得随机字符，但有数字，且长短不一</li></ul><h2 id="随机字符串函数，长度固定，且都是字母"><a href="#随机字符串函数，长度固定，且都是字母" class="headerlink" title="随机字符串函数，长度固定，且都是字母"></a>随机字符串函数，长度固定，且都是字母</h2><ul><li>从固定的字典中抽取字符构成随机字符串</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 在大小写字母之间随机生成 x 个字符</span><br><span class="line">function randStr(x)&#123;</span><br><span class="line">    var s = &apos;&apos;;</span><br><span class="line">    while(s.length &lt; x &amp;&amp; x &gt; 0)&#123;</span><br><span class="line">        var r = Math.random();</span><br><span class="line">        s += String.fromCharCode(Math.floor(r*26) + (r &gt; 0.5 ? 97 : 65))</span><br><span class="line">    &#125;;</span><br><span class="line">    return s;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(randStr(3)); //KzE 三个随机字符</span><br></pre></td></tr></table></figure><h2 id="颜色随机函数"><a href="#颜色随机函数" class="headerlink" title="颜色随机函数"></a>颜色随机函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function randomColor()&#123;  </span><br><span class="line">    var rand = &apos;#&apos;+(&apos;00000&apos;+(Math.random()*0x1000000&lt;&lt;0).toString(16)).slice(-6);</span><br><span class="line">    return rand;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>随机数相关得知识还又有很多，后面学到了再来补充笔记</li></ul>]]></content:encoded>
      
      <comments>https://shulu520.com/Math/Math-random/#disqus_thread</comments>
    </item>
    
    <item>
      <title>vue-source</title>
      <link>https://shulu520.com/vue-source/vue-source/</link>
      <guid>https://shulu520.com/vue-source/vue-source/</guid>
      <pubDate>Tue, 30 Apr 2019 10:49:43 GMT</pubDate>
      <description>
      
        vue 源码分析学习笔记
      
      </description>
      
      <content:encoded><![CDATA[<center>引言：read the fucking source code</center>                <a id="more"></a><h2 id="vue-源码分析知识点分析-vue-作为一个-MVVM-框架的基本实现原理"><a href="#vue-源码分析知识点分析-vue-作为一个-MVVM-框架的基本实现原理" class="headerlink" title="vue 源码分析知识点分析 vue 作为一个 MVVM 框架的基本实现原理"></a>vue 源码分析知识点分析 vue 作为一个 MVVM 框架的基本实现原理</h2><h2 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h2><ul><li>1  [].slice.call(lis): 将伪数组转换为真数组</li><li>slice 方法有浅拷贝的用法，表示截取一部分，不传参数的话就是拷贝原数组</li><li><em>这样更好</em> Array.prototype.slice.call(lis)</li><li>2  node.nodeType: 得到节点类型</li><li>节点类型：常用的<ul><li>document // 文档</li><li>Element //元素节点    节点类型 nodeType === 1;</li><li>Attr //属性</li><li>Text //文本</li><li>documentFragment // 文档碎片</li></ul></li></ul><ul><li>3 Object.defineProperty(obj, propName, {}):<ul><li>给对象添加/修改属性(指定描述符)</li><li>vue <em>数据代理的核心语法</em>，不支持ie8，面试题</li></ul></li><li>属性描述符：</li><li>数据描述符：<ul><li>configurable: true/false 是否可以重新 define</li><li>enumerable: true/false 是否可以枚举(for..in / keys())</li><li>value: 指定初始值</li><li>writable: true/false value 是否可以修改</li></ul></li><li>访问描述符：vue的<code>计算属性</code>就是利用get set 方法<ul><li>get: 回调函数, 根据其他相关的属性动态计算得到当前属性值，根据相关的属性更新（得到）当前的属性</li><li>set: 回调函数, <code>监视</code>当前属性值的变化，更新相关的属性值 ，根据当前的属性更新相关的属性 </li></ul></li><li>Object.keys(obj): 得到对象自身<code>可枚举</code>的属性名的数组</li><li>obj.hasOwnProperty(prop): 判断 prop 是否是 obj 自身的属性</li><li>DocumentFragment: <code>文档碎片</code>(高效批量更新多个节点)</li><li><p>传言啊  这个 childNodes是正统属性   亲生的  而这个children是野孩子   </p></li><li><p>这个野孩子比较随意   所以用它返回来的就只有DOM元素了  其他的文字啥的   都不返回   </p></li><li><p>而 childNodes比较讲究   事无巨细  都要返回来   </p></li><li><p>但是我还是觉得野孩子乖 所以也获得了几乎所有浏览器的支持 如果你想要DOM节点  直接用野孩子就可以了 </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">&lt;li&gt;test1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;test2&lt;/li&gt;</span><br><span class="line">&lt;li&gt;test3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let list = document.getElementById(&quot;list&quot;);</span><br><span class="line">// 1. 创建文档碎片</span><br><span class="line">let fragment = document.createDocumentFragment();</span><br><span class="line"></span><br><span class="line">// 2. 取出ul中 所有 子节点保存到fragment中</span><br><span class="line">//Array.prototype.slice.call(list.children).forEach(element =&gt; &#123;</span><br><span class="line">fragment.appendChild(element);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 3.修改fragment中的每一个子元素的内容</span><br><span class="line">Array.prototype.slice.call(fragment.children).forEach(element =&gt; &#123;</span><br><span class="line">element.textContent = &apos;舒璐&apos;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 4.将文档碎片插入到list中 </span><br><span class="line">list.appendChild(fragment);</span><br></pre></td></tr></table></figure><h2 id="数据代理的实现"><a href="#数据代理的实现" class="headerlink" title="数据代理的实现"></a>数据代理的实现</h2><h2 id="基本实现流程"><a href="#基本实现流程" class="headerlink" title="基本实现流程"></a>基本实现流程</h2><ul><li>通过 Object.defineProperty()给 vm 添加与 data 对象的属性对应的属性描述符</li><li>所有添加的属性都包含 getter/setter</li><li>getter/setter 内部去操作 data 中对应的属性数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">相当于Vue的构造函数</span><br><span class="line"></span><br><span class="line">function MVVM(options) &#123;</span><br><span class="line">  // 将选项对象保存到vm</span><br><span class="line">  this.$options = options;</span><br><span class="line"></span><br><span class="line">  // 将data对象保存到vm和datq变量中</span><br><span class="line">  var data = this._data = this.$options.data;</span><br><span class="line"></span><br><span class="line">  //将vm保存在me变量中</span><br><span class="line">  var me = this;</span><br><span class="line"></span><br><span class="line">  // 遍历data中所有属性</span><br><span class="line">  Object.keys(data).forEach(function (key) &#123; // 属性名: name</span><br><span class="line"></span><br><span class="line">    // 对指定属性实现代理</span><br><span class="line">    me._proxy(key);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 对data进行监视</span><br><span class="line">  observe(data, this);</span><br><span class="line"></span><br><span class="line">  // 创建一个用来编译模板的compile对象</span><br><span class="line">  this.$compile = new Compile(options.el || document.body, this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MVVM.prototype = &#123;</span><br><span class="line">  $watch: function (key, cb, options) &#123;</span><br><span class="line">    new Watcher(this, key, cb);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 对指定属性实现代理</span><br><span class="line">  _proxy: function (key) &#123;</span><br><span class="line">    // 保存vm</span><br><span class="line">    var me = this;</span><br><span class="line">    // 给vm添加指定属性名的属性(使用属性描述)</span><br><span class="line">    Object.defineProperty(me, key, &#123;</span><br><span class="line">      configurable: false, // 不能再重新定义</span><br><span class="line">      enumerable: true, // 可以枚举</span><br><span class="line">      // 当通过vm.name读取属性值时自动调用</span><br><span class="line">      get: function proxyGetter() &#123;</span><br><span class="line">        // 读取data中对应属性值返回(实现代理读操作)</span><br><span class="line">        return me._data[key];</span><br><span class="line">      &#125;,</span><br><span class="line">      // 当通过vm.name = &apos;xxx&apos;时自动调用</span><br><span class="line">      set: function proxySetter(newVal) &#123;</span><br><span class="line">        // 将最新的值保存到data中对应的属性上(实现代理写操作)</span><br><span class="line">        me._data[key] = newVal;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>其中最关键的部分为</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(me, key, &#123;</span><br><span class="line">   configurable: false, // 不能再重新定义</span><br><span class="line">   enumerable: true, // 可以枚举</span><br><span class="line">   // 当通过vm.name读取属性值时自动调用</span><br><span class="line">   get: function proxyGetter() &#123;</span><br><span class="line">     // 读取data中对应属性值返回(实现代理读操作)</span><br><span class="line">     return me._data[key];</span><br><span class="line">   &#125;,</span><br><span class="line">   // 当通过vm.name = &apos;xxx&apos;时自动调用</span><br><span class="line">   set: function proxySetter(newVal) &#123;</span><br><span class="line">     // 将最新的值保存到data中对应的属性上(实现代理写操作)</span><br><span class="line">     me._data[key] = newVal;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h2 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h2><ol><li>嵌套调用: a里面调用b,b里面调用c</li><li>递归: a 里面调用 a ,a继续调用a即特殊的嵌套调用</li><li>模板解析的基本流程</li></ol><ul><li>1)将 el 的所有子节点取出, 添加到一个新建的文档 fragment 对象中</li><li>2)对 fragment 中的<code>所有层次子节点</code>递归进行编译解析处理<ul><li>对大括号表达式文本节点进行解析</li><li>对元素节点的指令属性进行解析</li><li>事件指令解析</li><li>一般指令解析</li></ul></li><li>3) 将解析后的 fragment 添加到 el 中显示</li><li>模板解析(1): 大括号表达式解析<br><code>&lt;p&gt;&lt;/p&gt;</code></li></ul><ul><li>根据正则对象得到匹配出的表达式字符串: 子匹配/RegExp.$1   name</li><li>从 data 中取出表达式对应的属性值</li><li>将属性值设置为文本节点的 textContent</li></ul><ul><li>模板解析(2): 事件指令解析<pre><code>从指令名中取出事件名根据指令的值(表达式)从 methods 中得到对应的事件处理函数对象给当前元素节点绑定指定事件名和回调函数的 dom 事件监听指令解析完后, 移除此指令属性</code></pre></li><li>模板解析(3): 一般指令解析<pre><code>得到指令名和指令值(表达式) text/html/class msg/myClass从 data 中根据表达式得到对应的值根据指令名确定需要操作元素节点的什么属性</code></pre><ul><li>v-text—textContent 属性</li><li>v-html—innerHTML 属性</li><li>v-class–className 属性</li><li>4) 将得到的表达式的值设置到对应的属性上</li><li>5) 移除元素的指令属性</li></ul></li></ul><h2 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call   apply bind"></a>call   apply bind</h2><ul><li>JavaScript 的一大特点是，</li><li>函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念<br>  apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；<br>  apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；<br>  apply 、 call 、bind 三者都可以利用后续参数传参；</li><li>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。</li><li>call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里</li><li>bind()最简单的用法是创建一个函数，使这个函数<code>不论怎么调用都有同样的this值</code>。</li><li>常见的错误就像，将方法从对象中拿出来，然后调用，并且希望this指向原来的对象。</li><li>如果不做特殊处理，一般会丢失原来的对象。用bind方法可以</li></ul><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><ul><li>简单地说，就是数据更新，界面改变。</li><li>一旦更新了 data 中的某个属性数据, 所有界面上直接使用或间接使用了此属性的节点+更新</li><li>数据劫持<br>   数据劫持是 vue 中用来实现数据绑定的一种技术<br>   基本思想: 通过 defineProperty()来监视 data 中所有属性(任意层次)数据的变化, </li><li>一旦变化就去更新界面</li><li>初始化显示：页面（表达式/指令）能从data中读取数据显示（编译/解析）<br> 更新显示：更新data中的属性数据，.&gt;&gt;&gt; 页面更新<br> <img src="/vue-source/vue-source/vuenote/1.jpg" alt><br> 图中黑线表示初始化，红线表示更新时触发</li></ul><h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><ul><li>双向数据绑定是建立在单向数据绑定(model==&gt;View)的基础之上的</li><li>双向数据绑定的实现流程:<br>   在解析 v-model 指令时, 给当前元素添加 input 监听(input事件会在value属性值发生改变时触发，<pre><code>通过js改变value属性值不会触发此事件。只有IE8以上或者谷歌火狐等标准浏览器支持。)</code></pre>   当 input 的 value 发生改变时, 将最新的值赋值给当前表达式所对应的 data 属性</li></ul><h2 id="vuex-是vue-的一个插件"><a href="#vuex-是vue-的一个插件" class="headerlink" title="vuex 是vue 的一个插件"></a>vuex 是vue 的一个插件</h2><ul><li>简单来说: 对 vue 应用中多个组件的共享状态进行集中式的管理(读/写)</li><li><p>状态自管理应用<br>   state: 驱动应用的数据源（data）<br>   view: 以声明方式将 state 映射到视图(模板界面)<br>   actions:（在vue中是函数） 响应在 view 上的用户输入导致的状态变化</p><pre><code>(包含 n 个*更新状态的方法*)![](vuenote/2.jpg)多组件共享状态的问题     多个视图依赖于同一状态     来自不同视图的行为需要变更同一状态     以前的解决办         将数据以及操作数据的行为都定义在父组件         将数据以及操作数据的行为传递给需要的各个子组件(有可能需要多级传递)     vuex 就是用来解决这个问题的vuex 核心概念和 API    state         vuex 管理的状态对象,它应该是唯一的    mutations         包含多个直接更新 state 的方法(回调函数)的对象         谁来触发: action 中的 commit(&apos;mutation 名称&apos;)         只能包含同步的代码, 不能写异步代码    const mutations = {        yyy (state, {data1}) {        // 更新 state 的某个属性        }    }</code></pre></li><li><p>vuex  人生管理哲学，哈哈<br>State:想一想，你现在心里在意哪些事？</p></li><li><p>Mutation目标导向:  写下目标，直接改变State</p></li><li><p>Action阶段性执行： 写下行动 ，执行一个个Matation、异步函数、和其它阶段性执行。</p></li><li><p>Getters: 写下其它指标，根据现有的state得到其他的指标</p></li><li><p>mapState和mapGetters必须在computed中访问，因为它们返回的是对象，所以需要用拓展符…进行展开。</p></li><li><p>mapActions则是将Action挂载到methods上，也需要用拓展符…进行展开。</p></li><li><p>组件中的mapActions([“increment”])与<br>actions 中  increment 函数名一样<br>actions 中  commit(“INCREMENT”)与<br>mutations 中 INCREMENT函数名一样<br>大写的函数名只是为了区分各个函数 可以定义一个mutation-type.js </p></li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1>]]></content:encoded>
      
      <comments>https://shulu520.com/vue-source/vue-source/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>

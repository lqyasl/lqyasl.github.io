<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>梦不成</title>
    <link>https://shulu520.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>君子生非异也，善假于物也.</description>
    <pubDate>Mon, 17 Jun 2019 14:42:54 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>responsive-sites</title>
      <link>https://shulu520.com/responsive-sites/responsive-sites/</link>
      <guid>https://shulu520.com/responsive-sites/responsive-sites/</guid>
      <pubDate>Sun, 16 Jun 2019 11:23:58 GMT</pubDate>
      <description>
      
        慕课网响应式网站教程笔记。
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;梦终有你。</p><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><br><a id="more"></a></p><h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><ul><li>布局视口 就像一本书 大小固定 如960px 是设计图纸的大小</li><li>可视视口 就像放大镜 在它上面可以移动缩放 是设备屏幕的大小<ul><li>在这两种视口下，用户需要通过滑动缩放来查看整个页面的不同部分。</li></ul></li><li>理想视口 为了解决以上的问题而制定的视口。是布局视口在一个设备上的最佳尺寸。即让布局视口等于可视视口。</li></ul><p><a href="https://blog.csdn.net/qq_16339527/article/details/52996316" target="_blank" rel="noopener">大牛博客视口相关说明</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="爬虫协议robots-txt"><a href="#爬虫协议robots-txt" class="headerlink" title="爬虫协议robots.txt"></a>爬虫协议robots.txt</h2><ul><li>把“robots.txt”放在你网站的根目录，并确保他能让访问者（如搜索引擎）访问到。</li><li>Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”，网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: /admin/</span><br><span class="line">Sitemap: https://shulu520.com/sitemap.xml</span><br><span class="line">Sitemap: https://shulu520.com/sitemap.hxml</span><br></pre></td></tr></table></figure><h2 id="关于humans-txt"><a href="#关于humans-txt" class="headerlink" title="关于humans.txt"></a>关于humans.txt</h2><p><a href="http://humanstxt.org/ZH" target="_blank" rel="noopener">humans.txt官网</a></p><h3 id="这是什么？"><a href="#这是什么？" class="headerlink" title="这是什么？"></a>这是什么？</h3><ul><li>这是一个TXT文件，其中包含参加该网页设计和建立的人们的信息。</li></ul><h3 id="为什么是一个TXT？"><a href="#为什么是一个TXT？" class="headerlink" title="为什么是一个TXT？"></a>为什么是一个TXT？</h3><ul><li>这是因为TXT是一种快速和容易建立的档案格式，而且不是一种有侵扰性的格式。</li><li>很多时候业主并不希望作者在为他设计的网站签名，以为这样会降低其功能。</li><li>以我们这种方式可以从外部快速便利、经济实惠的显示证明网站作者（不是指网站的主人）。</li></ul><p><a href="http://humanstxt.org/humans.txt" target="_blank" rel="noopener">humans.txt官网格式</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* TEAM */</span><br><span class="line"></span><br><span class="line">/* THANKS */</span><br><span class="line"></span><br><span class="line">/* SITE */</span><br></pre></td></tr></table></figure><h2 id="项目目录的一些有用的文件"><a href="#项目目录的一些有用的文件" class="headerlink" title="项目目录的一些有用的文件"></a>项目目录的一些有用的文件</h2><ul><li>robots.txt</li><li>humans.txt</li><li>.editorConfig(编辑器风格配置)</li><li>.gitignore</li><li>LICENSE.txt(版权声明，协议是否开源)</li><li>README.md(项目简介 使用方式 相关链接)</li><li>CHANGLOG(说明版本更新相关)</li></ul><h2 id="html页面重要内容"><a href="#html页面重要内容" class="headerlink" title="html页面重要内容"></a>html页面重要内容</h2><ul><li>以前没有注意到的细节知识做一总结。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">网站内的语言为汉语，参考自淘宝网。</span><br><span class="line">&lt;html lang=&apos;zh-CN&apos;&gt;&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">这意味着，会强制浏览器按照最新的标准去渲染。添加”chrome=1“将允许站点在使用了谷歌浏览器内嵌框架（Chrome Frame）的客户端渲染，对于没有使用的，则没有任何影响。</span><br><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;/&gt;</span><br><span class="line"></span><br><span class="line">告诉浏览器启用理想视口来展示页面。不允许用户进行缩放。</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=0&quot; /&gt;</span><br><span class="line"></span><br><span class="line">条件注释：</span><br><span class="line">在body标签下争对IE低版本浏览器的更新提示信息：</span><br><span class="line">  &lt;!--[if lt IE 8]&gt;</span><br><span class="line">  &lt;style&gt;html,body&#123;overflow:hidden;height:100%&#125;&lt;/style&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;您的浏览器版本老的可笑，请到点击下面任一链接更新，以获取最佳的浏览体验。&lt;/p&gt;</span><br><span class="line">    &lt;a href=&quot;https://www.google.cn/intl/zh-CN/chrome/browser/desktop/&quot; &quot; target=&quot;_blank&quot;&gt;谷歌 Chrome&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;http://www.uc.cn/ucbrowser/download/&quot; target=&quot;_blank&quot;&gt;UC 浏览器&lt;/a&gt;&quot;</span><br><span class="line">    &lt;a href=&quot;http://browsehappy.com&quot;&gt;各大浏览器更新网站(外网)</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;![endif]--&gt;</span><br></pre></td></tr></table></figure><h2 id="logo-说明"><a href="#logo-说明" class="headerlink" title="logo 说明"></a>logo 说明</h2><ul><li>像logo这样重要的图片最好以img标签的形式嵌入页面。</li><li>其他的不太重要的图片可以考虑background的形式引入。</li></ul><h2 id="样式重置"><a href="#样式重置" class="headerlink" title="样式重置"></a>样式重置</h2><ul><li>传统css样式重置resets.css 性能不佳</li><li>H5标准的样式重置 GitHub 3万多star</li><li>npm install normalize.css</li></ul><h2 id="css单位"><a href="#css单位" class="headerlink" title="css单位"></a>css单位</h2><ul><li>px 1px=1像素</li></ul><h3 id="em-相对长度单位"><a href="#em-相对长度单位" class="headerlink" title="em 相对长度单位"></a>em 相对长度单位</h3><ul><li>em的相对参照物为 父元素的font-size值</li><li>em 具有继承的特点</li><li>当没有设值时，浏览器的默认em  1em=16px</li><li>em的缺点 容易错乱</li></ul><h3 id="rem-相对长度单位"><a href="#rem-相对长度单位" class="headerlink" title="rem 相对长度单位"></a>rem 相对长度单位</h3><ul><li>参照物为HTML根元素 其固定不变</li><li>计算简单</li><li>没有设值时，浏览器的默认值 1rem=16px</li><li>设置 font-size: 62.5%  那么 </li><li>1rem = 10px</li></ul><h2 id="css3-的一些样式"><a href="#css3-的一些样式" class="headerlink" title="css3 的一些样式"></a>css3 的一些样式</h2><ul><li>文本选中后的样式设置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">::selection &#123;</span><br><span class="line">  background-color: pink;</span><br><span class="line">  text-shadow: none</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>calc的使用例子</li><li>width: calc(33.33333333% - 2rem)</li><li>css3 box-sizing属性<ul><li>border-box，border和padding计算入width之内，其实就是怪异模式了</li></ul></li></ul><h2 id="box-sizing-border-box"><a href="#box-sizing-border-box" class="headerlink" title="box-sizing: border-box"></a>box-sizing: border-box</h2><ul><li>box-sizing:border-box;</li><li>将正常的width height的作用范围延申至border的地方。</li><li>也就是说，对元素指定宽度和高度包括了 padding 和 border 。</li><li>正常的元素宽高给定后，增加padding border他们会往外面阔展大小。</li><li>加了这个属性后，再增加padding border 此时元素内容区会向里面缩进。</li></ul><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><ul><li>当元素设置float浮动后，该元素就会脱离文档流并向左/向右浮动，直到碰到父元素或者另一个浮动元素，浮动元素会造成父元素高度塌陷，所以当我们设置float后，需进行相应的清除浮动操作。</li><li>清除浮动的原理<ul><li>触发BFC</li></ul></li></ul><h3 id="BFC-块级格式化上下文"><a href="#BFC-块级格式化上下文" class="headerlink" title="BFC 块级格式化上下文"></a>BFC 块级格式化上下文</h3><ul><li>一个HTML元素要创建BFC，则满足下列的任意一个或多个条件即可：</li></ul><p>1.float的值不是none。<br>2.position的值不是static或者relative。<br>3.display的值是inline-block、table-cell、flex、table-caption或者inline-flex<br>4.overflow的值不是visible</p><ul><li>BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列</li></ul><h3 id="清除浮动方式一"><a href="#清除浮动方式一" class="headerlink" title="清除浮动方式一"></a>清除浮动方式一</h3><ul><li>使用额外的标签clear:both</li><li>原理：在浮动元素下面添加一个空标签，在这个标签中设置clear：both；</li><li>优点：简单，浏览器兼容性好；</li><li>缺点：增加页面的标签，造成页面混乱；</li></ul><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><ul><li>使用overflow属性</li><li>原理：父元素定义overflow:hidden，此时，浏览器会自动检查浮动区域的高度；</li><li>优点：简单，无需增加新的标签；</li><li>缺点：不能和position配合使用，因为超出的尺寸的会被隐藏</li></ul><h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><ul><li>使用伪元素:after清除浮动</li><li>原理：原理同方法一有点类似，在元素最后定义一个空的内容，然后让该空的内容来清除浮动；</li><li>优点：无需额外的标签，浏览器兼容性好，是目前用的最多的一种清除浮动的方法之一；</li><li>缺点：代码稍微复杂点，初学者可能不太能理解其原理；</li></ul><h3 id="方式四-推荐"><a href="#方式四-推荐" class="headerlink" title="方式四 推荐"></a>方式四 推荐</h3><ul><li>老外大师推荐</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:before,</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line">  content: &apos; &apos;;</span><br><span class="line">  display: table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="line-height-注意事项"><a href="#line-height-注意事项" class="headerlink" title="line-height 注意事项"></a>line-height 注意事项</h2><ul><li>在使用rem 的单位设置时会有点问题</li><li>建议使用px的单位</li></ul><h2 id="diaplay-inline-block-注意事项"><a href="#diaplay-inline-block-注意事项" class="headerlink" title="diaplay: inline-block 注意事项"></a>diaplay: inline-block 注意事项</h2><ul><li>将元素设置为inline-block即行内块元素 多个inline-block元素会排列为一行 对外显示为行内元素 对内为块级元素的特性</li><li><p>带来的问题：</p><ul><li>各个元素间会出现一条小缝隙 即是元素间的空白字符</li><li>两个标签之间看不见的东西</li></ul></li><li><p>解决方法：</p><ul><li>将元素排列为一行</li><li>或去掉元素后面的闭合标签</li><li>将闭合标签放到下一个标签的开头部分</li><li>还有好多种方法</li></ul></li></ul><h2 id="雪碧图的使用"><a href="#雪碧图的使用" class="headerlink" title="雪碧图的使用"></a>雪碧图的使用</h2><ul><li>CSS雪碧 即CSS Sprite，也有人叫它CSS精灵，是一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分</li><li>CSS雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。该图片使用CSS background和background-position属性渲染。</li></ul><h2 id="省略号的设置"><a href="#省略号的设置" class="headerlink" title="省略号的设置"></a>省略号的设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  text-overflow: ellipsis;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  white-space: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div></p><center><img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:skyblue;font-weight:bold;" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">有事您Q我👇</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/responsive-sites/responsive-sites/#disqus_thread</comments>
    </item>
    
    <item>
      <title>express</title>
      <link>https://shulu520.com/express/express/</link>
      <guid>https://shulu520.com/express/express/</guid>
      <pubDate>Wed, 12 Jun 2019 01:34:23 GMT</pubDate>
      <description>
      
        node-express 珠峰教程笔记
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;</p><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><br><a id="more"></a></p><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div></p><center><img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:skyblue;font-weight:bold;" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">有事您Q我👇</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/express/express/#disqus_thread</comments>
    </item>
    
    <item>
      <title>cookie-js</title>
      <link>https://shulu520.com/cookie/cookie-js/</link>
      <guid>https://shulu520.com/cookie/cookie-js/</guid>
      <pubDate>Tue, 11 Jun 2019 15:13:25 GMT</pubDate>
      <description>
      
        cookie的设置/获取/删除封装
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;</p><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><br><a id="more"></a></p><p><a href="https://www.cnblogs.com/libin-1/p/6128903.html" target="_blank" rel="noopener">转载 原文链接</a><br>运用JS设置cookie、读取cookie、删除cookie<br>JavaScript是运行在客户端的脚本，因此一般是不能够设置Session的，因为Session是运行在服务器端的。</p><p>而cookie是运行在客户端的，所以可以用JS来设置cookie. </p><p>假设有这样一种情况，在某个用例流程中，由A页面跳至B页面，若在A页面中采用JS用变量temp保存了某一变量的值，在B页面的时候，同样需要使用JS来引用temp的变量值，对于JS中的全局变量或者静态变量的生命周期是有限的，当发生页面跳转或者页面关闭的时候，这些变量的值会重新载入，即没有达到保存的效果。解决这个问题的最好的方案是采用cookie来保存该变量的值，那么如何来设置和读取cookie呢？ </p><p>首先需要稍微了解一下cookie的结构，简单地说：cookie是以键值对的形式保存的，即key=value的格式。各个cookie之间一般是以“;”分隔。 </p><p>JS设置cookie:</p><p>假设在A页面中要保存变量username的值(“jack”)到cookie中,key值为name，则相应的JS代码为： </p><p>document.cookie=”name=”+username;  </p><p>JS读取cookie:</p><p>假设cookie中存储的内容为：name=jack;password=123</p><p>则在B页面中获取变量username的值的JS代码如下：</p><p>var username=document.cookie.split(“;”)[0].split(“=”)[1];  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">//JS操作cookies方法! </span><br><span class="line"></span><br><span class="line">//写cookies </span><br><span class="line">function setCookie(name, value) &#123;</span><br><span class="line">  var Days = 30;</span><br><span class="line">  var exp = new Date();</span><br><span class="line">  exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 1000);</span><br><span class="line">  document.cookie =</span><br><span class="line">    name + &quot;=&quot; + escape(value) + &quot;;expires=&quot; + exp.toGMTString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//读取cookies</span><br><span class="line">function getCookie(name) &#123;</span><br><span class="line">  var arr,</span><br><span class="line">    reg = new RegExp(&quot;(^| )&quot; + name + &quot;=([^;]*)(;|$)&quot;);</span><br><span class="line"></span><br><span class="line">  if ((arr = document.cookie.match(reg))) return unescape(arr[2]);</span><br><span class="line">  else return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除cookies</span><br><span class="line">function delCookie(name) &#123;</span><br><span class="line">  var exp = new Date();</span><br><span class="line">  exp.setTime(exp.getTime() - 1);</span><br><span class="line">  var cval = getCookie(name);</span><br><span class="line">  if (cval != null)</span><br><span class="line">    document.cookie = name + &quot;=&quot; + cval + &quot;;expires=&quot; + exp.toGMTString();</span><br><span class="line">&#125;</span><br><span class="line">//使用示例</span><br><span class="line">setCookie(&quot;name&quot;, &quot;hayden&quot;);</span><br><span class="line">alert(getCookie(&quot;name&quot;));</span><br><span class="line"></span><br><span class="line">//如果需要设定自定义过期时间</span><br><span class="line">//那么把上面的setCookie　函数换成下面两个函数就ok;</span><br><span class="line"></span><br><span class="line">//程序代码</span><br><span class="line">function setCookie(name, value, time) &#123;</span><br><span class="line">  var strsec = getsec(time);</span><br><span class="line">  var exp = new Date();</span><br><span class="line">  exp.setTime(exp.getTime() + strsec * 1);</span><br><span class="line">  document.cookie =</span><br><span class="line">    name + &quot;=&quot; + escape(value) + &quot;;expires=&quot; + exp.toGMTString();</span><br><span class="line">&#125;</span><br><span class="line">function getsec(str) &#123;</span><br><span class="line">  alert(str);</span><br><span class="line">  var str1 = str.substring(1, str.length) * 1;</span><br><span class="line">  var str2 = str.substring(0, 1);</span><br><span class="line">  if (str2 == &quot;s&quot;) &#123;</span><br><span class="line">    return str1 * 1000;</span><br><span class="line">  &#125; else if (str2 == &quot;h&quot;) &#123;</span><br><span class="line">    return str1 * 60 * 60 * 1000;</span><br><span class="line">  &#125; else if (str2 == &quot;d&quot;) &#123;</span><br><span class="line">    return str1 * 24 * 60 * 60 * 1000;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//这是有设定过期时间的使用示例：</span><br><span class="line">//s20是代表20秒</span><br><span class="line">//h是指小时，如12小时则是：h12</span><br><span class="line">//d是天数，30天则：d30</span><br><span class="line"></span><br><span class="line">setCookie(&quot;name&quot;, &quot;hayden&quot;, &quot;s20&quot;);</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/libin-1/p/6128903.html" target="_blank" rel="noopener">转载 原文链接</a></p><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div></p><center><img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:skyblue;font-weight:bold;" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">有事您Q我👇</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/cookie/cookie-js/#disqus_thread</comments>
    </item>
    
    <item>
      <title>localStorage</title>
      <link>https://shulu520.com/localStorage/localStorage/</link>
      <guid>https://shulu520.com/localStorage/localStorage/</guid>
      <pubDate>Tue, 11 Jun 2019 11:52:59 GMT</pubDate>
      <description>
      
        localStorage本地存贮，珠峰教程笔记
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;</p><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><br><a id="more"></a></p><h2 id="本地存贮"><a href="#本地存贮" class="headerlink" title="本地存贮"></a>本地存贮</h2><ul><li>把一些信息存储到客户端本地</li><li>存储到浏览器指定的地方</li><li>实现多页面之间的信息共享</li></ul><h2 id="本地存贮种类"><a href="#本地存贮种类" class="headerlink" title="本地存贮种类"></a>本地存贮种类</h2><ul><li>(xxx.manifest) 本地缓存   H5中的api</li><li>localStorage H5中的api 小数据的存储 <strong>常用</strong></li><li>indexDB / webSQL 本地数据库存储</li><li>CacheStroge / ApplicationCache</li><li>cookie <strong>常用</strong></li></ul><h2 id="本地存贮使用场景"><a href="#本地存贮使用场景" class="headerlink" title="本地存贮使用场景"></a>本地存贮使用场景</h2><ul><li>页面之间的信息通信</li><li>性能优化</li></ul><h2 id="本地存储信息的局限性"><a href="#本地存储信息的局限性" class="headerlink" title="本地存储信息的局限性"></a>本地存储信息的局限性</h2><ul><li>按照域来管理信息 如访问我的网站 则存储到shulu520.com这个域中</li><li>不能跨浏览器共享 </li><li>不能跨域共享</li></ul><h2 id="session-cookie-的关联"><a href="#session-cookie-的关联" class="headerlink" title="session cookie 的关联"></a>session cookie 的关联</h2><ul><li>session 服务器端存储</li><li>cookie 客户端存储</li><li>在服务器端创建session之后，服务器和当前客户端之间会建立一个唯一的标识(sessionID/sid),当前信息存储在对应的sid之下。</li><li>当服务器端把一些成功或失败的结果返回给客户端的时候，在响应头信息中会增加set-cookie(客户端cookie)这样的字段，把connect.sid存储到客户端的cookie中。即在客户端本地种下cookie.</li><li>当客户端再向服务器发送任何请求的时候，都会把cookie信息带上，传递给服务器.</li><li>服务器端根据sid值进行校验。</li></ul><h2 id="localStroge-vs-cookie"><a href="#localStroge-vs-cookie" class="headerlink" title="localStroge vs cookie"></a>localStroge vs cookie</h2><ul><li><p>cookie</p><ul><li>兼容所有浏览器</li><li>存储大小限制 一个域下能存储4kb左右数据</li><li>有过期时间(可以设置)</li><li>杀毒软件或浏览器的垃圾清理都可能会把cookie信息强制清除掉</li><li>在隐私或无痕浏览模式下，是不会记录cookie的</li><li>cookie不是严格的本地存储，因为要和服务器之间来回传输</li></ul></li><li><p>localStroge </p><ul><li>不兼容ie8 及以下</li><li>存储大小限制 一个域下能存储5Mb左右数据</li><li>本地永久存储(不手动删除的情况下)</li><li>杀毒软件或浏览器的垃圾清理暂时不会清理localStroge的信息(新版本google会清理localStroge的)</li><li>在隐私或无痕浏览模式下，是会记录localStroge的</li><li>localStroge和服务器之间无半毛钱的关系</li></ul></li></ul><h2 id="cookie的设置"><a href="#cookie的设置" class="headerlink" title="cookie的设置"></a>cookie的设置</h2><ul><li>document.cookie = ‘’<br><a href="https://www.cnblogs.com/libin-1/p/6128903.html" target="_blank" rel="noopener">转载 原文链接</a></li></ul><h2 id="localStroge的使用-常用"><a href="#localStroge的使用-常用" class="headerlink" title="localStroge的使用 常用"></a>localStroge的使用 常用</h2><ul><li>localStroge.setItem(key, value) 设置 其中value必须是字符串</li><li>localStroge.getItem(key) 获取</li><li>localStroge.removeItem(key) 删除</li><li>localStroge.clear() 清除当前域下的所有的localStroge信息</li></ul><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div></p><center><img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:skyblue;font-weight:bold;" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">有事您Q我👇</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/localStorage/localStorage/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Promise-zhuf</title>
      <link>https://shulu520.com/Promise/Promise-zhuf/</link>
      <guid>https://shulu520.com/Promise/Promise-zhuf/</guid>
      <pubDate>Mon, 10 Jun 2019 13:26:00 GMT</pubDate>
      <description>
      
        珠峰2018-node&amp;Promise教程笔记
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;</p><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><br><a id="more"></a></p><h2 id="js执行顺序优先级"><a href="#js执行顺序优先级" class="headerlink" title="js执行顺序优先级"></a>js执行顺序优先级</h2><ul><li>scncfunction –&gt; micro task –&gt; macro task<ul><li>同步代码 scncfunction</li><li>微任务   micro task</li><li>宏任务   macro task</li></ul></li></ul><h2 id="微任务-micro-task"><a href="#微任务-micro-task" class="headerlink" title="微任务 micro task"></a>微任务 micro task</h2><ul><li>Process.nextTick<ul><li>把当前任务放到主栈的最后执行</li></ul></li><li>Promise(async await)</li></ul><h2 id="宏任务-macro-task"><a href="#宏任务-macro-task" class="headerlink" title="宏任务 macro task"></a>宏任务 macro task</h2><ul><li>回调函数</li><li>ajax</li><li>事件绑定</li><li>node 中的 fs</li><li>三种定时器<ul><li>setImmediate (nodejs独有)</li><li>setTimeout</li><li>setInterval</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setImmediate (() =&gt; &#123;</span><br><span class="line">  console.log(&apos;shulu&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><ul><li>三种状态 进行中 成功 失败</li><li>Promise.all([promise1, promise2, promise3]).then(() =&gt; {……}).catch(){……} 即promise1,2,3都成功则执行then的成功方法，有一个失败则走catch方法。</li><li></li></ul><h2 id="es6-class-类"><a href="#es6-class-类" class="headerlink" title="es6 class 类"></a>es6 class 类</h2><ul><li>class 的本质是 function。</li><li>在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。</li><li>它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法</li><li>constructor 方法是类的默认方法，创建类的实例化对象时被调用</li><li>class 的实例化必须通过 new 关键字。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Promise &#123;</span><br><span class="line"></span><br><span class="line">  //constructor 创建类的实例化对象时被调用</span><br><span class="line">  constructor () &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //这里写原型上的方法</span><br><span class="line">  then()</span><br><span class="line"></span><br><span class="line">  catch()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/2d64c4c4accd" target="_blank" rel="noopener">手写Promise实现</a></p><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div></p><center><img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:skyblue;font-weight:bold;" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">有事您Q我👇</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/Promise/Promise-zhuf/#disqus_thread</comments>
    </item>
    
    <item>
      <title>git-linux</title>
      <link>https://shulu520.com/git/git-linux/</link>
      <guid>https://shulu520.com/git/git-linux/</guid>
      <pubDate>Sun, 09 Jun 2019 03:23:05 GMT</pubDate>
      <description>
      
        Linux常用命令,以及git的使用,git是linux团队开发的，故其中使用的命令都是linux命令。
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;终有一天，我会出现在你的眼前。<br><a id="more"></a></p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><br><center>个人本地操作篇</center><br><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><h2 id="显示目录或文件"><a href="#显示目录或文件" class="headerlink" title="显示目录或文件"></a>显示目录或文件</h2><ul><li>ls -s / ls -a<ul><li>-s 文件列表</li><li>-a 包括隐藏文件</li></ul></li></ul><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><ul><li>cd /</li><li>cd ../</li><li>可以直接拖动文件进入目录</li></ul><h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><ul><li>mkdir + shulu</li></ul><h2 id="创建空文件"><a href="#创建空文件" class="headerlink" title="创建空文件"></a>创建空文件</h2><ul><li>touch + lqy</li></ul><h2 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h2><ul><li>方式一<ul><li>vim/vi + lqy</li><li>A或I 键进入插入模式</li><li>编辑完成后 Esc 然后:wq 即可保存退出</li></ul></li></ul><ul><li>方式二<ul><li>向指定的文件输入内容</li><li>echo xxx &gt; shulu.txt </li><li>shulu.txt若不存在则创建</li><li>每次编辑都会覆盖之前的内容</li></ul></li></ul><h2 id="查看文件中的内容"><a href="#查看文件中的内容" class="headerlink" title="查看文件中的内容"></a>查看文件中的内容</h2><ul><li>cat lqy</li></ul><h2 id="删除文件或文件夹"><a href="#删除文件或文件夹" class="headerlink" title="删除文件或文件夹"></a>删除文件或文件夹</h2><ul><li><strong>一旦删除 不可恢复</strong></li><li>rm + name -rf<ul><li>-r 递归删除</li><li>-f 强制删除</li><li>-rf 以上二者都有</li></ul></li></ul><h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><ul><li>查看当前文件处于哪一个区域</li><li>红色：在工作区</li><li>绿色：在暂存区</li><li>看不见：已经提交到历史区，三区保持一致了</li></ul><h2 id="暂存区删除文件操作"><a href="#暂存区删除文件操作" class="headerlink" title="暂存区删除文件操作"></a>暂存区删除文件操作</h2><ul><li>只要新add一下新的内容 即可覆盖前面暂存区不好的代码</li><li>根据提示：<ul><li>(use “git reset HEAD <file>…” to unstage)</file></li><li>即git reset HEAD &lt;要删除的file&gt;</li><li>或git rm –cached &lt;要删除的file&gt;</li></ul></li></ul><h2 id="代码回滚-一-暂存区回滚"><a href="#代码回滚-一-暂存区回滚" class="headerlink" title="代码回滚 一 暂存区回滚"></a>代码回滚 一 暂存区回滚</h2><ul><li>一步回滚操作<ul><li>将暂存区文件撤回来覆盖工作区新写的不好的代码</li><li>git checkout &lt;要撤回的file&gt; (注意 . 表示所有的文件)</li><li>暂存区的文件依然在，只是将其拿出来覆盖新写的不好的代码</li><li>工作区和暂存区 状态保持一致了</li></ul></li><li>两步回滚操作<ul><li>git reset HEAD &lt;要删除的file&gt; 把当前暂存区的内容删掉，此时暂存区的内容为上一次add的内容</li><li>git checkout <file> 将上一次add的内容拿回来覆盖工作区的不好的代码</file></li></ul></li></ul><h2 id="代码回滚-二-历史版本回滚"><a href="#代码回滚-二-历史版本回滚" class="headerlink" title="代码回滚 二 历史版本回滚"></a>代码回滚 二 历史版本回滚</h2><ul><li>git log 版本信息</li><li><strong>若出现了 提交的信息最后有一个end 按Q键即可退出</strong></li><li>git reset –hard &lt;版本id&gt;</li><li>三区保持一致了</li></ul><h2 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h2><ul><li>添加不用git管理的文件</li></ul><h2 id="ctrl-L"><a href="#ctrl-L" class="headerlink" title="ctrl + L"></a>ctrl + L</h2><ul><li>清屏</li></ul><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><br><center>团队协作篇</center><br><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><h2 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h2><ul><li><strong>最好</strong>创建一个README.md文件</li><li>这样远程就会有一个master的分支</li><li>有利于后续的操作</li></ul><p><del>创建本地仓库初始化本地仓库连接远程仓库</del>这操作不常用</p><ul><li>mkdir repository </li><li>git init</li><li>git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:lqyasl/git-zhuf.git</li></ul><h2 id="git-clone-常用"><a href="#git-clone-常用" class="headerlink" title="git clone 常用"></a>git clone 常用</h2><ul><li>一步操作等于以上三步操作</li><li>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:lqyasl/git-zhuf.git</li></ul><h2 id="不同开发者之间的配合"><a href="#不同开发者之间的配合" class="headerlink" title="不同开发者之间的配合"></a>不同开发者之间的配合</h2><ul><li>假设有a b 两个开发者<h2 id="不冲突的情况"><a href="#不冲突的情况" class="headerlink" title="不冲突的情况"></a>不冲突的情况</h2></li><li>a b 两人提交修改的是不同的文件</li><li>提交之前最好git pull origin master 拉取远程仓库的内容</li><li>然后再git push origin master 推送到远程<h2 id="产生冲突的情况"><a href="#产生冲突的情况" class="headerlink" title="产生冲突的情况"></a>产生冲突的情况</h2></li><li>两人同时对相同的文件都做了不一样的修改</li></ul><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><ul><li>若直接弹出vim的内容 正常退出即可 即 输入a 然后按Esc 再按 :wq</li><li>若显示MERGEING 则删掉那些特殊符号 ，修改好后退出</li></ul><h2 id="无分支开发模式"><a href="#无分支开发模式" class="headerlink" title="无分支开发模式"></a>无分支开发模式</h2><ul><li>即只有一个master 分支<h2 id="分支开发模式"><a href="#分支开发模式" class="headerlink" title="分支开发模式"></a>分支开发模式</h2></li><li>新开一个分支即可</li><li>git checkout -b deva</li><li>即可创建一个deva分支 并且切换到这个分支上 </li><li>新创建分支的特点：本地master内容会自动同步到deva分支上 </li><li>在deva分支上完事后</li><li>git add .</li><li>git commit -m ‘……’</li><li>git stash 保存当前的工作进度。会分别对暂存区和工作区的状态进行保存 <strong>关于这一步操作后面有说明</strong></li><li>git checkout master</li><li>git merge deva</li><li>git pull origin master</li><li>git push origin master</li></ul><h2 id="git-stash-amp-git-stash-pop"><a href="#git-stash-amp-git-stash-pop" class="headerlink" title="git stash &amp; git stash pop"></a>git stash &amp; git stash pop</h2><ul><li>git stash 保存当前的工作进度。会分别对暂存区和工作区的状态进行保存.</li><li>git stash pop 恢复工作现场。</li><li><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p></li><li><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交。</p></li><li><p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p></li><li><p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来(<strong>先git add . 到暂存区 然后 git stash 藏起来</strong>)，等以后回来恢复现场后继续工作。</p></li><li>总结：<ul><li>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除bug分支；</li><li>当手头工作没有完成时，先把工作现场git stash一下，然后去bug分支修复bug，修复后，再回到之前的分支git stash pop，将工作现场恢复。</li></ul></li></ul><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div></p><center><img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:skyblue;font-weight:bold;" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">有事您Q我👇</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/git/git-linux/#disqus_thread</comments>
    </item>
    
    <item>
      <title>webpack-mooc</title>
      <link>https://shulu520.com/webpack/webpack-mooc/</link>
      <guid>https://shulu520.com/webpack/webpack-mooc/</guid>
      <pubDate>Sat, 01 Jun 2019 15:54:12 GMT</pubDate>
      <description>
      
        webpack 模块打包工具 慕课教程学习笔记
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;只要有想见的人，就不是孤身一人。</p><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><br><a id="more"></a></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ul><li>node 安装</li><li>webpack 安装</li><li>初始化文件夹 npm init 打包符合node规范的项目</li><li>或 npm init -y 生成默认初始化的文件夹</li><li>全局安装webpack 不推荐 因为各个项目依赖的webpack版本可能不一样</li><li>npm uninstall webpack webpack-cli -g 卸载webpack</li><li>npm install webpack webpack-cli -D 推荐在项目中独立安装</li><li>npm info webpack 打印输出webpack的信息 可以查看你想要的版本是否存在 </li><li>安装你所需要的版本就行了 npm i webpack@版本号 webpack-cli -D</li><li>webpack 默认的打包配置文件为webpack.config.js</li></ul><h2 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h2><ul><li>webpack.config.js初步配置</li><li>新建webpack.config.js文件</li><li>新建src目录 放我们的源代码</li><li>webpack.config.js配置如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//nodejs引入path模块 为commonjs规范</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: development, // 指定运行环境</span><br><span class="line">  entry: &apos;./src/index.js&apos;, // 入口文件</span><br><span class="line">  output: &#123; // 出口文件</span><br><span class="line">    //被编译到你指定的输出路径的文件夹中</span><br><span class="line">    path: path.resolve(_dirname, &apos;dist&apos;), </span><br><span class="line">    filename: &apos;bundle.js&apos; //指定打包生成的文件名字</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>package.json 配置scripts命令 简化命打包令为 npm run bundle</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;bundle&quot;: &quot;webpack&quot; //npm run bundle 执行webpack命令 </span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不同安装的webpack打包形式<ul><li>未配置scripts<br>npx webpack 要打包的文件</li><li>配置scripts后<br>npm run bundle 即可 </li></ul></li></ul><h2 id="配置打包图片"><a href="#配置打包图片" class="headerlink" title="配置打包图片"></a>配置打包图片</h2><ul><li>loader 所谓 loader 只是一个导出为函数的 JavaScript 模块。让 webpack 能够去处理那些非 JavaScript 文件</li><li>(webpack 自身只理解 JavaScript)</li><li>loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，</li><li>然后你就可以利用 webpack 的打包能力，对它们进行处理。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &apos;development&apos;,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &apos;./src/index.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: /\.(jpg|png|gif)$/,//用于标识出应该被对应的 loader 进行转换的某个或某些文件。</span><br><span class="line">      use: &#123;//表示进行转换时，应该使用哪个 loader。</span><br><span class="line">        loader: &apos;url-loader&apos;,</span><br><span class="line">        // loader: &apos;file-loader&apos;,</span><br><span class="line">        options: &#123; //配置项</span><br><span class="line">          name: &apos;[name].[ext]&apos;,//以原来的名字和后缀打包生成文件名</span><br><span class="line">          outputPath: &apos;images/&apos;,//打包生成的文件放到dist/images/</span><br><span class="line">          limit: 2048 //当图片的大小在2kb以下时直接打包成base64的图片嵌入js文件中</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;bundle.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="样式loader"><a href="#样式loader" class="headerlink" title="样式loader"></a>样式loader</h2><ul><li>css-loader 处理各个css文件间的关系</li><li>style-loader 将增加一个style标签并插入css文件然后挂载到head标签中   </li><li>处理sass文件 npm install sass-loader node-sass -D</li><li><strong>loader 的执行顺序 从下到上 从右到左</strong></li><li>处理less文件 首先npm install less –save-dev</li><li>再npm i -D less-loader</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">rules: [&#123;</span><br><span class="line">test: /\.scss$/,</span><br><span class="line">use: [&#123;</span><br><span class="line">loader: &quot;style-loader&quot; // 将 JS 字符串生成为 style 节点</span><br><span class="line">&#125;, &#123;</span><br><span class="line">loader: &quot;css-loader&quot; // 将 CSS 转化成 CommonJS 模块</span><br><span class="line">&#125;, &#123;</span><br><span class="line">loader: &quot;sass-loader&quot; // 将 Sass 编译成 CSS</span><br><span class="line">&#125;]</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动添加前缀loader"><a href="#自动添加前缀loader" class="headerlink" title="自动添加前缀loader"></a>自动添加前缀loader</h2><ul><li>使用Can I Use中的值为CSS规则添加供应商前缀。</li><li>Autoprefixer将使用基于当前浏览器流行度和属性支持的数据为您应用前缀。</li><li>npm i -D postcss-loader</li><li>npm i -D autoprefixer </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//配置新建postcss.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    require(&apos;autoprefixer&apos;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//然后配置webpack.config.js</span><br><span class="line">&#123;</span><br><span class="line">test: /\.css$/,</span><br><span class="line">use: [</span><br><span class="line">&apos;style-loader&apos;,</span><br><span class="line">&#123; loader: &apos;css-loader&apos;, options: &#123; importLoaders: 1 &#125; &#125;,</span><br><span class="line">&apos;postcss-loader&apos;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="css-loader-常用的配置"><a href="#css-loader-常用的配置" class="headerlink" title="css-loader 常用的配置"></a>css-loader 常用的配置</h2><ul><li>当less(sass)等文件中再引入其他的less(sass)文件时，默认是不会打包引入的文件的，</li><li>配置opations 中 importLoaders: 2 后，则会通过’less-loader’, ‘postcss-loader’ 这两个loader的打包</li></ul><hr><p>{<br>    loader: ‘css-loader’,<br>    options: {<br>        importLoaders: 2,<br>        modules: true //模块化<br>    }<br>},<br>‘less-loader’,<br>‘postcss-loader’    </p><hr><h2 id="css-打包的模块化"><a href="#css-打包的模块化" class="headerlink" title="css 打包的模块化"></a>css 打包的模块化</h2><ul><li>模块中需要哪个样式文件 引入即可import style from ‘./avator.less’</li><li>使用:如 img.classList.add(style.avator) 在avator.less样式中自己写的叫avator的classname</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options: &#123;</span><br><span class="line">  modules: true //开启css模块化</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字体的引入iconfont"><a href="#字体的引入iconfont" class="headerlink" title="字体的引入iconfont"></a>字体的引入iconfont</h2><ul><li>file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录。</li><li>这就是说，我们可以将它们用于任何类型的文件，包括字体。</li><li>src/font一般需要 中如下几种正则中的字体文件</li><li>iconfont.css文件，在需要字体的地方引入样式即可</li><li>src: url(‘./font/iconfont.eot?t=155948’)</li><li>url(‘./font/iconfont.ttf?t=155948’)</li><li>其中./font为自己加的路劲 </li><li>其中有个base64格式的路劲不用变</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test: /\.(woff|woff2|eot|ttf|svg)$/,</span><br><span class="line">use: [</span><br><span class="line">&apos;file-loader&apos;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="plugin-插件的使用"><a href="#plugin-插件的使用" class="headerlink" title="plugin 插件的使用"></a>plugin 插件的使用</h2><ul><li>html-webpack-plugin插件的使用</li><li>npm install –save-dev html-webpack-plugin</li><li>HtmlWebpackPlugin 插件的作用：<ul><li>会在打包结束后自动生成一个html文件，并把打包生成的js文件自动引入html文件</li></ul></li><li>plugin的作用：在webpack运行到某个时刻的时候，帮我门做一些在事情 就像vue中的生命周期钩子函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js中</span><br><span class="line">plugins: [</span><br><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">title: &quot;my html template&quot;, //自定义title 默认为webpack app</span><br><span class="line">filename: &quot;myindex.html&quot;, //自定义文件名 默认为index.html</span><br><span class="line">template: &quot;src/index.html&quot; //以此为模板创建html</span><br><span class="line">&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h2><ul><li>清除旧的打包的文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">new CleanWebpackPlugin(),//打包前删除前面旧的dist文件</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">main: &apos;./src/index.js&apos;,</span><br><span class="line">sub: &apos;./src/index.js&apos; //再打包生成一个js文件</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  publicPath: &apos;https://cdn.abc.com&apos;,//公共前缀路劲如cdn</span><br><span class="line">  filename: &apos;[name].js&apos;, //以entry的key值作为打包生成的文件名</span><br><span class="line">  path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="SourceMap"><a href="#SourceMap" class="headerlink" title="SourceMap"></a>SourceMap</h2><ul><li>再打包生成main.js文件之后如果代码里出现错误，它会将main.js中错误出现的地方与源码之间做一映射，告诉我们源码中错误出现在哪里，以便我们快速定位bug出处</li><li>错误代码使用chrome调试工具直接显示在index.js?b635这个文件打开即可看到源码里面错误出现的位置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">devtool: &apos;cheap-module-eval-source-map&apos;,//development模式推荐使用</span><br><span class="line"></span><br><span class="line">devtool: &apos;cheap-module-source-map&apos;,//production模式推荐使用</span><br></pre></td></tr></table></figure><h2 id="使用WebpackDevServer提升开发效率"><a href="#使用WebpackDevServer提升开发效率" class="headerlink" title="使用WebpackDevServer提升开发效率"></a>使用WebpackDevServer提升开发效率</h2><ul><li>npm install webpack-dev-server -D</li><li>在webpack.config.js</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">contentBase: &apos;./dist&apos;,//开启一个服务器运行dist里面的内容</span><br><span class="line">open: true ,//自动在浏览器里打开</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  //vue中就是配置的这样的代理</span><br><span class="line">  proxy: &#123; </span><br><span class="line">    &apos;/api&apos;: &apos;http://localhost:3000&apos;//当用户访问api这个地址时proxy将其转到localhost:3000这个地址</span><br><span class="line">  &#125;,</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">port: 8888//必要时可以自定义端口</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>在 package.json </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">&quot;start&quot;: &quot;webpack-dev-server&quot; //npm run start 开启服务器 自动刷新 目前最常用的 打包生成的dist文件直接放到内存里运行 速度更快</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="HotModuleReplacementPlugin-热模块更新"><a href="#HotModuleReplacementPlugin-热模块更新" class="headerlink" title="HotModuleReplacementPlugin 热模块更新"></a>HotModuleReplacementPlugin 热模块更新</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var webpack = require(&apos;webpack&apos;)</span><br><span class="line"></span><br><span class="line">//配置</span><br><span class="line">devServer: &#123;</span><br><span class="line">contentBase: &apos;./dist&apos;,</span><br><span class="line">open: true,</span><br><span class="line">hot: true, //代码更新时只会更新最新变化的部分 不会全部刷新一遍</span><br><span class="line">hotOnly: true</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">//配置</span><br><span class="line">plugins: [</span><br><span class="line">new webpack.HotModuleReplacementPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="使用-Babel-处理-ES6-语法"><a href="#使用-Babel-处理-ES6-语法" class="headerlink" title="使用 Babel 处理 ES6 语法"></a>使用 Babel 处理 ES6 语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-loader babel-core babel-preset-env</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.js$/,</span><br><span class="line">  include: &apos;../src&apos; , // 指定匹配文件的范围</span><br><span class="line">  exclude: /node_modules/,</span><br><span class="line">  loader: &apos;babel-loader&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tree-Shaking-概念详解"><a href="#Tree-Shaking-概念详解" class="headerlink" title="Tree Shaking 概念详解"></a>Tree Shaking 概念详解</h2><ul><li>把一个模块里面的没有用到的方法摇晃掉 去掉 不打包</li><li>如果对一些文件不使用此功能 则配置 </li><li>package.json 添加 配置 “sideEffects”: [‘不使用此功能的文件’]</li><li>.babelrc文件配置如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;env&quot; ,&#123;</span><br><span class="line">        &quot;targets&quot;: &#123;</span><br><span class="line">          &quot;chrome&quot;: &quot;67&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;useBuiltIns&quot;: &quot;usage&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Develoment-和-Production-模式的区分打包"><a href="#Develoment-和-Production-模式的区分打包" class="headerlink" title="Develoment 和 Production 模式的区分打包"></a>Develoment 和 Production 模式的区分打包</h2><ul><li>新建webpack.dev.js 开发环境</li><li>新建webpack.common.js 公共代码</li><li>新建webpack.prod.js 生产环境</li><li>详见简书配置</li></ul><h2 id="Webpack-和-Code-Splitting-代码分割"><a href="#Webpack-和-Code-Splitting-代码分割" class="headerlink" title="Webpack 和 Code Splitting 代码分割"></a>Webpack 和 Code Splitting 代码分割</h2><ul><li>将外来库的方法与业务逻辑代码分开打包</li><li>SplitChunksPlugin 配置参数详解</li><li>weback.common.js </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;//优化</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    chunks: &apos;all&apos;,//同步异步代码都分割</span><br><span class="line">    minSize: 30000,//30kb 分割的最小限度配合cacheGroups</span><br><span class="line">    //maxSize: 50000,//不常用</span><br><span class="line">    minChunks: 1,//当一个模块至少被使用了多少次的时候才代码分割</span><br><span class="line">    maxAsyncRequests: 5,//假设有多个库要进行分割，但这里只做分割5个</span><br><span class="line">    maxInitialRequests: 3,//不用修改 默认就行了</span><br><span class="line">    automaticNameDelimiter: &apos;~&apos;,//组和文件之间的连接符</span><br><span class="line">    name: true,</span><br><span class="line">    cacheGroups: &#123;//缓存组</span><br><span class="line">      vendors: &#123;</span><br><span class="line">        test: /[\\/]node_modules[\\/]/,//在node_modules里面匹配</span><br><span class="line">        priority: -10,//优先级和default的优先级作比较，</span><br><span class="line">                      // 若这里的高那么就将符合上面要求的文件打包放到vender组</span><br><span class="line">        //filename: &apos;vender.js&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      default: &#123;</span><br><span class="line">        // minChunks: 2,</span><br><span class="line">        priority: -20,</span><br><span class="line">        reuseExistingChunk: true ,//入一个文件已经在之前的步骤中打包过了，那这里就不用再打包了</span><br><span class="line">        filename: &apos;common.js&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="Lazy-Loading-和-chunk-是什么"><a href="#Lazy-Loading-和-chunk-是什么" class="headerlink" title="Lazy Loading 和 chunk 是什么"></a>Lazy Loading 和 chunk 是什么</h2><ul><li>懒加载 即当时机成熟的时候再加载代码</li><li>promise 必须要有catch() <strong>捕获错误</strong></li><li>chunk表示一个文件，默认情况下webpack的输入是一个入口entry文件，输出output也是一个文件，这个文件就是一个chunk，chunkId就是产出时给每个文件一个唯一标识id，chunkhash就是文件内容的md5值，name就是在entry中指定的key值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//安装插件</span><br><span class="line"></span><br><span class="line">npm install --save-dev @babel/plugin-syntax-dynamic-import</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//src/index.js</span><br><span class="line"></span><br><span class="line">async function getComponent () &#123;</span><br><span class="line">  const &#123; default: _ &#125; = await import(&apos;lodash&apos;)//异步按需引入lodash函数库</span><br><span class="line">  var dom = document.createElement(&apos;div&apos;)</span><br><span class="line">  dom.innerHTML = _.join([&apos;hello&apos;, &apos;shulu&apos;, &apos;lqy&apos;, &apos;love&apos;, &apos;you&apos;], &apos;^_^&apos;)</span><br><span class="line">  return dom</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">  getComponent().then((dom) =&gt; &#123;</span><br><span class="line">    document.body.appendChild(dom)</span><br><span class="line">  &#125;).catch((err) =&gt; &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//.babelrc</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;env&quot; ,&#123;</span><br><span class="line">        &quot;targets&quot;: &#123;</span><br><span class="line">          &quot;chrome&quot;: &quot;67&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;useBuiltIns&quot;: &quot;usage&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [&quot;@babel/plugin-syntax-dynamic-import&quot;,]//配置插件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//事实上webpack.common.js的配置如下即可</span><br><span class="line">optimization: &#123;</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    chunks: &apos;all&apos;//同步异步代码都分割</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="css-模块的分割打包"><a href="#css-模块的分割打包" class="headerlink" title="css 模块的分割打包"></a>css 模块的分割打包</h2><ul><li>目前不支持模块热跟新 故在生产环境使用好一些</li><li>将webpack.common.js中的css配置文件分别拿到webpack.dev.js 和webpack.prod.js </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extract-text-webpack-plugin还不能支持webpack4.0.0以上的版本。 </span><br><span class="line">解决办法： </span><br><span class="line">npm install -–save-dev extract-text-webpack-plugin@next </span><br><span class="line">会下载到+ extract-text-webpack-plugin@4.0.0-beta.0 </span><br><span class="line">然后打包就正常了</span><br><span class="line">//npm install --save-dev extract-text-webpack-plugin</span><br><span class="line"></span><br><span class="line">npm install --save-dev extract-text-webpack-plugin@next</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//webpack.prod.js</span><br><span class="line"></span><br><span class="line">const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;)</span><br><span class="line">//配置</span><br><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.css$/,</span><br><span class="line">      use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">        fallback: &quot;style-loader&quot;,</span><br><span class="line">        use: [&apos;css-loader&apos;, &apos;postcss-loader&apos;]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.less$/,</span><br><span class="line">      use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">        fallback: &apos;style-loader&apos;,</span><br><span class="line">        //如果需要，可以在 sass-loader 之前将 resolve-url-loader 链接进来</span><br><span class="line">        use: [&apos;css-loader&apos;, &apos;less-loader&apos;, &apos;postcss-loader&apos;]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  new ExtractTextPlugin(&quot;styles.css&quot;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//package.json 对css文件不使用tree shaking</span><br><span class="line"></span><br><span class="line">&quot;sideEffects&quot;: [</span><br><span class="line">  &quot;*.css&quot;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//webpack.common.js</span><br><span class="line"></span><br><span class="line">optimization: &#123;</span><br><span class="line">  usedExports: true, //模块中只引入使用了的方法(函数)</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    chunks: &apos;all&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>将打包后的css压缩代码 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S optimize-css-assets-webpack-plugin</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//webpack.prod.js</span><br><span class="line"></span><br><span class="line">const OptimizeCSSAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">optimization: &#123;</span><br><span class="line">  minimizer: [new OptimizeCSSAssetsPlugin(&#123;&#125;)],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="webpack-Library库"><a href="#webpack-Library库" class="headerlink" title="webpack Library库"></a>webpack Library库</h2><h2 id="webpack-PWA-的打包"><a href="#webpack-PWA-的打包" class="headerlink" title="webpack PWA 的打包"></a>webpack PWA 的打包</h2><h2 id="TypeScript-的打包配置"><a href="#TypeScript-的打包配置" class="headerlink" title="TypeScript 的打包配置"></a>TypeScript 的打包配置</h2><h2 id="WebpackDevServer-请求转发"><a href="#WebpackDevServer-请求转发" class="headerlink" title="WebpackDevServer 请求转发"></a>WebpackDevServer 请求转发</h2><ul><li>devServer.proxy的配置</li><li>开发环境development</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  proxy: &#123;//代理</span><br><span class="line">  &quot;/api&quot;: &#123;</span><br><span class="line">    //将所有对/api的请求转发到http://shulu520.com/test.json</span><br><span class="line">    target: &quot;http://shulu520.com/test.json&quot;,</span><br><span class="line"></span><br><span class="line">    //在开发中当后端/api还没有做好时，将路劲变为love.json, 做好后，将这里配置注释掉即可，就不用改源码了</span><br><span class="line">    pathRewrite: &#123;&quot;^/api&quot; : &quot;love.json&quot;&#125;,</span><br><span class="line"></span><br><span class="line">    //默认不支持https的 配置后即可支持</span><br><span class="line">    secure: false</span><br><span class="line"></span><br><span class="line">    //如果希望代理多个特定路径到同一个目标，可以这样使用</span><br><span class="line">    context: [&quot;/auth&quot;, &quot;/api&quot;],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="webpack-打包优化"><a href="#webpack-打包优化" class="headerlink" title="webpack 打包优化"></a>webpack 打包优化</h2><ul><li>跟上技术的迭代 工具的更新</li><li>在尽可能少的模块上应用loader<ul><li>约束loader的应用范围</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.js$/,</span><br><span class="line">  include: path.resolve(__diename, &apos;./src&apos;)</span><br><span class="line">  exclude: /node_modules/,</span><br><span class="line">  loader: &apos;babel-loader&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尽可能少的使用plugin 并确保可靠 官网的推荐</li><li>resolve 配置项 参数的合理配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//webpack.common.js</span><br><span class="line">resole: &#123;</span><br><span class="line">  alias: &#123;// 别名 简化长路劲 </span><br><span class="line">    Child: path.resolve(__dirname, &apos;./src/a/b/c/Child&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自己编写-Loader-实现代码的装饰"><a href="#自己编写-Loader-实现代码的装饰" class="headerlink" title="自己编写 Loader 实现代码的装饰"></a>自己编写 Loader 实现代码的装饰</h2><ul><li>loader 是转译模块源代码的转换规则。 </li><li>loader 被编写为，接受源代码作为参数的函数， 并返回这些转换过的新版本代码.</li></ul><h2 id="手写-plugin"><a href="#手写-plugin" class="headerlink" title="手写 plugin"></a>手写 plugin</h2><h2 id="bundler-源码编写-模块分析"><a href="#bundler-源码编写-模块分析" class="headerlink" title="bundler 源码编写 (模块分析)"></a>bundler 源码编写 (模块分析)</h2><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div></p><center><img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:skyblue;font-weight:bold;" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">有事您Q我👇</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/webpack/webpack-mooc/#disqus_thread</comments>
    </item>
    
    <item>
      <title>js-advance-four</title>
      <link>https://shulu520.com/js-advance/js-advance-four/</link>
      <guid>https://shulu520.com/js-advance/js-advance-four/</guid>
      <pubDate>Fri, 31 May 2019 02:57:20 GMT</pubDate>
      <description>
      
        guigu js 高级教程笔记④——线程机制和事件机制
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;这世界为何有那么可爱的人儿，儿童节快乐哦</p><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><br><a id="more"></a></p><h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><ul><li>进程:<ul><li>程序的一次执行, 它占有一片独有的内存空间</li><li>可以通过windows任务管理器查看进程</li></ul></li><li>线程:<ul><li>是进程内的一个独立执行单元</li><li>是程序执行的一个完整流程</li><li>是CPU的最小的调度单元</li></ul></li><li>关系<ul><li>一个进程至少有一个线程(主)</li><li>程序是在某个进程中的某个线程执行的</li></ul></li></ul><p><img src="https://www.z4a.net/images/2019/05/31/20190531222313.md.png" alt="线程与进程图"></p><ul><li>应用程序必须运行在某个进程的某个线程上</li><li>一个进程中至少有一个运行的线程: 主线程,  进程启动后自动创建</li><li>一个进程内的数据可以供其中的多个线程直接共享</li><li>多个进程之间的数据是不能直接共享的</li><li>线程池(thread pool): 保存多个线程对象的容器, 实现线程对象的反复利用</li><li><p>何为多进程与多线程?</p><ul><li>多进程运行: 一应用程序可以同时启动多个实例运行</li><li>多线程: 在一个进程内, 同时有多个线程运行</li></ul></li><li><p>比较单线程与多线程?</p><ul><li>多线程<br>优点：能有效提升CPU的利用率<br>缺点：创建多线程开销 线程间切换开销 死锁与状态同步问题</li><li>单线程<br>优点：顺序编程简单易懂<br>缺点：效率低</li></ul></li><li>JS是单线程还是多线程?<ul><li>js是单线程运行的</li><li>但使用H5中的 Web Workers可以多线程运行</li></ul></li><li>浏览器运行是单进程还是多进程?<ul><li>有的是单进程 firefox 老版IE</li><li>有的是多进程 chrome 新版IE</li></ul></li><li><p>如何查看浏览器是否是多进程运行的呢?</p><ul><li>任务管理器 —&gt; 进程</li></ul></li><li><p>浏览器内核</p></li><li>支撑浏览器运行的最核心的程序</li><li>不同的浏览器可能不一样<ul><li>Chrome, Safari : webkit</li><li>firefox : Gecko</li><li>IE: Trident</li><li>360,搜狗等国内浏览器: Trident + webkit</li></ul></li></ul><h2 id="浏览器内核模块组成"><a href="#浏览器内核模块组成" class="headerlink" title="浏览器内核模块组成"></a>浏览器内核模块组成</h2><ul><li>主线程<ul><li>js引擎模块 : 负责js程序的编译与运行</li><li>html,css文档解析模块 : 负责页面文本的解析</li><li>DOM/CSS模块 : 负责dom/css在内存中的相关处理 </li><li>布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象)</li></ul></li><li>分线程<ul><li>定时器模块 : 负责定时器的管理</li><li>DOM事件模块 : 负责事件的管理</li><li>网络请求模块 : 负责Ajax请求</li></ul></li></ul><h2 id="js线程"><a href="#js线程" class="headerlink" title="js线程"></a>js线程</h2><ul><li>js是单线程执行的(回调函数也是在主线程)</li><li>H5提出了实现多线程的方案: Web Workers</li><li>只能是主线程更新界面</li></ul><h2 id="定时器问题"><a href="#定时器问题" class="headerlink" title="定时器问题:"></a>定时器问题:</h2><ul><li>定时器并不真正完全定时</li><li>如果在主线程执行了一个长时间的操作, 可能导致延时才处理</li></ul><h2 id="事件处理机制-图"><a href="#事件处理机制-图" class="headerlink" title="事件处理机制(图)"></a>事件处理机制(图)</h2><ul><li>代码分类<ul><li>初始化执行代码: 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码</li><li>回调执行代码: 处理回调逻辑</li></ul></li><li>js引擎执行代码的基本流程: <ul><li>初始化代码===&gt;回调代码</li></ul></li><li>模型的2个重要组成部分:<ul><li>事件管理模块</li><li>回调队列</li></ul></li><li>模型的运转流程<ul><li>执行初始化代码, 将事件回调函数交给对应模块管理</li><li>当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中</li><li>只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行</li></ul></li></ul><p><img src="https://www.z4a.net/images/2019/06/01/loop.md.png" alt="loop.png"></p><h2 id="H5-Web-Workers"><a href="#H5-Web-Workers" class="headerlink" title="H5 Web Workers"></a>H5 Web Workers</h2><ul><li>可以让js在分线程执行</li><li>Worker 计算斐波那契数列的例子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//在主线程 创建一个Worker实例对象</span><br><span class="line">  var worker = new Worker(&apos;worker.js&apos;) // 其中worker.js为worker文件路劲</span><br><span class="line">  // 绑定接收消息的监听</span><br><span class="line">  worker.onmessage = function (event) &#123;</span><br><span class="line">    //通信的数据都在event.data里面</span><br><span class="line">    alert(event.data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 向分线程发送消息</span><br><span class="line">  worker.postMessage(number)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在分线程 斐波那契数列</span><br><span class="line">function fibonacci(n) &#123;</span><br><span class="line">  //递归调用</span><br><span class="line">  return n&lt;=2 ? 1 : fibonacci(n-1) + fibonacci(n-2)  </span><br><span class="line">&#125;</span><br><span class="line">this.onmessage = function (event) &#123;</span><br><span class="line">  var number = event.data </span><br><span class="line">  console.log(&apos;分线程接收到主线程发送的数据: &apos;+number)</span><br><span class="line">  </span><br><span class="line">  var result = fibonacci(number)//计算斐波那契数列</span><br><span class="line">  postMessage(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/<em><br>    分线程中this不再是window 而是另一个全局对象<br>    其有onmessage,postMessage等方法<br>    故在这里可以直接调用<br>    而不可以直接调用window的方法<br>    如alert() // alert is not defind<br>    document 方法 等 可以更新页面的方法都不可以调用<br>    只有主线程才可以跟新界面</em>/</p><ul><li>问题:<ul><li>worker内代码不能操作DOM更新UI</li><li>不是每个浏览器都支持这个新特性</li><li>不能跨域加载JS</li><li>慢一点 数据传输过程</li></ul></li></ul><p><img src="https://www.z4a.net/images/2019/06/01/worker.md.png" alt="worker.png"></p><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div></p><center><img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:skyblue;font-weight:bold;" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">来我QQ撩我哦👇</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/js-advance/js-advance-four/#disqus_thread</comments>
    </item>
    
    <item>
      <title>js-advance-three</title>
      <link>https://shulu520.com/js-advance/js-advance-three/</link>
      <guid>https://shulu520.com/js-advance/js-advance-three/</guid>
      <pubDate>Thu, 30 May 2019 10:42:14 GMT</pubDate>
      <description>
      
        guigu js 高级教程笔记③——对象高级
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;想起你，内心充满欢喜O(∩_∩)O</p><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><br><a id="more"></a></p><h2 id="对象的创建模式"><a href="#对象的创建模式" class="headerlink" title="对象的创建模式"></a>对象的创建模式</h2><ul><li><p>Object构造函数模式</p><ul><li>套路: 先创建空Object对象, 再动态添加属性/方法</li><li>适用场景: 起始时不确定对象内部数据</li><li>问题: 语句太多</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object()</span><br><span class="line">obj.name = &apos;Tom&apos;</span><br><span class="line">obj.setName = function(name)&#123;this.name=name&#125;</span><br></pre></td></tr></table></figure></li><li><p>对象字面量模式</p><ul><li>套路: 使用{}创建对象, 同时指定属性/方法</li><li>适用场景: 起始时对象内部数据是确定的</li><li>问题: 如果创建多个对象, 有重复代码</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name : &apos;Tom&apos;,</span><br><span class="line">  setName : function(name)&#123;this.name = name&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>工厂函数模式 <ul><li>套路: 通过工厂函数动态创建对象并返回</li><li>适用场景: 需要创建多个对象</li><li>问题: 对象没有一个具体的类型, 都是Object类型<br>  即通过instanceof判断得到的都是Object类型<br>  类型不够具体 人和🐶均为同一类型</li><li>用的不多 只是比较经典</li><li>返回一个对象的函数===&gt;工厂函数 联系真实工厂</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name, age) &#123; </span><br><span class="line">  var obj = &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    age: age,</span><br><span class="line">    setName: function (name) &#123;</span><br><span class="line">      this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造函数模式<ul><li>套路: 自定义构造函数, 通过new创建实例对象</li><li>适用场景: 需要创建多个类型确定的对象</li><li>问题: 每个对象都有相同的数据, 浪费内存</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.setName = function(name)&#123;this.name=name;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">new Person(&apos;tom&apos;, 12);</span><br></pre></td></tr></table></figure><ul><li>组合模式 (构造函数+原型)<ul><li>套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上</li><li>适用场景: 需要创建多个类型确定的对象</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = function(name)&#123;this.name=name;&#125;;</span><br><span class="line">new Person(&apos;tom&apos;, 12);</span><br></pre></td></tr></table></figure><h2 id="继承模式"><a href="#继承模式" class="headerlink" title="继承模式"></a>继承模式</h2><ul><li>原型链继承 : 得到方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;&#125;</span><br><span class="line">Parent.prototype.test = function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">function Child() &#123;&#125;</span><br><span class="line">Child.prototype = new Parent(); //子类型的原型指向父类型实例</span><br><span class="line">Child.prototype.constructor = Child //修正constructor属性重新指向子构造函数</span><br><span class="line"></span><br><span class="line">var child = new Child(); //有test()</span><br></pre></td></tr></table></figure><ul><li>借用构造函数 : 得到属性<br>(假继承)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Parent(xxx)&#123;this.xxx = xxx&#125;</span><br><span class="line">Parent.prototype.test = function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">function Child(xxx,yyy)&#123;</span><br><span class="line">  Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)</span><br><span class="line">&#125;</span><br><span class="line">var child = new Child(&apos;a&apos;, &apos;b&apos;);  //child.xxx为&apos;a&apos;, 但child没有test()</span><br></pre></td></tr></table></figure><ul><li>组合继承 (原型链继承+构造函数)<ul><li>利用原型链实现对父类型对象的方法继承</li><li>利用call()借用父类型构建函数初始化相同属性</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Parent(xxx)&#123;this.xxx = xxx&#125;</span><br><span class="line">Parent.prototype.test = function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">function Child(xxx,yyy)&#123;</span><br><span class="line">  Parent.call(this, xxx)//借用构造函数   this.Parent(xxx)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = new Parent() //得到test()</span><br><span class="line">Child.prototype.constructor = Child //修正constructor属性</span><br><span class="line"></span><br><span class="line">var child = new Child(); //child.xxx为&apos;a&apos;, 也有test()</span><br></pre></td></tr></table></figure><ul><li>new一个对象背后做了些什么?<ul><li>创建一个空对象</li><li>给对象设置<strong>proto</strong>, 值为构造函数对象的prototype属性值   this.<strong>proto</strong> = Fn.prototype</li><li>执行构造函数体(给对象添加属性/方法)</li></ul></li></ul><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div></p><center><img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:skyblue;font-weight:bold;" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">来我QQ撩我哦👇</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/js-advance/js-advance-three/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hotkey-listary</title>
      <link>https://shulu520.com/hotkey/hotkey-listary/</link>
      <guid>https://shulu520.com/hotkey/hotkey-listary/</guid>
      <pubDate>Tue, 28 May 2019 15:21:39 GMT</pubDate>
      <description>
      
        listary最常用的快捷键
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;人生如逆旅，我亦是行人。</p><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><br><a id="more"></a></p><h2 id="listary-最常用的快捷键"><a href="#listary-最常用的快捷键" class="headerlink" title="listary 最常用的快捷键"></a>listary 最常用的快捷键</h2><ul><li>alt A 打开listary</li><li><p>双击 ctrl 打开listary</p></li><li><p>bing 必应搜索</p></li><li>bd 百度一下 百度网盘</li><li><p>zh 知乎搜索</p></li><li><p>ctrl N 向下切换选中的目录</p></li><li><p>ctrl P 向上切换选中的目录</p></li><li><p>双击桌面 打开listary选项</p></li><li>在任意文件夹/目录下双击 打开listary选项 可以选命令打开cmd</li></ul><p><div style="width:100%;height:1px;background-color:pink"></div><br>&emsp;&emsp;未完待续……</p><center><img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:skyblue;font-weight:bold;" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">来我QQ撩我哦👇</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/hotkey/hotkey-listary/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hotkey-windows</title>
      <link>https://shulu520.com/hotkey/hotkey-windows/</link>
      <guid>https://shulu520.com/hotkey/hotkey-windows/</guid>
      <pubDate>Mon, 27 May 2019 04:24:05 GMT</pubDate>
      <description>
      
        windows 最常用快捷键总结
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;</p><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decoration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">Q我吧</a></center><a id="more"></a><h2 id="windows-最常用快捷键"><a href="#windows-最常用快捷键" class="headerlink" title="windows 最常用快捷键"></a>windows 最常用快捷键</h2><ul><li><p>ctrl  w  关闭当前网页</p></li><li><p>f2键 ：选中后按f2键即可重命名文件，另一种方法，点一下文件名，稍等，再点一下，即可重命名</p></li><li><p>f4: 重复上步操作</p></li><li><p>f5: 刷新桌面 刷新网页</p></li><li><p>f11: 全屏显示网页</p></li><li><p>shift :<br>  省略号    shift + 数字6  （表示六个点）    ……</p><p>  书名号     shift + &lt;&gt;   (小于大于）</p></li><li><p>分隔号   单独按 数字1 前面的键    《简 · 爱》</p></li><li><p>Alt + 单击拖动  为矩形选择</p></li><li><p>AlT + f4 关闭当前程序</p></li><li><p>删除  选中后 按delete </p></li><li><p>永久删除  选中后  shift +delete</p></li><li><p>截屏   PrtSc     截全屏<br>  Alt  +PrtSc  截当前窗口</p></li><li><p>ctrl alt delete 任务管理器</p></li><li><p>windows 打开开始菜单</p></li><li><p>ctrl shift n  新建文件夹</p></li><li><p>window e 打开文件资源管理器</p></li><li><p>alt tab 切换窗口 </p></li><li><p>window d 回到桌面</p></li></ul><hr><p>&emsp;&emsp;学到了再来补充😝</p><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decoration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">点这里，进入QQ交流</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/hotkey/hotkey-windows/#disqus_thread</comments>
    </item>
    
    <item>
      <title>js-advance-two</title>
      <link>https://shulu520.com/js-advance/js-advance-two/</link>
      <guid>https://shulu520.com/js-advance/js-advance-two/</guid>
      <pubDate>Sat, 25 May 2019 15:06:08 GMT</pubDate>
      <description>
      
        guigu js 高级教程笔记②——函数高级
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;又是元气满满的一天😝,文章链接失效，又好了。有惊无险</p><center><img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:skyblue;font-weight:bold;" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">来我QQ撩我哦👇</a></center><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div></p><h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><ul><li>所有函数都有一个特别的属性:<ul><li><strong>prototype</strong> : 显式原型属性</li></ul></li><li>所有实例对象都有一个特别的属性:<ul><li><strong><strong>proto</strong></strong> : 隐式原型属性</li></ul></li></ul><p><img src="https://www.z4a.net/images/2019/05/27/20190526235616.png" alt="原型链图"></p><ul><li>当然所有函数也都有一个特别的属性：<ul><li><strong><strong>proto</strong></strong> : 隐式原型属性</li></ul></li><li>且所有函数的 隐式原型 都一样 都等于Function的显式原型 </li><li>函数的显式原型指向的对象默认是空Object实例对象(但Object不满足)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(Fn.prototype instanceof Object) // true</span><br><span class="line">console.log(Object.prototype instanceof Object) // false</span><br><span class="line">console.log(Function.prototype instanceof Object) // true</span><br></pre></td></tr></table></figure><ul><li>所有函数都是Function的实例(包含Function自身)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Function.__proto__===Function.prototype)</span><br></pre></td></tr></table></figure><ul><li>Object的原型对象是原型链尽头</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.__proto__) // null</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)</span><br><span class="line">console.log(Date.prototype, typeof Date.prototype)</span><br><span class="line">function Fun () &#123;//alt + shift +r(重命名rename)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(Fun.prototype)  // 默认指向一个Object空对象(没有我们的属性)</span><br><span class="line"></span><br><span class="line">// 原型对象中有一个属性constructor, 它指向函数对象</span><br><span class="line">console.log(Date.prototype.constructor===Date)</span><br><span class="line">console.log(Fun.prototype.constructor===Fun)</span><br><span class="line"></span><br><span class="line">//给原型对象添加属性(一般是方法) ===&gt;实例对象可以访问</span><br><span class="line">Fun.prototype.test = function () &#123;</span><br><span class="line">  console.log(&apos;test()&apos;)</span><br><span class="line">&#125;</span><br><span class="line">var fun = new Fun()</span><br><span class="line">fun.test()</span><br></pre></td></tr></table></figure><ul><li>显式原型与隐式原型的关系<ul><li>函数的prototype: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象</li><li>实例对象的<strong>proto</strong>: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值</li><li>原型对象即为当前实例对象的父对象</li></ul></li><li><p>原型链</p><ul><li>所有的实例对象都有<strong>proto</strong>属性, 它指向的就是原型对象</li><li>这样通过<strong>proto</strong>属性就形成了一个链的结构—-&gt;原型链</li><li>当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找</li><li>当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作,如果当前对象中没有此属性, 直接添加此属性并设置其值</li><li>方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上</li></ul></li><li><p>面试题1</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function A () &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.n = 1</span><br><span class="line"></span><br><span class="line">var b = new A()</span><br><span class="line"></span><br><span class="line">A.prototype = &#123;</span><br><span class="line">  n: 2,</span><br><span class="line">  m: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c = new A()</span><br><span class="line">console.log(b.n, b.m, c.n, c.m) // 1  undifind  2  3</span><br></pre></td></tr></table></figure><ul><li>面试题2</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function F ()&#123;&#125;</span><br><span class="line">  Object.prototype.a = function()&#123;</span><br><span class="line">    console.log(&apos;a()&apos;)</span><br><span class="line">&#125;</span><br><span class="line">Function.prototype.b = function()&#123;</span><br><span class="line">  console.log(&apos;b()&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f = new F()</span><br><span class="line"></span><br><span class="line">f.a()</span><br><span class="line"></span><br><span class="line">f.b() // 找不到,可以看原型链图进行分析</span><br><span class="line"></span><br><span class="line">F.a()</span><br><span class="line">F.b()</span><br></pre></td></tr></table></figure><ul><li>instanceof是如何判断的?<ul><li>表达式: A instanceof B</li><li>如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false</li></ul></li><li>Function是通过new自己产生的实例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">案例1</span><br><span class="line"> */</span><br><span class="line">function Foo() &#123;  &#125;</span><br><span class="line">var f1 = new Foo()</span><br><span class="line">console.log(f1 instanceof Foo) // true</span><br><span class="line">console.log(f1 instanceof Object) // true</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">案例2</span><br><span class="line"> */</span><br><span class="line">console.log(Object instanceof Function) // true</span><br><span class="line">console.log(Object instanceof Object) // true</span><br><span class="line">console.log(Function instanceof Function) // true</span><br><span class="line">console.log(Function instanceof Object) // true</span><br><span class="line"></span><br><span class="line">function Foo() &#123;&#125;</span><br><span class="line">console.log(Object instanceof  Foo) // false</span><br></pre></td></tr></table></figure><h2 id="执行上下文与执行上下文栈"><a href="#执行上下文与执行上下文栈" class="headerlink" title="执行上下文与执行上下文栈"></a>执行上下文与执行上下文栈</h2><ul><li>变量提升与函数提升<ul><li>变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined)</li><li>函数提升: 在函数定义语句之前, 就执行该函数</li><li><strong>先执行变量提升, 再执行函数提升</strong></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;&#125;</span><br><span class="line">var a</span><br><span class="line">console.log(typeof a) // &apos;function&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var c = 1</span><br><span class="line">function c(c) &#123;</span><br><span class="line">  console.log(c)</span><br><span class="line">  var c = 3</span><br><span class="line">&#125;</span><br><span class="line">c(2) // 报错 c is not a function</span><br><span class="line"></span><br><span class="line">过程解析：</span><br><span class="line">  var c</span><br><span class="line">  fun c</span><br><span class="line">  c = 1</span><br><span class="line">  c(2)</span><br></pre></td></tr></table></figure><ul><li>理解<ul><li>执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性</li><li>执行上下文栈: 用来管理产生的多个执行上下文</li></ul></li><li>分类:<ul><li>全局: window</li><li>函数: 对程序员来说是透明的</li></ul></li><li>生命周期<ul><li>全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡</li><li>函数 : 调用函数时产生, 函数执行完时死亡</li></ul></li><li>包含哪些属性:<ul><li>全局 : <ul><li>用var定义的全局变量  ==&gt;undefined</li><li>使用function声明的函数   ===&gt;function</li><li>this   ===&gt;window</li></ul></li><li>函数<ul><li>用var定义的局部变量  ==&gt;undefined</li><li>使用function声明的函数   ===&gt;function</li><li>this   ===&gt; 调用函数的对象, 如果没有指定就是window </li><li>形参变量   ===&gt;对应实参值</li><li>arguments ===&gt;实参列表的伪数组</li></ul></li></ul></li><li>执行上下文 创建和初始化的过程</li><li>全局执行上下文:<ul><li>在全局代码执行前最先创建一个全局执行上下文(window)</li><li>收集一些全局变量, 并初始化<ul><li>var定义的全局变量==&gt;undefined, 添加为window的属性</li><li>function声明的全局函数==&gt;赋值(fun), 添加为window的方法</li></ul></li><li>this==&gt;赋值(<strong>window</strong>)</li><li>开始执行全局代码</li></ul></li><li>函数执行上下文:<ul><li>在调用函数时, 在执行函数体之前，先创建一个函数执行上下文对象(虚拟的, 存在于栈中)</li><li>收集一些局部变量, 并初始化<ul><li>形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性</li><li>arguments==&gt;赋值(实参列表), 添加为执行上下文的属性</li><li>var定义的局部变量==&gt;undefined, 添加为执行上下文的属性</li><li>function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法</li></ul></li><li>this==&gt;赋值(<strong>调用函数的对象</strong>)</li><li>开始执行函数体代码</li></ul></li><li>执行上下文栈<ul><li>在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象</li><li>在全局执行上下文(window)确定后, 将其添加到栈中(压栈)</li><li>在函数执行上下文创建后, 将其添加到栈中(压栈)</li><li>在当前函数执行完后,将栈顶的对象移除(出栈)</li><li>当所有的代码执行完后, 栈中只剩下window</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = 10</span><br><span class="line">var bar = function (x) &#123;</span><br><span class="line">  var b = 5</span><br><span class="line">  foo(x + b)</span><br><span class="line">&#125;</span><br><span class="line">var foo = function (y) &#123;</span><br><span class="line">  var c = 5</span><br><span class="line">  console.log(a + c + y)</span><br><span class="line">&#125;</span><br><span class="line">bar(10)</span><br></pre></td></tr></table></figure><p><img src="https://www.z4a.net/images/2019/05/27/20190527165142.md.png" alt="执行上下文栈图"></p><ul><li><p><strong>产生执行上下文的个数</strong> = (N)函数调用次数 + 1</p></li><li><p>面试题</p></li><li>整个过程中产生了几个执行上下文?  5</li><li>依次输出什么?<br>  gb: undefined<br>  fb: 1<br>  fb: 2<br>  fb: 3<br>  fe: 3<br>  fe: 2<br>  fe: 1<br>  ge: 1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;gb: &apos;+ i)</span><br><span class="line">var i = 1</span><br><span class="line">foo(1)</span><br><span class="line">function foo(i) &#123;</span><br><span class="line">  if (i == 4) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&apos;fb:&apos; + i)</span><br><span class="line">  foo(i + 1) // 递归调用: 在函数内部调用自己</span><br><span class="line">  console.log(&apos;fe:&apos; + i)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&apos;ge: &apos; + i)</span><br></pre></td></tr></table></figure><h2 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h2><ul><li>理解:<ul><li>作用域: 一块代码区域, 在编码时就确定了, 不会再变化</li><li>作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量</li><li><strong>产生作用域的个数</strong> = (N)定义函数的个数 + 1</li></ul></li><li>分类:<ul><li>全局</li><li>函数</li><li>js没有块作用域(在ES6之前)</li></ul></li><li>作用<ul><li>作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突</li><li>作用域链: 查找变量</li></ul></li><li><p>区别作用域与执行上下文</p><ul><li>作用域: <strong>静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了</strong></li><li>执行上下文: <strong>动态的, 执行代码时动态创建, 当执行结束消失</strong></li><li>联系: 执行上下文环境是在对应的作用域中的</li></ul></li><li><p>面试题</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var x = 10;</span><br><span class="line"></span><br><span class="line">  function fn() &#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function show(f) &#123;</span><br><span class="line">    var x = 20;</span><br><span class="line">    f();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  show(fn); // 10 </span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">    解析：作用域在函数创建的时候就确定了，一旦确定就不会变化了</span><br><span class="line">  */</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var fn = function () &#123;</span><br><span class="line">    console.log(fn)</span><br><span class="line">  &#125;</span><br><span class="line">  fn() // fn函数体</span><br><span class="line"></span><br><span class="line">  var obj = &#123;</span><br><span class="line">    fn2: function () &#123;</span><br><span class="line">     console.log(fn2)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  obj.fn2() // fn2 is not defind</span><br><span class="line">  /*</span><br><span class="line">    解析：</span><br><span class="line">      首先在fn2函数作用域里面找fn2 没有  </span><br><span class="line">      然后再全局作用域找 也没有 故报错</span><br><span class="line">      若为this.fn2 则可以</span><br><span class="line">  */</span><br></pre></td></tr></table></figure><h2 id="作用域链和原型链的用处"><a href="#作用域链和原型链的用处" class="headerlink" title="作用域链和原型链的用处"></a>作用域链和原型链的用处</h2><ul><li>作用域链用来找变量</li><li><p>原型链用来找方法</p></li><li><p>在全局直接找一个不存在的方法 a is not defined</p></li><li>而通过window.a 则为undifind</li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul><li><p>如何产生闭包?</p><ul><li>当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包</li></ul></li><li><p><strong>闭包到底是什么</strong>?</p><ul><li>使用chrome调试查看 会调试的程序员至少不是初级程序员</li><li>理解一: 闭包是嵌套的内部函数(绝大部分人) 初步认识</li><li>理解二: <strong>包含被引用变量(函数)的对象</strong>(极少数人) 高级认识</li><li>注意: 闭包存在于嵌套的内部函数中</li></ul></li><li><p>产生闭包的条件</p><ul><li>函数嵌套</li><li>内部函数引用了外部函数的数据(变量/函数)</li></ul></li><li><p>产生闭包的个数</p><ul><li>等于外部函数调用的次数</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//三个button按钮</span><br><span class="line">for (var i = 0,length=btns.length; i &lt; length; i++) &#123;</span><br><span class="line">    (function (j) &#123;</span><br><span class="line">      var btn = btns[j]</span><br><span class="line">      btn.onclick = function () &#123;</span><br><span class="line">        alert(&apos;第&apos;+(j+1)+&apos;个&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">  &#125;</span><br><span class="line">// 共产生三个闭包 因为外部函数共调用了三次，每一闭包内部都保存了各自的变量</span><br></pre></td></tr></table></figure><ul><li><p>常见的闭包</p><ul><li>将函数作为另一个函数的返回值</li><li>将函数作为实参传递给另一个函数调用</li></ul></li><li><p>闭包生命周期</p><ul><li>产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)</li><li>死亡: 在嵌套的内部函数成为垃圾对象时</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fn1() &#123;</span><br><span class="line">  //此时闭包就已经产生了(函数提升, 内部函数对象已经创建了)</span><br><span class="line">  var a = 2</span><br><span class="line">  function fn2 () &#123;</span><br><span class="line">    a++</span><br><span class="line">    console.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  return fn2</span><br><span class="line">&#125;</span><br><span class="line">var f = fn1() //f来接收fn2</span><br><span class="line">f() // 3</span><br><span class="line">f() // 4</span><br><span class="line">f = null //闭包死亡(包含闭包的函数对象成为垃圾对象)</span><br></pre></td></tr></table></figure><ul><li>作用:<ul><li>延长局部变量的生命周期</li><li>让函数外部能操作内部的局部变量</li></ul></li><li>写一个闭包程序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function fn1() &#123;</span><br><span class="line">  var a = 2</span><br><span class="line">  function fn2() &#123;</span><br><span class="line">    a++</span><br><span class="line">    console.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  return fn2</span><br><span class="line">&#125;</span><br><span class="line">var f = fn1()</span><br><span class="line">f()</span><br><span class="line">f()</span><br></pre></td></tr></table></figure><ul><li>闭包应用:<ul><li>模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为</li><li>循环遍历加监听</li><li>JS框架(jQuery)大量使用了闭包</li></ul></li><li>缺点:<ul><li>变量占用内存的时间可能会过长</li><li>可能导致内存泄露</li><li>解决:<ul><li><strong>及时释放</strong> : f = null; //让内部函数对象成为垃圾对象</li></ul></li></ul></li></ul><ul><li>面试题1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//代码片段一</span><br><span class="line">var name = &quot;The Window&quot;;</span><br><span class="line">var object = &#123;</span><br><span class="line">  name : &quot;My Object&quot;,</span><br><span class="line">  getNameFunc : function()&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">      return this.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()());  // the window</span><br><span class="line"></span><br><span class="line">//代码片段二</span><br><span class="line">var name2 = &quot;The Window&quot;;</span><br><span class="line">var object2 = &#123;</span><br><span class="line">  name2 : &quot;My Object&quot;,</span><br><span class="line">  getNameFunc : function()&#123;</span><br><span class="line">    var that = this;</span><br><span class="line">    return function()&#123;</span><br><span class="line">      return that.name2;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object2.getNameFunc()()); // my object</span><br></pre></td></tr></table></figure><h2 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h2><ul><li>内存溢出<ul><li>一种程序运行出现的错误</li><li>当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误</li></ul></li><li>内存泄露<ul><li>占用的内存没有及时释放</li><li><strong>内存泄露积累多了就容易导致内存溢出</strong></li></ul></li><li>常见的内存泄露:<ul><li>意外的全局变量</li><li>没有及时清理的计时器或回调函数</li><li>闭包</li></ul></li></ul><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div>  </p><center>&gt;<img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:hotpink;font-weight:bold;text-decoration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">👉点这里，进入QQ交流</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/js-advance/js-advance-two/#disqus_thread</comments>
    </item>
    
    <item>
      <title>js-advance-one</title>
      <link>https://shulu520.com/js-advance/js-advance-one/</link>
      <guid>https://shulu520.com/js-advance/js-advance-one/</guid>
      <pubDate>Fri, 24 May 2019 06:13:53 GMT</pubDate>
      <description>
      
        guigu js 高级教程笔记①——基础总结深入
      
      </description>
      
      <content:encoded><![CDATA[<center>能够让你后悔的<br><br><center>从来不是你做过的事<br><br><center>而是你想做却没有去做的事<br><br><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decoration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">Q我吧</a></center><a id="more"></a><h2 id="数据类型的分类和判断"><a href="#数据类型的分类和判断" class="headerlink" title="数据类型的分类和判断"></a>数据类型的分类和判断</h2><ul><li>基本(值)类型<ul><li>Number —– 任意数值 ——– typeof</li><li>String —– 任意字符串 —— typeof</li><li>Boolean —- true/false —– typeof</li><li>undefined — undefined —– typeof/===</li><li>null ——– null ———- ===</li></ul></li><li>对象(引用)类型<ul><li>Object  —– 任意对象  —– typeof/instanceof</li><li>Array —— 一种特别的对象(数值下标)—– instanceof</li><li>Function —- 一种特别的对象(可以执行，内部数据是有序的) —– typeof</li></ul></li><li>判断 <ul><li>typeof ——– 返回数据类型的<code>字符串表达</code><ul><li><code>不能判断</code> null和object ， object和array</li></ul></li><li>instanceof —- 判断<code>对象的具体类型</code><ul><li>a instanceof b 即a是否是b构造函数的一个实例</li></ul></li><li>=== ———— <code>可以判断</code> undefined 和 null</li></ul></li><li>名词解释<ul><li>实例 实例对象</li><li>类型 类型对象 即构造函数</li></ul></li><li>undefined与null的区别?<ul><li>undefined代表定义未赋值</li><li>nulll定义并赋值了, 只是值为null</li></ul></li><li>什么时候给变量赋值为null呢?<ul><li>初始赋值, 表明将要赋值为对象</li><li>结束前, 让对象成为垃圾对象(被垃圾回收器回收)</li></ul></li><li>严格区别变量类型与数据类型?<ul><li>数据的类型<ul><li>基本类型</li><li>对象类型</li></ul></li><li>变量的类型(变量内存值的类型)<ul><li>基本类型: 保存就是基本类型的数据</li><li>引用类型: 保存的是地址值</li></ul></li></ul></li></ul><h2 id="数据-变量-内存的理解"><a href="#数据-变量-内存的理解" class="headerlink" title="数据,变量, 内存的理解"></a>数据,变量, 内存的理解</h2><ul><li>什么是数据?<ul><li>在内存中可读的, 可传递的保存了特定信息的’东东’</li><li>一切皆数据, 函数也是数据</li><li>在内存中的所有操作的目标: 数据</li></ul></li><li>什么是变量?<ul><li>在程序运行过程中它的值是允许改变的量</li><li>一个变量对应一块小内存, 它的值保存在此内存中  </li></ul></li><li>什么是内存?<ul><li>内存条通电后产生的存储空间(临时的)</li><li>一块内存包含2个方面的数据<ul><li>内部存储的数据</li><li>地址值数据</li></ul></li><li>内存空间的分类<ul><li>栈空间: 全局变量和局部变量</li><li>堆空间: 对象 </li></ul></li></ul></li><li>内存,数据, 变量三者之间的关系<ul><li>内存是容器, 用来存储不同数据</li><li>变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据  </li></ul></li><li>问题: var a = xxx, a内存中到底保存的是什么?<ul><li>xxx是基本数据, 保存的就是这个数据</li><li>xxx是对象, 保存的是对象的地址值</li><li>xxx是一个变量, 保存的xxx的内存内容(可能是基本数据, 也可能是地址值)</li></ul></li><li>关于引用变量赋值问题<ul><li>2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据</li><li>2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象 </li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123; name: &apos;lqy&apos; &#125;</span><br><span class="line"></span><br><span class="line">情形一</span><br><span class="line">function fn1(obj) &#123;</span><br><span class="line">  obj.name = &apos;shulu&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1(obj1)</span><br><span class="line">console.log(obj1.name) // shulu</span><br><span class="line"></span><br><span class="line">情形二</span><br><span class="line">funtion fn2(obj) &#123;</span><br><span class="line">  obj = &#123;name: &apos;shulu&apos;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn2(obj1)</span><br><span class="line">console.log(obj1.name) // lqy</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">解析：</span><br><span class="line">形参obj 在函数内部为 var obj变量</span><br><span class="line">执行fn( ) 传入实参obj1 即将obj1的值(这里是地址值)复制一份给obj变量</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><ul><li>问题: 在js调用函数时传递变量参数时, 是值传递还是引用传递<ul><li>理解1: 都是值(基本值/地址值)传递 <code>推荐</code></li><li>理解2: 可能是值传递, 也可能是引用传递(地址值)</li></ul></li><li>问题: JS引擎如何管理内存?<ul><li>内存生命周期<ul><li>分配小内存空间, 得到它的使用权</li><li>存储数据, 可以反复进行操作</li><li>释放小内存空间</li></ul></li><li>释放内存<ul><li>局部变量: 函数执行完自动释放</li><li>对象: 成为垃圾对象==&gt;垃圾回收器回收</li></ul></li></ul></li></ul><h2 id="对象的理解和使用"><a href="#对象的理解和使用" class="headerlink" title="对象的理解和使用"></a>对象的理解和使用</h2><ul><li>什么是对象?<ul><li>多个数据(属性)的集合</li><li>用来保存多个数据(属性)的容器</li></ul></li><li>属性组成:<ul><li>属性名 : 字符串(标识)</li><li>属性值 : 任意类型</li></ul></li><li>属性的分类:<ul><li>一般 : 属性值不是function  描述对象的状态</li><li>方法 : 属性值为function的属性  描述对象的行为</li></ul></li><li>特别的对象<ul><li>数组: 属性名是0,1,2,3之类的索引</li><li>函数: 可以执行的</li></ul></li><li>如何操作内部属性(方法)<ul><li>.属性名</li><li>[‘属性名’]: 属性名有特殊字符/属性名是一个变量</li></ul></li><li>问题: 什么时候必须使用[‘属性名’]的方式?<ol><li>属性名包含特殊字符: - 空格</li><li>属性名不确定</li></ol></li></ul><h2 id="函数的理解和使用"><a href="#函数的理解和使用" class="headerlink" title="函数的理解和使用"></a>函数的理解和使用</h2><ul><li>什么是函数?<ul><li>用来实现特定功能的, n条语句的封装体</li><li>只有函数类型的数据是可以执行的, 其它的都不可以</li></ul></li><li>为什么要用函数?<ul><li>提高复用性</li><li>便于阅读交流</li></ul></li><li>函数也是对象<ul><li>instanceof Object===true</li><li>函数有属性: prototype</li><li>函数有方法: call()/apply()</li><li>可以添加新的属性/方法</li></ul></li><li>如何调用(执行)函数?<ul><li>test(): 直接调用</li><li>obj.test(): 通过对象调用</li><li>new test(): new调用</li><li>test.call/apply(obj): 临时让test成为obj的方法进行调用</li></ul></li><li>函数中的this是什么?<ul><li>任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window</li><li>所有函数内部都有一个变量this</li><li>它的值是调用函数的当前对象</li></ul></li><li>如何确定this的值?<ul><li>test(): window</li><li>p.test(): p</li><li>var p = new test(): 新创建的对象p</li><li>p.call(obj): obj</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function Person(color) &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line"></span><br><span class="line">    this.color = color;</span><br><span class="line">    this.getColor = function () &#123;</span><br><span class="line">      console.log(this)</span><br><span class="line">      return this.color;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.setColor = function (color) &#123;</span><br><span class="line">      console.log(this)</span><br><span class="line">      this.color = color;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Person(&quot;red&quot;); //this是谁? window</span><br><span class="line"></span><br><span class="line">  var p = new Person(&quot;yello&quot;); //this是谁? p</span><br><span class="line"></span><br><span class="line">  p.getColor(); //this是谁? p</span><br><span class="line"></span><br><span class="line">  var obj = &#123;&#125;;</span><br><span class="line">  p.setColor.call(obj, &quot;black&quot;); //this是谁? obj</span><br><span class="line"></span><br><span class="line">  var test = p.setColor;</span><br><span class="line">  test(); //this是谁? window</span><br><span class="line"></span><br><span class="line">  function fun1() &#123;</span><br><span class="line">    function fun2() &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun2(); //this是谁? window</span><br><span class="line">  &#125;</span><br><span class="line">  fun1();</span><br></pre></td></tr></table></figure><ul><li><p>匿名函数自调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function(w, obj)&#123;</span><br><span class="line">  //实现代码</span><br><span class="line">&#125;)(window, obj)</span><br></pre></td></tr></table></figure><ul><li>专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式 </li><li>作用<ul><li>隐藏实现</li><li>不会污染外部(全局)命名空间</li><li>用它来编码js模块</li></ul></li></ul></li><li><p>回调函数的理解</p><ul><li>什么函数才是回调函数?<ul><li>你定义的</li><li>你没有调用</li><li>但它最终执行了(在一定条件下或某个时刻)</li></ul></li><li>常用的回调函数<ul><li>dom事件回调函数</li><li>定时器回调函数</li><li>ajax请求回调函数(后面讲解)</li><li>生命周期回调函数(后面讲解)</li></ul></li></ul></li><li><p>问题 js一条语句的后面是否应该加分号？</p><ul><li>是否加分号是编码风格问题，没有应不应该，只有喜不喜欢——尤雨溪</li><li>必须加分号的情况：<ul><li>小括号开头的语句 ;(function () {…})()</li><li>方括号的开头 ;[1, 2, 3].forEach(() =&gt; {})</li></ul></li></ul></li></ul><hr><p>&emsp;&emsp;本篇笔记到此完结。</p><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decoration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">点这里，进入QQ交流</a></center></center></center></center>]]></content:encoded>
      
      <comments>https://shulu520.com/js-advance/js-advance-one/#disqus_thread</comments>
    </item>
    
    <item>
      <title>js-modularize</title>
      <link>https://shulu520.com/js-modularize/js-modularize/</link>
      <guid>https://shulu520.com/js-modularize/js-modularize/</guid>
      <pubDate>Thu, 23 May 2019 14:17:24 GMT</pubDate>
      <description>
      
        modularize js模块化历程，硅谷教程总结
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;</p><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">来QQ撩我啊</a></center><a id="more"></a><h2 id="modularize"><a href="#modularize" class="headerlink" title="modularize"></a>modularize</h2><ul><li>一阶段 所有的代码都写在一个文件下 即暴露在全局环境下 污染环境</li><li>二阶段 将某些api 放到一个对象之中 使用时通过obj.xxx来调用 不安全 因为在别处同样可以通过obj.xxx来将其修改掉</li><li>三阶段 匿名函数自执行(闭包)  安全 JQuery 就是这么做的 引入js文件太多 请求过多 依赖模糊</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(function( window )&#123;</span><br><span class="line">  function foo () &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  // 将foo方法挂载到window上的xxx属性对象上</span><br><span class="line">  // 调用时xxx.foo()即可</span><br><span class="line">  window.xxx = &#123; foo &#125;</span><br><span class="line"></span><br><span class="line">  // 或将foo方法挂载到window上的xxx属性对象上，作为一个函数</span><br><span class="line">  // 调用时直接foo()执行即可</span><br><span class="line">  window.xxx = foo </span><br><span class="line">&#125;)( window )</span><br></pre></td></tr></table></figure><h2 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h2><h3 id="commonJs"><a href="#commonJs" class="headerlink" title="commonJs"></a>commonJs</h3><ul><li>一个js文件就是一个模块</li><li>向外暴露1 module.exports = value  value可以是任意值</li><li>向外暴露2 exports.xxx = value  value可以是任意值</li><li>引入模块 require(‘包名’) 自己写的文件要相对路劲</li></ul><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><ul><li>define</li></ul><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><ul><li>阿里大牛结合commonjs和AMD写的 卖给老外了</li></ul><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><ul><li><p>webpack 模块打包工具</p></li><li><p>分别暴露 即常规暴露<br>相当于一个模块中有许多个变量<br>export xxx = …<br>export yyy = …<br>export zzz = …</p></li><li><p>引入时要解构赋值 指名道姓拿到相应的变量<br>import { xxx, yyy, zzz } from ‘路劲’</p></li><li><p>统一暴露 默认暴露<br>export default {…}</p></li><li><p>引入时 import xxx from ‘路劲’</p></li></ul><hr><p>&emsp;&emsp;未完待续……</p><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">点这里，跟我聊QQ</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/js-modularize/js-modularize/#disqus_thread</comments>
    </item>
    
    <item>
      <title>IT-proper-nouns</title>
      <link>https://shulu520.com/IT/IT-proper-nouns/</link>
      <guid>https://shulu520.com/IT/IT-proper-nouns/</guid>
      <pubDate>Thu, 23 May 2019 14:02:57 GMT</pubDate>
      <description>
      
        IT-proper-nouns it编程专有名词解释
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;</p><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decoration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">来QQ撩我啊</a></center><a id="more"></a><h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><ul><li>应用程序接口(Application Programming Interface)</li></ul><h2 id="cli"><a href="#cli" class="headerlink" title="cli"></a>cli</h2><ul><li>命令行界面(Command Line Interface)</li></ul><h2 id="sdk"><a href="#sdk" class="headerlink" title="sdk"></a>sdk</h2><ul><li>软件开发工具包(Software Development Kit)</li></ul><h2 id="rc-结尾的文件"><a href="#rc-结尾的文件" class="headerlink" title="rc 结尾的文件"></a>rc 结尾的文件</h2><ul><li>run control 运行时控制文件</li></ul><hr><p>&emsp;&emsp;未完待续……</p><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decoration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">点这里，跟我QQ聊天呗</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/IT/IT-proper-nouns/#disqus_thread</comments>
    </item>
    
    <item>
      <title>node-koa2</title>
      <link>https://shulu520.com/node/node-koa2/</link>
      <guid>https://shulu520.com/node/node-koa2/</guid>
      <pubDate>Tue, 21 May 2019 17:54:24 GMT</pubDate>
      <description>
      
        nodejs+koa2电影预告片
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;hello my world<br><a id="more"></a></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ul><li>github创建仓库</li><li>本地git clone 仓库</li><li>项目目录下 初始化 npm init<h2 id="npm-start-启动快捷方法"><a href="#npm-start-启动快捷方法" class="headerlink" title="npm start 启动快捷方法"></a>npm start 启动快捷方法</h2></li><li>在package.json 中添加配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;node server/index.js&quot;,</span><br></pre></td></tr></table></figure><ul><li>添加 .gitignore 文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># dependencies</span><br><span class="line">node_modules</span><br><span class="line"></span><br><span class="line"># logs</span><br><span class="line">npm-debug.log</span><br><span class="line"></span><br><span class="line"># System</span><br><span class="line">.DS_Store</span><br><span class="line"></span><br><span class="line">#Generate</span><br><span class="line">dist</span><br><span class="line"></span><br><span class="line"># Build</span><br><span class="line">bulid</span><br></pre></td></tr></table></figure><h2 id="pug-模板引擎"><a href="#pug-模板引擎" class="headerlink" title="pug 模板引擎"></a>pug 模板引擎</h2><p>npm i pug -S</p><hr><p>&emsp;&emsp;未完待续……</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/node/node-koa2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>async-fn-note</title>
      <link>https://shulu520.com/uncategorized/async-fn-note/</link>
      <guid>https://shulu520.com/uncategorized/async-fn-note/</guid>
      <pubDate>Mon, 20 May 2019 02:00:01 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp;&amp;emsp;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;</p><a id="more"></a><p>正文：</p><hr><p>&emsp;&emsp;</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/uncategorized/async-fn-note/#disqus_thread</comments>
    </item>
    
    <item>
      <title>arrow-js-note</title>
      <link>https://shulu520.com/arrowjs/arrow-js-note/</link>
      <guid>https://shulu520.com/arrowjs/arrow-js-note/</guid>
      <pubDate>Sun, 19 May 2019 16:11:45 GMT</pubDate>
      <description>
      
        箭头函数相关知识总结
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;今天是2019年，520，在这特殊的一天我面对的依然是code, but no Object, 我希望有一天能美梦成真——面向对象面向君，不负代码不负卿。</p><a id="more"></a><h2 id="箭头函数的经典题型"><a href="#箭头函数的经典题型" class="headerlink" title="箭头函数的经典题型"></a>箭头函数的经典题型</h2><ul><li>有关 this</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  id: 01,</span><br><span class="line">  say: function () &#123;</span><br><span class="line">    // 这里的this为obj</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      // 这里是匿名函数的this默认为window</span><br><span class="line">      console.log(&apos;arrow id:&apos;, this.id); // undifind</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;,</span><br><span class="line">  sayWithThis: function () &#123;</span><br><span class="line">    // 这里将this的值当成变量存起来</span><br><span class="line">    let that = this;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(&apos;arrow id:&apos;, that.id); // 01</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;,</span><br><span class="line">  sayWithArrow: function () &#123;</span><br><span class="line">    // 这里的this为obj</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(&apos;arrow id:&apos;, this.id); // 01</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;,</span><br><span class="line">  sayWithGlobalArrow: () =&gt; &#123;</span><br><span class="line">    // 这里的this已经为全局的this了</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(&apos;arrow id:&apos;, this.id); // undifind</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>&emsp;&emsp;未完待续……</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/arrowjs/arrow-js-note/#disqus_thread</comments>
    </item>
    
    <item>
      <title>git-qa-note</title>
      <link>https://shulu520.com/git/git-qa-note/</link>
      <guid>https://shulu520.com/git/git-qa-note/</guid>
      <pubDate>Sat, 18 May 2019 04:11:06 GMT</pubDate>
      <description>
      
        在git的使用中遇到的问题&amp;解决方法
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;<br><a id="more"></a></p><h2 id="科学上网之后，git-报错"><a href="#科学上网之后，git-报错" class="headerlink" title="科学上网之后，git 报错"></a>科学上网之后，git 报错</h2><ul><li>如下错误：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh: Could not resolve hostname github.com: Name or service not known</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure><ul><li>解决方法<br>1、找到本机的 host 文件，一般位置是进入 C:\Windows\System32\drivers\etc</li></ul><p>2、在host文件的最后一行加上，如果之前已经设置过，可以将ip地址更改为最新的正确的ip地址</p><p>192.30.255.112  github.com git<br>185.31.16.184   github.global.ssl.fastly.net</p><hr><p>&emsp;&emsp;遇到后继续补充……</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/git/git-qa-note/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Array-note</title>
      <link>https://shulu520.com/Array/Array-note/</link>
      <guid>https://shulu520.com/Array/Array-note/</guid>
      <pubDate>Fri, 17 May 2019 16:41:04 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp;&amp;emsp;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;</p><a id="more"></a><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><ul><li>计算数组成员的个数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const countOccurrences = (arr,val) =&gt; arr.reduce((a,v) =&gt; (v === val ? a + 1 : a), 0)</span><br><span class="line"></span><br><span class="line">alert(countOccurrences([1,111,2,2,2,3,4], 2)); // 3</span><br></pre></td></tr></table></figure><h2 id="max"><a href="#max" class="headerlink" title="max"></a>max</h2><ul><li>Math.max.apply(null, arr)</li><li>Math.max(…arr)</li></ul><p>&emsp;&emsp;未完待续……</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/Array/Array-note/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>梦不成</title>
    <link>https://shulu520.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>君子生非异也，善假于物也.</description>
    <pubDate>Mon, 10 Jun 2019 15:38:05 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Promise-zhuf</title>
      <link>https://shulu520.com/Promise/Promise-zhuf/</link>
      <guid>https://shulu520.com/Promise/Promise-zhuf/</guid>
      <pubDate>Mon, 10 Jun 2019 13:26:00 GMT</pubDate>
      <description>
      
        珠峰2018-node&amp;Promise教程笔记
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;</p><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><br><a id="more"></a></p><h2 id="js执行顺序优先级"><a href="#js执行顺序优先级" class="headerlink" title="js执行顺序优先级"></a>js执行顺序优先级</h2><ul><li>scncfunction –&gt; micro task –&gt; macro task<ul><li>同步代码 scncfunction</li><li>微任务   micro task</li><li>宏任务   macro task</li></ul></li></ul><h2 id="微任务-micro-task"><a href="#微任务-micro-task" class="headerlink" title="微任务 micro task"></a>微任务 micro task</h2><ul><li>Process.nextTick<ul><li>把当前任务放到主栈的最后执行</li></ul></li><li>Promise(async await)</li></ul><h2 id="宏任务-macro-task"><a href="#宏任务-macro-task" class="headerlink" title="宏任务 macro task"></a>宏任务 macro task</h2><ul><li>回调函数</li><li>ajax</li><li>事件绑定</li><li>node 中的 fs</li><li>三种定时器<ul><li>setImmediate (nodejs独有)</li><li>setTimeout</li><li>setInterval</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setImmediate (() =&gt; &#123;</span><br><span class="line">  console.log(&apos;shulu&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><ul><li>三种状态 进行中 成功 失败</li><li>Promise.all([promise1, promise2, promise3]).then(() =&gt; {……}).catch(){……} 即promise1,2,3都成功则执行then的成功方法，有一个失败则走catch方法。</li><li></li></ul><h2 id="es6-class-类"><a href="#es6-class-类" class="headerlink" title="es6 class 类"></a>es6 class 类</h2><ul><li>class 的本质是 function。</li><li>在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。</li><li>它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法</li><li>constructor 方法是类的默认方法，创建类的实例化对象时被调用</li><li>class 的实例化必须通过 new 关键字。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Promise &#123;</span><br><span class="line"></span><br><span class="line">  //constructor 创建类的实例化对象时被调用</span><br><span class="line">  constructor () &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //这里写原型上的方法</span><br><span class="line">  then()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div></p><center><img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:skyblue;font-weight:bold;" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">有事您Q我👇</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/Promise/Promise-zhuf/#disqus_thread</comments>
    </item>
    
    <item>
      <title>git-linux</title>
      <link>https://shulu520.com/git/git-linux/</link>
      <guid>https://shulu520.com/git/git-linux/</guid>
      <pubDate>Sun, 09 Jun 2019 03:23:05 GMT</pubDate>
      <description>
      
        Linux常用命令,以及git的使用,git是linux团队开发的，故其中使用的命令都是linux命令。
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;终有一天，我会出现在你的眼前。<br><a id="more"></a></p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><br><center>个人本地操作篇</center><br><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><h2 id="显示目录或文件"><a href="#显示目录或文件" class="headerlink" title="显示目录或文件"></a>显示目录或文件</h2><ul><li>ls -s / ls -a<ul><li>-s 文件列表</li><li>-a 包括隐藏文件</li></ul></li></ul><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><ul><li>cd /</li><li>cd ../</li><li>可以直接拖动文件进入目录</li></ul><h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><ul><li>mkdir + shulu</li></ul><h2 id="创建空文件"><a href="#创建空文件" class="headerlink" title="创建空文件"></a>创建空文件</h2><ul><li>touch + lqy</li></ul><h2 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h2><ul><li>方式一<ul><li>vim/vi + lqy</li><li>A或I 键进入插入模式</li><li>编辑完成后 Esc 然后:wq 即可保存退出</li></ul></li></ul><ul><li>方式二<ul><li>向指定的文件输入内容</li><li>echo xxx &gt; shulu.txt </li><li>shulu.txt若不存在则创建</li><li>每次编辑都会覆盖之前的内容</li></ul></li></ul><h2 id="查看文件中的内容"><a href="#查看文件中的内容" class="headerlink" title="查看文件中的内容"></a>查看文件中的内容</h2><ul><li>cat lqy</li></ul><h2 id="删除文件或文件夹"><a href="#删除文件或文件夹" class="headerlink" title="删除文件或文件夹"></a>删除文件或文件夹</h2><ul><li><strong>一旦删除 不可恢复</strong></li><li>rm + name -rf<ul><li>-r 递归删除</li><li>-f 强制删除</li><li>-rf 以上二者都有</li></ul></li></ul><h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><ul><li>查看当前文件处于哪一个区域</li><li>红色：在工作区</li><li>绿色：在暂存区</li><li>看不见：已经提交到历史区，三区保持一致了</li></ul><h2 id="暂存区删除文件操作"><a href="#暂存区删除文件操作" class="headerlink" title="暂存区删除文件操作"></a>暂存区删除文件操作</h2><ul><li>只要新add一下新的内容 即可覆盖前面暂存区不好的代码</li><li>根据提示：<ul><li>(use “git reset HEAD <file>…” to unstage)</file></li><li>即git reset HEAD &lt;要删除的file&gt;</li><li>或git rm –cached &lt;要删除的file&gt;</li></ul></li></ul><h2 id="代码回滚-一-暂存区回滚"><a href="#代码回滚-一-暂存区回滚" class="headerlink" title="代码回滚 一 暂存区回滚"></a>代码回滚 一 暂存区回滚</h2><ul><li>一步回滚操作<ul><li>将暂存区文件撤回来覆盖工作区新写的不好的代码</li><li>git checkout &lt;要撤回的file&gt; (注意 . 表示所有的文件)</li><li>暂存区的文件依然在，只是将其拿出来覆盖新写的不好的代码</li><li>工作区和暂存区 状态保持一致了</li></ul></li><li>两步回滚操作<ul><li>git reset HEAD &lt;要删除的file&gt; 把当前暂存区的内容删掉，此时暂存区的内容为上一次add的内容</li><li>git checkout <file> 将上一次add的内容拿回来覆盖工作区的不好的代码</file></li></ul></li></ul><h2 id="代码回滚-二-历史版本回滚"><a href="#代码回滚-二-历史版本回滚" class="headerlink" title="代码回滚 二 历史版本回滚"></a>代码回滚 二 历史版本回滚</h2><ul><li>git log 版本信息</li><li><strong>若出现了 提交的信息最后有一个end 按Q键即可退出</strong></li><li>git reset –hard &lt;版本id&gt;</li><li>三区保持一致了</li></ul><h2 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h2><ul><li>添加不用git管理的文件</li></ul><h2 id="ctrl-L"><a href="#ctrl-L" class="headerlink" title="ctrl + L"></a>ctrl + L</h2><ul><li>清屏</li></ul><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><br><center>团队协作篇</center><br><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><h2 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h2><ul><li><strong>最好</strong>创建一个README.md文件</li><li>这样远程就会有一个master的分支</li><li>有利于后续的操作</li></ul><p><del>创建本地仓库初始化本地仓库连接远程仓库</del>这操作不常用</p><ul><li>mkdir repository </li><li>git init</li><li>git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:lqyasl/git-zhuf.git</li></ul><h2 id="git-clone-常用"><a href="#git-clone-常用" class="headerlink" title="git clone 常用"></a>git clone 常用</h2><ul><li>一步操作等于以上三步操作</li><li>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:lqyasl/git-zhuf.git</li></ul><h2 id="不同开发者之间的配合"><a href="#不同开发者之间的配合" class="headerlink" title="不同开发者之间的配合"></a>不同开发者之间的配合</h2><ul><li>假设有a b 两个开发者<h2 id="不冲突的情况"><a href="#不冲突的情况" class="headerlink" title="不冲突的情况"></a>不冲突的情况</h2></li><li>a b 两人提交修改的是不同的文件</li><li>提交之前最好git pull origin master 拉取远程仓库的内容</li><li>然后再git push origin master 推送到远程<h2 id="产生冲突的情况"><a href="#产生冲突的情况" class="headerlink" title="产生冲突的情况"></a>产生冲突的情况</h2></li><li>两人同时对相同的文件都做了不一样的修改</li></ul><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><ul><li>若直接弹出vim的内容 正常退出即可 即 输入a 然后按Esc 再按 :wq</li><li>若显示MERGEING 则删掉那些特殊符号 ，修改好后退出</li></ul><h2 id="无分支开发模式"><a href="#无分支开发模式" class="headerlink" title="无分支开发模式"></a>无分支开发模式</h2><ul><li>即只有一个master 分支<h2 id="分支开发模式"><a href="#分支开发模式" class="headerlink" title="分支开发模式"></a>分支开发模式</h2></li><li>新开一个分支即可</li><li>git checkout -b deva</li><li>即可创建一个deva分支 并且切换到这个分支上 </li><li>新创建分支的特点：本地master内容会自动同步到deva分支上 </li><li>在deva分支上完事后</li><li>git add .</li><li>git commit -m ‘……’</li><li>git stash 保存当前的工作进度。会分别对暂存区和工作区的状态进行保存 <strong>关于这一步操作后面有说明</strong></li><li>git checkout master</li><li>git merge deva</li><li>git pull origin master</li><li>git push origin master</li></ul><h2 id="git-stash-amp-git-stash-pop"><a href="#git-stash-amp-git-stash-pop" class="headerlink" title="git stash &amp; git stash pop"></a>git stash &amp; git stash pop</h2><ul><li>git stash 保存当前的工作进度。会分别对暂存区和工作区的状态进行保存.</li><li>git stash pop 恢复工作现场。</li><li><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p></li><li><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交。</p></li><li><p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p></li><li><p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来(<strong>先git add . 到暂存区 然后 git stash 藏起来</strong>)，等以后回来恢复现场后继续工作。</p></li><li>总结：<ul><li>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除bug分支；</li><li>当手头工作没有完成时，先把工作现场git stash一下，然后去bug分支修复bug，修复后，再回到之前的分支git stash pop，将工作现场恢复。</li></ul></li></ul><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div></p><center><img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:skyblue;font-weight:bold;" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">有事您Q我👇</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/git/git-linux/#disqus_thread</comments>
    </item>
    
    <item>
      <title>webpack-mooc</title>
      <link>https://shulu520.com/webpack/webpack-mooc/</link>
      <guid>https://shulu520.com/webpack/webpack-mooc/</guid>
      <pubDate>Sat, 01 Jun 2019 15:54:12 GMT</pubDate>
      <description>
      
        webpack 模块打包工具 慕课教程学习笔记
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;只要有想见的人，就不是孤身一人。</p><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><br><a id="more"></a></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ul><li>node 安装</li><li>webpack 安装</li><li>初始化文件夹 npm init 打包符合node规范的项目</li><li>或 npm init -y 生成默认初始化的文件夹</li><li>全局安装webpack 不推荐 因为各个项目依赖的webpack版本可能不一样</li><li>npm uninstall webpack webpack-cli -g 卸载webpack</li><li>npm install webpack webpack-cli -D 推荐在项目中独立安装</li><li>npm info webpack 打印输出webpack的信息 可以查看你想要的版本是否存在 </li><li>安装你所需要的版本就行了 npm i webpack@版本号 webpack-cli -D</li><li>webpack 默认的打包配置文件为webpack.config.js</li></ul><h2 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h2><ul><li>webpack.config.js初步配置</li><li>新建webpack.config.js文件</li><li>新建src目录 放我们的源代码</li><li>webpack.config.js配置如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//nodejs引入path模块 为commonjs规范</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: development, // 指定运行环境</span><br><span class="line">  entry: &apos;./src/index.js&apos;, // 入口文件</span><br><span class="line">  output: &#123; // 出口文件</span><br><span class="line">    //被编译到你指定的输出路径的文件夹中</span><br><span class="line">    path: path.resolve(_dirname, &apos;dist&apos;), </span><br><span class="line">    filename: &apos;bundle.js&apos; //指定打包生成的文件名字</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>package.json 配置scripts命令 简化命打包令为 npm run bundle</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;bundle&quot;: &quot;webpack&quot; //npm run bundle 执行webpack命令 </span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不同安装的webpack打包形式<ul><li>未配置scripts<br>npx webpack 要打包的文件</li><li>配置scripts后<br>npm run bundle 即可 </li></ul></li></ul><h2 id="配置打包图片"><a href="#配置打包图片" class="headerlink" title="配置打包图片"></a>配置打包图片</h2><ul><li>loader 所谓 loader 只是一个导出为函数的 JavaScript 模块。让 webpack 能够去处理那些非 JavaScript 文件</li><li>(webpack 自身只理解 JavaScript)</li><li>loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，</li><li>然后你就可以利用 webpack 的打包能力，对它们进行处理。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &apos;development&apos;,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &apos;./src/index.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: /\.(jpg|png|gif)$/,//用于标识出应该被对应的 loader 进行转换的某个或某些文件。</span><br><span class="line">      use: &#123;//表示进行转换时，应该使用哪个 loader。</span><br><span class="line">        loader: &apos;url-loader&apos;,</span><br><span class="line">        // loader: &apos;file-loader&apos;,</span><br><span class="line">        options: &#123; //配置项</span><br><span class="line">          name: &apos;[name].[ext]&apos;,//以原来的名字和后缀打包生成文件名</span><br><span class="line">          outputPath: &apos;images/&apos;,//打包生成的文件放到dist/images/</span><br><span class="line">          limit: 2048 //当图片的大小在2kb以下时直接打包成base64的图片嵌入js文件中</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;bundle.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="样式loader"><a href="#样式loader" class="headerlink" title="样式loader"></a>样式loader</h2><ul><li>css-loader 处理各个css文件间的关系</li><li>style-loader 将增加一个style标签并插入css文件然后挂载到head标签中   </li><li>处理sass文件 npm install sass-loader node-sass -D</li><li><strong>loader 的执行顺序 从下到上 从右到左</strong></li><li>处理less文件 首先npm install less –save-dev</li><li>再npm i -D less-loader</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">rules: [&#123;</span><br><span class="line">test: /\.scss$/,</span><br><span class="line">use: [&#123;</span><br><span class="line">loader: &quot;style-loader&quot; // 将 JS 字符串生成为 style 节点</span><br><span class="line">&#125;, &#123;</span><br><span class="line">loader: &quot;css-loader&quot; // 将 CSS 转化成 CommonJS 模块</span><br><span class="line">&#125;, &#123;</span><br><span class="line">loader: &quot;sass-loader&quot; // 将 Sass 编译成 CSS</span><br><span class="line">&#125;]</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动添加前缀loader"><a href="#自动添加前缀loader" class="headerlink" title="自动添加前缀loader"></a>自动添加前缀loader</h2><ul><li>使用Can I Use中的值为CSS规则添加供应商前缀。</li><li>Autoprefixer将使用基于当前浏览器流行度和属性支持的数据为您应用前缀。</li><li>npm i -D postcss-loader</li><li>npm i -D autoprefixer </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//配置新建postcss.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    require(&apos;autoprefixer&apos;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//然后配置webpack.config.js</span><br><span class="line">&#123;</span><br><span class="line">test: /\.css$/,</span><br><span class="line">use: [</span><br><span class="line">&apos;style-loader&apos;,</span><br><span class="line">&#123; loader: &apos;css-loader&apos;, options: &#123; importLoaders: 1 &#125; &#125;,</span><br><span class="line">&apos;postcss-loader&apos;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="css-loader-常用的配置"><a href="#css-loader-常用的配置" class="headerlink" title="css-loader 常用的配置"></a>css-loader 常用的配置</h2><ul><li>当less(sass)等文件中再引入其他的less(sass)文件时，默认是不会打包引入的文件的，</li><li>配置opations 中 importLoaders: 2 后，则会通过’less-loader’, ‘postcss-loader’ 这两个loader的打包</li></ul><hr><p>{<br>    loader: ‘css-loader’,<br>    options: {<br>        importLoaders: 2,<br>        modules: true //模块化<br>    }<br>},<br>‘less-loader’,<br>‘postcss-loader’    </p><hr><h2 id="css-打包的模块化"><a href="#css-打包的模块化" class="headerlink" title="css 打包的模块化"></a>css 打包的模块化</h2><ul><li>模块中需要哪个样式文件 引入即可import style from ‘./avator.less’</li><li>使用:如 img.classList.add(style.avator) 在avator.less样式中自己写的叫avator的classname</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options: &#123;</span><br><span class="line">  modules: true //开启css模块化</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字体的引入iconfont"><a href="#字体的引入iconfont" class="headerlink" title="字体的引入iconfont"></a>字体的引入iconfont</h2><ul><li>file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录。</li><li>这就是说，我们可以将它们用于任何类型的文件，包括字体。</li><li>src/font一般需要 中如下几种正则中的字体文件</li><li>iconfont.css文件，在需要字体的地方引入样式即可</li><li>src: url(‘./font/iconfont.eot?t=155948’)</li><li>url(‘./font/iconfont.ttf?t=155948’)</li><li>其中./font为自己加的路劲 </li><li>其中有个base64格式的路劲不用变</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test: /\.(woff|woff2|eot|ttf|svg)$/,</span><br><span class="line">use: [</span><br><span class="line">&apos;file-loader&apos;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="plugin-插件的使用"><a href="#plugin-插件的使用" class="headerlink" title="plugin 插件的使用"></a>plugin 插件的使用</h2><ul><li>html-webpack-plugin插件的使用</li><li>npm install –save-dev html-webpack-plugin</li><li>HtmlWebpackPlugin 插件的作用：<ul><li>会在打包结束后自动生成一个html文件，并把打包生成的js文件自动引入html文件</li></ul></li><li>plugin的作用：在webpack运行到某个时刻的时候，帮我门做一些在事情 就像vue中的生命周期钩子函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js中</span><br><span class="line">plugins: [</span><br><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">title: &quot;my html template&quot;, //自定义title 默认为webpack app</span><br><span class="line">filename: &quot;myindex.html&quot;, //自定义文件名 默认为index.html</span><br><span class="line">template: &quot;src/index.html&quot; //以此为模板创建html</span><br><span class="line">&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h2><ul><li>清除旧的打包的文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">new CleanWebpackPlugin(),//打包前删除前面旧的dist文件</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">main: &apos;./src/index.js&apos;,</span><br><span class="line">sub: &apos;./src/index.js&apos; //再打包生成一个js文件</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  publicPath: &apos;https://cdn.abc.com&apos;,//公共前缀路劲如cdn</span><br><span class="line">  filename: &apos;[name].js&apos;, //以entry的key值作为打包生成的文件名</span><br><span class="line">  path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="SourceMap"><a href="#SourceMap" class="headerlink" title="SourceMap"></a>SourceMap</h2><ul><li>再打包生成main.js文件之后如果代码里出现错误，它会将main.js中错误出现的地方与源码之间做一映射，告诉我们源码中错误出现在哪里，以便我们快速定位bug出处</li><li>错误代码使用chrome调试工具直接显示在index.js?b635这个文件打开即可看到源码里面错误出现的位置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">devtool: &apos;cheap-module-eval-source-map&apos;,//development模式推荐使用</span><br><span class="line"></span><br><span class="line">devtool: &apos;cheap-module-source-map&apos;,//production模式推荐使用</span><br></pre></td></tr></table></figure><h2 id="使用WebpackDevServer提升开发效率"><a href="#使用WebpackDevServer提升开发效率" class="headerlink" title="使用WebpackDevServer提升开发效率"></a>使用WebpackDevServer提升开发效率</h2><ul><li>npm install webpack-dev-server -D</li><li>在webpack.config.js</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">contentBase: &apos;./dist&apos;,//开启一个服务器运行dist里面的内容</span><br><span class="line">open: true ,//自动在浏览器里打开</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  //vue中就是配置的这样的代理</span><br><span class="line">  proxy: &#123; </span><br><span class="line">    &apos;/api&apos;: &apos;http://localhost:3000&apos;//当用户访问api这个地址时proxy将其转到localhost:3000这个地址</span><br><span class="line">  &#125;,</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">port: 8888//必要时可以自定义端口</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>在 package.json </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">&quot;start&quot;: &quot;webpack-dev-server&quot; //npm run start 开启服务器 自动刷新 目前最常用的 打包生成的dist文件直接放到内存里运行 速度更快</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="HotModuleReplacementPlugin-热模块更新"><a href="#HotModuleReplacementPlugin-热模块更新" class="headerlink" title="HotModuleReplacementPlugin 热模块更新"></a>HotModuleReplacementPlugin 热模块更新</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var webpack = require(&apos;webpack&apos;)</span><br><span class="line"></span><br><span class="line">//配置</span><br><span class="line">devServer: &#123;</span><br><span class="line">contentBase: &apos;./dist&apos;,</span><br><span class="line">open: true,</span><br><span class="line">hot: true, //代码更新时只会更新最新变化的部分 不会全部刷新一遍</span><br><span class="line">hotOnly: true</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">//配置</span><br><span class="line">plugins: [</span><br><span class="line">new webpack.HotModuleReplacementPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="使用-Babel-处理-ES6-语法"><a href="#使用-Babel-处理-ES6-语法" class="headerlink" title="使用 Babel 处理 ES6 语法"></a>使用 Babel 处理 ES6 语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-loader babel-core babel-preset-env</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.js$/,</span><br><span class="line">  include: &apos;../src&apos; , // 指定匹配文件的范围</span><br><span class="line">  exclude: /node_modules/,</span><br><span class="line">  loader: &apos;babel-loader&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tree-Shaking-概念详解"><a href="#Tree-Shaking-概念详解" class="headerlink" title="Tree Shaking 概念详解"></a>Tree Shaking 概念详解</h2><ul><li>把一个模块里面的没有用到的方法摇晃掉 去掉 不打包</li><li>如果对一些文件不使用此功能 则配置 </li><li>package.json 添加 配置 “sideEffects”: [‘不使用此功能的文件’]</li><li>.babelrc文件配置如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;env&quot; ,&#123;</span><br><span class="line">        &quot;targets&quot;: &#123;</span><br><span class="line">          &quot;chrome&quot;: &quot;67&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;useBuiltIns&quot;: &quot;usage&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Develoment-和-Production-模式的区分打包"><a href="#Develoment-和-Production-模式的区分打包" class="headerlink" title="Develoment 和 Production 模式的区分打包"></a>Develoment 和 Production 模式的区分打包</h2><ul><li>新建webpack.dev.js 开发环境</li><li>新建webpack.common.js 公共代码</li><li>新建webpack.prod.js 生产环境</li><li>详见简书配置</li></ul><h2 id="Webpack-和-Code-Splitting-代码分割"><a href="#Webpack-和-Code-Splitting-代码分割" class="headerlink" title="Webpack 和 Code Splitting 代码分割"></a>Webpack 和 Code Splitting 代码分割</h2><ul><li>将外来库的方法与业务逻辑代码分开打包</li><li>SplitChunksPlugin 配置参数详解</li><li>weback.common.js </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;//优化</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    chunks: &apos;all&apos;,//同步异步代码都分割</span><br><span class="line">    minSize: 30000,//30kb 分割的最小限度配合cacheGroups</span><br><span class="line">    //maxSize: 50000,//不常用</span><br><span class="line">    minChunks: 1,//当一个模块至少被使用了多少次的时候才代码分割</span><br><span class="line">    maxAsyncRequests: 5,//假设有多个库要进行分割，但这里只做分割5个</span><br><span class="line">    maxInitialRequests: 3,//不用修改 默认就行了</span><br><span class="line">    automaticNameDelimiter: &apos;~&apos;,//组和文件之间的连接符</span><br><span class="line">    name: true,</span><br><span class="line">    cacheGroups: &#123;//缓存组</span><br><span class="line">      vendors: &#123;</span><br><span class="line">        test: /[\\/]node_modules[\\/]/,//在node_modules里面匹配</span><br><span class="line">        priority: -10,//优先级和default的优先级作比较，</span><br><span class="line">                      // 若这里的高那么就将符合上面要求的文件打包放到vender组</span><br><span class="line">        //filename: &apos;vender.js&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      default: &#123;</span><br><span class="line">        // minChunks: 2,</span><br><span class="line">        priority: -20,</span><br><span class="line">        reuseExistingChunk: true ,//入一个文件已经在之前的步骤中打包过了，那这里就不用再打包了</span><br><span class="line">        filename: &apos;common.js&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="Lazy-Loading-和-chunk-是什么"><a href="#Lazy-Loading-和-chunk-是什么" class="headerlink" title="Lazy Loading 和 chunk 是什么"></a>Lazy Loading 和 chunk 是什么</h2><ul><li>懒加载 即当时机成熟的时候再加载代码</li><li>promise 必须要有catch() <strong>捕获错误</strong></li><li>chunk表示一个文件，默认情况下webpack的输入是一个入口entry文件，输出output也是一个文件，这个文件就是一个chunk，chunkId就是产出时给每个文件一个唯一标识id，chunkhash就是文件内容的md5值，name就是在entry中指定的key值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//安装插件</span><br><span class="line"></span><br><span class="line">npm install --save-dev @babel/plugin-syntax-dynamic-import</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//src/index.js</span><br><span class="line"></span><br><span class="line">async function getComponent () &#123;</span><br><span class="line">  const &#123; default: _ &#125; = await import(&apos;lodash&apos;)//异步按需引入lodash函数库</span><br><span class="line">  var dom = document.createElement(&apos;div&apos;)</span><br><span class="line">  dom.innerHTML = _.join([&apos;hello&apos;, &apos;shulu&apos;, &apos;lqy&apos;, &apos;love&apos;, &apos;you&apos;], &apos;^_^&apos;)</span><br><span class="line">  return dom</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">  getComponent().then((dom) =&gt; &#123;</span><br><span class="line">    document.body.appendChild(dom)</span><br><span class="line">  &#125;).catch((err) =&gt; &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//.babelrc</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;env&quot; ,&#123;</span><br><span class="line">        &quot;targets&quot;: &#123;</span><br><span class="line">          &quot;chrome&quot;: &quot;67&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;useBuiltIns&quot;: &quot;usage&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [&quot;@babel/plugin-syntax-dynamic-import&quot;,]//配置插件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//事实上webpack.common.js的配置如下即可</span><br><span class="line">optimization: &#123;</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    chunks: &apos;all&apos;//同步异步代码都分割</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="css-模块的分割打包"><a href="#css-模块的分割打包" class="headerlink" title="css 模块的分割打包"></a>css 模块的分割打包</h2><ul><li>目前不支持模块热跟新 故在生产环境使用好一些</li><li>将webpack.common.js中的css配置文件分别拿到webpack.dev.js 和webpack.prod.js </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extract-text-webpack-plugin还不能支持webpack4.0.0以上的版本。 </span><br><span class="line">解决办法： </span><br><span class="line">npm install -–save-dev extract-text-webpack-plugin@next </span><br><span class="line">会下载到+ extract-text-webpack-plugin@4.0.0-beta.0 </span><br><span class="line">然后打包就正常了</span><br><span class="line">//npm install --save-dev extract-text-webpack-plugin</span><br><span class="line"></span><br><span class="line">npm install --save-dev extract-text-webpack-plugin@next</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//webpack.prod.js</span><br><span class="line"></span><br><span class="line">const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;)</span><br><span class="line">//配置</span><br><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.css$/,</span><br><span class="line">      use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">        fallback: &quot;style-loader&quot;,</span><br><span class="line">        use: [&apos;css-loader&apos;, &apos;postcss-loader&apos;]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.less$/,</span><br><span class="line">      use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">        fallback: &apos;style-loader&apos;,</span><br><span class="line">        //如果需要，可以在 sass-loader 之前将 resolve-url-loader 链接进来</span><br><span class="line">        use: [&apos;css-loader&apos;, &apos;less-loader&apos;, &apos;postcss-loader&apos;]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  new ExtractTextPlugin(&quot;styles.css&quot;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//package.json 对css文件不使用tree shaking</span><br><span class="line"></span><br><span class="line">&quot;sideEffects&quot;: [</span><br><span class="line">  &quot;*.css&quot;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//webpack.common.js</span><br><span class="line"></span><br><span class="line">optimization: &#123;</span><br><span class="line">  usedExports: true, //模块中只引入使用了的方法(函数)</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    chunks: &apos;all&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>将打包后的css压缩代码 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S optimize-css-assets-webpack-plugin</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//webpack.prod.js</span><br><span class="line"></span><br><span class="line">const OptimizeCSSAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">optimization: &#123;</span><br><span class="line">  minimizer: [new OptimizeCSSAssetsPlugin(&#123;&#125;)],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="webpack-Library库"><a href="#webpack-Library库" class="headerlink" title="webpack Library库"></a>webpack Library库</h2><h2 id="webpack-PWA-的打包"><a href="#webpack-PWA-的打包" class="headerlink" title="webpack PWA 的打包"></a>webpack PWA 的打包</h2><h2 id="TypeScript-的打包配置"><a href="#TypeScript-的打包配置" class="headerlink" title="TypeScript 的打包配置"></a>TypeScript 的打包配置</h2><h2 id="WebpackDevServer-请求转发"><a href="#WebpackDevServer-请求转发" class="headerlink" title="WebpackDevServer 请求转发"></a>WebpackDevServer 请求转发</h2><ul><li>devServer.proxy的配置</li><li>开发环境development</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  proxy: &#123;//代理</span><br><span class="line">  &quot;/api&quot;: &#123;</span><br><span class="line">    //将所有对/api的请求转发到http://shulu520.com/test.json</span><br><span class="line">    target: &quot;http://shulu520.com/test.json&quot;,</span><br><span class="line"></span><br><span class="line">    //在开发中当后端/api还没有做好时，将路劲变为love.json, 做好后，将这里配置注释掉即可，就不用改源码了</span><br><span class="line">    pathRewrite: &#123;&quot;^/api&quot; : &quot;love.json&quot;&#125;,</span><br><span class="line"></span><br><span class="line">    //默认不支持https的 配置后即可支持</span><br><span class="line">    secure: false</span><br><span class="line"></span><br><span class="line">    //如果希望代理多个特定路径到同一个目标，可以这样使用</span><br><span class="line">    context: [&quot;/auth&quot;, &quot;/api&quot;],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="webpack-打包优化"><a href="#webpack-打包优化" class="headerlink" title="webpack 打包优化"></a>webpack 打包优化</h2><ul><li>跟上技术的迭代 工具的更新</li><li>在尽可能少的模块上应用loader<ul><li>约束loader的应用范围</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.js$/,</span><br><span class="line">  include: path.resolve(__diename, &apos;./src&apos;)</span><br><span class="line">  exclude: /node_modules/,</span><br><span class="line">  loader: &apos;babel-loader&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尽可能少的使用plugin 并确保可靠 官网的推荐</li><li>resolve 配置项 参数的合理配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//webpack.common.js</span><br><span class="line">resole: &#123;</span><br><span class="line">  alias: &#123;// 别名 简化长路劲 </span><br><span class="line">    Child: path.resolve(__dirname, &apos;./src/a/b/c/Child&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自己编写-Loader-实现代码的装饰"><a href="#自己编写-Loader-实现代码的装饰" class="headerlink" title="自己编写 Loader 实现代码的装饰"></a>自己编写 Loader 实现代码的装饰</h2><ul><li>loader 是转译模块源代码的转换规则。 </li><li>loader 被编写为，接受源代码作为参数的函数， 并返回这些转换过的新版本代码.</li></ul><h2 id="手写-plugin"><a href="#手写-plugin" class="headerlink" title="手写 plugin"></a>手写 plugin</h2><h2 id="bundler-源码编写-模块分析"><a href="#bundler-源码编写-模块分析" class="headerlink" title="bundler 源码编写 (模块分析)"></a>bundler 源码编写 (模块分析)</h2><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div></p><center><img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:skyblue;font-weight:bold;" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">有事您Q我👇</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/webpack/webpack-mooc/#disqus_thread</comments>
    </item>
    
    <item>
      <title>js-advance-four</title>
      <link>https://shulu520.com/js-advance/js-advance-four/</link>
      <guid>https://shulu520.com/js-advance/js-advance-four/</guid>
      <pubDate>Fri, 31 May 2019 02:57:20 GMT</pubDate>
      <description>
      
        guigu js 高级教程笔记④——线程机制和事件机制
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;这世界为何有那么可爱的人儿，儿童节快乐哦</p><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><br><a id="more"></a></p><h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><ul><li>进程:<ul><li>程序的一次执行, 它占有一片独有的内存空间</li><li>可以通过windows任务管理器查看进程</li></ul></li><li>线程:<ul><li>是进程内的一个独立执行单元</li><li>是程序执行的一个完整流程</li><li>是CPU的最小的调度单元</li></ul></li><li>关系<ul><li>一个进程至少有一个线程(主)</li><li>程序是在某个进程中的某个线程执行的</li></ul></li></ul><p><img src="https://www.z4a.net/images/2019/05/31/20190531222313.md.png" alt="线程与进程图"></p><ul><li>应用程序必须运行在某个进程的某个线程上</li><li>一个进程中至少有一个运行的线程: 主线程,  进程启动后自动创建</li><li>一个进程内的数据可以供其中的多个线程直接共享</li><li>多个进程之间的数据是不能直接共享的</li><li>线程池(thread pool): 保存多个线程对象的容器, 实现线程对象的反复利用</li><li><p>何为多进程与多线程?</p><ul><li>多进程运行: 一应用程序可以同时启动多个实例运行</li><li>多线程: 在一个进程内, 同时有多个线程运行</li></ul></li><li><p>比较单线程与多线程?</p><ul><li>多线程<br>优点：能有效提升CPU的利用率<br>缺点：创建多线程开销 线程间切换开销 死锁与状态同步问题</li><li>单线程<br>优点：顺序编程简单易懂<br>缺点：效率低</li></ul></li><li>JS是单线程还是多线程?<ul><li>js是单线程运行的</li><li>但使用H5中的 Web Workers可以多线程运行</li></ul></li><li>浏览器运行是单进程还是多进程?<ul><li>有的是单进程 firefox 老版IE</li><li>有的是多进程 chrome 新版IE</li></ul></li><li><p>如何查看浏览器是否是多进程运行的呢?</p><ul><li>任务管理器 —&gt; 进程</li></ul></li><li><p>浏览器内核</p></li><li>支撑浏览器运行的最核心的程序</li><li>不同的浏览器可能不一样<ul><li>Chrome, Safari : webkit</li><li>firefox : Gecko</li><li>IE: Trident</li><li>360,搜狗等国内浏览器: Trident + webkit</li></ul></li></ul><h2 id="浏览器内核模块组成"><a href="#浏览器内核模块组成" class="headerlink" title="浏览器内核模块组成"></a>浏览器内核模块组成</h2><ul><li>主线程<ul><li>js引擎模块 : 负责js程序的编译与运行</li><li>html,css文档解析模块 : 负责页面文本的解析</li><li>DOM/CSS模块 : 负责dom/css在内存中的相关处理 </li><li>布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象)</li></ul></li><li>分线程<ul><li>定时器模块 : 负责定时器的管理</li><li>DOM事件模块 : 负责事件的管理</li><li>网络请求模块 : 负责Ajax请求</li></ul></li></ul><h2 id="js线程"><a href="#js线程" class="headerlink" title="js线程"></a>js线程</h2><ul><li>js是单线程执行的(回调函数也是在主线程)</li><li>H5提出了实现多线程的方案: Web Workers</li><li>只能是主线程更新界面</li></ul><h2 id="定时器问题"><a href="#定时器问题" class="headerlink" title="定时器问题:"></a>定时器问题:</h2><ul><li>定时器并不真正完全定时</li><li>如果在主线程执行了一个长时间的操作, 可能导致延时才处理</li></ul><h2 id="事件处理机制-图"><a href="#事件处理机制-图" class="headerlink" title="事件处理机制(图)"></a>事件处理机制(图)</h2><ul><li>代码分类<ul><li>初始化执行代码: 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码</li><li>回调执行代码: 处理回调逻辑</li></ul></li><li>js引擎执行代码的基本流程: <ul><li>初始化代码===&gt;回调代码</li></ul></li><li>模型的2个重要组成部分:<ul><li>事件管理模块</li><li>回调队列</li></ul></li><li>模型的运转流程<ul><li>执行初始化代码, 将事件回调函数交给对应模块管理</li><li>当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中</li><li>只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行</li></ul></li></ul><p><img src="https://www.z4a.net/images/2019/06/01/loop.md.png" alt="loop.png"></p><h2 id="H5-Web-Workers"><a href="#H5-Web-Workers" class="headerlink" title="H5 Web Workers"></a>H5 Web Workers</h2><ul><li>可以让js在分线程执行</li><li>Worker 计算斐波那契数列的例子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//在主线程 创建一个Worker实例对象</span><br><span class="line">  var worker = new Worker(&apos;worker.js&apos;) // 其中worker.js为worker文件路劲</span><br><span class="line">  // 绑定接收消息的监听</span><br><span class="line">  worker.onmessage = function (event) &#123;</span><br><span class="line">    //通信的数据都在event.data里面</span><br><span class="line">    alert(event.data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 向分线程发送消息</span><br><span class="line">  worker.postMessage(number)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在分线程 斐波那契数列</span><br><span class="line">function fibonacci(n) &#123;</span><br><span class="line">  //递归调用</span><br><span class="line">  return n&lt;=2 ? 1 : fibonacci(n-1) + fibonacci(n-2)  </span><br><span class="line">&#125;</span><br><span class="line">this.onmessage = function (event) &#123;</span><br><span class="line">  var number = event.data </span><br><span class="line">  console.log(&apos;分线程接收到主线程发送的数据: &apos;+number)</span><br><span class="line">  </span><br><span class="line">  var result = fibonacci(number)//计算斐波那契数列</span><br><span class="line">  postMessage(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/<em><br>    分线程中this不再是window 而是另一个全局对象<br>    其有onmessage,postMessage等方法<br>    故在这里可以直接调用<br>    而不可以直接调用window的方法<br>    如alert() // alert is not defind<br>    document 方法 等 可以更新页面的方法都不可以调用<br>    只有主线程才可以跟新界面</em>/</p><ul><li>问题:<ul><li>worker内代码不能操作DOM更新UI</li><li>不是每个浏览器都支持这个新特性</li><li>不能跨域加载JS</li><li>慢一点 数据传输过程</li></ul></li></ul><p><img src="https://www.z4a.net/images/2019/06/01/worker.md.png" alt="worker.png"></p><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div></p><center><img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:skyblue;font-weight:bold;" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">来我QQ撩我哦👇</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/js-advance/js-advance-four/#disqus_thread</comments>
    </item>
    
    <item>
      <title>js-advance-three</title>
      <link>https://shulu520.com/js-advance/js-advance-three/</link>
      <guid>https://shulu520.com/js-advance/js-advance-three/</guid>
      <pubDate>Thu, 30 May 2019 10:42:14 GMT</pubDate>
      <description>
      
        guigu js 高级教程笔记③——对象高级
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;想起你，内心充满欢喜O(∩_∩)O</p><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><br><a id="more"></a></p><h2 id="对象的创建模式"><a href="#对象的创建模式" class="headerlink" title="对象的创建模式"></a>对象的创建模式</h2><ul><li><p>Object构造函数模式</p><ul><li>套路: 先创建空Object对象, 再动态添加属性/方法</li><li>适用场景: 起始时不确定对象内部数据</li><li>问题: 语句太多</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object()</span><br><span class="line">obj.name = &apos;Tom&apos;</span><br><span class="line">obj.setName = function(name)&#123;this.name=name&#125;</span><br></pre></td></tr></table></figure></li><li><p>对象字面量模式</p><ul><li>套路: 使用{}创建对象, 同时指定属性/方法</li><li>适用场景: 起始时对象内部数据是确定的</li><li>问题: 如果创建多个对象, 有重复代码</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name : &apos;Tom&apos;,</span><br><span class="line">  setName : function(name)&#123;this.name = name&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>工厂函数模式 <ul><li>套路: 通过工厂函数动态创建对象并返回</li><li>适用场景: 需要创建多个对象</li><li>问题: 对象没有一个具体的类型, 都是Object类型<br>  即通过instanceof判断得到的都是Object类型<br>  类型不够具体 人和🐶均为同一类型</li><li>用的不多 只是比较经典</li><li>返回一个对象的函数===&gt;工厂函数 联系真实工厂</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name, age) &#123; </span><br><span class="line">  var obj = &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    age: age,</span><br><span class="line">    setName: function (name) &#123;</span><br><span class="line">      this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造函数模式<ul><li>套路: 自定义构造函数, 通过new创建实例对象</li><li>适用场景: 需要创建多个类型确定的对象</li><li>问题: 每个对象都有相同的数据, 浪费内存</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.setName = function(name)&#123;this.name=name;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">new Person(&apos;tom&apos;, 12);</span><br></pre></td></tr></table></figure><ul><li>组合模式 (构造函数+原型)<ul><li>套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上</li><li>适用场景: 需要创建多个类型确定的对象</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = function(name)&#123;this.name=name;&#125;;</span><br><span class="line">new Person(&apos;tom&apos;, 12);</span><br></pre></td></tr></table></figure><h2 id="继承模式"><a href="#继承模式" class="headerlink" title="继承模式"></a>继承模式</h2><ul><li>原型链继承 : 得到方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;&#125;</span><br><span class="line">Parent.prototype.test = function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">function Child() &#123;&#125;</span><br><span class="line">Child.prototype = new Parent(); //子类型的原型指向父类型实例</span><br><span class="line">Child.prototype.constructor = Child //修正constructor属性重新指向子构造函数</span><br><span class="line"></span><br><span class="line">var child = new Child(); //有test()</span><br></pre></td></tr></table></figure><ul><li>借用构造函数 : 得到属性<br>(假继承)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Parent(xxx)&#123;this.xxx = xxx&#125;</span><br><span class="line">Parent.prototype.test = function()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">function Child(xxx,yyy)&#123;</span><br><span class="line">  Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)</span><br><span class="line">&#125;</span><br><span class="line">var child = new Child(&apos;a&apos;, &apos;b&apos;);  //child.xxx为&apos;a&apos;, 但child没有test()</span><br></pre></td></tr></table></figure><ul><li>组合继承 (原型链继承+构造函数)<ul><li>利用原型链实现对父类型对象的方法继承</li><li>利用call()借用父类型构建函数初始化相同属性</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Parent(xxx)&#123;this.xxx = xxx&#125;</span><br><span class="line">Parent.prototype.test = function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">function Child(xxx,yyy)&#123;</span><br><span class="line">  Parent.call(this, xxx)//借用构造函数   this.Parent(xxx)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = new Parent() //得到test()</span><br><span class="line">Child.prototype.constructor = Child //修正constructor属性</span><br><span class="line"></span><br><span class="line">var child = new Child(); //child.xxx为&apos;a&apos;, 也有test()</span><br></pre></td></tr></table></figure><ul><li>new一个对象背后做了些什么?<ul><li>创建一个空对象</li><li>给对象设置<strong>proto</strong>, 值为构造函数对象的prototype属性值   this.<strong>proto</strong> = Fn.prototype</li><li>执行构造函数体(给对象添加属性/方法)</li></ul></li></ul><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div></p><center><img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:skyblue;font-weight:bold;" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">来我QQ撩我哦👇</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/js-advance/js-advance-three/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hotkey-listary</title>
      <link>https://shulu520.com/hotkey/hotkey-listary/</link>
      <guid>https://shulu520.com/hotkey/hotkey-listary/</guid>
      <pubDate>Tue, 28 May 2019 15:21:39 GMT</pubDate>
      <description>
      
        listary最常用的快捷键
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;人生如逆旅，我亦是行人。</p><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div><br><a id="more"></a></p><h2 id="listary-最常用的快捷键"><a href="#listary-最常用的快捷键" class="headerlink" title="listary 最常用的快捷键"></a>listary 最常用的快捷键</h2><ul><li>alt A 打开listary</li><li><p>双击 ctrl 打开listary</p></li><li><p>bing 必应搜索</p></li><li>bd 百度一下 百度网盘</li><li><p>zh 知乎搜索</p></li><li><p>ctrl N 向下切换选中的目录</p></li><li><p>ctrl P 向上切换选中的目录</p></li><li><p>双击桌面 打开listary选项</p></li><li>在任意文件夹/目录下双击 打开listary选项 可以选命令打开cmd</li></ul><p><div style="width:100%;height:1px;background-color:pink"></div><br>&emsp;&emsp;未完待续……</p><center><img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:skyblue;font-weight:bold;" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">来我QQ撩我哦👇</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/hotkey/hotkey-listary/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hotkey-windows</title>
      <link>https://shulu520.com/hotkey/hotkey-windows/</link>
      <guid>https://shulu520.com/hotkey/hotkey-windows/</guid>
      <pubDate>Mon, 27 May 2019 04:24:05 GMT</pubDate>
      <description>
      
        windows 最常用快捷键总结
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;</p><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decoration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">Q我吧</a></center><a id="more"></a><h2 id="windows-最常用快捷键"><a href="#windows-最常用快捷键" class="headerlink" title="windows 最常用快捷键"></a>windows 最常用快捷键</h2><ul><li><p>ctrl  w  关闭当前网页</p></li><li><p>f2键 ：选中后按f2键即可重命名文件，另一种方法，点一下文件名，稍等，再点一下，即可重命名</p></li><li><p>f4: 重复上步操作</p></li><li><p>f5: 刷新桌面 刷新网页</p></li><li><p>f11: 全屏显示网页</p></li><li><p>shift :<br>  省略号    shift + 数字6  （表示六个点）    ……</p><p>  书名号     shift + &lt;&gt;   (小于大于）</p></li><li><p>分隔号   单独按 数字1 前面的键    《简 · 爱》</p></li><li><p>Alt + 单击拖动  为矩形选择</p></li><li><p>AlT + f4 关闭当前程序</p></li><li><p>删除  选中后 按delete </p></li><li><p>永久删除  选中后  shift +delete</p></li><li><p>截屏   PrtSc     截全屏<br>  Alt  +PrtSc  截当前窗口</p></li><li><p>ctrl alt delete 任务管理器</p></li><li><p>windows 打开开始菜单</p></li><li><p>ctrl shift n  新建文件夹</p></li><li><p>window e 打开文件资源管理器</p></li><li><p>alt tab 切换窗口 </p></li><li><p>window d 回到桌面</p></li></ul><hr><p>&emsp;&emsp;学到了再来补充😝</p><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decoration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">点这里，进入QQ交流</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/hotkey/hotkey-windows/#disqus_thread</comments>
    </item>
    
    <item>
      <title>js-advance-two</title>
      <link>https://shulu520.com/js-advance/js-advance-two/</link>
      <guid>https://shulu520.com/js-advance/js-advance-two/</guid>
      <pubDate>Sat, 25 May 2019 15:06:08 GMT</pubDate>
      <description>
      
        guigu js 高级教程笔记②——函数高级
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;又是元气满满的一天😝,文章链接失效，又好了。有惊无险</p><center><img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:skyblue;font-weight:bold;" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">来我QQ撩我哦👇</a></center><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div></p><h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><ul><li>所有函数都有一个特别的属性:<ul><li><strong>prototype</strong> : 显式原型属性</li></ul></li><li>所有实例对象都有一个特别的属性:<ul><li><strong><strong>proto</strong></strong> : 隐式原型属性</li></ul></li></ul><p><img src="https://www.z4a.net/images/2019/05/27/20190526235616.png" alt="原型链图"></p><ul><li>当然所有函数也都有一个特别的属性：<ul><li><strong><strong>proto</strong></strong> : 隐式原型属性</li></ul></li><li>且所有函数的 隐式原型 都一样 都等于Function的显式原型 </li><li>函数的显式原型指向的对象默认是空Object实例对象(但Object不满足)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(Fn.prototype instanceof Object) // true</span><br><span class="line">console.log(Object.prototype instanceof Object) // false</span><br><span class="line">console.log(Function.prototype instanceof Object) // true</span><br></pre></td></tr></table></figure><ul><li>所有函数都是Function的实例(包含Function自身)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Function.__proto__===Function.prototype)</span><br></pre></td></tr></table></figure><ul><li>Object的原型对象是原型链尽头</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.__proto__) // null</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)</span><br><span class="line">console.log(Date.prototype, typeof Date.prototype)</span><br><span class="line">function Fun () &#123;//alt + shift +r(重命名rename)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(Fun.prototype)  // 默认指向一个Object空对象(没有我们的属性)</span><br><span class="line"></span><br><span class="line">// 原型对象中有一个属性constructor, 它指向函数对象</span><br><span class="line">console.log(Date.prototype.constructor===Date)</span><br><span class="line">console.log(Fun.prototype.constructor===Fun)</span><br><span class="line"></span><br><span class="line">//给原型对象添加属性(一般是方法) ===&gt;实例对象可以访问</span><br><span class="line">Fun.prototype.test = function () &#123;</span><br><span class="line">  console.log(&apos;test()&apos;)</span><br><span class="line">&#125;</span><br><span class="line">var fun = new Fun()</span><br><span class="line">fun.test()</span><br></pre></td></tr></table></figure><ul><li>显式原型与隐式原型的关系<ul><li>函数的prototype: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象</li><li>实例对象的<strong>proto</strong>: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值</li><li>原型对象即为当前实例对象的父对象</li></ul></li><li><p>原型链</p><ul><li>所有的实例对象都有<strong>proto</strong>属性, 它指向的就是原型对象</li><li>这样通过<strong>proto</strong>属性就形成了一个链的结构—-&gt;原型链</li><li>当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找</li><li>当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作,如果当前对象中没有此属性, 直接添加此属性并设置其值</li><li>方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上</li></ul></li><li><p>面试题1</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function A () &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.n = 1</span><br><span class="line"></span><br><span class="line">var b = new A()</span><br><span class="line"></span><br><span class="line">A.prototype = &#123;</span><br><span class="line">  n: 2,</span><br><span class="line">  m: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c = new A()</span><br><span class="line">console.log(b.n, b.m, c.n, c.m) // 1  undifind  2  3</span><br></pre></td></tr></table></figure><ul><li>面试题2</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function F ()&#123;&#125;</span><br><span class="line">  Object.prototype.a = function()&#123;</span><br><span class="line">    console.log(&apos;a()&apos;)</span><br><span class="line">&#125;</span><br><span class="line">Function.prototype.b = function()&#123;</span><br><span class="line">  console.log(&apos;b()&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f = new F()</span><br><span class="line"></span><br><span class="line">f.a()</span><br><span class="line"></span><br><span class="line">f.b() // 找不到,可以看原型链图进行分析</span><br><span class="line"></span><br><span class="line">F.a()</span><br><span class="line">F.b()</span><br></pre></td></tr></table></figure><ul><li>instanceof是如何判断的?<ul><li>表达式: A instanceof B</li><li>如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false</li></ul></li><li>Function是通过new自己产生的实例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">案例1</span><br><span class="line"> */</span><br><span class="line">function Foo() &#123;  &#125;</span><br><span class="line">var f1 = new Foo()</span><br><span class="line">console.log(f1 instanceof Foo) // true</span><br><span class="line">console.log(f1 instanceof Object) // true</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">案例2</span><br><span class="line"> */</span><br><span class="line">console.log(Object instanceof Function) // true</span><br><span class="line">console.log(Object instanceof Object) // true</span><br><span class="line">console.log(Function instanceof Function) // true</span><br><span class="line">console.log(Function instanceof Object) // true</span><br><span class="line"></span><br><span class="line">function Foo() &#123;&#125;</span><br><span class="line">console.log(Object instanceof  Foo) // false</span><br></pre></td></tr></table></figure><h2 id="执行上下文与执行上下文栈"><a href="#执行上下文与执行上下文栈" class="headerlink" title="执行上下文与执行上下文栈"></a>执行上下文与执行上下文栈</h2><ul><li>变量提升与函数提升<ul><li>变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined)</li><li>函数提升: 在函数定义语句之前, 就执行该函数</li><li><strong>先执行变量提升, 再执行函数提升</strong></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;&#125;</span><br><span class="line">var a</span><br><span class="line">console.log(typeof a) // &apos;function&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var c = 1</span><br><span class="line">function c(c) &#123;</span><br><span class="line">  console.log(c)</span><br><span class="line">  var c = 3</span><br><span class="line">&#125;</span><br><span class="line">c(2) // 报错 c is not a function</span><br><span class="line"></span><br><span class="line">过程解析：</span><br><span class="line">  var c</span><br><span class="line">  fun c</span><br><span class="line">  c = 1</span><br><span class="line">  c(2)</span><br></pre></td></tr></table></figure><ul><li>理解<ul><li>执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性</li><li>执行上下文栈: 用来管理产生的多个执行上下文</li></ul></li><li>分类:<ul><li>全局: window</li><li>函数: 对程序员来说是透明的</li></ul></li><li>生命周期<ul><li>全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡</li><li>函数 : 调用函数时产生, 函数执行完时死亡</li></ul></li><li>包含哪些属性:<ul><li>全局 : <ul><li>用var定义的全局变量  ==&gt;undefined</li><li>使用function声明的函数   ===&gt;function</li><li>this   ===&gt;window</li></ul></li><li>函数<ul><li>用var定义的局部变量  ==&gt;undefined</li><li>使用function声明的函数   ===&gt;function</li><li>this   ===&gt; 调用函数的对象, 如果没有指定就是window </li><li>形参变量   ===&gt;对应实参值</li><li>arguments ===&gt;实参列表的伪数组</li></ul></li></ul></li><li>执行上下文 创建和初始化的过程</li><li>全局执行上下文:<ul><li>在全局代码执行前最先创建一个全局执行上下文(window)</li><li>收集一些全局变量, 并初始化<ul><li>var定义的全局变量==&gt;undefined, 添加为window的属性</li><li>function声明的全局函数==&gt;赋值(fun), 添加为window的方法</li></ul></li><li>this==&gt;赋值(<strong>window</strong>)</li><li>开始执行全局代码</li></ul></li><li>函数执行上下文:<ul><li>在调用函数时, 在执行函数体之前，先创建一个函数执行上下文对象(虚拟的, 存在于栈中)</li><li>收集一些局部变量, 并初始化<ul><li>形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性</li><li>arguments==&gt;赋值(实参列表), 添加为执行上下文的属性</li><li>var定义的局部变量==&gt;undefined, 添加为执行上下文的属性</li><li>function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法</li></ul></li><li>this==&gt;赋值(<strong>调用函数的对象</strong>)</li><li>开始执行函数体代码</li></ul></li><li>执行上下文栈<ul><li>在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象</li><li>在全局执行上下文(window)确定后, 将其添加到栈中(压栈)</li><li>在函数执行上下文创建后, 将其添加到栈中(压栈)</li><li>在当前函数执行完后,将栈顶的对象移除(出栈)</li><li>当所有的代码执行完后, 栈中只剩下window</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = 10</span><br><span class="line">var bar = function (x) &#123;</span><br><span class="line">  var b = 5</span><br><span class="line">  foo(x + b)</span><br><span class="line">&#125;</span><br><span class="line">var foo = function (y) &#123;</span><br><span class="line">  var c = 5</span><br><span class="line">  console.log(a + c + y)</span><br><span class="line">&#125;</span><br><span class="line">bar(10)</span><br></pre></td></tr></table></figure><p><img src="https://www.z4a.net/images/2019/05/27/20190527165142.md.png" alt="执行上下文栈图"></p><ul><li><p><strong>产生执行上下文的个数</strong> = (N)函数调用次数 + 1</p></li><li><p>面试题</p></li><li>整个过程中产生了几个执行上下文?  5</li><li>依次输出什么?<br>  gb: undefined<br>  fb: 1<br>  fb: 2<br>  fb: 3<br>  fe: 3<br>  fe: 2<br>  fe: 1<br>  ge: 1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;gb: &apos;+ i)</span><br><span class="line">var i = 1</span><br><span class="line">foo(1)</span><br><span class="line">function foo(i) &#123;</span><br><span class="line">  if (i == 4) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&apos;fb:&apos; + i)</span><br><span class="line">  foo(i + 1) // 递归调用: 在函数内部调用自己</span><br><span class="line">  console.log(&apos;fe:&apos; + i)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&apos;ge: &apos; + i)</span><br></pre></td></tr></table></figure><h2 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h2><ul><li>理解:<ul><li>作用域: 一块代码区域, 在编码时就确定了, 不会再变化</li><li>作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量</li><li><strong>产生作用域的个数</strong> = (N)定义函数的个数 + 1</li></ul></li><li>分类:<ul><li>全局</li><li>函数</li><li>js没有块作用域(在ES6之前)</li></ul></li><li>作用<ul><li>作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突</li><li>作用域链: 查找变量</li></ul></li><li><p>区别作用域与执行上下文</p><ul><li>作用域: <strong>静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了</strong></li><li>执行上下文: <strong>动态的, 执行代码时动态创建, 当执行结束消失</strong></li><li>联系: 执行上下文环境是在对应的作用域中的</li></ul></li><li><p>面试题</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var x = 10;</span><br><span class="line"></span><br><span class="line">  function fn() &#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function show(f) &#123;</span><br><span class="line">    var x = 20;</span><br><span class="line">    f();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  show(fn); // 10 </span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">    解析：作用域在函数创建的时候就确定了，一旦确定就不会变化了</span><br><span class="line">  */</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var fn = function () &#123;</span><br><span class="line">    console.log(fn)</span><br><span class="line">  &#125;</span><br><span class="line">  fn() // fn函数体</span><br><span class="line"></span><br><span class="line">  var obj = &#123;</span><br><span class="line">    fn2: function () &#123;</span><br><span class="line">     console.log(fn2)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  obj.fn2() // fn2 is not defind</span><br><span class="line">  /*</span><br><span class="line">    解析：</span><br><span class="line">      首先在fn2函数作用域里面找fn2 没有  </span><br><span class="line">      然后再全局作用域找 也没有 故报错</span><br><span class="line">      若为this.fn2 则可以</span><br><span class="line">  */</span><br></pre></td></tr></table></figure><h2 id="作用域链和原型链的用处"><a href="#作用域链和原型链的用处" class="headerlink" title="作用域链和原型链的用处"></a>作用域链和原型链的用处</h2><ul><li>作用域链用来找变量</li><li><p>原型链用来找方法</p></li><li><p>在全局直接找一个不存在的方法 a is not defined</p></li><li>而通过window.a 则为undifind</li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul><li><p>如何产生闭包?</p><ul><li>当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包</li></ul></li><li><p><strong>闭包到底是什么</strong>?</p><ul><li>使用chrome调试查看 会调试的程序员至少不是初级程序员</li><li>理解一: 闭包是嵌套的内部函数(绝大部分人) 初步认识</li><li>理解二: <strong>包含被引用变量(函数)的对象</strong>(极少数人) 高级认识</li><li>注意: 闭包存在于嵌套的内部函数中</li></ul></li><li><p>产生闭包的条件</p><ul><li>函数嵌套</li><li>内部函数引用了外部函数的数据(变量/函数)</li></ul></li><li><p>产生闭包的个数</p><ul><li>等于外部函数调用的次数</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//三个button按钮</span><br><span class="line">for (var i = 0,length=btns.length; i &lt; length; i++) &#123;</span><br><span class="line">    (function (j) &#123;</span><br><span class="line">      var btn = btns[j]</span><br><span class="line">      btn.onclick = function () &#123;</span><br><span class="line">        alert(&apos;第&apos;+(j+1)+&apos;个&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">  &#125;</span><br><span class="line">// 共产生三个闭包 因为外部函数共调用了三次，每一闭包内部都保存了各自的变量</span><br></pre></td></tr></table></figure><ul><li><p>常见的闭包</p><ul><li>将函数作为另一个函数的返回值</li><li>将函数作为实参传递给另一个函数调用</li></ul></li><li><p>闭包生命周期</p><ul><li>产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)</li><li>死亡: 在嵌套的内部函数成为垃圾对象时</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fn1() &#123;</span><br><span class="line">  //此时闭包就已经产生了(函数提升, 内部函数对象已经创建了)</span><br><span class="line">  var a = 2</span><br><span class="line">  function fn2 () &#123;</span><br><span class="line">    a++</span><br><span class="line">    console.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  return fn2</span><br><span class="line">&#125;</span><br><span class="line">var f = fn1() //f来接收fn2</span><br><span class="line">f() // 3</span><br><span class="line">f() // 4</span><br><span class="line">f = null //闭包死亡(包含闭包的函数对象成为垃圾对象)</span><br></pre></td></tr></table></figure><ul><li>作用:<ul><li>延长局部变量的生命周期</li><li>让函数外部能操作内部的局部变量</li></ul></li><li>写一个闭包程序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function fn1() &#123;</span><br><span class="line">  var a = 2</span><br><span class="line">  function fn2() &#123;</span><br><span class="line">    a++</span><br><span class="line">    console.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  return fn2</span><br><span class="line">&#125;</span><br><span class="line">var f = fn1()</span><br><span class="line">f()</span><br><span class="line">f()</span><br></pre></td></tr></table></figure><ul><li>闭包应用:<ul><li>模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为</li><li>循环遍历加监听</li><li>JS框架(jQuery)大量使用了闭包</li></ul></li><li>缺点:<ul><li>变量占用内存的时间可能会过长</li><li>可能导致内存泄露</li><li>解决:<ul><li><strong>及时释放</strong> : f = null; //让内部函数对象成为垃圾对象</li></ul></li></ul></li></ul><ul><li>面试题1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//代码片段一</span><br><span class="line">var name = &quot;The Window&quot;;</span><br><span class="line">var object = &#123;</span><br><span class="line">  name : &quot;My Object&quot;,</span><br><span class="line">  getNameFunc : function()&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">      return this.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()());  // the window</span><br><span class="line"></span><br><span class="line">//代码片段二</span><br><span class="line">var name2 = &quot;The Window&quot;;</span><br><span class="line">var object2 = &#123;</span><br><span class="line">  name2 : &quot;My Object&quot;,</span><br><span class="line">  getNameFunc : function()&#123;</span><br><span class="line">    var that = this;</span><br><span class="line">    return function()&#123;</span><br><span class="line">      return that.name2;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object2.getNameFunc()()); // my object</span><br></pre></td></tr></table></figure><h2 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h2><ul><li>内存溢出<ul><li>一种程序运行出现的错误</li><li>当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误</li></ul></li><li>内存泄露<ul><li>占用的内存没有及时释放</li><li><strong>内存泄露积累多了就容易导致内存溢出</strong></li></ul></li><li>常见的内存泄露:<ul><li>意外的全局变量</li><li>没有及时清理的计时器或回调函数</li><li>闭包</li></ul></li></ul><p><div style="width:100%;height:1px;background-color:pink;opacity:.7"></div>  </p><center>&gt;<img width="50px" height="50px" src="https://www.z4a.net/images/2019/05/27/20190527-20267.th.png" alt="QQ" border="0"><a target="_blank" style="color:hotpink;font-weight:bold;text-decoration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">👉点这里，进入QQ交流</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/js-advance/js-advance-two/#disqus_thread</comments>
    </item>
    
    <item>
      <title>js-advance-one</title>
      <link>https://shulu520.com/js-advance/js-advance-one/</link>
      <guid>https://shulu520.com/js-advance/js-advance-one/</guid>
      <pubDate>Fri, 24 May 2019 06:13:53 GMT</pubDate>
      <description>
      
        guigu js 高级教程笔记①——基础总结深入
      
      </description>
      
      <content:encoded><![CDATA[<center>能够让你后悔的<br><br><center>从来不是你做过的事<br><br><center>而是你想做却没有去做的事<br><br><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decoration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">Q我吧</a></center><a id="more"></a><h2 id="数据类型的分类和判断"><a href="#数据类型的分类和判断" class="headerlink" title="数据类型的分类和判断"></a>数据类型的分类和判断</h2><ul><li>基本(值)类型<ul><li>Number —– 任意数值 ——– typeof</li><li>String —– 任意字符串 —— typeof</li><li>Boolean —- true/false —– typeof</li><li>undefined — undefined —– typeof/===</li><li>null ——– null ———- ===</li></ul></li><li>对象(引用)类型<ul><li>Object  —– 任意对象  —– typeof/instanceof</li><li>Array —— 一种特别的对象(数值下标)—– instanceof</li><li>Function —- 一种特别的对象(可以执行，内部数据是有序的) —– typeof</li></ul></li><li>判断 <ul><li>typeof ——– 返回数据类型的<code>字符串表达</code><ul><li><code>不能判断</code> null和object ， object和array</li></ul></li><li>instanceof —- 判断<code>对象的具体类型</code><ul><li>a instanceof b 即a是否是b构造函数的一个实例</li></ul></li><li>=== ———— <code>可以判断</code> undefined 和 null</li></ul></li><li>名词解释<ul><li>实例 实例对象</li><li>类型 类型对象 即构造函数</li></ul></li><li>undefined与null的区别?<ul><li>undefined代表定义未赋值</li><li>nulll定义并赋值了, 只是值为null</li></ul></li><li>什么时候给变量赋值为null呢?<ul><li>初始赋值, 表明将要赋值为对象</li><li>结束前, 让对象成为垃圾对象(被垃圾回收器回收)</li></ul></li><li>严格区别变量类型与数据类型?<ul><li>数据的类型<ul><li>基本类型</li><li>对象类型</li></ul></li><li>变量的类型(变量内存值的类型)<ul><li>基本类型: 保存就是基本类型的数据</li><li>引用类型: 保存的是地址值</li></ul></li></ul></li></ul><h2 id="数据-变量-内存的理解"><a href="#数据-变量-内存的理解" class="headerlink" title="数据,变量, 内存的理解"></a>数据,变量, 内存的理解</h2><ul><li>什么是数据?<ul><li>在内存中可读的, 可传递的保存了特定信息的’东东’</li><li>一切皆数据, 函数也是数据</li><li>在内存中的所有操作的目标: 数据</li></ul></li><li>什么是变量?<ul><li>在程序运行过程中它的值是允许改变的量</li><li>一个变量对应一块小内存, 它的值保存在此内存中  </li></ul></li><li>什么是内存?<ul><li>内存条通电后产生的存储空间(临时的)</li><li>一块内存包含2个方面的数据<ul><li>内部存储的数据</li><li>地址值数据</li></ul></li><li>内存空间的分类<ul><li>栈空间: 全局变量和局部变量</li><li>堆空间: 对象 </li></ul></li></ul></li><li>内存,数据, 变量三者之间的关系<ul><li>内存是容器, 用来存储不同数据</li><li>变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据  </li></ul></li><li>问题: var a = xxx, a内存中到底保存的是什么?<ul><li>xxx是基本数据, 保存的就是这个数据</li><li>xxx是对象, 保存的是对象的地址值</li><li>xxx是一个变量, 保存的xxx的内存内容(可能是基本数据, 也可能是地址值)</li></ul></li><li>关于引用变量赋值问题<ul><li>2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据</li><li>2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象 </li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123; name: &apos;lqy&apos; &#125;</span><br><span class="line"></span><br><span class="line">情形一</span><br><span class="line">function fn1(obj) &#123;</span><br><span class="line">  obj.name = &apos;shulu&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1(obj1)</span><br><span class="line">console.log(obj1.name) // shulu</span><br><span class="line"></span><br><span class="line">情形二</span><br><span class="line">funtion fn2(obj) &#123;</span><br><span class="line">  obj = &#123;name: &apos;shulu&apos;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn2(obj1)</span><br><span class="line">console.log(obj1.name) // lqy</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">解析：</span><br><span class="line">形参obj 在函数内部为 var obj变量</span><br><span class="line">执行fn( ) 传入实参obj1 即将obj1的值(这里是地址值)复制一份给obj变量</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><ul><li>问题: 在js调用函数时传递变量参数时, 是值传递还是引用传递<ul><li>理解1: 都是值(基本值/地址值)传递 <code>推荐</code></li><li>理解2: 可能是值传递, 也可能是引用传递(地址值)</li></ul></li><li>问题: JS引擎如何管理内存?<ul><li>内存生命周期<ul><li>分配小内存空间, 得到它的使用权</li><li>存储数据, 可以反复进行操作</li><li>释放小内存空间</li></ul></li><li>释放内存<ul><li>局部变量: 函数执行完自动释放</li><li>对象: 成为垃圾对象==&gt;垃圾回收器回收</li></ul></li></ul></li></ul><h2 id="对象的理解和使用"><a href="#对象的理解和使用" class="headerlink" title="对象的理解和使用"></a>对象的理解和使用</h2><ul><li>什么是对象?<ul><li>多个数据(属性)的集合</li><li>用来保存多个数据(属性)的容器</li></ul></li><li>属性组成:<ul><li>属性名 : 字符串(标识)</li><li>属性值 : 任意类型</li></ul></li><li>属性的分类:<ul><li>一般 : 属性值不是function  描述对象的状态</li><li>方法 : 属性值为function的属性  描述对象的行为</li></ul></li><li>特别的对象<ul><li>数组: 属性名是0,1,2,3之类的索引</li><li>函数: 可以执行的</li></ul></li><li>如何操作内部属性(方法)<ul><li>.属性名</li><li>[‘属性名’]: 属性名有特殊字符/属性名是一个变量</li></ul></li><li>问题: 什么时候必须使用[‘属性名’]的方式?<ol><li>属性名包含特殊字符: - 空格</li><li>属性名不确定</li></ol></li></ul><h2 id="函数的理解和使用"><a href="#函数的理解和使用" class="headerlink" title="函数的理解和使用"></a>函数的理解和使用</h2><ul><li>什么是函数?<ul><li>用来实现特定功能的, n条语句的封装体</li><li>只有函数类型的数据是可以执行的, 其它的都不可以</li></ul></li><li>为什么要用函数?<ul><li>提高复用性</li><li>便于阅读交流</li></ul></li><li>函数也是对象<ul><li>instanceof Object===true</li><li>函数有属性: prototype</li><li>函数有方法: call()/apply()</li><li>可以添加新的属性/方法</li></ul></li><li>如何调用(执行)函数?<ul><li>test(): 直接调用</li><li>obj.test(): 通过对象调用</li><li>new test(): new调用</li><li>test.call/apply(obj): 临时让test成为obj的方法进行调用</li></ul></li><li>函数中的this是什么?<ul><li>任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window</li><li>所有函数内部都有一个变量this</li><li>它的值是调用函数的当前对象</li></ul></li><li>如何确定this的值?<ul><li>test(): window</li><li>p.test(): p</li><li>var p = new test(): 新创建的对象p</li><li>p.call(obj): obj</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function Person(color) &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line"></span><br><span class="line">    this.color = color;</span><br><span class="line">    this.getColor = function () &#123;</span><br><span class="line">      console.log(this)</span><br><span class="line">      return this.color;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.setColor = function (color) &#123;</span><br><span class="line">      console.log(this)</span><br><span class="line">      this.color = color;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Person(&quot;red&quot;); //this是谁? window</span><br><span class="line"></span><br><span class="line">  var p = new Person(&quot;yello&quot;); //this是谁? p</span><br><span class="line"></span><br><span class="line">  p.getColor(); //this是谁? p</span><br><span class="line"></span><br><span class="line">  var obj = &#123;&#125;;</span><br><span class="line">  p.setColor.call(obj, &quot;black&quot;); //this是谁? obj</span><br><span class="line"></span><br><span class="line">  var test = p.setColor;</span><br><span class="line">  test(); //this是谁? window</span><br><span class="line"></span><br><span class="line">  function fun1() &#123;</span><br><span class="line">    function fun2() &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun2(); //this是谁? window</span><br><span class="line">  &#125;</span><br><span class="line">  fun1();</span><br></pre></td></tr></table></figure><ul><li><p>匿名函数自调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function(w, obj)&#123;</span><br><span class="line">  //实现代码</span><br><span class="line">&#125;)(window, obj)</span><br></pre></td></tr></table></figure><ul><li>专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式 </li><li>作用<ul><li>隐藏实现</li><li>不会污染外部(全局)命名空间</li><li>用它来编码js模块</li></ul></li></ul></li><li><p>回调函数的理解</p><ul><li>什么函数才是回调函数?<ul><li>你定义的</li><li>你没有调用</li><li>但它最终执行了(在一定条件下或某个时刻)</li></ul></li><li>常用的回调函数<ul><li>dom事件回调函数</li><li>定时器回调函数</li><li>ajax请求回调函数(后面讲解)</li><li>生命周期回调函数(后面讲解)</li></ul></li></ul></li><li><p>问题 js一条语句的后面是否应该加分号？</p><ul><li>是否加分号是编码风格问题，没有应不应该，只有喜不喜欢——尤雨溪</li><li>必须加分号的情况：<ul><li>小括号开头的语句 ;(function () {…})()</li><li>方括号的开头 ;[1, 2, 3].forEach(() =&gt; {})</li></ul></li></ul></li></ul><hr><p>&emsp;&emsp;本篇笔记到此完结。</p><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decoration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">点这里，进入QQ交流</a></center></center></center></center>]]></content:encoded>
      
      <comments>https://shulu520.com/js-advance/js-advance-one/#disqus_thread</comments>
    </item>
    
    <item>
      <title>js-modularize</title>
      <link>https://shulu520.com/js-modularize/js-modularize/</link>
      <guid>https://shulu520.com/js-modularize/js-modularize/</guid>
      <pubDate>Thu, 23 May 2019 14:17:24 GMT</pubDate>
      <description>
      
        modularize js模块化历程，硅谷教程总结
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;</p><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">来QQ撩我啊</a></center><a id="more"></a><h2 id="modularize"><a href="#modularize" class="headerlink" title="modularize"></a>modularize</h2><ul><li>一阶段 所有的代码都写在一个文件下 即暴露在全局环境下 污染环境</li><li>二阶段 将某些api 放到一个对象之中 使用时通过obj.xxx来调用 不安全 因为在别处同样可以通过obj.xxx来将其修改掉</li><li>三阶段 匿名函数自执行(闭包)  安全 JQuery 就是这么做的 引入js文件太多 请求过多 依赖模糊</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(function( window )&#123;</span><br><span class="line">  function foo () &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  // 将foo方法挂载到window上的xxx属性对象上</span><br><span class="line">  // 调用时xxx.foo()即可</span><br><span class="line">  window.xxx = &#123; foo &#125;</span><br><span class="line"></span><br><span class="line">  // 或将foo方法挂载到window上的xxx属性对象上，作为一个函数</span><br><span class="line">  // 调用时直接foo()执行即可</span><br><span class="line">  window.xxx = foo </span><br><span class="line">&#125;)( window )</span><br></pre></td></tr></table></figure><h2 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h2><h3 id="commonJs"><a href="#commonJs" class="headerlink" title="commonJs"></a>commonJs</h3><ul><li>一个js文件就是一个模块</li><li>向外暴露1 module.exports = value  value可以是任意值</li><li>向外暴露2 exports.xxx = value  value可以是任意值</li><li>引入模块 require(‘包名’) 自己写的文件要相对路劲</li></ul><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><ul><li>define</li></ul><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><ul><li>阿里大牛结合commonjs和AMD写的 卖给老外了</li></ul><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><ul><li><p>webpack 模块打包工具</p></li><li><p>分别暴露 即常规暴露<br>相当于一个模块中有许多个变量<br>export xxx = …<br>export yyy = …<br>export zzz = …</p></li><li><p>引入时要解构赋值 指名道姓拿到相应的变量<br>import { xxx, yyy, zzz } from ‘路劲’</p></li><li><p>统一暴露 默认暴露<br>export default {…}</p></li><li><p>引入时 import xxx from ‘路劲’</p></li></ul><hr><p>&emsp;&emsp;未完待续……</p><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">点这里，跟我聊QQ</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/js-modularize/js-modularize/#disqus_thread</comments>
    </item>
    
    <item>
      <title>IT-proper-nouns</title>
      <link>https://shulu520.com/IT/IT-proper-nouns/</link>
      <guid>https://shulu520.com/IT/IT-proper-nouns/</guid>
      <pubDate>Thu, 23 May 2019 14:02:57 GMT</pubDate>
      <description>
      
        IT-proper-nouns it编程专有名词解释
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;</p><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decoration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">来QQ撩我啊</a></center><a id="more"></a><h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><ul><li>应用程序接口(Application Programming Interface)</li></ul><h2 id="cli"><a href="#cli" class="headerlink" title="cli"></a>cli</h2><ul><li>命令行界面(Command Line Interface)</li></ul><h2 id="sdk"><a href="#sdk" class="headerlink" title="sdk"></a>sdk</h2><ul><li>软件开发工具包(Software Development Kit)</li></ul><h2 id="rc-结尾的文件"><a href="#rc-结尾的文件" class="headerlink" title="rc 结尾的文件"></a>rc 结尾的文件</h2><ul><li>run control 运行时控制文件</li></ul><hr><p>&emsp;&emsp;未完待续……</p><center>👉<a target="_blank" style="color:hotpink;font-weight:bold;text-decoration:none" href="http://wpa.qq.com/msgrd?v=3&uin=2642816105&site=qq&menu=yes">点这里，跟我QQ聊天呗</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/IT/IT-proper-nouns/#disqus_thread</comments>
    </item>
    
    <item>
      <title>node-koa2</title>
      <link>https://shulu520.com/node/node-koa2/</link>
      <guid>https://shulu520.com/node/node-koa2/</guid>
      <pubDate>Tue, 21 May 2019 17:54:24 GMT</pubDate>
      <description>
      
        nodejs+koa2电影预告片
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;hello my world<br><a id="more"></a></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ul><li>github创建仓库</li><li>本地git clone 仓库</li><li>项目目录下 初始化 npm init<h2 id="npm-start-启动快捷方法"><a href="#npm-start-启动快捷方法" class="headerlink" title="npm start 启动快捷方法"></a>npm start 启动快捷方法</h2></li><li>在package.json 中添加配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;node server/index.js&quot;,</span><br></pre></td></tr></table></figure><ul><li>添加 .gitignore 文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># dependencies</span><br><span class="line">node_modules</span><br><span class="line"></span><br><span class="line"># logs</span><br><span class="line">npm-debug.log</span><br><span class="line"></span><br><span class="line"># System</span><br><span class="line">.DS_Store</span><br><span class="line"></span><br><span class="line">#Generate</span><br><span class="line">dist</span><br><span class="line"></span><br><span class="line"># Build</span><br><span class="line">bulid</span><br></pre></td></tr></table></figure><h2 id="pug-模板引擎"><a href="#pug-模板引擎" class="headerlink" title="pug 模板引擎"></a>pug 模板引擎</h2><p>npm i pug -S</p><hr><p>&emsp;&emsp;未完待续……</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/node/node-koa2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>async-fn-note</title>
      <link>https://shulu520.com/uncategorized/async-fn-note/</link>
      <guid>https://shulu520.com/uncategorized/async-fn-note/</guid>
      <pubDate>Mon, 20 May 2019 02:00:01 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp;&amp;emsp;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;</p><a id="more"></a><p>正文：</p><hr><p>&emsp;&emsp;</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/uncategorized/async-fn-note/#disqus_thread</comments>
    </item>
    
    <item>
      <title>arrow-js-note</title>
      <link>https://shulu520.com/arrowjs/arrow-js-note/</link>
      <guid>https://shulu520.com/arrowjs/arrow-js-note/</guid>
      <pubDate>Sun, 19 May 2019 16:11:45 GMT</pubDate>
      <description>
      
        箭头函数相关知识总结
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;今天是2019年，520，在这特殊的一天我面对的依然是code, but no Object, 我希望有一天能美梦成真——面向对象面向君，不负代码不负卿。</p><a id="more"></a><h2 id="箭头函数的经典题型"><a href="#箭头函数的经典题型" class="headerlink" title="箭头函数的经典题型"></a>箭头函数的经典题型</h2><ul><li>有关 this</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  id: 01,</span><br><span class="line">  say: function () &#123;</span><br><span class="line">    // 这里的this为obj</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      // 这里是匿名函数的this默认为window</span><br><span class="line">      console.log(&apos;arrow id:&apos;, this.id); // undifind</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;,</span><br><span class="line">  sayWithThis: function () &#123;</span><br><span class="line">    // 这里将this的值当成变量存起来</span><br><span class="line">    let that = this;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      console.log(&apos;arrow id:&apos;, that.id); // 01</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;,</span><br><span class="line">  sayWithArrow: function () &#123;</span><br><span class="line">    // 这里的this为obj</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(&apos;arrow id:&apos;, this.id); // 01</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;,</span><br><span class="line">  sayWithGlobalArrow: () =&gt; &#123;</span><br><span class="line">    // 这里的this已经为全局的this了</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(&apos;arrow id:&apos;, this.id); // undifind</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>&emsp;&emsp;未完待续……</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/arrowjs/arrow-js-note/#disqus_thread</comments>
    </item>
    
    <item>
      <title>git-qa-note</title>
      <link>https://shulu520.com/git/git-qa-note/</link>
      <guid>https://shulu520.com/git/git-qa-note/</guid>
      <pubDate>Sat, 18 May 2019 04:11:06 GMT</pubDate>
      <description>
      
        在git的使用中遇到的问题&amp;解决方法
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;<br><a id="more"></a></p><h2 id="科学上网之后，git-报错"><a href="#科学上网之后，git-报错" class="headerlink" title="科学上网之后，git 报错"></a>科学上网之后，git 报错</h2><ul><li>如下错误：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh: Could not resolve hostname github.com: Name or service not known</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure><ul><li>解决方法<br>1、找到本机的 host 文件，一般位置是进入 C:\Windows\System32\drivers\etc</li></ul><p>2、在host文件的最后一行加上，如果之前已经设置过，可以将ip地址更改为最新的正确的ip地址</p><p>192.30.255.112  github.com git<br>185.31.16.184   github.global.ssl.fastly.net</p><hr><p>&emsp;&emsp;遇到后继续补充……</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/git/git-qa-note/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Array-note</title>
      <link>https://shulu520.com/Array/Array-note/</link>
      <guid>https://shulu520.com/Array/Array-note/</guid>
      <pubDate>Fri, 17 May 2019 16:41:04 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp;&amp;emsp;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;</p><a id="more"></a><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><ul><li>计算数组成员的个数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const countOccurrences = (arr,val) =&gt; arr.reduce((a,v) =&gt; (v === val ? a + 1 : a), 0)</span><br><span class="line"></span><br><span class="line">alert(countOccurrences([1,111,2,2,2,3,4], 2)); // 3</span><br></pre></td></tr></table></figure><h2 id="max"><a href="#max" class="headerlink" title="max"></a>max</h2><ul><li>Math.max.apply(null, arr)</li><li>Math.max(…arr)</li></ul><p>&emsp;&emsp;未完待续……</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/Array/Array-note/#disqus_thread</comments>
    </item>
    
    <item>
      <title>node-blue-note</title>
      <link>https://shulu520.com/node/node-blue-note-md/</link>
      <guid>https://shulu520.com/node/node-blue-note-md/</guid>
      <pubDate>Thu, 16 May 2019 13:44:45 GMT</pubDate>
      <description>
      
        taobao前端工程师石川(blue)视频教程笔记
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;我本来要忘记你了，可我又做梦了。<br><a id="more"></a></p><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><ul><li>http 模块 GET方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http);</span><br><span class="line">  //创建一个服务器</span><br><span class="line">var server = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">  /*</span><br><span class="line">    给这个地址随便提交一个表单 http://localhost:8080/aaa</span><br><span class="line">    其中 req.url = &apos;/aaa?user=shulu&amp;pass=123&apos;</span><br><span class="line">    运用字符串的切割数组的拼接就可以拿到用户名与密码</span><br><span class="line">  */</span><br><span class="line">&#125;).listen(8080);</span><br></pre></td></tr></table></figure><ul><li>queryString 模块 GET方式<br>争对这种数据 xxx=…&amp;yyy=…&amp;zzz=…</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const querystring = require(&apos;queryString&apos;);</span><br><span class="line">var json = querystring.parse(&apos;user=shulu&amp;pass=123&amp;age=18&apos;);</span><br><span class="line">console.log(json) // &#123;&quot;user&quot;: &quot;shulu&quot;, &quot;pass&quot;: &quot;123&quot;, &quot;age&quot;: &quot;18&quot;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>url 模块 GET方式<br>争对这种数据 整个url部分 参数为true效果更好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http);</span><br><span class="line">const _url = require(&apos;url&apos;);</span><br><span class="line">var server = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">  var obj = _url.parse(req.url, true);</span><br><span class="line">  var url = obj.pathname;</span><br><span class="line">  const GET = obj.query;</span><br><span class="line">&#125;).listen(8080);</span><br></pre></td></tr></table></figure></li><li><p>http 模块 POST方式</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">const querystring = require(&apos;querystring&apos;);</span><br><span class="line">var server = http.createServer((req, res) =&gt;&#123;</span><br><span class="line">  //请求数据一样在req中</span><br><span class="line">  var str = &apos;&apos;;</span><br><span class="line">  //data数据大 分多次到达</span><br><span class="line">  req.on(&apos;data&apos;, (data) =&gt; &#123; //data事件</span><br><span class="line">    str += data;</span><br><span class="line">  &#125;);</span><br><span class="line">  req.on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">    var POST = querystring.parse(str)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).listen(8888);</span><br></pre></td></tr></table></figure><h2 id="express-框架"><a href="#express-框架" class="headerlink" title="express 框架"></a>express 框架</h2><ul><li>express保留了原生的功能，增加了一些自己的功能</li><li>基本使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">var server = express();</span><br><span class="line">server.use(&apos;/a.html&apos;, function (req, res) &#123;</span><br><span class="line">  //res.send() 方法参数可以是json等</span><br><span class="line">  //res.write() 参数只能是字符串或buffer</span><br><span class="line">  res.send(&apos;aaaa&apos;);</span><br><span class="line">  res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(8080);</span><br></pre></td></tr></table></figure><ul><li>三种接收处理请求的方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.get()</span><br><span class="line">server.post()</span><br><span class="line">server.use()</span><br></pre></td></tr></table></figure><ul><li>express-static 插件 处理静态文件的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const expresStatic = require(&apos;express-static&apos;);</span><br><span class="line"></span><br><span class="line">var server = express();</span><br><span class="line">server.listen(8888);</span><br><span class="line"></span><br><span class="line">server.use(expresStatic(&apos;./www&apos;));</span><br></pre></td></tr></table></figure><ul><li>中间件 body-parser 解析POST数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.use(bodyParser.urlencode(&#123;</span><br><span class="line">  extend: false, //扩展模式</span><br><span class="line">  limit: 1024*1024 //限制1M</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><ul><li><p>multer 解析post文件<br> multipart/form-data 格式的表单数据</p></li><li><p>链式操作 next</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server.use(&apos;/&apos;, function (req, res, next) &#123;</span><br><span class="line">  console.log(&apos;aaa&apos;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line">server.use(&apos;/&apos;, function (req, res, next) &#123;</span><br><span class="line">  console.log(&apos;bbb&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="模板引擎-ejs"><a href="#模板引擎-ejs" class="headerlink" title="模板引擎 ejs"></a>模板引擎 ejs</h2><h2 id="path-模块"><a href="#path-模块" class="headerlink" title="path 模块"></a>path 模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">var str = &apos;c:\\user\\www\\a.html&apos;;</span><br><span class="line">var obj = path.parse(str);</span><br><span class="line">console.log(obj);</span><br><span class="line"></span><br><span class="line">//base: 文件名部分 如a.html</span><br><span class="line">//ext: 扩展名 如.html</span><br><span class="line">//dir: 文件路劲 如c:\\user\\www</span><br></pre></td></tr></table></figure><p><hr><br>&emsp;&emsp;未完待续……</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/node/node-blue-note-md/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hotkey-vim</title>
      <link>https://shulu520.com/hotkey/hotkey-vim/</link>
      <guid>https://shulu520.com/hotkey/hotkey-vim/</guid>
      <pubDate>Wed, 15 May 2019 15:34:56 GMT</pubDate>
      <description>
      
        vim的封号为&quot;编辑器之神&quot;, 学会了vimium也就掌握vim的核心用法, 一举两得!
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;You only live on this earth once.<br><a id="more"></a></p><h2 id="快捷强大的vim"><a href="#快捷强大的vim" class="headerlink" title="快捷强大的vim"></a>快捷强大的vim</h2><ul><li><p>vimium能提升我们的浏览速度, 鼠标比键盘简单, 键盘比鼠标快!</p></li><li><p>快速向下滚动d </p></li><li>快速向上滚动u</li><li>滚动到页面顶部gg </li><li><p>滚动到页面底部G</p></li><li><p>神技! 快速搜索 (相当于浏览器顶部搜索框), 并在新标签打开 大写的O</p></li><li>关闭页面x  恢复页面X</li><li>主动脱离焦点esc 比如按下o搜索退出时按esc</li><li>shift+/,查看所有快捷键</li></ul><p>&emsp;&emsp;如果你想要个和现在不同的人生，就必须去做你从未做过的事情。努力之后最坏的结果是失败，但不尝试的结果则是无止境的懊悔、怀疑和平庸。<br><!--more--></p><h2 id="vscode-常用快捷键"><a href="#vscode-常用快捷键" class="headerlink" title="vscode 常用快捷键"></a>vscode 常用快捷键</h2><ul><li><p>上下移动一行： Alt+Up 或 Alt+Down</p></li><li><p>向上或向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down</p></li><li><p>同时选中所有匹配： Ctrl+Shift+L</p></li><li><p>Ctrl+D 下一个匹配的也被选中 </p></li><li><p>Alt + 单击  ：插入光标</p></li><li><p>Ctrl + F2    选择当前字的所有出现</p></li><li><p>ctrl  shift  k   删除整行</p></li><li><p>ctrl  shift  a   多行注释</p></li><li><p>ctrl  f     当前文件内搜索相关代码，终于找到这个功能了，哈哈，右上角会有弹框，其中有前后箭头，表示搜索的代码上一次、下一次出现的位置，点击直接会跳转到相应的位置，并且侧边上有相应的位置标识。</p></li><li><p>ctrl - 整体缩小</p></li><li><p>ctrl = 整体放大</p></li><li><p>文件/首选项/设置 搜索zoom 根据配置 可以更精细的对大小进行操作 ctrl 加滚轮</p></li></ul><hr><p>&emsp;&emsp;未完待续……</p><center><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me by QQ email</a></center>]]></content:encoded>
      
      <comments>https://shulu520.com/hotkey/hotkey-vim/#disqus_thread</comments>
    </item>
    
    <item>
      <title>nodejs-guigu</title>
      <link>https://shulu520.com/node/nodejs-guigu/</link>
      <guid>https://shulu520.com/node/nodejs-guigu/</guid>
      <pubDate>Tue, 14 May 2019 14:50:21 GMT</pubDate>
      <description>
      
        硅谷nodejs视频教程笔记
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;我期待有一天背着背包出现在你的城市。<br><a id="more"></a></p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul><li>小娜 输入 环境变量 进入环境变量/用户变量/path 点开 里面是一条条的文件路劲 可以新建一个文件的路劲</li><li>在这里配置了 相当于 声明了一个 类似于 js 中的全局变量 为作用域链的最高层</li><li>可以将一些常用的文件或程序的路劲添加到path下 这样我们就可以在任意的位置访问他们了</li></ul><h2 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程 线程"></a>进程 线程</h2><ul><li>进程<br>  负责为程序的运行提供必备的环境<br>  工厂的车间</li><li>线程<br>  负责执行进程中的程序<br>  车间工人</li><li>单线程<br>  一个人干活</li><li>多线程<br>  多人合作干一个活 </li></ul><h2 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h2><ul><li>事件驱动</li><li>非阻塞</li><li>异步I/O  (性能瓶颈阶段)  input写入操作  output读操作</li><li>版本 奇数为开发版  偶数为稳定版</li><li>在Node中，模块分为三类：一类是底层由C++编写的内建模块，一类是Node提供的核心模块；还有一类是用户编写的模块，称为文件模块。<h2 id="node-js-模块化"><a href="#node-js-模块化" class="headerlink" title="node.js 模块化"></a>node.js 模块化</h2></li><li>新建一个js文件就是一个模块</li><li>这个模块里面写的代码其实是包在一个函数里面的 即</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">funcyion (exports, require, module, _filename, _dirname) &#123;</span><br><span class="line">/*</span><br><span class="line">这里是我们写的代码 外面其实包了一层这个函数 默认不可见</span><br><span class="line">可以通过console.log(arguments.callee) 或</span><br><span class="line">  console.log(arguments.callee + &quot;&quot;) 将此函数打印出来 </span><br><span class="line">  该函数执行时传进了5个参数</span><br><span class="line">所以模块里面的代码是局部变量</span><br><span class="line">exports参数 用来将变量或函数暴露到外边</span><br><span class="line">require参数 用来引入外部的模块</span><br><span class="line">module参数 代表模块本身 exports是module的属性</span><br><span class="line">_filename 当前模块的完整路劲</span><br><span class="line">_dirname 当前模块所在文件夹的路劲</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>module.exports 与exports的区别<br>  module.exports == exports  true<br>  exports 只能使用.的方式向外暴露 若exports = {} 这样向外暴露的话就修改了exports的引用对象<br>  module.exports 既可以通过.的形式 也可以直接赋值 <code>推荐写法</code></li><li>核心模块<br>  由node 提供的模块 node_moudle中的 引入时直接写模块名字 不需要路劲 </li><li>文件模块<br>  由我们自己创建的模块   引入时添加./或../等路劲</li></ul><h2 id="包-package"><a href="#包-package" class="headerlink" title="包 package"></a>包 package</h2><ul><li>包实际上就是一个压缩文件 解压以后还原为目录</li><li>规范的目录包含以下文件：<br>  -package.json <code>包描述文件</code> (必须的) <code>里面不能写注释</code><br>  -bin 可执行二进制文件  binary 二进制<br>  -lib js代码 library 库 图书馆<br>  -doc 文档 document<br>  -test 单元测试</li></ul><h2 id="npm-即-Node-Package-Manager-node包管理器"><a href="#npm-即-Node-Package-Manager-node包管理器" class="headerlink" title="npm 即 (Node Package Manager) node包管理器"></a>npm 即 (Node Package Manager) node包管理器</h2><ul><li>commonjs包规范的是一种理论 npm是其中一种实践</li><li>对node而言 npm帮助其完成了第三方模块的发布安和依赖</li><li>借助npm 使得node与第三方模块之间形成一个生态系统</li><li>查看版本 npm version查看相关的版本 或npm -v</li><li>npm search 包名 搜索包</li><li>npm init 在某一文件夹下初始化该文件夹 帮助我们根据提示生成一个package.json的文件<br>  在初始化后的文件夹下 安装搜索的包 并新建一个index.js 入口文件在里面就可以直接引入math模块使用了</li><li>npm install 包名 安装 包 或npm i</li><li>npm remove 或 npm r  删除包 </li><li>npm install 包名 杠杠save  安装包并添加到依赖中</li><li>npm install 下载当前项目所依赖的包</li><li>npm install 包名 -g 全局安装包 一般是安装一些工具 如vue-cli </li><li>cnpm 也可以用 快速</li><li>node在使用下载的包时 会沿着作用域链一直往上找直到磁盘根目录找不到则报错 这就解释了某的包在删除之后依然能用的情况</li></ul><h2 id="Buffer-（缓冲区）"><a href="#Buffer-（缓冲区）" class="headerlink" title="Buffer （缓冲区）"></a>Buffer （缓冲区）</h2><ul><li>结构和数组很相似 方法也类似</li><li>补充了数组方法的不足 Buffer专门存贮二进制数据的</li><li>实际上Buffer中的内存不是通过JavaScript分配的，而是在底层通过C++申请的。也就是我们可以直接通过Buffer来创建内存中的空间。</li><li>使用buffer无需引入模块 直接使用即可</li><li>Buffer.from(str) 将字符串str转为buffer二进制数据</li><li>在buffer中存贮的都是二进制数据 但在显示时都是以16进制的形式显示的<br>  二进制 00-255 或 00-ff</li><li>计算机 一个0或一个1 称为一位(bit)</li><li>8bit = 1byte(字节) 最小单位 中文一个汉字占用三个字节</li><li>创建一个制定大小的buffer<br>  Buffer.alloc(10) 10字节大小<br>  可通过索引来操作buffer中的元素</li><li>Buffer的大小一旦确定 不能再更该 因为存储空间是连续的 性能好</li><li>Buffer与字符串间的转换</li><li>支持的编码:<br>   ASCII、UTF-8、UTF-16LE/UCS-2、Base64、Binary、Hex</li><li>字符串转Buffer<br>   Buffer.from(str , [encoding]); </li><li>Buffer转字符串 buf.toString()<br>   buf.toString([encoding] , [start] , [end]);</li><li>复制缓冲区<br>   buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])</li><li>对缓冲区切片<br> buf.slice([start[, end]])</li><li>拼接缓冲区<br>   Buffer.concat(list[, totalLength])     <h2 id="fs-文件系统"><a href="#fs-文件系统" class="headerlink" title="fs (文件系统)"></a>fs (文件系统)</h2></li><li>在Node中，与文件系统的交互是非常重要的，服务器的本质就将本地的文件发送给远程的客户端</li><li>核心模块 直接引入使用</li><li>const fs = require(‘fs’)</li><li>fs 模块中所有的操作都有两种形式 同步(会阻塞 带sync) 异步(不会阻塞 带回调函数)</li><li>fs模块中所有的操作都有两种形式可供选择同步和异步</li><li>同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码。异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。</li><li>打开文件<br>   fs.open(path, flags[, mode], callback)<br>   fs.openSync(path, flags[, mode])</li><li>关闭文件<br>   fs.close(fd, callback)<br>   fs.closeSync(fd)</li><li>fs中提供了四种不同的方式将数据写入文件<br>   简单文件写入<br>   同步文件写入<br>   异步文件写入<br>   流式文件写入</li><li><p>同步文件的写入：<br>  1.打开文件<br>  操作方式为定为写 即<br>  var fd = fs.openSync(path, flags) 参数为字符串类型</p><pre><code>path即文件的路劲flags即 r表示读操作  w表示写入操作</code></pre><p>  通过返回的描述符fd对文件进行各种操作 </p><p>  2.写入内容数据<br>  fs.writeSync(fd, string)</p><pre><code>fd文件的描述符 需要传入文件的描述符string要写入的内容</code></pre><p>  3.关闭文件 考虑性能<br>  fs.closeSync(fd)</p></li><li><p>异步文件写入<br>  1.打开文件</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fs.open(path, flags, function (err, fd) &#123;</span><br><span class="line">if (!err) &#123;</span><br><span class="line">2.在这里往文件写入内容 写操作</span><br><span class="line">fs.write(fd, &apos;要异步写入的内容&apos;, function (err) &#123;</span><br><span class="line">if (!err) &#123;</span><br><span class="line">console.log(&apos;write success&apos;)</span><br><span class="line">&#125;</span><br><span class="line">fs.close(fd, function (err) &#123;</span><br><span class="line">if (!err) &#123;</span><br><span class="line">console.log(&apos;close success&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(fd)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">console.log(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>返回值为 callback的参数</p><ul><li>简单文件写入<br>  简单同步文件<br>  fs.write<br>  简单异步文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(&apos;hello.txt&apos;, &apos;shulu520&apos;, &#123;flag: &apos;a&apos;&#125; function (err) &#123; //flag: &apos;a&apos; 追加文件内容 不会覆盖原来的 如果文件不存在则创建 flag还有好多的模式</span><br><span class="line">if (!err) &#123;</span><br><span class="line">console.log(&apos;write success&apos;)</span><br><span class="line">&#125;</span><br><span class="line">//文件路劲可以是F:\JSdownload\npm-test 这种 `但是要变为`F:\\JSdownload\\npm-test或F:/JSdownload/npm-test</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>同步 异步 简单文件 的写入都不适合大文件爱的写入 易导致内存溢出 性能差</li><li>流式文件写入</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">创建流</span><br><span class="line">var ws = fs.createWriteStream(path)</span><br><span class="line">监听事件 once绑定一次性的事件</span><br><span class="line">ws.once(&apos;open&apos;, function () &#123; </span><br><span class="line">console.log(&apos;stream success&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">ws.once(&apos;close&apos;, function () &#123;</span><br><span class="line">console.log(&apos;stream close&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">写入内容 大量内容</span><br><span class="line">ws.write(&apos;写入内容1&apos;)</span><br><span class="line">ws.write(&apos;写入内容2&apos;)</span><br><span class="line">ws.write(&apos;写入内容3&apos;)</span><br><span class="line">ws.write(&apos;写入内容4&apos;)</span><br><span class="line">……</span><br><span class="line">关闭流 在流开始的一方结束流</span><br><span class="line">ws.end()</span><br><span class="line">```</span><br><span class="line">+ fs中提供了四种读取文件的方式</span><br><span class="line"> 简单文件读取</span><br><span class="line"> 同步文件读取</span><br><span class="line"> 异步文件读取</span><br><span class="line"> 流式文件读取</span><br><span class="line">+ 简单文件读取</span><br><span class="line">  简单异步文件读取</span><br></pre></td></tr></table></figure><p>const fs = require(‘fs’);<br>fs.readFile(‘shulu.jpg’, (err, data) =&gt; {<br>    if(!err) {<br>        fs.writeFile(‘桌面路劲/lqy.jpg’, data, () =&gt; {<br>            if(!err) {<br>                console.log(‘文件写入成功 ‘)<br>            }<br>        })<br>    }<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 流式文件读取 适用于大文件</span><br></pre></td></tr></table></figure></p><p>const fs = require(‘fs’);<br>1.创建读取流<br>const rs = fs.createReadStream(‘shulu.jpg’);<br>2.监听流的开启和关闭<br>rs.once(‘open’, () =&gt; {<br>    console.log(‘流打开成功了’)<br>})<br>rs.once(‘close’, () =&gt; {<br>    console.log(‘流关闭了’)<br>})<br>3.读取数据<br>rs.on(‘data’, (data) =&gt; {<br>    console.log(data) //多次分批读取大数据<br>})</p><ul><li>pipe 流方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>const fs = require(‘fs’);<br>const rs = fs.createReadStream(‘shulu.mp3’);<br>const ws = fs.createWriteStrem(‘lqy.mp3’);<br>rs.pipe(ws); 读取后直接流入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ fs 模块其他操作</span><br><span class="line">检查一个文件是否存在</span><br><span class="line">+ 列出文件</span><br><span class="line"> fs.readdir(path[, options], callback)</span><br><span class="line"> fs.readdirSync(path[, options])</span><br><span class="line">+ 截断文件</span><br><span class="line"> fs.truncate(path, len, callback)</span><br><span class="line"> fs.truncateSync(path, len)</span><br><span class="line">+ 建立目录</span><br><span class="line"> fs.mkdir(path[, mode], callback)</span><br><span class="line"> fs.mkdirSync(path[, mode])</span><br><span class="line">+ 验证路径是否存在</span><br><span class="line"> fs.existsSync(path)</span><br><span class="line">+ 获取文件信息</span><br><span class="line"> fs.stat(path, callback)</span><br><span class="line"> fs.statSync(path)</span><br><span class="line">+ 删除文件</span><br><span class="line"> fs.unlink(path, callback)</span><br><span class="line"> fs.unlinkSync(path)</span><br><span class="line"></span><br><span class="line">+ 删除目录</span><br><span class="line"> fs.rmdir(path, callback)</span><br><span class="line"> fs.rmdirSync(path)</span><br><span class="line">+ 重命名文件和目录</span><br><span class="line"> fs.rename(oldPath, newPath, callback)</span><br><span class="line"> fs.renameSync(oldPath, newPath)</span><br><span class="line">+ 监视文件更改写入</span><br><span class="line"> fs.watchFile(filename[, options], listener)</span><br></pre></td></tr></table></figure><p>const fs = require(‘fs’);<br>const isExists = fs.existsSync(‘shulu.mp3’);<br>console.log(isExists);<br><code>`</code></p><hr><p>&emsp;&emsp;未完待续……<br>&emsp;&emsp;</p><h2><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=LEBdVU1fQGxdXQJPQ0E" style="text-decoration:none;color:hotpink;">write to me</a></h2><p></p><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/node/nodejs-guigu/#disqus_thread</comments>
    </item>
    
    <item>
      <title>es6-zhuf-01.md</title>
      <link>https://shulu520.com/es6/es6-zhuf-01/</link>
      <guid>https://shulu520.com/es6/es6-zhuf-01/</guid>
      <pubDate>Mon, 13 May 2019 15:46:29 GMT</pubDate>
      <description>
      
        zhuf架构视频教程笔记
      
      </description>
      
      <content:encoded><![CDATA[<hr><p>&emsp;&emsp;想要的东西，会以最快的速度来到你的身边。</p><hr><a id="more"></a><h2 id="var-与-let-和-const-的区别"><a href="#var-与-let-和-const-的区别" class="headerlink" title="var 与 let 和 const 的区别"></a>var 与 let 和 const 的区别</h2><p>新的方法解决了老方法遗留的问题</p><ul><li><p>var<br>  在同一作用域内可以对同一变量重复声明<br>  不能定义常量(控制不了，因为可以修改，写了等于没写)<br>  不支持块级作用域</p></li><li><p>let<br>  在同一作用域内不能对同一变量重复声明<br>  变量不会提升 变量定义之前使用会报错<br>  有块级作用域 {这里面为块级作用域}<br>  以前js只有两种作用域 一个是全局 一个是函数级<br>  作用域经典问题： for 循环里面套 定时器 当时的解决方法 给定时器包一层自执行的匿名函数并将循环变量传进去 本质上是作用域问题 现在用let声明变量就可以了</p></li><li><p>const<br>  在同一作用域内不能对同一变量重复声明<br>  专门声明常量 常量声明后不可修改<br>  但若此常量是一个引用类型的话(例如一个对象) 引用对象的属性还是可以改的 例如：定义 const USER = {name: ‘shulu’} 更改为 USER.name = ‘lqy’ 可以的</p></li></ul><h2 id="解构-分解一个对象的解构"><a href="#解构-分解一个对象的解构" class="headerlink" title="解构 分解一个对象的解构"></a>解构 分解一个对象的解构</h2><ul><li>解构的时候 等号的两边解构相似 右边必须是一个真实的值</li><li>数组的省略赋值<br>  let arr = [1, 2, 3]; let [,,x] = arr 则只拿到x=3的值</li></ul><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><ul><li>以前是字符串拼串 现在是这个符号  <code></code> 可以折行 换行</li><li>模板语言的原理 正则实现 面试</li><li>带参数的模板字符串</li><li><p>字符串的新方法 返回布尔值<br>  str.startWith(‘http’)<br>  str.endsWith(‘.com’)<br>  str.includes(‘shulu’) 以前 str.indexOf(‘shulu’) == -1  做判断<br>  str.repeat(10) 重复10次</p></li><li><p>展开运算符 …<br>   对象合并：<br>   Object.assign(obj3, obj2, obj1); 将对象1，2合并为3<br>   obj3 = {…obj1, …obj2} 更简洁</p></li><li><p>对象的深拷贝</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let obj2 = JSON.parse(JSON.stringify(obj1))</span><br></pre></td></tr></table></figure><ul><li>递归实现对象深拷贝</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//对象深拷贝</span><br><span class="line">function deepClone(origin,target)&#123;</span><br><span class="line"></span><br><span class="line">//target是否存在如果不存在创建空对象</span><br><span class="line">let tar = target || &#123;&#125;,</span><br><span class="line"></span><br><span class="line">//判断是否为引用数据类型</span><br><span class="line">toStr = Object.prototype.toString,</span><br><span class="line">arrType=&apos;[object Array]&apos;;</span><br><span class="line"></span><br><span class="line">for(let key in origin)&#123;</span><br><span class="line">//剥离原型链的数据</span><br><span class="line">if(origin.hasOwnProperty(key))&#123;</span><br><span class="line">//判断是否为引用数据类型 对象或数组</span><br><span class="line">if(typeof(origin[key]) === &apos;object&apos; &amp;&amp; origin[key] !== null)&#123;</span><br><span class="line">if(toStr.call(origin[key]) === arrType )&#123;</span><br><span class="line">tar[key] = [];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">tar[key] = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">deepClone(origin[key],tar[key]);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">tar[key] = origin[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return tar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>箭头函数<br>箭头函数this 继承自父级，自己本身没有this</li></ul><hr><p>&emsp;&emsp;未完待续……</p><hr>]]></content:encoded>
      
      <comments>https://shulu520.com/es6/es6-zhuf-01/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>

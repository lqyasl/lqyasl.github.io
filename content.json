{"meta":{"title":"梦不成","subtitle":"思念如马-自别离-未停蹄","description":"君子生非异也，善假于物也","author":"梦不成","url":"https://shulu520.com","root":"/"},"pages":[{"title":"categories","date":"2019-04-20T01:53:24.000Z","updated":"2019-04-20T05:54:52.506Z","comments":true,"path":"categories/index.html","permalink":"https://shulu520.com/categories/index.html","excerpt":"","text":""},{"title":"js","date":"2019-04-16T18:00:45.000Z","updated":"2019-04-16T18:00:45.870Z","comments":true,"path":"js/index.html","permalink":"https://shulu520.com/js/index.html","excerpt":"","text":""},{"title":"","date":"2019-04-22T05:57:10.894Z","updated":"2019-04-22T05:57:10.894Z","comments":true,"path":"404/404.html","permalink":"https://shulu520.com/404/404.html","excerpt":"","text":"L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"model\":{\"scale\":1,\"hHeadPos\":0.5,\"vHeadPos\":0.618,\"jsonPath\":\"/live2dw/assets/shizuku.model.json\"},\"display\":{\"superSample\":2,\"width\":160,\"height\":320,\"position\":\"left\",\"hOffset\":-12,\"vOffset\":-43},\"mobile\":{\"show\":true,\"scale\":0.5},\"react\":{\"opacityDefault\":0.7,\"opacityOnHover\":0.2},\"log\":false,\"tagMode\":false});"},{"title":"","date":"2019-04-22T05:41:23.000Z","updated":"2019-04-25T17:02:04.110Z","comments":false,"path":"/404.html","permalink":"https://shulu520.com//404.html","excerpt":"","text":"&lt;!DOCTYPE HTML&gt; L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"model\":{\"scale\":1,\"hHeadPos\":0.5,\"vHeadPos\":0.618,\"jsonPath\":\"/live2dw/assets/shizuku.model.json\"},\"display\":{\"superSample\":2,\"width\":160,\"height\":320,\"position\":\"left\",\"hOffset\":-12,\"vOffset\":-43},\"mobile\":{\"show\":true,\"scale\":0.5},\"react\":{\"opacityDefault\":0.7,\"opacityOnHover\":0.2},\"log\":false,\"tagMode\":false});"},{"title":"guestbook","date":"2019-04-20T10:28:28.000Z","updated":"2019-04-20T10:30:14.977Z","comments":true,"path":"guestbook/index.html","permalink":"https://shulu520.com/guestbook/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-20T01:52:59.000Z","updated":"2019-04-20T05:55:51.245Z","comments":true,"path":"tags/index.html","permalink":"https://shulu520.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-08-22T09:28:15.270Z","updated":"2020-08-22T09:28:15.270Z","comments":true,"path":"about/css/style.css","permalink":"https://shulu520.com/about/css/style.css","excerpt":"","text":"*{ margin: 0;padding: 0; } a{ text-decoration: none; } #beye{ margin-top: 10px; text-align: center; font-size: 30px; } body{ width: 100%; height: 100%; overflow: hidden; border: 24px solid transparent; /* border-image: url(../assets/img/border.png) 80 100 repeat ; */ background-color: pink; } #box{ height: 140px; margin: 80px auto; line-height: 140px; text-align: center; font-size: 38px; border-radius: 20px; color: red; } canvas { position:absolute; right:0; width:100%; height: 50%; z-index: 999; } #gohome a{ text-decoration: none; color: #fff; font-weight: bold; display: block; width: 100%; height: 100%; text-align: center; } #gohome a:hover{ color:red; } #gohome{ position: absolute; bottom: 15%; left: 50%; z-index: 9999; text-align: center; margin-left:-50px; width: 80px; height: 80px; overflow: hidden; font-size: 18px; line-height: 80px; border-radius: 50%; opacity: 0.4; background-color:rgba(45, 182, 67, 0.9); -webkit-animation: rotate 3s linear infinite; -moz-animation: rotate 3s linear infinite; -o-animation: rotate 3s linear infinite; animation: rotate 3s linear infinite; } @-webkit-keyframes rotate{from{-webkit-transform: rotate(0deg)} to{-webkit-transform: rotate(360deg)} } @-moz-keyframes rotate{from{-moz-transform: rotate(0deg)} to{-moz-transform: rotate(359deg)} } @-o-keyframes rotate{from{-o-transform: rotate(0deg)} to{-o-transform: rotate(359deg)} } @keyframes rotate{from{transform: rotate(0deg)} to{transform: rotate(359deg)} }"},{"title":"","date":"2020-07-13T10:46:49.466Z","updated":"2019-04-26T10:48:46.313Z","comments":true,"path":"about/js/index.js","permalink":"https://shulu520.com/about/js/index.js","excerpt":"","text":"(function () { var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame; window.requestAnimationFrame = requestAnimationFrame; })(); var canvas = document.getElementById(\"canvas\"), shapeCan = document.createElement(\"canvas\"), ctx = canvas.getContext(\"2d\"), sCtx = shapeCan.getContext(\"2d\"), width = window.innerWidth, height = document.body.offsetHeight, vanishPointY = height / 2, vanishPointX = width / 2, focalLength = 300, angle = 0, angleY = 0, angleX = 0, angleZ = 0, mouseX = 0, mouseY = 0; var settings = { MouseRotation: false, ClockColor: { r: 255, g: 0, b: 0 } } canvas.width = width; canvas.height = height; shapeCan.width = 200; shapeCan.height = 100; sCtx.font = '3em Arial'; /* * Controls the emitter */ function Emitter() { this.particles = []; this.shapeParts = []; this.x = 1; this.y = 1; this.z = 1; this.getShape(); this.startTime = new Date().getTime(); this.checkInterval = 200; } Emitter.prototype.update = function () { var partLen = this.particles.length; if (settings.MouseRotation) { angleX = (mouseY - vanishPointY) * 0.01; angleY = (mouseX - vanishPointX) * 0.01; } else { angleY = Math.sin(angle += 0.01); angleX = Math.sin(angle); angleZ = Math.sin(angle); } // z-sorting this.particles.sort(function (a, b) { return b.z - a.z; }); for (var i = 0; i < partLen; i++) { var particle = this.particles[i]; if (particle) { particle.update(); } } } Emitter.prototype.getShape = function () { var d = new Date(), hour = d.getHours() % 12, min = (d.getMinutes() < 10 ? \"0\" : \"\") + d.getMinutes(), sec = (d.getSeconds() < 10 ? \"0\" : \"\") + d.getSeconds(); sCtx.clearRect(0, 0, shapeCan.width, shapeCan.height); sCtx.fillText(hour + \":\" + min + \":\" + sec, 0, 30); var imageData = sCtx.getImageData(0, 0, shapeCan.width, shapeCan.height).data; for (var i = 0; i < imageData.length; i += 4) { var x = i / 4 % shapeCan.width, y = (i / 4 - x) / shapeCan.width, index = i; if (imageData[i + 3] > 0) { for (var p = 0; p < 4; p++) { if (!this.shapeParts[index + p]) { var particle = new Particle({ x: ((x * 2)) - 200, y: ((y * 2)) - 100, z: 10 }); this.shapeParts[index + p] = particle; this.particles[index + p] = particle; } } } else { for (var p = 0; p < 4; p++) { if (this.shapeParts[index + p]) { this.shapeParts[index + p].explode(); this.shapeParts[index + p] = undefined; } } } } } Emitter.prototype.render = function () { if (new Date().getTime() > this.startTime + this.checkInterval) { this.startTime = new Date().getTime(); this.getShape(); } var imgData = ctx.createImageData(width, height), data = imgData.data, partLen = this.particles.length; for (var i = 0; i < partLen; i++) { var particle = this.particles[i]; if (particle && particle.render && particle.xPos < width && particle.xPos > 0 && particle.yPos > 0 && particle.yPos < height) { for (var w = 0; w < particle.size; w++) { for (var h = 0; h < particle.size; h++) { if (particle.xPos + w < width && particle.xPos + w > 0 && particle.yPos + h > 0 && particle.yPos + h < height) { pData = (~~ (particle.xPos + w) + (~~ (particle.yPos + h) * width)) * 4; data[pData] = settings.ClockColor.r; data[pData + 1] = settings.ClockColor.g; data[pData + 2] = settings.ClockColor.b; data[pData + 3] = particle.color[3]; } } } } else if (particle && !particle.render) { this.particles[i] = undefined; delete particle; } } ctx.putImageData(imgData, 0, 0); } /* * Controls the individual particles */ function Particle(options) { options = options || {}; this.maxDist = 1000; this.x = options.x || (Math.random() * 10) - 5; this.y = options.y || (Math.random() * 10) - 5; this.z = options.z || (Math.random() * 10) - 5; this.startX = this.x; this.startY = this.y; this.startZ = this.z; this.xPos = 0; this.yPos = 0; this.angle = 0; this.vx = 0; this.vy = 0; this.vz = 0; this.color = [255, 0, 0, 255] this.render = true; this.scaler = 2; } Particle.prototype.explode = function () { this.vx = (Math.random() * 30) - 15; this.vy = (Math.random() * 30) - 15; this.vz = (Math.random() * 30) - 15; } Particle.prototype.rotate = function () { var x = this.startX * Math.cos(angleZ) - this.startY * Math.sin(angleZ), y = this.startY * Math.cos(angleZ) + this.startX * Math.sin(angleZ); this.x = x; this.y = y; x = this.startX * Math.cos(angleY) - this.startZ * Math.sin(angleY); var z = this.startZ * Math.cos(angleY) + this.startX * Math.sin(angleY); this.x = x; this.z = z; y = this.startY * Math.cos(angleX) - this.startZ * Math.sin(angleX); z = this.startZ * Math.cos(angleX) + this.startY * Math.sin(angleX); this.y = y; this.z = z; } Particle.prototype.update = function () { this.x = (this.startX += this.vx); this.y = (this.startY += this.vy); this.z = (this.startZ -= this.vz); this.rotate(); this.render = false; if (this.z > -focalLength) { var scale = focalLength / (focalLength + this.z); this.size = scale * this.scaler; this.xPos = vanishPointX + this.x * scale; this.yPos = vanishPointY + this.y * scale; var dx = this.startX - this.x, dy = this.startY - this.y, dz = this.startZ - this.z, dist = Math.sqrt(dx * dx + dy * dy + dz * dz); if (dist < this.maxDist) { this.render = true; } } } function render() { emitter.update(); emitter.render(); requestAnimationFrame(render); } var emitter = new Emitter(); render(); // var gui = new dat.GUI(); // gui.add(settings, 'MouseRotation'); // gui.addColor(settings, 'ClockColor'); document.body.addEventListener(\"mousemove\", function (e) { mouseX = e.clientX; mouseY = e.clientY; }); window.onresize = function () { height = canvas.height = document.body.offsetHeight; width = canvas.width = document.body.offsetWidth; vanishPointY = height / 2; vanishPointX = width / 2; };"},{"title":"","date":"2020-07-14T06:52:02.354Z","updated":"2020-07-14T06:52:02.354Z","comments":true,"path":"love/css/style.css","permalink":"https://shulu520.com/love/css/style.css","excerpt":"","text":"*{margin:0px;padding:0px;} body{ background-color: rgba(153, 205, 50, 0.358); } .heart3d { position: absolute; top: 12%; right: 0; left: 0; margin: auto; width: 100px; height: 160px; transform-origin:centercenter center; transform-style: preserve-3d; animation: spin 15s infinite linear; } #display{ position: absolute; top: 40%; left: 0; right: 0; margin: 0 10%; } .display { background-image: -webkit-linear-gradient(left,rgb(13, 13, 216),#66ffff 10%,#cc00ff 20%,#CC00CC 30%, #CCCCFF 40%, #00FFFF 50%,#CCCCFF 60%,#CC00CC 70%,#CC00FF 80%,#66FFFF 90%,rgb(4, 0, 255) 100%); -webkit-text-fill-color: transparent;/* 将字体设置成透明色 */ -webkit-background-clip: text;/* 裁剪背景图，使文字作为裁剪区域向外裁剪 */ -webkit-background-size: 200% 100%; -webkit-animation: masked-animation 5s linear infinite; } @keyframes masked-animation { 0% { background-position: 0 0; } 50% { background-position: -50% 0; } 100% { background-position: -100% 0; } } #gohome a{ text-decoration: none; color: #fff; font-weight: bold; display: block; width: 100%; height: 100%; text-align: center; } #gohome a:hover{ color:red; } #gohome{ /* position: absolute; */ position: fixed; bottom: 10%; left: 50%; text-align: center; margin-left:-50px; width: 80px; height: 80px; overflow: hidden; font-size: 18px; line-height: 80px; border-radius: 50%; opacity: 0.4; background-color:rgba(45, 182, 67, 0.2); -webkit-animation: rotate 3s linear infinite; -moz-animation: rotate 3s linear infinite; -o-animation: rotate 3s linear infinite; animation: rotate 3s linear infinite; } @-webkit-keyframes rotate{from{-webkit-transform: rotate(0deg)} to{-webkit-transform: rotate(360deg)} } @-moz-keyframes rotate{from{-moz-transform: rotate(0deg)} to{-moz-transform: rotate(359deg)} } @-o-keyframes rotate{from{-o-transform: rotate(0deg)} to{-o-transform: rotate(359deg)} } @keyframes rotate{from{transform: rotate(0deg)} to{transform: rotate(359deg)} } .heart3d [class^=\"rib\"] { position: absolute; width: 100px; height: 160px; border: solid #f22613; border-width: 1px 1px 00; border-radius: 50% 50% 0 /40% 50% 0; } .heart3d [class$=\"1\"] { transform: rotateY(10deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"2\"] { transform: rotateY(20deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"3\"] { transform: rotateY(30deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"4\"] { transform: rotateY(40deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"5\"] { transform: rotateY(50deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"6\"] { transform: rotateY(60deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"7\"] { transform: rotateY(70deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"8\"] { transform: rotateY(80deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"9\"] { transform: rotateY(90deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"10\"] { transform: rotateY(100deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"11\"] { transform: rotateY(110deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"12\"] { transform: rotateY(120deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"13\"] { transform: rotateY(130deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"14\"] { transform: rotateY(140deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"15\"] { transform: rotateY(150deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"16\"] { transform: rotateY(160deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"17\"] { transform: rotateY(170deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"18\"] { transform: rotateY(180deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"19\"] { transform: rotateY(190deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"20\"] { transform: rotateY(200deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"21\"] { transform: rotateY(210deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"22\"] { transform: rotateY(220deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"23\"] { -webkit-transform: rotateY(230deg) rotateZ(45deg) translateX(30px); transform: rotateY(230deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"24\"] { transform: rotateY(240deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"25\"] { transform: rotateY(250deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"26\"] { transform: rotateY(260deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"27\"] { transform: rotateY(270deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"28\"] { transform: rotateY(280deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"29\"] { transform: rotateY(290deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"30\"] { transform: rotateY(300deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"31\"] { transform: rotateY(310deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"32\"] { transform: rotateY(320deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"33\"] { transform: rotateY(330deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"34\"] { transform: rotateY(340deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"35\"] { transform: rotateY(350deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"36\"] { transform: rotateY(360deg) rotateZ(45deg) translateX(30px); } @keyframes spin { to { transform: rotateY(360deg) rotateX(360deg); } } .per{ width:50px;height:50px;position:absolute;top:0;left:0;right:0;bottom:0; margin:auto;transform-style:preserve-3d;perspective:800px; } .img{width:50px;height:50px;position:absolute;backface-visibility:hidden; } .img:nth-child(1){top:-50px;left:0;transform-origin:bottom; transform:translateZ(30px)rotateX(90deg);} .img:nth-child(2){top:50px;left:0;transform-origin:top; transform:translateZ(30px)rotateX(-90deg);} .img:nth-child(3){top:0px;left:-50px;transform-origin:right; transform:translateZ(30px)rotateY(-90deg);} .img:nth-child(4){top:0px;left:50px;transform-origin:left; transform:translateZ(30px)rotateY(90deg);} .img:nth-child(6){top:0px;left:0;transform:translateZ(30px);} .img:nth-child(5){top:0px;left:0;transform:translateZ(0px);} #dance span.dance-content{ float:left; position: relative; top: 10px; left: 35%; margin: 5px; font-size: 30px; } #dance span.dance-content:nth-child(1){ -webkit-animation:jump 2s linear 0s infinite alternate; } #dance span.dance-content:nth-child(2){ -webkit-animation:jump 2s linear 0.2s infinite alternate; } #dance span.dance-content:nth-child(3){ -webkit-animation:jump 2s linear 0.4s infinite alternate; } #dance span.dance-content:nth-child(4){ -webkit-animation:jump 2s linear 0.3s infinite alternate; } #dance span.dance-content:nth-child(5){ -webkit-animation:jump 2s linear 0.4s infinite alternate; } #dance span.dance-content:nth-child(6){ -webkit-animation:jump 2s linear 0.3s infinite alternate; } #dance span.dance-content:nth-child(7){ -webkit-animation:jump 2s linear 0.4s infinite alternate; } @-webkit-keyframes jump { 0%{ top:0px; color:red; } 10%{ top:-4px; color:#66ffff; } 20%{ top:-8px; color:#cc00ff; } 30%{ top:-12px; color:#CC00CC; } 50%{ top:-16px; color:#00FFFF; } 60%{ top:-12px; color:rgb(105, 108, 255); } 70%{ top:-8px; color:#CC00CC; } 80%{ top:-4px; color:#CC00FF; } 90%{ top:-2px; color:#66FFFF; } 100%{ top:0px; color:rgb(13, 13, 216); } }"},{"title":"","date":"2019-05-02T14:08:55.625Z","updated":"2019-05-02T14:08:55.625Z","comments":true,"path":"about/assets/css/styles.css","permalink":"https://shulu520.com/about/assets/css/styles.css","excerpt":"","text":"/*------------------------- Simple reset --------------------------*/ *{ margin:0; padding:0; } /*------------------------- General Styles --------------------------*/ html{ position:relative; } body{ min-height: 600px; padding: 200px 0 0; font:14px/1.3 'Segoe UI',Arial, sans-serif; } a, a:visited { text-decoration:none; outline:none; color:#54a6de; } a:hover{ text-decoration:underline; } section, footer{ display: block; } /*---------------------------- Main Section -----------------------------*/ #note{ color: #666666; font-size: 12px; margin: 0 auto; padding: 4px; text-align: center; text-shadow: 1px 1px 0 rgba(255, 255, 255, 0.3); width: 400px; } /*---------------------------- The Footer -----------------------------*/ footer{ background-color: #111111; bottom: 0; box-shadow: 0 -1px 2px #111111; height: 45px; left: 0; position: fixed; width: 100%; z-index: 100000; } footer h2{ color: #EEEEEE; font-size: 14px; font-weight: normal; left: 50%; margin-left: -400px; padding: 13px 0 0; position: absolute; width: 540px; } footer h2 i{ font-style:normal; color:#888; } footer a.tzine,a.tzine:visited{ color: #999999; font-size: 12px; left: 50%; margin: 16px 0 0 110px; position: absolute; text-decoration: none; top: 0; } footer a i{ color:#ccc; font-style: normal; } footer a i b{ color:#c92020; font-weight: normal; }"},{"title":"","date":"2019-04-28T11:56:26.010Z","updated":"2011-12-29T19:39:44.000Z","comments":true,"path":"about/assets/countdown/jquery.countdown.css","permalink":"https://shulu520.com/about/assets/countdown/jquery.countdown.css","excerpt":"","text":".countdownHolder{ width:450px; margin:0 auto; font: 40px/1.5 'Open Sans Condensed',sans-serif; text-align:center; letter-spacing:-3px; } .position{ display: inline-block; height: 1.6em; overflow: hidden; position: relative; width: 1.05em; } .digit{ position:absolute; display:block; width:1em; background-color:#444; border-radius:0.2em; text-align:center; color:#fff; letter-spacing:-1px; } .digit.static{ box-shadow:1px 1px 1px rgba(4, 4, 4, 0.35); background-image: linear-gradient(bottom, #3A3A3A 50%, #444444 50%); background-image: -o-linear-gradient(bottom, #3A3A3A 50%, #444444 50%); background-image: -moz-linear-gradient(bottom, #3A3A3A 50%, #444444 50%); background-image: -webkit-linear-gradient(bottom, #3A3A3A 50%, #444444 50%); background-image: -ms-linear-gradient(bottom, #3A3A3A 50%, #444444 50%); background-image: -webkit-gradient( linear, left bottom, left top, color-stop(0.5, #3A3A3A), color-stop(0.5, #444444) ); } /** * You can use these classes to hide parts * of the countdown that you don't need. */ .countDays{ /* display:none !important;*/ } .countDiv0{ /* display:none !important;*/ } .countHours{} .countDiv1{} .countMinutes{} .countDiv2{} .countSeconds{} .countDiv{ display:inline-block; width:16px; height:1.6em; position:relative; } .countDiv:before, .countDiv:after{ position:absolute; width:5px; height:5px; background-color:#444; border-radius:50%; left:50%; margin-left:-3px; top:0.5em; box-shadow:1px 1px 1px rgba(4, 4, 4, 0.5); content:''; } .countDiv:after{ top:0.9em; }"},{"title":"","date":"2019-04-28T13:14:54.512Z","updated":"2019-04-28T13:14:54.512Z","comments":true,"path":"about/assets/js/script.js","permalink":"https://shulu520.com/about/assets/js/script.js","excerpt":"","text":"$(function(){ var note = $('#note'), // ts = new Date(2012, 0, 1), ts = new Date(2020,6,15); newYear = true; if((new Date()) > ts){ // The new year is here! Count towards something else. // Notice the *1000 at the end - time must be in milliseconds ts = (new Date()).getTime() + 10*24*60*60*1000; newYear = false; } $('#countdown').countdown({ timestamp : ts, callback : function(days, hours, minutes, seconds){ var message = \"\"; message += days + \" day\" + ( days==1 ? '':'s' ) + \", \"; message += hours + \" hour\" + ( hours==1 ? '':'s' ) + \", \"; message += minutes + \" minute\" + ( minutes==1 ? '':'s' ) + \" and \"; message += seconds + \" second\" + ( seconds==1 ? '':'s' ) + \" \"; if(newYear){ message += \"left until the new year!\"; } else { message += \"left to 10 days from now!\"; } note.html(message); } }); });"},{"title":"","date":"2019-04-28T11:56:26.035Z","updated":"2011-12-29T19:48:15.000Z","comments":true,"path":"about/assets/countdown/jquery.countdown.js","permalink":"https://shulu520.com/about/assets/countdown/jquery.countdown.js","excerpt":"","text":"/** * @name jQuery Countdown Plugin * @author Martin Angelov * @version 1.0 * @url http://tutorialzine.com/2011/12/countdown-jquery/ * @license MIT License */ (function($){ // Number of seconds in every time division var days = 24*60*60, hours = 60*60, minutes = 60; // Creating the plugin $.fn.countdown = function(prop){ var options = $.extend({ callback : function(){}, timestamp : 0 },prop); var left, d, h, m, s, positions; // Initialize the plugin init(this, options); positions = this.find('.position'); (function tick(){ // Time left left = Math.floor((options.timestamp - (new Date())) / 1000); if(left < 0){ left = 0; } // Number of days left d = Math.floor(left / days); updateDuo(0, 1, d); left -= d*days; // Number of hours left h = Math.floor(left / hours); updateDuo(2, 3, h); left -= h*hours; // Number of minutes left m = Math.floor(left / minutes); updateDuo(4, 5, m); left -= m*minutes; // Number of seconds left s = left; updateDuo(6, 7, s); // Calling an optional user supplied callback options.callback(d, h, m, s); // Scheduling another call of this function in 1s setTimeout(tick, 1000); })(); // This function updates two digit positions at once function updateDuo(minor,major,value){ switchDigit(positions.eq(minor),Math.floor(value/10)%10); switchDigit(positions.eq(major),value%10); } return this; }; function init(elem, options){ elem.addClass('countdownHolder'); // Creating the markup inside the container $.each(['Days','Hours','Minutes','Seconds'],function(i){ $('').html( '\\ 0\\ \\ \\ 0\\ ' ).appendTo(elem); if(this!=\"Seconds\"){ elem.append(''); } }); } // Creates an animated transition between the two numbers function switchDigit(position,number){ var digit = position.find('.digit') if(digit.is(':animated')){ return false; } if(position.data('digit') == number){ // We are already showing this number return false; } position.data('digit', number); var replacement = $('',{ 'class':'digit', css:{ top:'-2.1em', opacity:0 }, html:number }); // The .static class is added when the animation // completes. This makes it run smoother. digit .before(replacement) .removeClass('static') .animate({top:'2.5em',opacity:0},'fast',function(){ digit.remove(); }) replacement .delay(100) .animate({top:0,opacity:1},'fast',function(){ replacement.addClass('static'); }); } })(jQuery);"},{"title":"","date":"2019-04-26T09:48:38.162Z","updated":"2014-06-27T06:32:24.438Z","comments":true,"path":"about/js/dat.gui.min.js","permalink":"https://shulu520.com/about/js/dat.gui.min.js","excerpt":"","text":"/** * dat-gui JavaScript Controller Library * http://code.google.com/p/dat-gui * * Copyright 2011 Data Arts Team, Google Creative Lab * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 */ var dat=dat||{};dat.gui=dat.gui||{};dat.utils=dat.utils||{};dat.controllers=dat.controllers||{};dat.dom=dat.dom||{};dat.color=dat.color||{};dat.utils.css=function(){return{load:function(e,a){var a=a||document,c=a.createElement(\"link\");c.type=\"text/css\";c.rel=\"stylesheet\";c.href=e;a.getElementsByTagName(\"head\")[0].appendChild(c)},inject:function(e,a){var a=a||document,c=document.createElement(\"style\");c.type=\"text/css\";c.innerHTML=e;a.getElementsByTagName(\"head\")[0].appendChild(c)}}}(); dat.utils.common=function(){var e=Array.prototype.forEach,a=Array.prototype.slice;return{BREAK:{},extend:function(c){this.each(a.call(arguments,1),function(a){for(var f in a)this.isUndefined(a[f])||(c[f]=a[f])},this);return c},defaults:function(c){this.each(a.call(arguments,1),function(a){for(var f in a)this.isUndefined(c[f])&&(c[f]=a[f])},this);return c},compose:function(){var c=a.call(arguments);return function(){for(var d=a.call(arguments),f=c.length-1;f>=0;f--)d=[c[f].apply(this,d)];return d[0]}}, each:function(a,d,f){if(e&&a.forEach===e)a.forEach(d,f);else if(a.length===a.length+0)for(var b=0,n=a.length;b"}],"posts":[{"title":"Python数据分析之pandas笔记","slug":"Python数据分析之pandas笔记","date":"2021-04-15T04:42:39.000Z","updated":"2021-04-15T06:39:39.698Z","comments":true,"path":"pandas/Python数据分析之pandas笔记/","link":"","permalink":"https://shulu520.com/pandas/Python数据分析之pandas笔记/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; pandas数据帧DataFrame列操作1234567891011121314#创建数据帧import numpy as npimport pandas as pddata = &#123;&quot;name&quot;: [&quot;sun&quot;, &quot;liu&quot;, &quot;zhan&quot;, &quot;ren&quot;, &quot;dao&quot;], &quot;age&quot;:[18, 20, 16, 34, 25]&#125;df = pd.DataFrame(data, index=[&quot;rank1&quot;, &quot;rank2&quot;, &quot;rank3&quot;, &quot;rank4&quot;, &quot;rank5&quot;])print(df) name agerank1 sun 18rank2 liu 20rank3 zhan 16rank4 ren 34rank5 dao 25 12345678910# 列获取df[&apos;name&apos;] 或df.name 或df.get(&apos;name&apos;) #只有get方法找不到不报错，返回nonerank1 sunrank2 liurank3 zhanrank4 renrank5 daoName: name, dtype: object 12345678910# 列增加或修改df[&apos;sex&apos;]=[&apos;男&apos;,&apos;女&apos;,&apos;男&apos;,&apos;女&apos;,&apos;男&apos;]dfname age sexrank1 sun 18 男rank2 liu 20 女rank3 zhan16 男rank4 ren 34 女rank5 dao 25 男 12345678910# 列删除del df[&apos;age&apos;]df name sexrank1 sun 男rank2 liu 女rank3 zhan男rank4 ren 女rank5 dao 男 pandas数据帧DataFrame行操作12345678910111213141516# 行选择 按非数字index值(自定义非数字的index)data = &#123;&quot;name&quot;: [&quot;sun&quot;, &quot;liu&quot;, &quot;hao&quot;, &quot;ren&quot;, &quot;dao&quot;], &quot;age&quot;:[18, 20, 16, 34, 25]&#125;df=pd.DataFrame(data,index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])print(df)df.loc[&apos;b&apos;] name agea sun 18b liu 20c hao 16d ren 34e dao 25name liuage 20Name: b, dtype: object 12345678910111213141516171819202122232425# 行选择 按数字index值data = &#123;&quot;name&quot;: [&quot;sun&quot;, &quot;liu&quot;, &quot;hao&quot;, &quot;ren&quot;, &quot;dao&quot;], &quot;age&quot;:[18, 20, 16, 34, 25]&#125;df=pd.DataFrame(data)print(df)df.iloc[2] name age0 sun 181 liu 202 hao 163 ren 344 dao 25name haoage 16Name: 2, dtype: object#可以使用切片操作`:`运算符选择多行#loc和iloc的第二个参数都表示列选择，不写和写一个冒号都表示所有列#参数之间逗号隔开df.iloc[2:4] name age2 hao 163 ren 34 123456789101112# 行修改data = &#123;&quot;name&quot;: [&quot;sun&quot;, &quot;liu&quot;, &quot;hao&quot;, &quot;ren&quot;, &quot;dao&quot;], &quot;age&quot;:[18, 20, 16, 34, 25]&#125;df=pd.DataFrame(data,index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])df.loc[&apos;b&apos;]=&#123;&apos;shu&apos;,22&#125;df name agea sun 18b shu 22c hao 16d ren 34e dao 25 1234567891011121314# 行添加append# 行添加df2=pd.DataFrame([[&apos;lul&apos;,17],[&apos;yun&apos;,19]],index=[&apos;f&apos;,&apos;g&apos;],columns=[&apos;name&apos;,&apos;age&apos;])df=df.append(df2)dfname agea sun 18b lu 23c hao 16d ren 34e dao 25f lul 17g yun 19 12345678910111213#行删除df3=df[:3]print(df3) name agea sun 18b lu 23c hao 16df4=df3.drop(&apos;b&apos;) print(df4) name agea sun 18c hao 16 查看头尾 两个方法可以快速浏览数据结构，可以传数字参数，表示获取几条数据 df.head() df.tail() 重建索引reindex 其作用是创建一个适应新索引的新对象 参数index行索引 参数columns列索引 index和columns必须是原索引的子集 copy=true 123456789101112131415161718df=pd.DataFrame([[&apos;lul&apos;,17],[&apos;yun&apos;,19]],columns=[&apos;name&apos;,&apos;age&apos;])print(df)df2=df.reindex(index=[1],columns=[&apos;name&apos;,&apos;age&apos;])print(&apos;df2:&apos;)print(df2)print(df) name age0 lul 171 yun 19df2: name age1 yun 19 name age0 lul 171 yun 19 排序123456789101112131415161718192021#按行索引排序data = &#123;&quot;name&quot;: [&quot;sun&quot;, &quot;liu&quot;, &quot;hao&quot;, &quot;ren&quot;, &quot;dao&quot;], &quot;age&quot;:[18, 20, 16, 34, 25]&#125;df=pd.DataFrame(data,index=[3,2,4,0,1])print(df)df2=df.sort_index() #按行索引排序print(df2) name age3 sun 182 liu 204 hao 160 ren 341 dao 25 name age0 ren 341 dao 252 liu 203 sun 184 hao 16 12345678910#升降序可选ascending参数df3=df.sort_index(ascending=False) #降序print(df3) name age4 hao 163 sun 182 liu 201 dao 250 ren 34 12345678910111213141516#按列索引排序data = &#123;&quot;col2&quot;: [&quot;sun&quot;, &quot;liu&quot;, &quot;hao&quot;], &quot;col3&quot;:[18, 20, 16],&quot;col1&quot;:[&apos;sd&apos;,&apos;dd&apos;,8]&#125;df=pd.DataFrame(data)print(df)df2=df.sort_index(axis=1) #按列索引排序print(df2) col2 col3 col10 sun 18 sd1 liu 20 dd2 hao 16 8 col1 col2 col30 sd sun 181 dd liu 202 8 hao 16 12345678910111213141516# 按某列的值排序data = &#123;&quot;col2&quot;: [&quot;sun&quot;, &quot;liu&quot;, &quot;hao&quot;], &quot;col3&quot;:[18, 20, 16],&quot;col1&quot;:[&apos;sd&apos;,&apos;dd&apos;,8]&#125;df=pd.DataFrame(data)print(df)df2=df.sort_values(by=&apos;col3&apos;) #对col3列的值排序print(df2) col2 col3 col10 sun 18 sd1 liu 20 dd2 hao 16 8 col2 col3 col12 hao 16 80 sun 18 sd1 liu 20 dd 层次化索引1#层次化行索引 1#层次化列索引 123456789101112131415#行列同时层次化索引mindex1 = pd.MultiIndex.from_product([list(&quot;ABC&quot;),[&apos;期中&apos;,&apos;期末&apos;]])mindex2=pd.MultiIndex.from_product([[&apos;Python&apos;,&apos;Java&apos;, &apos;C++&apos;],[&apos;去年&apos;,&apos;今年&apos;]])socre = np.random.randint(0,150,(6,6))df = pd.DataFrame(data = socre,index = mindex1,columns = mindex2)df Python Java C++ 去年 今年 去年 今年 去年 今年A 期中 133 107 66 67 52 143 期末 44 93 59 3 55 46B 期中 148 14 123 136 102 69 期末 13 97 67 85 118 68C 期中 139 0 135 107 32 64 期末 51 144 138 62 68 35 层次化索引选择123456789101112131415161718192021#层次化索引选择df[[&apos;Java&apos;,&apos;C++&apos;]] Java C++去年 今年 去年 今年A 期中 45 26 79 89期末 130 113 122 42B 期中 79 44 45 8期末 116 125 23 31C 期中 148 141 117 99期末 27 50 102 23df[&apos;Java&apos;][&apos;今年&apos;]A 期中 26 期末 113B 期中 44 期末 125C 期中 141 期末 50Name: 今年, dtype: int32 123456df.loc[&apos;A&apos;] Python Java C++ 去年 今年 去年 今年 去年 今年期中 125 142 45 26 79 89期末 108 108 130 113 122 42 层次化行索引行列转置 stack()将列索引变为行索引 unstack()将行索引变为列索引 level参数：level=0对一级索引操作，=1对二级索引操作 1234567891011121314mindex1 = pd.MultiIndex.from_product([list(&quot;ABC&quot;),[&apos;期中&apos;,&apos;期末&apos;]])mindex2=pd.MultiIndex.from_product([[&apos;Python&apos;,&apos;Java&apos;, &apos;C++&apos;],[&apos;去年&apos;,&apos;今年&apos;]])socre = np.random.randint(0,150,(6,6))df = pd.DataFrame(data = socre,index = mindex1,columns = mindex2)df Python Java C++ 去年 今年 去年 今年 去年 今年A 期中 133 107 66 67 52 143 期末 44 93 59 3 55 46B 期中 148 14 123 136 102 69 期末 13 97 67 85 118 68C 期中 139 0 135 107 32 64 期末 51 144 138 62 68 35 1234567891011121314151617181920212223#一级列索引变为最小级行索引df.stack(level=0) 今年 去年A 期中 C++ 90 18 Java 6 1 Python 61 34 期末 C++ 84 78 Java 95 105 Python 113 132B 期中 C++ 146 80 Java 114 139 Python 42 104 期末 C++ 142 113 Java 118 59 Python 95 85C 期中 C++ 80 20 Java 126 118 Python 125 99 期末 C++ 51 43 Java 97 84 Python 29 16 1234567891011121314151617#二级列索引变为最小级行索引df.stack(level=1) C++ Java PythonA 期中 今年 90 6 61 去年 18 1 34 期末 今年 84 95 113 去年 78 105 132B 期中 今年 146 114 42 去年 80 139 104 期末 今年 142 118 95 去年 113 59 85C 期中 今年 80 126 125 去年 20 118 99 期末 今年 51 97 29 去年 43 84 16 12345678#一级行索引变为最小级列索引df.unstack(level=0) Python Java C++ 去年 今年 去年 今年 去年 今年 A B C A B C A B C A B C A B C A B C期中 34 104 99 61 42 125 1 139 118 6 114 126 18 80 20 90 146 80期末 132 85 16 113 95 29 105 59 84 95 118 97 78 113 43 84 142 51 123456789#二级行索引变为最小级列索引df.unstack(level=1) Python Java C++ 去年 今年 去年 今年 去年 今年 期中 期末 期中 期末 期中 期末 期中 期末 期中 期末 期中 期末A 34 132 61 113 1 105 6 95 18 78 90 84B 104 85 42 95 139 59 114 118 80 113 146 142C 99 16 125 29 118 84 126 97 20 43 80 51 日期与时间 pandas模块下的datetime模块在将来的版本中会被弃用 建议直接引入datetime模块使用 12import pandas as pdfrom datetime import datetime 获取日期、时间和时间戳123456789print(datetime.now())print(datetime.now().date())print(datetime.now().time())print(datetime.now().timestamp())2021-04-12 14:11:17.7900212021-04-1214:11:17.7910251618207877.791025 123456789101112print(datetime.today())print(datetime.today().date())print(datetime.today().time())print(datetime.today().timestamp())2021-04-12 14:35:16.0163022021-04-1214:35:16.0163021618209316.016302pd.datetime.now()2021-04-12 14:35:16.017273 字符串转为日期时间12345678910111213141516d=&apos;2021-5-1&apos;d1=[&apos;2021-1-1&apos;,&apos;2021-2-8&apos;,&apos;2021-3-2&apos;]d2=[&apos;2021-1-1&apos;,&apos;shulu&apos;,&apos;2021-3-2&apos;]print(pd.to_datetime(d))print(pd.to_datetime(d1))print(pd.to_datetime(d2,errors=&apos;ignore&apos;))print(pd.to_datetime(d2,errors=&apos;coerce&apos;))print(pd.Timestamp(d))2021-05-01 00:00:00DatetimeIndex([&apos;2021-01-01&apos;, &apos;2021-02-08&apos;, &apos;2021-03-02&apos;], dtype=&apos;datetime64[ns]&apos;, freq=None)Index([&apos;2021-1-1&apos;, &apos;shulu&apos;, &apos;2021-3-2&apos;], dtype=&apos;object&apos;)DatetimeIndex([&apos;2021-01-01&apos;, &apos;NaT&apos;, &apos;2021-03-02&apos;], dtype=&apos;datetime64[ns]&apos;, freq=None)2021-05-01 00:00:00#NaT表示不是一个时间的值(相当于NaN) 时间差1234567891011past=datetime(2017, 4, 16, 21, 21, 20, 871000)now=datetime.now()delta=now-pastprint(delta) print(delta.days)1456 days, 17:30:33.2169221456print(pd.Timedelta(now - past))1456 days 17:30:33.216922 时间戳索引DatetimeIndex的快速创建123456789print(pd.date_range(start=&apos;2021-5-1&apos;,end=&apos;2021-5-3&apos;))print(pd.date_range(start=&apos;2021-6-15&apos;,end=&apos;2021-8-6&apos;,freq=&apos;M&apos;))print(pd.date_range(start=&apos;2021-5-1&apos;,periods=3))print(pd.date_range(end=&apos;2021-5-1&apos;,periods=3))DatetimeIndex([&apos;2021-05-01&apos;, &apos;2021-05-02&apos;, &apos;2021-05-03&apos;], dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)DatetimeIndex([&apos;2021-06-30&apos;, &apos;2021-07-31&apos;], dtype=&apos;datetime64[ns]&apos;, freq=&apos;M&apos;)DatetimeIndex([&apos;2021-05-01&apos;, &apos;2021-05-02&apos;, &apos;2021-05-03&apos;], dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)DatetimeIndex([&apos;2021-04-29&apos;, &apos;2021-04-30&apos;, &apos;2021-05-01&apos;], dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;) 重采样 重新采样，是对原样本重新处理的一个方法，是一个对常规时间序列数据重新采样和频率转换的便捷的方法。 降采样：高频数据到低频数据 升采样：低频数据到高频数据 降采样1234567891011121314index = pd.date_range(&apos;1/1/2021&apos;, periods=9, freq=&apos;D&apos;)series = pd.Series(range(9), index=index)print(series)2021-01-01 02021-01-02 12021-01-03 22021-01-04 32021-01-05 42021-01-06 52021-01-07 62021-01-08 72021-01-09 8Freq: D, dtype: int64 123#默认：closed=left, label=leftprint(series.resample(&apos;3D&apos;)) #DatetimeIndexResampler 得到这个重采样构建器DatetimeIndexResampler [freq=&lt;3 * Days&gt;, axis=0, closed=left, label=left, convention=start, origin=start_day] 12345print(series.resample(&apos;3D&apos;).sum()) #通过聚合方法可以展现出来2021-01-01 32021-01-04 122021-01-07 21Freq: 3D, dtype: int64 12345print(series.resample(&apos;3D&apos;,label=&apos;right&apos;).sum())2021-01-04 32021-01-07 122021-01-10 21Freq: 3D, dtype: int64 123456print(series.resample(&apos;3D&apos;,closed=&apos;right&apos;).sum())2020-12-29 02021-01-01 62021-01-04 152021-01-07 15Freq: 3D, dtype: int64 123456print(series.resample(&apos;3D&apos;,label=&apos;right&apos;,closed=&apos;right&apos;).sum())2021-01-01 02021-01-04 62021-01-07 152021-01-10 15Freq: 3D, dtype: int64 增采样1234567891011121314index = pd.date_range(&apos;1/1/2000&apos;, periods=9, freq=&apos;T&apos;)series = pd.Series(range(9), index=index)series2000-01-01 00:00:00 02000-01-01 00:01:00 12000-01-01 00:02:00 22000-01-01 00:03:00 32000-01-01 00:04:00 42000-01-01 00:05:00 52000-01-01 00:06:00 62000-01-01 00:07:00 72000-01-01 00:08:00 8Freq: T, dtype: int64 12series.resample(&apos;30S&apos;)&lt;pandas.core.resample.DatetimeIndexResampler object at 0x000002B91F375CA0&gt; 12345678series.resample(&apos;30S&apos;).asfreq().head() #新索引没有值，为nan2000-01-01 00:00:00 0.02000-01-01 00:00:30 NaN2000-01-01 00:01:00 1.02000-01-01 00:01:30 NaN2000-01-01 00:02:00 2.0Freq: 30S, dtype: float64 12345678910series.resample(&apos;30S&apos;).asfreq().bfill().head(8) #用后面的一个数据填充nan2000-01-01 00:00:00 0.02000-01-01 00:00:30 1.02000-01-01 00:01:00 1.02000-01-01 00:01:30 2.02000-01-01 00:02:00 2.02000-01-01 00:02:30 3.02000-01-01 00:03:00 3.02000-01-01 00:03:30 4.0Freq: 30S, dtype: float64 12345678series.resample(&apos;30S&apos;).asfreq().ffill().head(6) #用前面的一个数据填充nan2000-01-01 00:00:00 0.02000-01-01 00:00:30 0.02000-01-01 00:01:00 1.02000-01-01 00:01:30 1.02000-01-01 00:02:00 2.02000-01-01 00:02:30 2.0Freq: 30S, dtype: float64 描述性统计信息函数123456789101112131415161718192021222324import numpy as npimport pandas as pddata = &#123; &apos;Name&apos;:pd.Series([&apos;Tom&apos;,&apos;James&apos;,&apos;Ricky&apos;,&apos;Vin&apos;,&apos;Steve&apos;,&apos;Minsu&apos;,&apos;Jack&apos;,&apos;Lee&apos;,&apos;David&apos;]), &apos;Age&apos;:pd.Series([25,np.nan,25,23,30,29,23,34,40]), &apos;Rating&apos;:pd.Series([4.23,3.24,np.nan,2.56,3.20,4.6,3.8,np.nan,2.98])&#125;df = pd.DataFrame(data)print(&quot;原数据：&quot;)print(df)print(&quot;\\n&quot;)原数据： Name Age Rating0 Tom 25.0 4.231 James NaN 3.242 Ricky 25.0 NaN3 Vin 23.0 2.564 Steve 30.0 3.205 Minsu 29.0 4.606 Jack 23.0 3.807 Lee 34.0 NaN8 David 40.0 2.98 123456789print(&quot;count():非空观测数量&quot;)print(df.count())print(&quot;\\n&quot;)count():非空观测数量Name 9Age 8Rating 7dtype: int64 12345678print(&quot;sum():返回所请求轴的值的总和。 默认情况下，轴为索引(axis=0)&quot;)print(df.sum())print(&quot;\\n&quot;)Name TomJamesRickyVinSteveMinsuJackLeeDavidAge 229Rating 24.61dtype: object 1234567891011121314print(&quot;sum():axis=1&quot;)print(df.sum(1))print(&quot;\\n&quot;)0 29.231 3.242 25.003 25.564 33.205 33.606 26.807 34.008 42.98dtype: float64 1234567891011121314print(&apos;cumsum()累计总和&apos;)print(df.cumsum())print(&quot;\\n&quot;) Name Age Rating0 Tom 25.0 4.231 TomJames NaN 7.472 TomJamesRicky 50.0 NaN3 TomJamesRickyVin 73.0 10.034 TomJamesRickyVinSteve 103.0 13.235 TomJamesRickyVinSteveMinsu 132.0 17.836 TomJamesRickyVinSteveMinsuJack 155.0 21.637 TomJamesRickyVinSteveMinsuJackLee 189.0 NaN8 TomJamesRickyVinSteveMinsuJackLeeDavid 229.0 24.61 12345678910111213print(&apos;cumprod()累计乘积&apos;)print(df[[&apos;Age&apos;,&apos;Rating&apos;]].cumprod()) Age Rating0 2.500000e+01 4.2300001 NaN 13.7052002 6.250000e+02 NaN3 1.437500e+04 35.0853124 4.312500e+05 112.2729985 1.250625e+07 516.4557936 2.876438e+08 1962.5320127 9.779888e+09 NaN8 3.911955e+11 5848.345396 1234567891011121314151617181920212223242526272829303132333435363738#唯一值 去重s=pd.Series(list(&apos;asaddvfshu&apos;))print(s.value_counts()) #重复值计数sq=s.unique() #去重print(s) print(sq) #[&apos;a&apos; &apos;s&apos; &apos;d&apos; &apos;v&apos; &apos;f&apos; &apos;h&apos; &apos;u&apos;]print(pd.Series(sq)) #包装成Seriesd 2a 2s 2v 1f 1h 1u 1dtype: int640 a1 s2 a3 d4 d5 v6 f7 s8 h9 udtype: object0 a1 s2 d3 v4 f5 h6 udtype: object 123456## 成员资格s=pd.Series(list([123]))s.isin([123,22])0 Truedtype: bool pandas的字符串操作 某一列.str.contains(字符) 筛选出含有特定字符串的行 某一列.str.split(分割字符) 分割字符串(加参数expand=True分割后变两列) 某一列.str.replace(old,new)字符串的替换 某一列.str.startswith() 与 endswith()字符串两端的字符的判断 某一列.str.findall()正则表达式 以数组形式返回 某一列.str.cat()拼接字符串 某一列.str.extract() 抽取匹配的字符串出来，注意要加上括号，如extract(“([d-z])”) 某一列.str.match() 检测是否全部匹配给定点的字符串或者表达式 某一列.str.strip()去除特定字符(包括lstrip和rstrip) 某一列.str.get() 获取指定位置的字符串 某一列.str.pad() 左右补齐 某一列.str.len()len() 计算字符串的长度 某一列.str.center() 中间补齐 某一列.str.ljust() 右边补齐 rjust() 左边补齐 某一列.str.zfill() 左边补0 某一列.str.lower() 全部小写 upper() 全部大写 某一列.str.repeat() 重复 某一列.str.wrap() 在指定的位置加回车符号 某一列.str.slice() 按给点的开始结束位置切割字符串 某一列.str.slice_replace() 使用给定的字符串，替换指定的位置的字符 某一列.str.count() 计算给定单词出现的次数 某一列.str.strip() 去除前后的空白字符 某一列.str.strip() lstrip() rstrip() 去除前后的空白字符 某一列.str.find() 从左边开始，查找给定字符串的所在位置 rfind() 从右边开始 某一列.str.index() 查找给定字符串的位置，注意，如果不存在这个字符串，那么会报错 某一列.str.capitalize() 首字符大写 某一列.str.swapcase() 大小写互换 某一列.str.isalnum() 是否全部是数字和字母组成 某一列.str.isdecimal() 是否全是数字 某一列.str.isdigit() 是否全部都是数字 某一列.str.istitle() 是否只有首字母为大写，其他字母为小写 某一列.str.isspace() 是否空格 某一列.str.islower() 是否全部小写 某一列.str.isalpha() 是否全部是字母 列的合并merge,以某个键为参考，默认how=’inner’使用键的交集1234567891011121314151617181920212223242526import pandas as pdleft = pd.DataFrame(&#123; &apos;id&apos;:[1,2,3,4,5], &apos;Name&apos;: [&apos;Alex&apos;, &apos;Amy&apos;, &apos;Allen&apos;, &apos;Alice&apos;, &apos;Ayoung&apos;], &apos;subject_id&apos;:[&apos;sub1&apos;,&apos;sub2&apos;,&apos;sub4&apos;,&apos;sub6&apos;,&apos;sub5&apos;]&#125;)right = pd.DataFrame( &#123;&apos;id&apos;:[1,2,3,4,5], &apos;Name&apos;: [&apos;Billy&apos;, &apos;Brian&apos;, &apos;Bran&apos;, &apos;Bryce&apos;, &apos;Betty&apos;], &apos;subject_id&apos;:[&apos;sub2&apos;,&apos;sub4&apos;,&apos;sub3&apos;,&apos;sub6&apos;,&apos;sub5&apos;]&#125;)print (left)print(&quot;========================================&quot;)print (right) id Name subject_id0 1 Alex sub11 2 Amy sub22 3 Allen sub43 4 Alice sub64 5 Ayoung sub5======================================== id Name subject_id0 1 Billy sub21 2 Brian sub42 3 Bran sub33 4 Bryce sub64 5 Betty sub5 12345678910# 在一个键上合并两个数据帧mdf=pd.merge(left,right,on=&apos;id&apos;)print(mdf) id Name_x subject_id_x Name_y subject_id_y0 1 Alex sub1 Billy sub21 2 Amy sub2 Brian sub42 3 Allen sub4 Bran sub33 4 Alice sub6 Bryce sub64 5 Ayoung sub5 Betty sub5 1234567# 合并多个键上的两个数据帧mdf=pd.merge(left,right,on=[&apos;id&apos;,&apos;subject_id&apos;])print(mdf) id Name_x subject_id Name_y0 4 Alice sub6 Bryce1 5 Ayoung sub5 Betty 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 使用“how”的参数# left使用左侧对象的键# right使用右侧对象的键# outer使用键的并集# inner使用键的交集 默认innermdf=pd.merge(left,right,on=&apos;subject_id&apos;,how=&apos;left&apos;)print(mdf)print(&quot;========================================&quot;)mdf=pd.merge(left,right,on=&apos;subject_id&apos;,how=&apos;right&apos;)print(mdf)print(&quot;========================================&quot;)mdf=pd.merge(left,right,on=&apos;subject_id&apos;,how=&apos;inner&apos;)print(mdf)print(&quot;========================================&quot;)mdf=pd.merge(left,right,on=&apos;subject_id&apos;,how=&apos;outer&apos;)print(mdf) id_x Name_x subject_id id_y Name_y0 1 Alex sub1 NaN NaN1 2 Amy sub2 1.0 Billy2 3 Allen sub4 2.0 Brian3 4 Alice sub6 4.0 Bryce4 5 Ayoung sub5 5.0 Betty======================================== id_x Name_x subject_id id_y Name_y0 2.0 Amy sub2 1 Billy1 3.0 Allen sub4 2 Brian2 NaN NaN sub3 3 Bran3 4.0 Alice sub6 4 Bryce4 5.0 Ayoung sub5 5 Betty======================================== id_x Name_x subject_id id_y Name_y0 2 Amy sub2 1 Billy1 3 Allen sub4 2 Brian2 4 Alice sub6 4 Bryce3 5 Ayoung sub5 5 Betty======================================== id_x Name_x subject_id id_y Name_y0 1.0 Alex sub1 NaN NaN1 2.0 Amy sub2 1.0 Billy2 3.0 Allen sub4 2.0 Brian3 4.0 Alice sub6 4.0 Bryce4 5.0 Ayoung sub5 5.0 Betty5 NaN NaN sub3 3.0 Bran 1234567891011121314151617181920212223242526import pandas as pdleft = pd.DataFrame(&#123; &apos;id&apos;:[1,2,3,4,5], &apos;Name&apos;: [&apos;Alex&apos;, &apos;Amy&apos;, &apos;Allen&apos;, &apos;Alice&apos;, &apos;Ayoung&apos;], &apos;sub_l&apos;:[&apos;sub1&apos;,&apos;sub2&apos;,&apos;sub4&apos;,&apos;sub6&apos;,&apos;sub5&apos;]&#125;)right = pd.DataFrame( &#123;&apos;id&apos;:[1,2,3,4,5], &apos;Name&apos;: [&apos;Billy&apos;, &apos;Brian&apos;, &apos;Bran&apos;, &apos;Bryce&apos;, &apos;Betty&apos;], &apos;sub_r&apos;:[&apos;sub2&apos;,&apos;sub4&apos;,&apos;sub3&apos;,&apos;sub6&apos;,&apos;sub5&apos;]&#125;)print (left)print(&quot;========================================&quot;)print (right) id Name sub_l0 1 Alex sub11 2 Amy sub22 3 Allen sub43 4 Alice sub64 5 Ayoung sub5======================================== id Name sub_r0 1 Billy sub21 2 Brian sub42 3 Bran sub33 4 Bryce sub64 5 Betty sub5 12345678mdf=pd.merge(left,right,left_on=&apos;sub_l&apos;,right_on=&apos;sub_r&apos;)print(mdf) id_x Name_x sub_l id_y Name_y sub_r0 2 Amy sub2 1 Billy sub21 3 Allen sub4 2 Brian sub42 4 Alice sub6 4 Bryce sub63 5 Ayoung sub5 5 Betty sub5 12345678910111213141516171819202122232425import pandas as pdleft = pd.DataFrame(&#123; &apos;id&apos;:[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;], &apos;Name&apos;: [&apos;Alex&apos;, &apos;Amy&apos;, &apos;Allen&apos;, &apos;Alice&apos;, &apos;Ayoung&apos;], &apos;sub_l&apos;:[&apos;sub1&apos;,&apos;sub2&apos;,&apos;sub4&apos;,&apos;sub6&apos;,&apos;sub5&apos;]&#125;)right = pd.DataFrame( &#123;&apos;Name&apos;: [&apos;Billy&apos;, &apos;Brian&apos;, &apos;Bran&apos;, &apos;Bryce&apos;, &apos;Betty&apos;], &apos;sub_r&apos;:[&apos;sub2&apos;,&apos;sub4&apos;,&apos;sub3&apos;,&apos;sub6&apos;,&apos;sub5&apos;]&#125;,index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;])print (left)print(&quot;========================================&quot;)print (right) id Name sub_l0 a Alex sub11 b Amy sub22 c Allen sub43 d Alice sub64 e Ayoung sub5======================================== Name sub_ra Billy sub2b Brian sub4c Bran sub3d Bryce sub6e Betty sub5 123456789mdf=pd.merge(left,right,left_on=&apos;id&apos;,right_index=True)print(mdf) id Name_x sub_l Name_y sub_r0 a Alex sub1 Billy sub21 b Amy sub2 Brian sub42 c Allen sub4 Bran sub33 d Alice sub6 Bryce sub64 e Ayoung sub5 Betty sub5 数据帧的堆叠concat，默认join=’outer’取并集，axis=0竖向堆叠12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import pandas as pddf1 = pd.DataFrame(&#123;&apos;A&apos;: [&apos;A0&apos;, &apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;], &apos;B&apos;: [&apos;B0&apos;, &apos;B1&apos;, &apos;B2&apos;, &apos;B3&apos;], &apos;C&apos;: [&apos;C0&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;C3&apos;], &apos;D&apos;: [&apos;D0&apos;, &apos;D1&apos;, &apos;D2&apos;, &apos;D3&apos;]&#125;, index=[0, 1, 2, 3])df2 = pd.DataFrame(&#123;&apos;A&apos;: [&apos;A4&apos;, &apos;A5&apos;, &apos;A6&apos;, &apos;A7&apos;], &apos;B&apos;: [&apos;B4&apos;, &apos;B5&apos;, &apos;B6&apos;, &apos;B7&apos;], &apos;C&apos;: [&apos;C4&apos;, &apos;C5&apos;, &apos;C6&apos;, &apos;C7&apos;], &apos;D&apos;: [&apos;D4&apos;, &apos;D5&apos;, &apos;D6&apos;, &apos;D7&apos;]&#125;, index=[4, 5, 6, 7])df3 = pd.DataFrame(&#123;&apos;A&apos;: [&apos;A8&apos;, &apos;A9&apos;, &apos;A10&apos;, &apos;A11&apos;], &apos;B&apos;: [&apos;B8&apos;, &apos;B9&apos;, &apos;B10&apos;, &apos;B11&apos;], &apos;C&apos;: [&apos;C8&apos;, &apos;C9&apos;, &apos;C10&apos;, &apos;C11&apos;], &apos;D&apos;: [&apos;D8&apos;, &apos;D9&apos;, &apos;D10&apos;, &apos;D11&apos;]&#125;, index=[8, 9, 10, 11])print(&quot;df1:&quot;)print(df1)print(&quot;\\n&quot;)print(&quot;df2:&quot;)print(df2)print(&quot;\\n&quot;)print(&quot;df3:&quot;)print(df3)df1: A B C D0 A0 B0 C0 D01 A1 B1 C1 D12 A2 B2 C2 D23 A3 B3 C3 D3df2: A B C D4 A4 B4 C4 D45 A5 B5 C5 D56 A6 B6 C6 D67 A7 B7 C7 D7df3: A B C D8 A8 B8 C8 D89 A9 B9 C9 D910 A10 B10 C10 D1011 A11 B11 C11 D11 1234567891011121314151617181920212223242526272829303132333435#默认join=&apos;outer&apos;取并集，默认axis=0竖向堆叠cdf=pd.concat([df1,df2,df3]) print(cdf)print(&quot;========================================&quot;)# 使用传递的键作为最外层构建层次索引。cdf=pd.concat([df1,df2,df3],keys=[&apos;x&apos;,&apos;y&apos;,&apos;z&apos;])print(cdf) A B C D0 A0 B0 C0 D01 A1 B1 C1 D12 A2 B2 C2 D23 A3 B3 C3 D34 A4 B4 C4 D45 A5 B5 C5 D56 A6 B6 C6 D67 A7 B7 C7 D78 A8 B8 C8 D89 A9 B9 C9 D910 A10 B10 C10 D1011 A11 B11 C11 D11======================================== A B C Dx 0 A0 B0 C0 D0 1 A1 B1 C1 D1 2 A2 B2 C2 D2 3 A3 B3 C3 D3y 4 A4 B4 C4 D4 5 A5 B5 C5 D5 6 A6 B6 C6 D6 7 A7 B7 C7 D7z 8 A8 B8 C8 D8 9 A9 B9 C9 D9 10 A10 B10 C10 D10 11 A11 B11 C11 D11 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#修改df3的index索引，方便对比df3 = pd.DataFrame(&#123;&apos;A&apos;: [&apos;A8&apos;, &apos;A9&apos;, &apos;A10&apos;, &apos;A11&apos;], &apos;B&apos;: [&apos;B8&apos;, &apos;B9&apos;, &apos;B10&apos;, &apos;B11&apos;], &apos;C&apos;: [&apos;C8&apos;, &apos;C9&apos;, &apos;C10&apos;, &apos;C11&apos;], &apos;D&apos;: [&apos;D8&apos;, &apos;D9&apos;, &apos;D10&apos;, &apos;D11&apos;]&#125;, index=[6, 7, 10, 11])print(df3)print(&quot;========================================&quot;)cdf=pd.concat([df1,df2,df3])print(cdf)print(&quot;========================================&quot;)# 如果想要生成的对象遵循新的索引，请将ignore_index设置为Truecdf=pd.concat([df1,df2,df3],ignore_index=True)print(cdf) A B C D6 A8 B8 C8 D87 A9 B9 C9 D910 A10 B10 C10 D1011 A11 B11 C11 D11======================================== A B C D0 A0 B0 C0 D01 A1 B1 C1 D12 A2 B2 C2 D23 A3 B3 C3 D34 A4 B4 C4 D45 A5 B5 C5 D56 A6 B6 C6 D67 A7 B7 C7 D76 A8 B8 C8 D87 A9 B9 C9 D910 A10 B10 C10 D1011 A11 B11 C11 D11======================================== A B C D0 A0 B0 C0 D01 A1 B1 C1 D12 A2 B2 C2 D23 A3 B3 C3 D34 A4 B4 C4 D45 A5 B5 C5 D56 A6 B6 C6 D67 A7 B7 C7 D78 A8 B8 C8 D89 A9 B9 C9 D910 A10 B10 C10 D1011 A11 B11 C11 D11 123456789101112131415161718192021222324252627282930cdf=pd.concat([df1,df2],axis=1) #横向堆叠数据帧print(cdf)print(&quot;========================================&quot;)cdf=pd.concat([df2,df3],axis=1) #6,7两行索引一样print(cdf)print(&quot;========================================&quot;)cdf=pd.concat([df2,df3],axis=1,join=&apos;inner&apos;) #取交集print(cdf) A B C D A B C D0 A0 B0 C0 D0 NaN NaN NaN NaN1 A1 B1 C1 D1 NaN NaN NaN NaN2 A2 B2 C2 D2 NaN NaN NaN NaN3 A3 B3 C3 D3 NaN NaN NaN NaN4 NaN NaN NaN NaN A4 B4 C4 D45 NaN NaN NaN NaN A5 B5 C5 D56 NaN NaN NaN NaN A6 B6 C6 D67 NaN NaN NaN NaN A7 B7 C7 D7======================================== A B C D A B C D4 A4 B4 C4 D4 NaN NaN NaN NaN5 A5 B5 C5 D5 NaN NaN NaN NaN6 A6 B6 C6 D6 A8 B8 C8 D87 A7 B7 C7 D7 A9 B9 C9 D910 NaN NaN NaN NaN A10 B10 C10 D1011 NaN NaN NaN NaN A11 B11 C11 D11======================================== A B C D A B C D6 A6 B6 C6 D6 A8 B8 C8 D87 A7 B7 C7 D7 A9 B9 C9 D9 123456cdf.index=[0,1]print(cdf) A B C D A B C D0 A6 B6 C6 D6 A8 B8 C8 D81 A7 B7 C7 D7 A9 B9 C9 D9 去重duplicated(),drop_duplicates()123456789101112131415161718192021222324# 去重data=&#123; &apos;age&apos;:[1,2,1,2,3,2,1,4,5,3]&#125;df=pd.DataFrame(data)print(df)print(&apos;````````````````````````````&apos;)print(df.duplicated()) #得到布尔型dfprint(&apos;````````````````````````````&apos;)#通过布尔型索引得到去重后的值print(df[df.duplicated()==False]) age0 11 22 13 24 35 26 17 48 59 3````````````````````````` 0 False1 False2 True3 True4 False5 True6 True7 False8 False9 Truedtype: bool123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 age0 11 24 37 48 5``````#在原数据之上修改df.drop_duplicates(inplace=True)print(df) age0 11 24 37 48 5```## 替换replace```data=&#123; &apos;name&apos;:[&apos;shu&apos;,&apos;lu&apos;,&apos;yun&apos;,&apos;wu&apos;,&apos;jia&apos;,&apos;yi&apos;], &apos;age&apos;:[1,2,1,4,5,3]&#125;df=pd.DataFrame(data)print(df)print(&apos;````````````````````````````&apos;)print(df[&apos;age&apos;].replace(1,18)) #用18替换所有的1print(&apos;````````````````````````````&apos;)print(df[&apos;age&apos;].replace([2,4],20)) #用20替换所有的2，4print(&apos;````````````````````````````&apos;)df[&apos;name&apos;].replace(&#123; #多个值分别替换 &apos;lu&apos;:&apos;lulu&apos;, &apos;yi&apos;:&apos;loveyi&apos;, &apos;jia&apos;:&apos;jiaa&apos;&#125;,inplace=True) #inplace=True修改原始值print(df) name age0 shu 11 lu 22 yun 13 wu 44 jia 55 yi 3 0 181 22 183 44 55 3Name: age, dtype: int6412345670 11 202 13 204 55 3Name: age, dtype: int64 name age 0 shu 11 lulu 22 yun 13 wu 44 jiaa 55 loveyi 3123456## 分组groupby，我们将数据分成多个集合，并在每个子集上应用一些函数- 分组后可以执行操作：- 聚合：计算汇总统计，指对有关数据进行内容挑选、分析、归类，最后分析得到想要的结果- 转换：执行一些特定于组的操作- 过滤：在某些情况下丢弃数据 数据拆分成组并查看import numpy as npimport pandas as pd data = { ‘Team’: [‘Riders’, ‘Riders’, ‘Devils’, ‘Devils’, ‘Kings’, ‘king’, ‘Kings’, ‘Kings’, ‘Riders’, ‘Royals’, ‘Royals’, ‘Riders’], ‘Rank’: [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2], ‘Year’: [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017], ‘Points’:[876,789,863,673,741,812,756,788,694,701,804,690]}df = pd.DataFrame(data)print(df)print(“\\n”)gs = df.groupby(“Team”) #按列分组print(gs) #DataFrameGroupBy类对象print(“\\n”)print(gs.groups) #字典形式，键为队名，值为索引构成的列表print(“\\n”) Team Rank Year Points 0 Riders 1 2014 8761 Riders 2 2015 7892 Devils 2 2014 8633 Devils 3 2015 6734 Kings 3 2014 7415 king 4 2015 8126 Kings 1 2016 7567 Kings 1 2017 7888 Riders 2 2016 6949 Royals 4 2014 70110 Royals 1 2015 80411 Riders 2 2017 690 &lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x000001FF1ACEE4C0&gt; {‘Devils’: [2, 3], ‘Kings’: [4, 6, 7], ‘Riders’: [0, 1, 8, 11], ‘Royals’: [9, 10], ‘king’: [5]}1234567891011121314151617181920212223242526272829303132333435```# 遍历分组结果gs = df.groupby(&quot;Team&quot;)for name, g in gs: print(name) print(g) print(&quot;------------------------------&quot;)Devils Team Rank Year Points2 Devils 2 2014 8633 Devils 3 2015 673------------------------------Kings Team Rank Year Points4 Kings 3 2014 7416 Kings 1 2016 7567 Kings 1 2017 788------------------------------Riders Team Rank Year Points0 Riders 1 2014 8761 Riders 2 2015 7898 Riders 2 2016 69411 Riders 2 2017 690------------------------------Royals Team Rank Year Points9 Royals 4 2014 70110 Royals 1 2015 804------------------------------king Team Rank Year Points5 king 4 2015 812------------------------------ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960gs = df.groupby([&quot;Team&quot;, &quot;Year&quot;]) #按多列分组print(gs.groups)print(&quot;\\n&quot;)for name, g in gs: print(name) print(g) print(&quot;-------------------------------&quot;)&#123;(&apos;Devils&apos;, 2014): [2], (&apos;Devils&apos;, 2015): [3], (&apos;Kings&apos;, 2014): [4], (&apos;Kings&apos;, 2016): [6], (&apos;Kings&apos;, 2017): [7], (&apos;Riders&apos;, 2014): [0], (&apos;Riders&apos;, 2015): [1], (&apos;Riders&apos;, 2016): [8], (&apos;Riders&apos;, 2017): [11], (&apos;Royals&apos;, 2014): [9], (&apos;Royals&apos;, 2015): [10], (&apos;king&apos;, 2015): [5]&#125;(&apos;Devils&apos;, 2014) Team Rank Year Points2 Devils 2 2014 863-------------------------------(&apos;Devils&apos;, 2015) Team Rank Year Points3 Devils 3 2015 673-------------------------------(&apos;Kings&apos;, 2014) Team Rank Year Points4 Kings 3 2014 741-------------------------------(&apos;Kings&apos;, 2016) Team Rank Year Points6 Kings 1 2016 756-------------------------------(&apos;Kings&apos;, 2017) Team Rank Year Points7 Kings 1 2017 788-------------------------------(&apos;Riders&apos;, 2014) Team Rank Year Points0 Riders 1 2014 876-------------------------------(&apos;Riders&apos;, 2015) Team Rank Year Points1 Riders 2 2015 789-------------------------------(&apos;Riders&apos;, 2016) Team Rank Year Points8 Riders 2 2016 694-------------------------------(&apos;Riders&apos;, 2017) Team Rank Year Points11 Riders 2 2017 690-------------------------------(&apos;Royals&apos;, 2014) Team Rank Year Points9 Royals 4 2014 701-------------------------------(&apos;Royals&apos;, 2015) Team Rank Year Points10 Royals 1 2015 804-------------------------------(&apos;king&apos;, 2015) Team Rank Year Points5 king 4 2015 812------------------------------- 12345678# **选择一个分组**gs = df.groupby(&quot;Year&quot;)g = gs.get_group(2017)print(g) Team Rank Year Points7 Kings 1 2017 78811 Riders 2 2017 690 123456789101112131415161718192021222324252627282930313233343536gs=df.groupby(df.dtypes,axis=1) #按数据类型分组for name, g in gs: print(name) print(g) print(&quot;-------------------------------&quot;)int64 Rank Year Points0 1 2014 8761 2 2015 7892 2 2014 8633 3 2015 6734 3 2014 7415 4 2015 8126 1 2016 7567 1 2017 7888 2 2016 6949 4 2014 70110 1 2015 80411 2 2017 690-------------------------------object Team0 Riders1 Riders2 Devils3 Devils4 Kings5 king6 Kings7 Kings8 Riders9 Royals10 Royals11 Riders------------------------------- 聚合，操作分组后的数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# 聚合 **操作分组后的数据** 忽略nan值data = &#123; &apos;Team&apos;: [&apos;Riders&apos;, &apos;Riders&apos;, &apos;Devils&apos;, &apos;Devils&apos;, &apos;Kings&apos;, &apos;king&apos;, &apos;Kings&apos;, &apos;Kings&apos;, &apos;Riders&apos;, &apos;Royals&apos;, &apos;Royals&apos;, &apos;Riders&apos;], &apos;Rank&apos;: [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2], &apos;Year&apos;: [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017], &apos;Points&apos;:[876,789,863,673,741,812,756,788,694,701,804,690]&#125;df = pd.DataFrame(data)print(df)print(&quot;\\n&quot;)# 应用一个聚合函数gs=df.groupby(&apos;Team&apos;).sum()#按队名分组，并对每个队的其他项目求和print(gs)print(&apos;----------------------------&apos;)# 同时应用多个聚合函数gs=df.groupby(&apos;Team&apos;)# 若要对每个项目都应用多个函数，则只需df.groupby(&apos;Team&apos;).agg([各个方法即可])#这里，按队名分组，并对每个队的&apos;Rank&apos;项目求各个值g=gs[&apos;Rank&apos;].agg([np.sum,np.min,np.size])#按队名分组，并对每个队的其他项目求和print(g)g.columns=[&apos;求和&apos;,&apos;最小值&apos;,&apos;个数&apos;]g Team Rank Year Points0 Riders 1 2014 8761 Riders 2 2015 7892 Devils 2 2014 8633 Devils 3 2015 6734 Kings 3 2014 7415 king 4 2015 8126 Kings 1 2016 7567 Kings 1 2017 7888 Riders 2 2016 6949 Royals 4 2014 70110 Royals 1 2015 80411 Riders 2 2017 690 Rank Year PointsTeam Devils 5 4029 1536Kings 5 6047 2285Riders 7 8062 3049Royals 5 4029 1505king 4 2015 812---------------------------- sum amin sizeTeam Devils 5 2 2Kings 5 1 3Riders 7 1 4Royals 5 1 2king 4 4 1 求和 最小值 个数Team Devils 5 2 2Kings 5 1 3Riders 7 1 4Royals 5 1 2king 4 4 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445# apply聚合 应用自己写的函数data = &#123; &apos;Team&apos;: [&apos;Riders&apos;, &apos;Riders&apos;, &apos;Devils&apos;, &apos;Devils&apos;, &apos;Kings&apos;, &apos;king&apos;, &apos;Kings&apos;, &apos;Kings&apos;, &apos;Riders&apos;, &apos;Royals&apos;, &apos;Royals&apos;, &apos;Riders&apos;], &apos;Rank&apos;: [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2], &apos;Year&apos;: [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017], &apos;Points&apos;:[876,789,863,673,741,812,756,788,694,701,804,690]&#125;df = pd.DataFrame(data)print(df)print(&quot;\\n&quot;)# 应用一个自定义的聚合函数gs=df.groupby(&apos;Team&apos;)[&apos;Rank&apos;].apply(lambda x:x+10)print(gs) Team Rank Year Points0 Riders 1 2014 8761 Riders 2 2015 7892 Devils 2 2014 8633 Devils 3 2015 6734 Kings 3 2014 7415 king 4 2015 8126 Kings 1 2016 7567 Kings 1 2017 7888 Riders 2 2016 6949 Royals 4 2014 70110 Royals 1 2015 80411 Riders 2 2017 6900 111 122 123 134 135 146 117 118 129 1410 1111 12Name: Rank, dtype: int64 转换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354print(df)gs = df.groupby(&quot;Team&quot;)print(&quot;\\n&quot;)# 转换返回索引与原DataFrame的索引相同的对象# 对比gs=df.groupby(&apos;Team&apos;).sum()看更好理解print(gs.transform(np.sum))print(&quot;\\n&quot;)print(gs[&quot;Points&quot;].transform(np.sum)) Team Rank Year Points0 Riders 1 2014 8761 Riders 2 2015 7892 Devils 2 2014 8633 Devils 3 2015 6734 Kings 3 2014 7415 king 4 2015 8126 Kings 1 2016 7567 Kings 1 2017 7888 Riders 2 2016 6949 Royals 4 2014 70110 Royals 1 2015 80411 Riders 2 2017 690 Rank Year Points0 7 8062 30491 7 8062 30492 5 4029 15363 5 4029 15364 5 6047 22855 4 2015 8126 5 6047 22857 5 6047 22858 7 8062 30499 5 4029 150510 5 4029 150511 7 8062 30490 30491 30492 15363 15364 22855 8126 22857 22858 30499 150510 150511 3049Name: Points, dtype: int64 过滤 根据定义的标准，过滤数据并返回数据的子集12345678910111213141516171819202122232425262728293031print(df)print(&quot;\\n&quot;)gs = df.groupby(&quot;Team&quot;)print(gs.groups)print(&quot;\\n&quot;)print(gs.filter(lambda x: len(x) &gt;= 4)) Team Rank Year Points0 Riders 1 2014 8761 Riders 2 2015 7892 Devils 2 2014 8633 Devils 3 2015 6734 Kings 3 2014 7415 king 4 2015 8126 Kings 1 2016 7567 Kings 1 2017 7888 Riders 2 2016 6949 Royals 4 2014 70110 Royals 1 2015 80411 Riders 2 2017 690&#123;&apos;Devils&apos;: [2, 3], &apos;Kings&apos;: [4, 6, 7], &apos;Riders&apos;: [0, 1, 8, 11], &apos;Royals&apos;: [9, 10], &apos;king&apos;: [5]&#125; Team Rank Year Points0 Riders 1 2014 8761 Riders 2 2015 7898 Riders 2 2016 69411 Riders 2 2017 690 分类数据123456789101112131415161718192021# 分类是Pandas中的一种数据类型，通常实时的数据包括重复的文本列# 例如：性别，国家和代码等特征总是重复的import numpy as npimport pandas as pddata = &#123; &quot;name&quot;: pd.Series([&quot;刘德华&quot;, &quot;阿尔帕西诺&quot;, &quot;成德善&quot;, &quot;张学友&quot;, &quot;金正焕&quot;, &quot;刀郎&quot;]), &quot;country&quot;: pd.Series([&quot;中国&quot;, &quot;美国&quot;, &quot;韩国&quot;, &quot;中国&quot;, &quot;韩国&quot;, &quot;中国&quot;],dtype=&apos;category&apos;), &quot;sex&quot;: pd.Categorical([&quot;男&quot;, &quot;男&quot;, &quot;女&quot;, &quot;男&quot;, &quot;男&quot;, &quot;男&quot;])&#125;df = pd.DataFrame(data)dfname country sex0 刘德华 中国 男1 阿尔帕西诺 美国 男2 成德善 韩国 女3 张学友 中国 男4 金正焕 韩国 男5 刀郎 中国 男 1234567891011121314151617181920print(df[&apos;country&apos;])print(df[&apos;sex&apos;])0 中国1 美国2 韩国3 中国4 韩国5 中国Name: country, dtype: categoryCategories (3, object): [&apos;中国&apos;, &apos;美国&apos;, &apos;韩国&apos;]0 男1 男2 女3 男4 男5 男Name: sex, dtype: categoryCategories (2, object): [&apos;女&apos;, &apos;男&apos;] 数据透视表 未设置aggfunc时，它默认aggfunc=’mean’计算均值 它根据一个或多个键对数据进行聚合， 并根据行和列上的分组键将数据分配到各个矩形区域中。 参数 说明 data DataFrame values 待聚合的列的名称。默认聚合所有数值列 index 用于分组的列名或其他分组键，出现在结果透视表的行 columns 用于分组的列名或其他分组键，出现在结果透视表的列 aggfunc 聚合函数或函数列表，默认为‘mean’。可以使任何对groupby有效的函数 fill_value 用于替换结果表中的缺失值 dropna boolean，默认为True margins_name string，默认为‘ALL’，当参数margins为True时，ALL行和列的名字 12345678910path=&apos;E:/Users/lqy/Desktop/Pandas学习/James_Harden.csv&apos;df = pd.read_csv(path)df.head() 对手 胜负 主客场 命中 投篮数 投篮命中率 3分命中率 篮板 助攻 得分0 勇士 胜 客 10 23 0.435 0.444 6 11 271 国王 胜 客 8 21 0.381 0.286 3 9 272 小牛 胜 主 10 19 0.526 0.462 3 7 293 灰熊 负 主 8 20 0.400 0.250 5 8 224 76人 胜 客 10 20 0.500 0.250 3 13 27 123456789101112131415index作用：每个pivot_table必须拥有一个index，Index就是层次字段，要通过透视表获取什么信息就按照相应的顺序设置字段，所以在进行pivot之前你也需要足够了解你的数据# 如果想查看哈登对阵每个队伍的得分，首先我们将对手设置为indexpd.pivot_table(df,index=[u&apos;对手&apos;]).head() 3分命中率 助攻 命中 得分 投篮命中率 投篮数 篮板对手 76人 0.3395 10.0 9.0 28.0 0.4405 20.5 3.5勇士 0.4440 11.0 10.0 27.0 0.4350 23.0 6.0国王 0.2860 9.0 8.0 27.0 0.3810 21.0 3.0太阳 0.5450 7.0 12.0 48.0 0.5450 22.0 2.0小牛 0.4620 7.0 10.0 29.0 0.5260 19.0 3.0 1234567891011# 对手成为了第一层索引，还想看看对阵同一对手在不同主客场下的数据，# 试着将对手与胜负与主客场都设置为index，其实就变成为了两层索引pd.pivot_table(df,index=[u&apos;对手&apos;, u&apos;主客场&apos;]).head() 3分命中率 助攻 命中 得分 投篮命中率 投篮数 篮板对手 主客场 76人 主 0.429 7.0 8.0 29.0 0.381 21.0 4.0客 0.250 13.0 10.0 27.0 0.500 20.0 3.0勇士 客 0.444 11.0 10.0 27.0 0.435 23.0 6.0国王 客 0.286 9.0 8.0 27.0 0.381 21.0 3.0太阳 客 0.545 7.0 12.0 48.0 0.545 22.0 2.0 1234567891011121314151617181920# 试着交换下它们的顺序，数据结果一样pd.pivot_table(df,index=[u&apos;主客场&apos;,u&apos;对手&apos;]).head(15) 3分命中率 助攻 命中 得分 投篮命中率 投篮数 篮板主客场 对手 主 76人 0.4290 7.0 8.0 29.0 0.381 21.0 4.0 小牛 0.4620 7.0 10.0 29.0 0.526 19.0 3.0 尼克斯 0.3850 10.0 12.0 37.0 0.444 27.0 2.0 掘金 0.1430 9.0 6.0 21.0 0.375 16.0 8.0 步行者 0.3330 10.0 8.0 29.0 0.364 22.0 8.0 灰熊 0.3395 8.0 9.5 30.0 0.420 22.5 4.5 爵士 0.8750 13.0 19.0 56.0 0.760 25.0 2.0 猛龙 0.2730 11.0 8.0 38.0 0.320 25.0 6.0 篮网 0.6150 8.0 13.0 37.0 0.650 20.0 10.0 骑士 0.4290 13.0 8.0 35.0 0.381 21.0 11.0 鹈鹕 0.4000 17.0 8.0 26.0 0.500 16.0 1.0 客 76人 0.2500 13.0 10.0 27.0 0.500 20.0 3.0 勇士 0.4440 11.0 10.0 27.0 0.435 23.0 6.0 国王 0.2860 9.0 8.0 27.0 0.381 21.0 3.0 太阳 0.5450 7.0 12.0 48.0 0.545 22.0 2.0 123456789101112# values# 作用：可以对需要的计算数据进行筛选# 案例：我们只需要james harden在主客场和不同胜负情况下的得分、篮板与助攻三项数据pd.pivot_table(df,index=[u&apos;主客场&apos;,u&apos;胜负&apos;],values=[u&apos;得分&apos;,u&apos;助攻&apos;,u&apos;篮板&apos;]) 助攻 得分 篮板主客场 胜负 主 胜 10.555556 34.222222 5.444444 负 8.666667 29.666667 5.000000 客 胜 9.000000 32.000000 4.916667 负 8.000000 20.000000 4.000000 123456789101112131415# aggfunc# 作用：设置我们对数据聚合时进行的函数操作，未设置aggfunc时，它默认aggfunc=&apos;mean&apos;计算均值# 1. 获得james harden在主客场和不同胜负情况下的总得分、总篮板、总助攻pd.pivot_table(df,index=[u&apos;主客场&apos;,u&apos;胜负&apos;],values=[u&apos;得分&apos;,u&apos;助攻&apos;,u&apos;篮板&apos;],aggfunc=[np.sum,np.max]) sum amax 助攻 得分 篮板 助攻 得分 篮板主客场 胜负 主 胜 95 308 49 17 56 11 负 26 89 15 11 38 6 客 胜 108 384 59 15 48 10 负 8 20 4 8 20 4 123456789101112# aggfunc也可以使用dict类型，助攻求min,max和mean,得分求meanpd.pivot_table(df,index=[u&apos;对手&apos;,u&apos;胜负&apos;],values=[u&apos;得分&apos;,u&apos;助攻&apos;,u&apos;篮板&apos;], aggfunc=&#123;u&apos;得分&apos;:np.mean, u&apos;助攻&apos;:[min, max, np.mean]&#125;).head() 助攻 得分 max mean min mean对手 胜负 76人 胜 13.0 13.0 13.0 27.0 负 7.0 7.0 7.0 29.0勇士 胜 11.0 11.0 11.0 27.0国王 胜 9.0 9.0 9.0 27.0太阳 胜 7.0 7.0 7.0 48.0 1234567891011121314# columns# 作用：类似Index可以设置列层次字段，它不是一个必要参数，作为一种分割数据的可选方式pd.pivot_table(df,index=[u&apos;对手&apos;,u&apos;胜负&apos;],columns=[u&apos;主客场&apos;],values=[u&apos;得分&apos;]).head() 得分 主客场 主 客对手 胜负 76人 胜 NaN 27.0 负 29.0 NaN勇士 胜 NaN 27.0国王 胜 NaN 27.0太阳 胜 NaN 48.0 12345678910111213# fill_value# 作用：填充空值pd.pivot_table(df,index=[u&apos;对手&apos;,u&apos;胜负&apos;],columns=[u&apos;主客场&apos;],values=[u&apos;得分&apos;], fill_value=0).head() 得分 主客场 主 客对手 胜负 76人 胜 0 27 负 29 0勇士 胜 0 27国王 胜 0 27太阳 胜 0 48 123456789101112# margins# 作用：是否进行汇总pd.pivot_table(df,index=[u&apos;主客场&apos;],columns=[u&apos;对手&apos;],values=[u&apos;得分&apos;],aggfunc=[np.sum],fill_value=0,margins=1) sum 得分对手 76人 勇士 国王 太阳 小牛 尼克斯 开拓者 掘金 步行者 湖人 灰熊 爵士 猛龙 篮网 老鹰 骑士 鹈鹕 黄蜂 All主客场 主 29 0 0 0 29 37 0 21 29 0 60 56 38 37 0 35 26 0 397 客 27 27 27 48 0 31 48 0 26 36 49 29 0 0 29 0 0 27 404 All 56 27 27 48 29 68 48 21 55 36 109 85 38 37 29 35 26 27 801 数据交叉表 透视表pivot_table()是一种进行分组统计的函数，参数aggfunc决定统计类型 交叉表crosstab()是一种特殊的pivot_table()，专用于计算分组频率 123456789101112131415import pandas as pddf = pd.DataFrame(&#123;&apos;Sample&apos;: range(1, 8), &apos;Gender&apos;: [&apos;Female&apos;, &apos;Male&apos;, &apos;Female&apos;, &apos;Male&apos;, &apos;Male&apos;, &apos;Male&apos;, &apos;Female&apos;], &apos;Handedness&apos;: [&apos;Right-handed&apos;, &apos;Left-handed&apos;, &apos;Right-handed&apos;, &apos;Right-handed&apos;, &apos;Left-handed&apos;, &apos;Right-handed&apos;, &apos;Right-handed&apos;]&#125;)df Sample Gender Handedness0 1 Female Right-handed1 2 Male Left-handed2 3 Female Right-handed3 4 Male Right-handed4 5 Male Left-handed5 6 Male Right-handed6 7 Female Right-handed 1234567891011# 需求：根据性别和用手习惯对这段数据进行统计汇总# 1. pivot_table()实现该功能pd.pivot_table(df, index=[&apos;Gender&apos;], columns=&apos;Handedness&apos;, aggfunc=len, margins=True) SampleHandedness Left-handed Right-handed All Gender Female NaN 3.0 3 Male 2.0 2.0 4 All 2.0 5.0 7 12345678# crosstab()函数会更方便pd.crosstab(df.Gender, df.Handedness, margins=True)Handedness Left-handed Right-handed All Gender Female 0 3 3 Male 2 2 4 All 2 5 7 IO操作 文件读写 read_csv 读取CSV文件 read_excel 读取Excel文件 read_html 读取网页HTML文件 read_sql 读取sql数据库 read_sql_table 读取sql数据库中的表 常用写文件方法 说明 to_csv 写CSV文件 to_excel 写Excel文件 to_sql 写数据库 注意事项： encoding一般情况下我们用utf-8编码进行保存，如果出现中文编码错误，则可以依次换用gbk，gb2312 , gb18030，一般总能成功的，本例中用utf-8 to_csv方法，具体参数还有很多，可以去看官方文档，这里提到一个index = False参数，表示保存csv的时候，我们不保存pandas 的Data frame的行索引1234这样的序号，默认情况不加的话是index = True，会有行号，这点在保存数据库mysql的时候体现尤其明显，不注意的话可能会出错 从csv文件读取后，作为DataFrame时，会自动添加索引列，然后保存，当再次读取时，会多一列叫：Unnamed: 0 ，处理如下： 12345df=pd.read_csv(&quot;./data.csv&quot;, index_col=[&quot;Unnamed: 0&quot;])或者直接删除这一列：del df[&apos;Unnamed: 0&apos;] 12#dtype的列可以作为字典传递,分别指定某一列的数据类型dtype=&#123;&apos;id&apos;: np.float64&#125; 有事您Q我👇","categories":[{"name":"pandas","slug":"pandas","permalink":"https://shulu520.com/categories/pandas/"}],"tags":[{"name":"pandas","slug":"pandas","permalink":"https://shulu520.com/tags/pandas/"}]},{"title":"数据分析之NumPy笔记","slug":"Python数据分析之NumPy笔记","date":"2021-04-08T14:03:00.000Z","updated":"2021-04-22T12:32:44.793Z","comments":true,"path":"NumPy/Python数据分析之NumPy笔记/","link":"","permalink":"https://shulu520.com/NumPy/Python数据分析之NumPy笔记/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; NumPy简介 是一个运行速度非常快的数学库，主要用于数组计算 NumPy 通常与 SciPy和 Matplotlib（绘图库）一起使用， 这种组合广泛用于替代 MatLab 是一个强大的科学计算环境，有助于我们通过 Python 学习数据科学或者机器学习 包含一个强大的N维数组对象 ndarrayNumPy数据结构 numpy 支持的数据类型比 Python 内置的类型要多很多， 基本上可以和 C 语言的数据类型对应上，其中部分类型对应为 Python 内置的类型 创建Ndarray数组对象使用array函数 numpy默认ndarray的所有元素的类型是相同的，这一点与Python中的list不同 如果传进来的列表中包含不同的类型，则统一为同一类型，优先级：str&gt;float&gt;int1234一维数组import numpy as nparr = np.array([1,2,3,4,5])print(arr) # [1 2 3 4 5] 1234二维数组import numpy as nparr = np.array([[1,2,3],[4,5,6]])print(arr) 1234567891011121314常用的二维数组创建方式a=np.random.randint(0,8,6)print(a) #[6 2 4 4 0 6]a=np.random.randint(0,8,6).reshape(2,3)print(a) [[3 1 1] [7 6 3]]a4=np.arange(0,20,2).reshape(2,5)print(a4)[[ 0, 2, 4, 6, 8],[10, 12, 14, 16, 18]]) 数组形状12345678910111213141516171819202122232425a4.shape #(2, 5)#转置a5=a4.Ta5[[ 0, 10], [ 2, 12], [ 4, 14], [ 6, 16], [ 8, 18]]a5.shape #(5, 2)#resizea6=np.arange(0,10,2)print(a6) #[0 2 4 6 8]a6.resize(3)print(a6) #[0 2 4]a6.resize(6)print(a6) #[0 2 4 6 8 0]a6.size #6 数组类型转换12345a=np.random.randint(1,8,3)a.dtype #dtype(&apos;int32&apos;)a=np.random.randint(1,8,3).astype(&apos;int64&apos;)a.dtype #dtype(&apos;int64&apos;) 数组拼接1234567891011a1=np.arange(4)a2=np.arange(2,6)print(a1) #[0 1 2 3]print(a2) #[2 3 4 5]#横向拼接print(np.hstack((a1,a2))) #[0 1 2 3 2 3 4 5]#竖向拼接print(np.vstack((a1,a2)))[[0 1 2 3] [2 3 4 5]] 数组添加 在数组的末尾添加值 追加操作会分配整个数组，并把原来的数组复制到新数组中 输入数组的维度必须匹配否则将生成ValueError axis当axis无定义时，是横向加成，返回总是为一维数组！ 当axis有定义的时候，分别为0和1的时候。为0的时候（列数要相同）。 当axis为1时，数组是加在右边（行数要相同） 12345678910111213141516x=np.arange(6).reshape(2,3)print(x) # [[0 1 2] [3 4 5]]y=[7,8,9]z=np.append(x,y)print(z)# [0 1 2 3 4 5 7 8 9]z2=np.append(x,[y],axis=0)print(z2)#[[0 1 2] [3 4 5] [7 8 9]] insert()方法 在给定索引之前，沿给定轴在输入数组中插入值 delete()删除unique()去重数组拆分12345678910111213141516171819202122232425262728a3=np.arange(16).reshape(4,4)#横向a4,a5=np.hsplit(a3,2)print(a3)print(a4)print(a5)[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15]][[ 0 1] [ 4 5] [ 8 9] [12 13]][[ 2 3] [ 6 7] [10 11] [14 15]]#纵向a6,a7,a8,a9=np.vsplit(a3,4)print(a6) #[[0 1 2 3]]print(a7) #[[4 5 6 7]]print(a8) #[[ 8 9 10 11]]print(a9) #[[12 13 14 15]] 数组的复制 复制数组，产生一个新的数组，而直接赋值的话，一个修改后另一个也跟着变1234567a=np.array([1,2,3])b=aprint(a) #[1 2 3]print(b) #[1 2 3]b[0]=8print(a) #[8 2 3]print(b) #[8 2 3] 12345c=a.copy()print(c) #[8 2 3]c[1]=6print(a) #[8 2 3]print(c) #[8 6 3] 数组索引 ndarray对象的内容可以通过索引或切片来访问和修改，与Python中list的切片操作一样 二维时，a[1:,3:],这种第一个表示行索引，第二个表示列索引 布尔索引通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组,如print(a[a&gt;5]) 可以通过冒号分隔切片参数 start:stop:step 来进行切片操作 冒号 : 的解释 如果只放置一个参数，如 [2]，将返回与该索引相对应的单个元素。如果为 [2:]，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如 [2:7]，那么则提取两个索引(不包括停止索引)之间的项 广播 是numpy对不同形状(shape)的数组进行数值计算的方式，对数组的算术运算通常在相应的元素上进行 较小的数组会广播到较大数组的大小，以便使它们的形状可兼容 123456789101112131415a=np.array([1,2,3])b=np.arange(12).reshape(4,3)print(a) #[1 2 3]print(b) [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]]print(a+b)[[ 1, 3, 5],[ 4, 6, 8],[ 7, 9, 11],[10, 12, 14]] extract()函数提取元素 根据某个条件从数组中抽取元素，返回满足条件的元素 123a=np.arange(5)print(np.extract(a&gt;2,a))# [3 4] arange函数用于创建等差数组1np.arange([start, ]stop, [step, ]dtype=None) np.random随机数123456789101112131415rand() 生成一个[0,1),不包括1，之间的随机浮点数或N维浮点数组。1 np.random.rand(a)表示生成a个[0,1)的数2 np.random.rand(a,b))表示生成a行b列的二维数组，值为[0,1)randn(d0, d1, …, dn) 产生标准正态分布随机数randint(low[, high, size, dtype]) 产生随机整数random_sample([size]) 在[0,1）内产生随机数choice(a[, size, replace, p]) 从a中随机选择指定数据 NumPy是后面pandas的基础，了解一下就行了，以后都是在它的封装之上的pandas上操作 有事您Q我👇","categories":[{"name":"NumPy","slug":"NumPy","permalink":"https://shulu520.com/categories/NumPy/"}],"tags":[]},{"title":"excel笔记","slug":"excel笔记","date":"2021-04-04T12:22:51.000Z","updated":"2021-04-08T14:18:24.238Z","comments":true,"path":"excel/excel笔记/","link":"","permalink":"https://shulu520.com/excel/excel笔记/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 处理带单位的运算12345678910import pandas as pde1=pd.read_excel(&apos;E:/Users/lqy/Desktop/Excel学习/带单位运算.xlsx&apos;,sheet_name=&apos;带单位运算&apos;)e1*提取数字并将字符串类型转为数字类型*e1[&apos;单价&apos;]=e1[&apos;单价&apos;].str.extract(&apos;(\\d+)&apos;).astype(&apos;int&apos;) e1[&apos;销量&apos;]=e1[&apos;销量&apos;].str.extract(&apos;(\\d+)&apos;).astype(&apos;int&apos;)e1[&apos;销售额&apos;]=e1[&apos;单价&apos;]*e1[&apos;销量&apos;]e1e1.to_excel(&apos;E:/Users/lqy/Desktop/Excel学习/带单位运算.xlsx&apos;,sheet_name=&apos;带单位运算&apos;) 更换证件照底色12不用Excel ，以下网站可以抠图并更换背景https://koutu.gaoding.com/clip?from=0&amp;id=15342049129143310 更改第一列的索引从1开始12e1.index=list(range(1,len(e1[&apos;销量&apos;])+1))e1 多处自动求和1对应excel表中的汇总1和汇总2这两行都是要将他们上面的数据进行求和的，首先选中所有数据，CTRL+G ，在定位条件里面选择空值，然后，在菜单栏选择自动求和即可 身份证输入12单元格默认输入数字的长度为11个首先键入英文逗号’再在后面输入即可，本质上是将数字类型转为文本类型 分数输入3/412直接输入会变成月份日期形式首先输入零0+空格，再输入即可3/4 工资条添加头部1234假如有三个人的工资在表的右边工资行空白列输入1，2，3，三列然后再复制这三列到下面一格，然后在空白处点一下，在导航栏选择数据&gt;筛选&gt;升序，即可留出各个表头的空行，然后选中这些数据（不要辅助列），CTRL+G在定位条件里面选择空值，然后输入=，再点一下姓名那一格之后，按CTRL+enter即可 工号输入 前面带有0的长数字1234前面有零会默认不显示的可以正常输入后再选中然后点击子体栏右下角，选择数字，自定义，右侧通用格式(第一行通用格式里面输入5个0即可)，几位工号输入几个0或者按身份证好的那种方法也可以 保护工作簿和工作表1选择审阅，保护工作簿或保护工作表 将打开的两张工作簿，显示在一个一个窗口里面，方便对比1选择视图&gt;全部重排&gt;垂直即可 打印页头123打印时保证每一页都有页头页面布局&gt;打印标题&gt;工作表&gt;顶端标题行，在这个框里面点击，然后在做左侧选择表头所在行点击即可 打印页脚1234567页面布局栏右下角&gt;页面设置&gt;页眉页脚&gt;页脚，一般选‘第几页，共几页’的格式即可#合并的单元格内容向下填充可以从右下角加号往下拉也可以选中这个单元格和下面的填充位置按CTRL+enter即可 合并的单元格公式向下填充：加法为例123456点击这一格，按=号，点击前面需要加和的单元格，再按+号，再点击前面需要加和的单元格，输完公式，按enter，右下角加号往下拉即可或者输完公式，按enter后，选中这一格和需要填充的单元格在编辑栏（fx那一栏）点击一下， CTRL+enter即可 ctrl+E 快速拆分填充 2013版本新增功能123456789用法：https://zhuanlan.zhihu.com/p/42571089：以下内容2010版虽然不行，但是难不倒一个会python的帅哥！！字符中统一添加特定字符拆分姓名和手机号码 合并姓名和手机号码从身份证号码中提取生日提取括号内的字符和数字手机号码分段显示和加密提取市区名称银行账号添加空格 查找和替换1234CTRL + F即可调出查找和替换，两个在一起，点击全部查找，再点击全部替换，或点下一个也行可以点击右下角选项，有更多的搜索选项 CTRL+；快速输入日期Alt+=快速求和123选中数据框按Alt+=快速求和横向、竖向都会求和单独选横向，可以单独求和，竖向一样 F4重复上一步骤;添加$绝对引用符号left函数：从左往右提取几个字符的内容left(单元格，取几个数)right函数一样用法mid函数：从中间提取，mid(单元格，从第几位数开始, 娶几个数)123如身份证号码提取生日：=MID(B3,7,8) 形如：19960823=TEXT(MID(B3,7,8),&quot;0000-00-00&quot;) 形如：1996-08-23 find函数，查找某一字符在数据源单元格里面出现的位置。12配合上面的提取函数可以组合使用find(要查找的字符，数据源单元格) len函数求某一单元格字符的长度，配合提取函数可以组合使用row函数，返回单元格所在的行号，‘动态变化的’1=ROW(单元格) - 一个数字，用作序号等 mod取模函数，实现隔行设置样式12选中表格&gt;条件格式&gt;新建规则&gt;使用公式确定单元格格式&gt;=mod(row(),2)=1 相对引用12即在公式中所引用的单元格会随着公式所在单元格的变化而相应的变化。比如对前面两列数据进行求和的操作 绝对引用1234即在公式中将所引用的特定单元格进行锁定。比如公式中的某个值只在某一个单元格里面，那进行向下填充公式时候就要将这个单元格绝对引用，在编辑栏点击单元格前后都行，按F4即可添加美元符号，表示绝对引用 countif函数，避免重复输入1234选中表格&gt;条件格式&gt;新建规则&gt;使用公式确定单元格格式&gt;编辑如下公式即可=countif($B:$B,B1)&gt;1，注意第二个参数不用绝对引用，去掉$符号即可点击格式，进行格式设置。效果是B列若输入了重复值，则重复值所在行按设置样式显示出来 根据日期得到星期几1=text(日期单元格, “aaaa”) weekday设置周末样式123选中需要设置的数据区域，条件格式&gt;新建规则&gt;使用公式确定单元格格式&gt;编辑如下=weekday(C$1,2)&gt;5，点击格式，进行格式设置这里第一个日期在C1单元格，列相对引用，行绝对引用 输入内容时自动生成边框，删除时自动删除边框12选择数据所在列，条件格式&gt;新建规则&gt;使用公式确定单元格格式&gt;编辑如下=$A1&lt;&gt;&quot;&quot; 然后设置相应的样式即可 rank排序函数12在要放排序的第一个单元格输入=RANK(B2,$B$2:$B$5)，这里B2是第一个数据，B2到B5是数据区域 subtotal可视区域求和12345先对首行做一个筛选，即点数据&gt;筛选对合计单元格公式 =CONCATENATE(&quot;合计: &quot;,SUBTOTAL(109,B2:B7))外层函数CONCATENATE是连接字符的函数，109表示求和函数，B2到B7是要求和的数据区域 phonetic合并单元格内容到另一单元格1=PHONETIC(A2:C2) sumifs隔列求和12=SUMIFS(B3:E3,$B$2:$E$2,$F$2)参数1：求和数据，2：条件区域，3：求和条件 快速输入26个字母1234=CHAR(ROW()+63) 假设从第二个单元格开始,则row行号等于2，而字母A等于65，所以加上63就是字母A了，向下拉即可得到26个字母 isodd函数判断奇偶，根据身份证得到性别1234身份证倒数第二位奇数表示男性=IF(ISODD(MID(B2,17,1)),&quot;男&quot;,&quot;女&quot;)if函数三个参数，第一个条件判断，第二个参数是为true时返回值，第三个是为false时返回值 lookup函数做库存预警12345678=LOOKUP(C2,$F$1:$G$4)C2是库存数据单元格，第二个参数是辅助列表，辅助表就是两列，第一列为数据区间，第二列为对应的区间名称选中库存预警列，条件格式&gt;突出显示单元格&gt;文本包含&gt;填写文本&gt;设置样式也可以用嵌套if来实现=IF(C12&gt;90,&quot;优秀&quot;,IF(C12&lt;60,&quot;差&quot;,&quot;合格&quot;)) kpi绩效计算12=SUMPRODUCT($B$2:$E$2,B3:E3)B2到E2是百分比数据项，B3:E3是第一个人的各项得分 数据有效性，新版本叫数据验证12345678910当分类较多的时候就不用重复的输入，简单的设置一下数据的有效性就节省了很多时间对输入的数据有了规定，或只能从给定的里面选择性输入有效条件可以是：整数，小数，日期，时间，文本长度，序列(即写出几个选项,之间用英文逗号隔开)，还可以自定义条件案例：使用date函数做动态考勤表，年份、月份可选，配合text函数由日期得到星期并且配合weekday函数设置了周末的样式，都是动态可变得 VLOOKUP 查找123456函数的语法结构：VLOOKUP(lookup_value,table_array,col_index_num,range_lookup)lookup_value：查找值table_array：查找的区域col_index_num：返回数据在查找区域的第几列range_lookup：匹配模式（0为精确查找，1为模糊查找） N函数对数值类型的值做批注12=5397+N(&quot;这个妹子不错&quot;)当点击这个单元格的时候，上面的公式编辑栏就会出现备注内容 有事您Q我👇","categories":[{"name":"excel","slug":"excel","permalink":"https://shulu520.com/categories/excel/"}],"tags":[]},{"title":"几个小模块","slug":"Python-模块","date":"2021-03-04T09:45:30.000Z","updated":"2021-04-07T02:26:40.382Z","comments":true,"path":"python/Python-模块/","link":"","permalink":"https://shulu520.com/python/Python-模块/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 常见的datetime日期时间模块123456789101112131415161718192021222324252627#datetime模块重新封装了time模块import datetimetime1=datetime.datetime.now()print(time1) #2021-02-27 18:59:13.885794time2=datetime.date.today()print(time2) #2021-02-27time3=datetime.datetime.today()print(time3) #2021-02-27 18:58:39.614459time4=datetime.datetime.today().timestamp()print(time4) #1614423830.81342# 返回当前日期时间的日期部分：2021-02-27print(datetime.datetime.now().date())# 返回当前日期时间的时间部分：19:13:45.310397print(datetime.datetime.now().time())# delta时间间隔past=datetime.datetime(2017, 4, 16, 21, 21, 20, 871000)now=datetime.datetime.now()delta=now-pastprint(delta) #1412 days, 22:07:46.382359print(delta.days) #1412 pickle 文件模块1234567891011121314151617181920pickle可以将一个对象保存成一个文件，例如列表，DataFrame等import osimport pickleos.chdir(&apos;E:\\Users\\lqy\\Desktop\\&apos;)os.getcwd()data=&#123;&apos;a&apos;:[1,2,3],&apos;b&apos;:8,&apos;c&apos;:&apos;shulu&apos;&#125;创建保存文件pic=open(&apos;data.pkl&apos;,&apos;wb&apos;)pickle.dump(data,pic)pic.close()print(&quot;完成了&quot;)读取文件pic2=open(&apos;E:/Users/lqy/Desktop/data.pkl&apos;,&apos;rb&apos;)data=pickle.load(pic2)data re 正则字符串提取数字或字母1234567import re# 字符串中提取数字s=&quot;sDsd123.555dfd888F&quot;print(re.findall(&apos;\\d+\\.?\\d*&apos;,s))# 字符串中提取字母print(re.findall(&apos;[A-Za-z]&apos;, s)) 有事您Q我👇","categories":[{"name":"python","slug":"python","permalink":"https://shulu520.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://shulu520.com/tags/python/"}]},{"title":"python操作Word文档","slug":"Python-word","date":"2021-02-26T05:48:10.000Z","updated":"2021-03-03T11:18:53.654Z","comments":true,"path":"py-word/Python-word/","link":"","permalink":"https://shulu520.com/py-word/Python-word/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; python操作Word文档https://python-docx.readthedocs.io/en/latest/user/quickstart.html 12345678910111213from docx import Document# 获取文档对象doc=Document(&apos;./我的.docx&apos;)# 获取段落paragraphs=doc.paragraphsfor para in paragraphs: # 每一段落的内容 print(para.text) # 文字块 相同格式的内容 runs=para.runs for run in runs: print(run.text) word基础1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from docx import Documentfrom docx.shared import Cm #图片单位厘米# 创建新的文本对象doc= Document()# 添加标题doc.add_heading(&apos;这是标题&apos;)# 默认情况下，这会添加一个顶级标题，在Word中显示为“标题1”。# 当您想要一个小节的标题时，只需将所需的级别指定为1到9之间的整数即可：doc.add_heading(&apos;二级标题&apos;,level=2)# 段落是Word的基础。它们用于正文，也用于标题和项目符号# 此方法返回对段落的引用para=doc.add_paragraph(&apos;添加一段内容添一段内容添加一段内容添加一段内容&apos;)para2=doc.add_paragraph()para2.add_run(&apos;fdfdfdfdf&apos;)# 也可以将一个段落用作“光标”，并在其上方直接插入一个新段落ins_para=para.insert_paragraph_before(&apos;把某一段落当做光标，可以在其上方直接插入一个新段落&apos;)# 添加分页doc.add_page_break()# 添加表格table=doc.add_table(rows=2,cols=3,style=&apos;Light List Accent 4&apos;)# 访问单个单元,您始终可以通过其行和列索引访问单元格：就像坐标一样cell=table.cell(0, 1)cell.text=&apos;表格内容&apos;# rows 表的属性提供对各个行的访问，每个行都有一个 .cells属性。# 该.cells两个属性Row和Column 支持索引访问，就像一个列表：row=table.rows[1]row.cells[2].text=&apos;表格内容&apos;# rows和.columns集合是可迭代的# 使用一个两层元组或两层列表的方式循环写入表格table2=doc.add_table(rows=3,cols=2)lst=[ [&apos;姓名&apos;,&apos;成绩&apos;], [&apos;shulu&apos;,&apos;100&apos;], [&apos;qiuyun&apos;,&apos;99&apos;]]for i in range(0,len(table2.rows)): row=table2.rows[i] for x in range(0,len(row.cells)): cell=row.cells[x] cell.text=lst[i][x]# 添加图片# doc.add_picture(&apos;shulu520.com.png&apos;)# 宽度高度设置一个，另一个自动缩放doc.add_picture(&apos;shulu520.com.png&apos;, width=Cm(5))# 保存doc.save(&apos;我的文档.docx&apos;) 搜索指定内容123456789101112131415161718192021# 这一块的思路 非常重要！# 每次前进一个字符长度，每次匹配输入内容的长度个字符from docx import Documentdoc=Document(&apos;我的.docx&apos;)word=input(&apos;请输入搜索内容：&apos;)# 输入内容的长度，以此为每次切片搜索的长度单位word_len=len(word)count=0for para in doc.paragraphs: # 每一段文本的长度 text_len=len(para.text) for i in range(0,text_len-word_len+1): if word==para.text[i:word_len+i]: count+=1print(word+&apos;出现了&apos;+str(count)+&apos;次&apos;) 文本对齐方式和间距123456789101112131415161718from docx import Documentfrom docx.shared import Pt #英镑单位# WD_PARAGRAPH_ALIGNMENT 即word段落对齐from docx.enum.text import WD_PARAGRAPH_ALIGNMENT doc=Document(&apos;./word/美文.docx&apos;)for para in doc.paragraphs: para.alignment=WD_PARAGRAPH_ALIGNMENT.CENTER # WD_PARAGRAPH_ALIGNMENT虽然编辑器对其飘红，但程序会执行的 # 行间距 para.paragraph_format.line_spacing=2.0 # 段前段后间距 para.paragraph_format.space_before=Pt(12) para.paragraph_format.space_after=Pt(12)doc.save(&apos;./word/美文.docx&apos;) 设置字体和字体样式123456789101112131415161718from docx import Documentfrom docx.oxml.ns import qnfrom docx.shared import Pt,RGBColordoc=Document()para=doc.add_paragraph()para.add_run(&apos;人生苦短&apos;).font.bold=True #加粗para.add_run(&apos;人生苦短&apos;).font.shadow=True #阴影para.add_run(&apos;Python&apos;).font.italic=True #倾斜para.add_run(&apos;你好吗&apos;).font.underline=True #下划线para.add_run(&apos;shulu&apos;).font.strike=True #删除线para.add_run(&apos;哈哈哈&apos;).font.size=Pt(20) #字体大小para.add_run(&apos;睡大觉&apos;).font.color.rgb=RGBColor(255,255,0) #字体颜色# 设置中文字体 宋体、楷体等等doc.styles[&apos;Normal&apos;].font.name = u&apos;楷体&apos;doc.styles[&apos;Normal&apos;]._element.rPr.rFonts.set(qn(&apos;w:eastAsia&apos;), u&apos;楷体&apos;)doc.save(&apos;中文字体.docx&apos;) 设置表格样式12345678910111213141516171819202122from docx import *# word当中的样式类型WD_STYLE_TYPEfrom docx.enum.style import WD_STYLE_TYPE doc=Document()styles=doc.stylesprint(styles) #所有文档样式for style in styles: # 表格的样式 if style.type==WD_STYLE_TYPE.TABLE: doc.add_paragraph(&apos;表格样式：&apos;+style.name) table=doc.add_table(3,3,style=style) cells=table.rows[0].cells cells[0].text=&apos;第1列&apos; cells[1].text=&apos;第2列&apos; cells[2].text=&apos;第3列&apos;# 如上代码得到所有表格的样式名称，# 创建表格时，指定样式名称即可：doc.add_table(4,5,style=&apos;Light List Accent 4&apos;)doc.save(&apos;所有表格样式.docx&apos;) 读取文本文档并按指定的格式写入Word1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 读取文本文档# 这里的line一行指的是上一个换行符&apos;\\n&apos;&apos;与下一个\\n&apos;之间的内容# 原文中的软回车删不掉！！！！！！from docx import Documentfrom docx.shared import Ptfrom docx.oxml.ns import qnfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENTwith open(&apos;./word/生活.txt&apos;,&apos;r&apos;) as r_file: lines=r_file.readlines()with open(&apos;./word/生活.txt&apos;,&apos;w&apos;) as w_file: for line in lines: if line!=&apos;\\n&apos;: w_file.write(line)with open(&apos;./word/生活.txt&apos;,&apos;r&apos;) as r_file: lines=r_file.readlines() for line in lines: if line==&apos;\\n&apos;: lines.remove(line)print(len(lines))doc=Document()# 标题部分title=doc.add_paragraph(lines[0])for run1 in title.runs: run1.font.bold=True run1.font.name=&apos;宋体&apos; run1.font.size=Pt(20) r=run1._element.rPr.rFonts r.set(qn(&apos;w:eastAsia&apos;), &apos;微软雅黑&apos;)title.alignment=WD_PARAGRAPH_ALIGNMENT.CENTER# 日期部分para1=doc.add_paragraph(lines[1])para1.alignment=WD_PARAGRAPH_ALIGNMENT.RIGHT# 正文部分for i in range(2,len(lines)): para_others=doc.add_paragraph(lines[i]) for run2 in para_others.runs: run2.font.size=Pt(12) run2.font.name=&apos;微软雅黑&apos; r=run2._element.rPr.rFonts r.set(qn(&apos;w:eastAsia&apos;), &apos;微软雅黑&apos;) para_others.paragraph_format.line_spacing=1.5 #行间距doc.save(&apos;./word/生活.docx&apos;) 有事您Q我👇","categories":[{"name":"py-word","slug":"py-word","permalink":"https://shulu520.com/categories/py-word/"}],"tags":[{"name":"python","slug":"python","permalink":"https://shulu520.com/tags/python/"}]},{"title":"officePython2","slug":"officePython2","date":"2021-02-20T23:24:42.000Z","updated":"2021-02-25T15:44:23.464Z","comments":true,"path":"officePython/officePython2/","link":"","permalink":"https://shulu520.com/officePython/officePython2/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 打开一个Excel表格1234567891011121314151617181920212223242526272829303132333435363738394041424344# 获取一个工作簿对象import openpyxlworkbook=openpyxl.load_workbook(&apos;我的工作簿.xlsx&apos;)# 获取所有工作簿的名称print(workbook.sheetnames)# 获取某一个具体的sheet工作表sheet=workbook[&apos;评论信息&apos;]# 获取这个工作表的大小范围print(sheet.dimensions)# 获取单元格和内容cell=sheet[&apos;A2&apos;]print(cell.value)# 获取一些列的单元格cells=sheet[&apos;A1:A3&apos;]print(cells)for cell in cells: print(cell[0].value) #两层元组# 获取一整列cols=sheet[&apos;A&apos;]for col in cols: print(col.value)# 获取一整行row=sheet[3]for cell in row: print(cell.value)# 获取所有行，再遍历输出rows=sheet.rows# 获取所有列，再遍历输出cols=sheet.columns# 在第1行到第5行，第1列到第3之间rows=sheet.iter_rows(min_row=1,max_row=5,min_col=1,max_col=3)for row in rows: for cell in row: print(cell.value) print(&apos;-----------------&apos;) 123456789# 在一列中筛选某一个值,也可以做个统计count=0cols=sheet[&apos;A&apos;]for col in cols: if col.value==2: count+=1 print(col.row) #输出目标值所在行print(&apos;count=&apos;+str(count)) 创建一个工作薄(一个Excel文件)12345678910111213141516171819202122232425262728293031323334# 关于报错：关闭手动打开的文件，重新运行即可import openpyxlworkbook=openpyxl.Workbook()# 创建sheet工作表sheet=workbook.create_sheet() #在excel中显示为sheet1,默认的活动页# 向表中写入内容sheet[&apos;A1&apos;]=&apos;shulu520哈哈哈&apos;cell=sheet[&apos;A2&apos;]cell.value=&apos;do you love me?&apos;lst=[&apos;姓名&apos;,&apos;爱好&apos;]sheet.append(lst)stu_lst=[ [&apos;张三&apos;,80], [&apos;李思&apos;,90], [&apos;王武&apos;,100]]for cell in stu_lst: sheet.append(cell)# 可以给单元格赋求值公式sheet[&apos;B7&apos;]=&apos;=sum(B4:B6)&apos;# 保存工作簿并命名workbook.save(&apos;写入内容.xlsx&apos;)# 查看openpyxl支持的Excel公式from openpyxl.utils import FORMULAEprint(FORMULAE)# https://product.pconline.com.cn/itbk/software/excel/1506/6538476.html 向工作表中指定位置插入一列123456# 插入行与插入列做法一样，就不写了import openpyxlworkbook=openpyxl.load_workbook(&apos;我的工作簿.xlsx&apos;)sheet=workbook[&apos;评论信息&apos;]sheet.insert_cols(idx=1) #往第一列插入一列workbook.save(&apos;我的工作簿.xlsx&apos;) 向工作表中指定位置插入多列12345import openpyxlworkbook=openpyxl.load_workbook(&apos;我的工作簿.xlsx&apos;)sheet=workbook[&apos;评论信息&apos;]sheet.insert_cols(idx=3,amount=2) #在第三列插入两列workbook.save(&apos;我的工作簿.xlsx&apos;) 删除行列123456import openpyxlworkbook=openpyxl.load_workbook(&apos;我的工作簿.xlsx&apos;)sheet=workbook[&apos;评论信息&apos;]sheet.delete_cols(idx=1,amount=2) sheet.delete_rows(idx=1,amount=1) #从第一行开始删除一行workbook.save(&apos;我的工作簿.xlsx&apos;) 移动一些单元格123456# 向下向右为正数，向左向上为负数import openpyxlworkbook=openpyxl.load_workbook(&apos;我的工作簿.xlsx&apos;)sheet=workbook[&apos;评论信息&apos;]sheet.move_range(&apos;A1:B4&apos;,rows=2,cols=2)workbook.save(&apos;我的工作簿.xlsx&apos;) sheet工作表的创建12345import openpyxlworkbook=openpyxl.load_workbook(&apos;我的工作簿.xlsx&apos;)# 创建工作表workbook.create_sheet(&apos;学生信息&apos;)workbook.save(&apos;我的工作簿.xlsx&apos;) 删除工作表12345import openpyxlworkbook=openpyxl.load_workbook(&apos;我的工作簿.xlsx&apos;)sheet=workbook[&apos;Sheet2&apos;]workbook.remove(sheet)workbook.save(&apos;我的工作簿.xlsx&apos;) 复制sheet和重命名1234import openpyxlworkbook=openpyxl.load_workbook(&apos;我的工作簿.xlsx&apos;)src_sheet=workbook[&apos;评论信息&apos;]sheet=workbook.copy_worksheet(src_sheet) #名称叫做：评论信息 Copy 修改sheet名称12sheet.title=&apos;mysheet&apos;workbook.save(&apos;我的工作簿.xlsx&apos;) 冻结窗格123456789101112131415161718192021如果对于太大而不能一屏显示的电子表格，“冻结”顶部的几行或最左边的几列，是很有帮助的，可以帮助你来判断这行或这列所对应的数据类型，比如查看你的成绩排名。例如，冻结的列或行表头，就算用户滚动电子表格，也是始终可见的。在 Openpyxl中，每个 Worksheet 对象都有一个 freeze_panes 属性，可以设置为一个 Cell 对象或一个单元格坐标的字符串。请注意，单元格上边的所有行和左边的所有列都会冻结，但单元格所在的行和列不会冻结。要解冻所有的单元格，就将 freeze_panes 设置为 None 或’A1’sheet.freeze_panes=‘A2’ 冻结第一行sheet.freeze_panes=‘B1’ 冻结第一列sheet.freeze_panes=‘C2’ 冻结第一行，第一列和第二列sheet.freeze_panes=None 什么也不冻结sheet.freeze_panes=‘A1’ 什么也不冻结import openpyxlworkbook=openpyxl.load_workbook(&apos;冻结.xlsx&apos;)sheet=workbook[&apos;Sheet1&apos;]# 冻结，固定它的位置sheet.freeze_panes=&apos;A2&apos; #冻结第一行workbook.save(&apos;冻结.xlsx&apos;) 添加筛选按钮12345import openpyxlworkbook=openpyxl.load_workbook(&apos;筛选.xlsx&apos;)sheet=workbook[&apos;Sheet1&apos;]sheet.auto_filter.ref=sheet.dimensionsworkbook.save(&apos;筛选.xlsx&apos;) 1234567891011121314151617181920212223242526# 筛选出所有关于41码鞋子的评论，并且将其添加到一个新的excel文件import openpyxlworkbook=openpyxl.load_workbook(&apos;课堂练习.xlsx&apos;)sheet=workbook[&apos;Sheet1&apos;]rows=sheet.rows #获取所有行 一个迭代器对象lst=[] #放入41码相关的所有行for row in rows: # print(row) #每一行都是一个元组 每个元组共三个数据(只写了三列数据) sub_lst=[] #把sub_lst在这里定义是为了每次进来它都是空的列表，然后再赋值，不重复添加 if row[2].value==41: # print(row) for i in range(0,3): sub_lst.append(row[i].value) lst.append(sub_lst) #这一行的缩进也很讲究# 存放到一个新的excel文件中 创建新的工作簿new_workbook=openpyxl.Workbook()new_sheet=new_workbook.active #获取默认的活动页(Sheet)for row in lst: new_sheet.append(row) #因为lst是双层列表，所以这样就可以将相同类型的数据放到一列new_workbook.save(&apos;所有41码鞋子.xlsx&apos;) 填充颜色1234567891011121314151617import openpyxlfrom openpyxl.styles import PatternFillworkbook=openpyxl.load_workbook(&apos;填充颜色.xlsx&apos;)sheet=workbook[&apos;Sheet1&apos;]cell_b5=sheet[&apos;B5&apos;]pattren_fill=PatternFill(fill_type=&apos;solid&apos;,fgColor=&apos;ff0000&apos;)cell_b5.fill=pattren_fill# workbook.save(&apos;填充颜色.xlsx&apos;)# 填充渐变色from openpyxl.styles import GradientFillcell_c3=sheet[&apos;C3&apos;]gradient=GradientFill(stop=(&apos;ff00ff&apos;,&apos;00ff00&apos;))cell_c3.fill=gradientworkbook.save(&apos;填充颜色.xlsx&apos;) 正则匹配12345678import rerows=sheet.rowsfor row in rows: if re.search(&apos;.*好.*&apos;,row[0].value): for i in range(0,3): row[i].fill=gradient workbook.save(&apos;看看.xlsx&apos;) 设置单元格的大小12345import openpyxlworkbook=openpyxl.load_workbook(&apos;练习.xlsx&apos;)sheet=workbook[&apos;Sheet1&apos;]sheet.row_dimensions[2].height=50sheet.column_dimensions[&apos;B&apos;].width=50 合并单元格12345sheet.merge_cells(&apos;C2:E4&apos;)# 取消合并单元格sheet.unmerge_cells(&apos;C2:E4&apos;)workbook.save(&apos;练习.xlsx&apos;) 向excel中插入图片12345678910111213141516import openpyxlfrom openpyxl.drawing.image import Imageworkbook=openpyxl.load_workbook(&apos;我的工作簿.xlsx&apos;)sheet=workbook.create_sheet(&apos;插入图片&apos;)# 创建图片对象logo=Image(&apos;shulu520.com.png&apos;)# 设置宽高logo.height=200logo.width=180# 添加图片sheet.add_image(logo,&apos;E3&apos;)workbook.save(&apos;我的工作簿.xlsx&apos;) 创建柱状图图表123456789101112131415161718192021222324import openpyxlfrom openpyxl.chart import BarChart,Referenceworkbook=openpyxl.load_workbook(&apos;我的工作簿.xlsx&apos;)sheet=workbook[&apos;成绩&apos;]# 创建柱状图图表对象chart=BarChart()# 数据引用来源data=Reference(worksheet=sheet,min_row=1,max_row=7,min_col=1,max_col=2)# 将数据插入图表当中chart.add_data(data,titles_from_data=True)# 类别的引用范围 (柱子下面的东西)categorys=Reference(sheet,min_row=2,max_row=7,min_col=1)# 设置类别chart.set_categories(categorys)# 插入图表sheet.add_chart(chart,&apos;F8&apos;)workbook.save(&apos;我的工作簿.xlsx&apos;) 生成条形图123456789101112131415161718192021222324import openpyxlfrom openpyxl.chart import LineChart,Referenceworkbook=openpyxl.load_workbook(&apos;我的工作簿.xlsx&apos;)sheet=workbook[&apos;工资&apos;]# 创建图表对象chart=LineChart()# 数据引用来源data=Reference(worksheet=sheet,min_row=1,max_row=2,min_col=1,max_col=13)# # 将数据插入图表当中chart.add_data(data,from_rows=True,titles_from_data=True)# 类别的引用范围categorys=Reference(sheet,min_row=1,min_col=2,max_col=13)# 设置类别chart.set_categories(categorys)# 插入图表sheet.add_chart(chart,&apos;F8&apos;)workbook.save(&apos;我的工作簿.xlsx&apos;) 案例：工资明细1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import openpyxlfrom openpyxl.styles import Font,Alignment,Border,Sideworkbook=openpyxl.load_workbook(&apos;工资明细.xlsx&apos;)sheet=workbook[&apos;Sheet1&apos;]# 设置字体样式font=Font(name=&apos;宋体&apos;,sz=20,b=True)font2=Font(name=&apos;宋体&apos;,sz=12,b=True)# 设置对其方式alignment=Alignment(horizontal=&apos;center&apos;,vertical=&apos;center&apos;,wrap_text=True)# 边框和线条side=Side(style=&apos;thin&apos;,color=&apos;000000&apos;)border=Border(left=side,right=side,top=side,bottom=side)# 获取指定单元格的值a1_value=sheet[&apos;A1&apos;].valuel2_value=sheet[&apos;L2&apos;].value# 获取指定的行row3=sheet[3] #第三行 # 每一行都是一个元组 遍历元组，拿出每一个值，放入列表list_value=[]for cell in row3: list_value.append(cell.value)# 将需要的内容进新的excel文件# print(sheet.max_row) #工作表总共的行数 int类型for i in range(4,sheet.max_row+1): write_book=openpyxl.Workbook() write_sheet=write_book.active # 合并新文件标题的单元格 write_sheet.merge_cells(start_row=1,end_row=1,start_column=1,end_column=12) write_sheet.row_dimensions[1].height=25.8 #第一行的高度 write_sheet[&apos;A1&apos;]=a1_value write_sheet[&apos;A1&apos;].font=font write_sheet[&apos;A1&apos;].alignment=alignment # 薪水单位的单元格样式 write_sheet[&apos;L2&apos;]=l2_value write_sheet[&apos;L2&apos;].font=font2 # 第三行样式 write_sheet.append(list_value) three_rows=write_sheet[3] for cell in three_rows: cell.font=font2 cell.alignment=alignment cell.border=border # 设置每一列列宽 write_sheet.column_dimensions[cell.column_letter].width=13 # 第三行的高度 write_sheet.row_dimensions[3].height=40.8 # 第四行样式 four_rows=write_sheet[4] for cell in four_rows: cell.font=Font(name=&apos;宋体&apos;,sz=12) cell.alignment=alignment cell.border=border # 向第四行的每一格添加数据 lst=[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;,&apos;K&apos;,&apos;L&apos;] for letter in lst: write_sheet[letter+&apos;4&apos;].value=sheet[letter+str(i)].value # 这两格的原内容是公式 write_sheet[&apos;F4&apos;].value=&apos;=SUM(C4:E4)&apos; write_sheet[&apos;L4&apos;].value=&apos;=F4-G4-H4-I4-J4-K4&apos; # 以每一个人的姓名命名文件 write_book.save(&apos;工资/&apos;+write_sheet[&apos;B4&apos;].value+&apos;个人工资明细.xlsx&apos;) 有事您Q我👇","categories":[{"name":"officePython","slug":"officePython","permalink":"https://shulu520.com/categories/officePython/"}],"tags":[{"name":"python","slug":"python","permalink":"https://shulu520.com/tags/python/"}]},{"title":"officePython1","slug":"officePython1","date":"2021-02-18T03:56:12.000Z","updated":"2021-02-23T03:09:24.199Z","comments":true,"path":"officePython/officePython1/","link":"","permalink":"https://shulu520.com/officePython/officePython1/","excerpt":"&emsp;&emsp;python -m pip install –upgrade pip 升级pip包管理器","text":"&emsp;&emsp;python -m pip install –upgrade pip 升级pip包管理器 Excel 无法打开文件“新建 Microsoft Excel 工作表.xlsx”，因为文件格式或文件扩展名无效 windows+r 输入regedit 打开注册表，按如下连接指示，发现问题之所在：Excel原模板路径是wps的，按照下面教程改回来就好了1https://blog.csdn.net/learllp/article/details/79723078?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;dist_request_id=229aed61-e516-4d52-bab0-8fb76592087b&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control os.scandir查询文件信息12345678910111213141516171819202122import osimport time import datetime print(os.scandir()) #得到一个可遍历的对象for file in os.scandir(&apos;xue3&apos;): #可以指定路径 print(file.stat()) # 得到好多属性 # st_size 文件的体积大小(字节) # st_atime 文件最近访问时间 时间戳 # st_mtime 文件最近修改时间 时间戳 # st_ctime 文件创建时间 时间戳 print(time.ctime(file.stat().st_atime)) print(time.ctime(file.stat().st_mtime)) print(time.ctime(file.stat().st_ctime)) # #Thu Feb 18 12:20:17 2021 print(datetime.datetime.fromtimestamp(file.stat().st_atime)) # 2021-02-18 21:09:39.046517## 某一个指定文件的信息print(os.stat(&apos;./xue3/3.py&apos;)) 创建临时文件、文件夹1234567891011121314151617181920212223# 学习爬虫的时候需要使用# 用完之后自动删除from tempfile import TemporaryFilefile=TemporaryFile(&apos;w+&apos;)file.write(&apos;我最帅&apos;)file.seek(0) # 将光标移动到第一位print(file.readlines())print(file.name) #得到文件位置和名称input(&apos;我去找找临时文件在哪里：随便输入&apos;)file.close()# 推荐这种写法with TemporaryFile(&apos;w+&apos;) as file: file.write(&apos;你最帅了&apos;) file.seek(2) print(file.readlines())# 创建临时文件夹from tempfile import TemporaryDirectorywith TemporaryDirectory() as tem_dir: print(tem_dir) input(&apos;我去找找它在哪里：随便输入&apos;) 创建文件或文件夹123456789101112import os# os.mkdir(&apos;我的文件夹&apos;) #在5.py文件夹同层创建一个文件夹# 老师演示时创建的是与5.py文件同级的文件夹，可能是编辑器的不同# os.mkdir(&apos;xue3\\我的文件夹&apos;) #创建成功了，但是有警告！！！# 先判断有没有，再创建if not os.path.exists(&apos;我的文件夹2&apos;): os.mkdir(&apos;我的文件夹2&apos;)# 创建多层文件夹os.makedirs(&apos;第一层/第二层/第三层&apos;) 复制文件、文件夹123456789import shutil# 将当前test.py复制到xue3文件夹下shutil.copy(&apos;test.py&apos;,&apos;xue3&apos;) #复制并改名字为test2.pyshutil.copy(&apos;test.py&apos;,&apos;xue3/test2.py&apos;) # 复制文件夹shutil.copytree(&apos;xue3&apos;,&apos;hh/jj/xue3&apos;)# 注意：hh/jj/xue3 这个xue3文件夹原先要不存在才行 剪贴文件、文件夹12345678import shutil# shutil.move(&apos;./xue3/test2.py&apos;,&apos;./&apos;) #移动文件#剪贴并重命名 # shutil.move(&apos;./test2.py&apos;,&apos;./xue3/move_test2.py&apos;) # 剪贴文件夹shutil.move(&apos;./test&apos;,&apos;./xue3&apos;) 删除文件或文件夹1234567import os# 注意：利用Python会彻底删除os.remove(&apos;./xue3/move_test2.py&apos;)# 删除文件夹import shutilshutil.rmtree(&apos;./xue3/test&apos;) 文件或文件夹重命名123import osos.rename(&apos;./xue3/8.py&apos;,&apos;./xue3/re8.py&apos;)os.rename(&apos;./xue&apos;,&apos;./xue1&apos;) 读取压缩文件包123456789101112import zipfilewith zipfile.ZipFile(&apos;./hh.zip&apos;,&apos;r&apos;) as zipobj: # 列出此压缩包下的所有文件和文件夹，带路径的 print(zipobj.namelist()) # 获取压缩包内文件信息 for file_name in zipobj.namelist(): info=zipobj.getinfo(file_name) #file_size 压缩之前大小 #compress_size 压缩之后大小 print(file_name,info.file_size,info.compress_size) 解压压缩包1234567891011# 将压缩包内单个文件解压出来import zipfilewith zipfile.ZipFile(&apos;hh.zip&apos;,&apos;r&apos;) as zipobj: # extract(要解压的文件路径，解压后放置位置) # 注意解压后文件的相对路径不会变，会带上路径 # 比如要放置的位置没有hh/jj/xue3这个路径，则会创建再放入 zipobj.extract(&apos;hh/jj/xue3/test2.py&apos;,&apos;./&apos;) print(zipobj.namelist()) # 解压出所有的文件 zipobj.extractall(&apos;./zip&apos;) #要放置的位置 创建压缩包1234567891011import zipfilefile_list=[&apos;./xue3/1.py&apos;,&apos;./xue3/2.py&apos;,&apos;./xue3/3.py&apos;]# 要创建的压缩包名叫压缩包.zip,在程序中起个别名叫zipobj,方便操作with zipfile.ZipFile(&apos;压缩包.zip&apos;,&apos;w&apos;) as zipobj: for file in file_list: zipobj.write(file)# 向压缩包中添加文件 a是append的意思with zipfile.ZipFile(&apos;压缩包.zip&apos;,&apos;a&apos;) as zipobj: zipobj.write(&apos;./test.py&apos;) 有事您Q我👇","categories":[{"name":"officePython","slug":"officePython","permalink":"https://shulu520.com/categories/officePython/"}],"tags":[{"name":"python","slug":"python","permalink":"https://shulu520.com/tags/python/"}]},{"title":"Python-文件系统","slug":"Python-文件系统","date":"2021-02-14T00:49:13.000Z","updated":"2021-03-02T13:37:10.793Z","comments":true,"path":"Python语法/Python-文件系统/","link":"","permalink":"https://shulu520.com/Python语法/Python-文件系统/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 模块化、文件系统1234# 一个.py文件就是一个模块# 导入内置模块# import 模块名 [as 可以起个别名使用]# from 模块名 import 包/模块/函数/变量/类等 导入自定义模块12345# 学习到这里时遇到了问题，搜索得到：https://www.jianshu.com/p/6692b48c7295# 选择了其中一个方法:# 将自定义模块打包:将一揽子的模块（.py文件）放在一个文件夹里面，再添加一个__init__.py，这样这个文件夹就成为了一个包。# 自定义模块打包后，放在需要调用的.py文件同一个目录下# 注意要包名+模块名的前缀写完整 1234567891011121314这是我创建的myfun包下的模块#calc.pydef add(a,b): return a+bdef div(c,d): return c/d# 只有当此模块以主程序运行时才会运行下面内容# 被其他模块导入使用时不会出现如下内容# 如点击本.py文件运行的时候if __name__ == &apos;__main__&apos;: print(add(1,22)) #33 12345import myfun.calc as calc #导入整个模块,并起个别名，方便使用print(calc.add(1,5)) #6from myfun.calc import div #导入模块下指定函数print(div(6,2)) #3.0 第三方模块的安装与使用12345678910111213# 安装：window + r 输入cmd进入黑窗口# pip install schedule(要安装的模块) import scheduledef job(): print(&apos;你好呀！&apos;)schedule.every(3).seconds.do(job)while True: schedule.run_pending()&lt;!-- 每隔三秒输出：你好呀！ --&gt;schedule 该模块可以应用于邮件自动化 python编码格式1234# .py文件默认存储方式为utf-8# 修改储存方式：在.py文件最开始加一句#encoding=gbk,我这里会报错# 文件读写io操作 input output 1234567891011file=open(&apos;xue2/c.txt&apos;,&apos;r&apos;,encoding=&apos;UTF-8&apos;)print(file.readlines())file.close()file2=open(&apos;xue2/d.txt&apos;,&apos;w&apos;,encoding=&apos;UTF-8&apos;)file2.write(&apos;Python,shulu,啥啥啥&apos;)file2.close()file2=open(&apos;xue2/d.txt&apos;,&apos;a&apos;,encoding=&apos;UTF-8&apos;)file2.write(&apos;Python,shulu,啥啥啥&apos;)file2.close() 文件路径（相对或者绝对路径）rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。一般用于非文本文件如图片等。注意：使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。1234567src_file=open(&apos;xue2/s.jpg&apos;,&apos;rb&apos;) #源文件target_file=open(&apos;xue2/copy.jpg&apos;,&apos;wb&apos;) #目标文件target_file.write(src_file.read()) #读取并写入src_file.close() #关闭文件。关闭后文件不能再进行读写操作。target_file.close() 文件读写io操作open文件路径（相对或者绝对路径）rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。一般用于非文本文件如图片等。注意：使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。1234567src_file=open(&apos;xue2/s.jpg&apos;,&apos;rb&apos;) #源文件target_file=open(&apos;xue2/copy.jpg&apos;,&apos;wb&apos;) #目标文件target_file.write(src_file.read()) #读取并写入src_file.close() #关闭文件。关闭后文件不能再进行读写操作。target_file.close() with语句，上写文管理器，自动释放资源这三句代码相当于上面的5行代码123with open(&apos;xue2/s.jpg&apos;,&apos;rb&apos;) as src_file: with open(&apos;xue2/copy2.jpg&apos;,&apos;wb&apos;) as target_file: target_file.write(src_file.read()) OS模块，操作系统相关的123456import os# os.system(&apos;calc.exe&apos;) #打开系统自带程序# os.system(&apos;notepad.exe&apos;)# 直接调用可执行文件# os.startfile(&apos;C:\\\\Program Files (x86)\\\\Tencent\\\\QQ\\\\Bin\\\\qq.exe&apos;) #打开QQ 12345678910import osprint(os.getcwd()) #获取当前目录路劲# E:\\Users\\lqy\\Desktop\\xuexiPyos.mkdir(&apos;haha&apos;) #创建文件目录os.rmdir(&apos;haha&apos;) #s删除指定目录os.chdir(&apos;E:\\\\Users\\\\lqy\\\\Desktop&apos;) #将path设置为当前工作目录# print(os.getcwd()) os.path模块12345678910111213141516171819202122232425262728293031import os.path#获取文件或目录的绝对路径print(os.path.abspath(&apos;xue2\\\\11.py&apos;)) # E:\\Users\\lqy\\Desktop\\xuexiPy\\xue2\\11.py#路径拼接：文件和目录名之间print(os.path.join(&apos;E:\\\\Users\\\\lqy\\\\Desktop\\\\xuexiPy&apos;,&apos;jj.py&apos;)) # E:\\Users\\lqy\\Desktop\\xuexiPy\\jj.py#拆分路径：文件和目录名之间print(os.path.split(&apos;E:\\\\Users\\\\lqy\\\\Desktop\\\\xuexiPy\\\\jj.py&apos;)) # (&apos;E:\\\\Users\\\\lqy\\\\Desktop\\\\xuexiPy&apos;, &apos;jj.py&apos;)#拆分路径：文件名和扩展名之间print(os.path.splitext(&apos;E:\\\\Users\\\\lqy\\\\Desktop\\\\xuexiPy\\\\jj.py&apos;)) # (&apos;E:\\\\Users\\\\lqy\\\\Desktop\\\\xuexiPy\\\\jj&apos;, &apos;.py&apos;)# 从一个目录中提取文件名print(os.path.basename(&apos;E:\\\\Users\\\\lqy\\\\Desktop\\\\xuexiPy\\\\jj.py&apos;))# jj.py# 从一个目录中提取文件路径print(os.path.dirname(&apos;E:\\\\Users\\\\lqy\\\\Desktop\\\\xuexiPy\\\\jj.py&apos;))# E:\\Users\\lqy\\Desktop\\xuexiPy# 判断路径是否存在 True Falseprint(os.path.exists(&apos;E:\\\\Users\\\\lqy\\\\Desktop\\\\xuexiPy\\\\jj.py&apos;))# 是否为路径 True Falseprint(os.path.exists(&apos;E:\\\\Users\\\\lqy\\\\Desktop\\\\xuexiPy&apos;)) 搜索文件12345678import oslts=os.listdir(&apos;xue2&apos;)for pyfile in lts: if pyfile.endswith(&apos;.py&apos;): #以谁结尾 print(pyfile)for item in lts: if item.startswith(&apos;c&apos;): #以谁开头 print(item) 12import globprint(glob.glob(&apos;xue2\\\\*.py&apos;)) #查找更方便 搜索指定文件123 #全部包括子文件夹的全找出来了 强import globprint(glob.glob(&apos;xue2/**/*.py&apos;,recursive=True)) glob模块12345# 类似正则表达式# *匹配所有，任意字符# ?匹配任意单个字符# []匹配其中任何字符，如[1-8], [1,2,3]# [!]不匹配其中任何字符,如[!8] 遍历文件os.listdir与os.scandir12345# print(os.listdir(&apos;xue2&apos;)) #返回指定目录下的文件嗯和目录# os.scandir() 比os.listdir强大一些for file in os.scandir(): print(file.name,file.path,file.is_dir()) os.walk 遍历所有文件和目录12345678910import ospath=os.getcwd() #获取当前目录lts_files=os.walk(path) #遍历当前目录for dirpath,dirname,filename in lts_files: # print(dirpath) #目录路径 # print(dirname) #目录名称 # print(filename) #文件名 for pyfiles in filename: if pyfiles.endswith(&apos;.py&apos;): #输出所有的Python文件 print(pyfiles) 验证文件名是否符合指定的要求12import fnmatchprint(fnmatch.fnmatch(&apos;8.py&apos;,&apos;?.py&apos;)) 有事您Q我👇","categories":[{"name":"Python语法","slug":"Python语法","permalink":"https://shulu520.com/categories/Python语法/"}],"tags":[{"name":"python","slug":"python","permalink":"https://shulu520.com/tags/python/"}]},{"title":"Python-面向对象","slug":"Python-面向对象","date":"2021-02-11T13:13:36.000Z","updated":"2021-03-02T13:33:36.089Z","comments":true,"path":"Python语法/Python-面向对象/","link":"","permalink":"https://shulu520.com/Python语法/Python-面向对象/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; class类 面向对象123456# 类，人类，鸟类，物以类聚，类即具有某些共同特征的一些对象 # self代表类的实例，而非类# 类的方法与普通的函数只有一个特别的区别：# 它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。# 与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数 12345678910111213141516171819202122232425262728class Test: #类名 一个或多个字母组成，且每个字母开头要大写，这是规范 love=&apos;shu&apos; #公开属性 #类的私有属性 两个下划线开头，声明该属性为私有， 不能在类的外部被使用或直接访问。 __love=&apos;lu&apos; # 普通方法(参数self) def prt(self): print(self.love) #可以访问 print(self.__love) #可以访问 print(self) print(self.__class__) # 类的私有方法 # 两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。 def __foo(self): print(&apos;这是私有方法&apos;)t = Test() #实例化一个对象print(t.love) #shut.prt() # &lt;__main__.Test instance at 0x100771878&gt; # __main__.Test # 从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。print(t._Test__love) 这样是可以访问类的私有方法的 类方法和静态方法12345678910# 静态方法是类中的函数，不需要实例。# 主要是用来存放逻辑性的代码，主要是一些逻辑属于类，但是和类本身没有交互，# 即在静态方法中，不会涉及到类中的方法和属性的操作。类方法（@classmethod）和静态方法（@staticmethod）都是为了对类参数进行一些预处理的过程，方便使用不同参数对类的调用类方法推荐使用类名直接调用，当然也可以使用实例对象来调用（不推荐）静态方法，其实就是我们学过的函数，和函数唯一的区别是，静态方法定义在类这个空间（类命名空间）中，而函数则定义在程序所在的空间（全局命名空间）中。在实际编程中，几乎不会用到类方法和静态方法，因为我们完全可以使用函数代替它们实现想要的功能，但在一些特殊的场景中（例如工厂模式中），使用类方法和静态方法也是很不错的选择。 123456789101112131415161718192021class Classname: @staticmethod #静态方法 def fun(): print(&apos;静态方法&apos;) @classmethod #类方法 默认有个 cls 参数，可以被类和对象调用 def a(cls): print(&apos;类方法&apos;) # 实例方法 默认有个self参数，且只能被实例对象调用。 def b(self): print(&apos;普通方法&apos;)Classname.fun()Classname.a()# Classname.b() 报错C = Classname()C.fun()C.a()C.b() 给实例对象动态添加属性和方法12345678910111213141516class Love: love=&apos;shu&apos; def mylove(self): print(self.love)lu=Love()lu.mylove()def eat(): #定义一个普通函数 print(&apos;吃吃吃&apos;)# 给实例对象动态添加属性和方法lu.age=18lu.eat=eatlu.eat() 类的三大特征 封装、继承与多态类的封装 封装就像ATM机，内部复杂的结构无需使用者知道，安全外人不会对其内部进行操作 类的继承 1234567891011121314151617181920212223242526272829303132333435class Person(): #默认继承Object类，可以不写 def __init__(self,name,age): #类的初始化方法 self.name=name self.age=age def info(self): print(self.name,self.age) class Student(Person): #这就是继承的书写方式 def __init__(self,name,age,num): super().__init__(name,age) #调用父类Person的方法，继承 self.num=num #方法重写 def info(self): super().info() #继承父类方法，不满足需求，扩充或更改 print(self.num)class Teacher(Person): def __init__(self,name,age,money): super().__init__(name,age) self.money=money def info(self): super().info() print(self.money)stu=Student(&apos;shulu&apos;,18,80)stu.info() #shulu 18 #20tec=Teacher(&apos;liu&apos;,20,888888)tec.info() #liu 20#888888 多继承，一个类可以同时继承多个父类1234567891011多继承时，若父类方法名同，子类中默认调用的是在括号中排前的父类的方法，如下为A的方法class A(): passclass B(): passclass C(A,B): #多继承 pass 查看对象所有属性方法，内置函数dir()123456789101112131415class Person(): passp1=Person()print(dir(p1))# 结果为 # [&apos;__class__&apos;, &apos;__delattr__&apos;, # &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;,# &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, # &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, # &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;,# &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;,# &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, # &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;,# &apos;__subclasshook__&apos;, &apos;__weakref__&apos;] 重写str方法 返回一个对象的描述信息123# __str__方法需要返回一个字符串，当做这个对象的描写# 当使用print输出对象的时候，若重写__str__方法，就会打印从在这个方法中return的数据# 帮我们查看对象的信息 1234567891011class Student(): def __init__(self,name,age): self.name=name self.age=age def __str__(self): return &apos;我的名字叫&#123;0&#125;,今年&#123;1&#125;岁了&apos;.format(self.name,self.age)stu=Student(&apos;shu&apos;,18)print(stu) #结果为：# 没重写之前： &lt;__main__.Student object at 0x0000027798F25EB0&gt;# 重写之后：我的名字叫shu,今年18岁了 多态,让代码更加通用12345# Python中多态的特点# 1、只关心对象的实例方法是否同名，不关心对象所属的类型；# 2、对象所属的类之间，继承关系可有可无；(对象所属的类之间有继承关系应用更广)# 3、多态的好处可以增加代码的外部调用灵活度，让代码更加通用，兼容性比较强；# 4、多态是调用方法的技巧，不会影响到类的内部设计。 123456789101112131415161718192021222324# 调用同一个函数fly(), 传入不同的参数（对象），可以达成不同的功能class Duck(object): # 鸭类 def fly(self): print(&quot;鸭子沿着地面飞起来了&quot;)class Swan(object): # 天鹅类 def fly(self): print(&quot;天鹅在空中翱翔&quot;)class Plane(object): # 飞机类 def fly(self): print(&quot;飞机隆隆地起飞了&quot;)def fly(obj): # 实现飞的功能函数 obj.fly()duck = Duck()swan = Swan()plane = Plane()fly(duck) #鸭子沿着地面飞起来了fly(swan) #天鹅在空中翱翔fly(plane) #飞机隆隆地起飞了 Python 中的new和init的区别二者均是Python面向对象语言中的函数，new比较少用，init则用的比较多。new是在实例创建之前被调用的，因为它的任务就是创建实例然后返回该实例对象，是个静态方法。init是当实例对象创建完成后被调用的，然后设置对象属性的一些初始值，通常用在初始化一个类实例的时候。是一个实例方法。也就是： new先被调用，init后被调用，new的返回值（实例）将传递给init方法的第一个参数，然后init给这个实例设置一些参数。参数self与clsself是类的实例对象，cls是类对象Python 直接赋值、浅拷贝和深度拷贝解析12345678# 直接赋值：其实就是对象的引用（别名）。# b = a: 赋值引用，a 和 b 都指向同一个对象。# 浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。# b = a.copy(): 浅拷贝, a 和 b 是一个独立的对象，但他们会引用同一个子对象。# 深拷贝(deepcopy)：copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。# b = copy.deepcopy(a): 深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。 12345678910111213141516171819import copya = [1, 2, 3, [&apos;a&apos;, &apos;b&apos;]] #原始对象 b = a #赋值，传对象的引用c = copy.copy(a) #对象拷贝，浅拷贝d = copy.deepcopy(a) #对象拷贝，深拷贝 a.append(4) #修改原对象a (父对象)a[3].append(&apos;c&apos;) #修改原对象a中的[&apos;a&apos;, &apos;b&apos;]数组对象 (子对象) print( &apos;a = &apos;, a )print( &apos;b = &apos;, b )print( &apos;c = &apos;, c )print( &apos;d = &apos;, d )# a = [1, 2, 3, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 4]# b = [1, 2, 3, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 4]# c = [1, 2, 3, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]# d = [1, 2, 3, [&apos;a&apos;, &apos;b&apos;]] 有事您Q我👇","categories":[{"name":"Python语法","slug":"Python语法","permalink":"https://shulu520.com/categories/Python语法/"}],"tags":[{"name":"python","slug":"python","permalink":"https://shulu520.com/tags/python/"}]},{"title":"Python-函数","slug":"Python-函数","date":"2021-02-10T14:34:13.000Z","updated":"2021-03-03T11:23:26.559Z","comments":true,"path":"Python语法/Python-函数/","link":"","permalink":"https://shulu520.com/Python语法/Python-函数/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 函数总结调用函数时，进行参数的传递1234567891011121314151617# 若果是不可变对象(数字、字符串、元组)，在函数体内对形参的修改不会影响实参# 若果是可变对象(列表、字典、集合)，在函数体内对形参的修改会影响实参def fun1(arg1,arg2): print(arg1) print(arg2) arg1=100 arg2.append(10) print(arg1) print(arg2)n1=12n2=[11,33,44]fun1(n1,n2)print(n1) #12print(n2) #[11, 33, 44, 10] 函数的返回值，是否需要自己决定12345678910111213# 函数的返回值为1个值时，返回值为原类型# 函数的返回值为多个值时，返回值为元组类型n3=88n4=[22,45,66]def fun2(arg1,arg2): arg1=100 arg2.append(10) print(arg1) print(arg2) return n3,n4print(fun2(n3,n4)) #输出函数的返回值 (88, [22, 45, 66, 10]) 设置函数的默认参数值12345678910111213141516171819202122232425262728def fun3(a,b=8): print(a,b)fun3(1) #1 8fun3(1,32) #1 32## 个数可变的位置参数def fun4(*args): print(args)fun4(1) #(1,)fun4(1,2,3) #(1, 2, 3)## 个数可变的关键字参数def fun5(**args): print(args)fun5(a=1) #&#123;&apos;a&apos;: 1&#125;fun5(a=1,b=2,c=3) #&#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;## 个数可变得位置形参与个数可变得关键字形参都有时，# 个数可变的位置形参在前，不然报错def fun6(*arg1,**arg2): print(arg1,arg2)fun6(1,4) #(1, 4) &#123;&#125;fun6(a=22,b=33) #() &#123;&apos;a&apos;: 22, &apos;b&apos;: 33&#125;fun6(1,3,a=121,c=88) #(1, 3) &#123;&apos;a&apos;: 121, &apos;c&apos;: 88&#125; 函数传参，传列表，字典12345678def fun7(x,y,z): print(x,y,z)ls=[1,2,3]d=&#123;&apos;x&apos;:&apos;shu&apos;,&apos;y&apos;:18,&apos;z&apos;:&apos;men&apos;&#125;fun7(*ls) #1 2 3 展开列表元素并传入实参fun7(**d) #shu 18 men 展开字典元素并传入实参 1234def fun8(a,b,*,c,d): #从*之后的参数只能采用关键字传参 print(a,b,c,d)fun8(1,2,c=3,d=4) #1 2 3 4 递归函数123456789# 计算阶乘def fun1(n): if n==1: return 1 else: res=n*fun1(n-1) return resprint(fun1(5)) #120 计算菲波拉契数列123456789def fun2(n): if n==1: return 1 elif n==2: return 1 else: return fun2(n-1)+fun2(n-2)print(fun2(6)) #8 函数的异常处理机制12345678910111213141516# 一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组。# 使用 else 子句比把所有的语句都放在 try 子句里面要好，# 这样可以避免一些意想不到，而 except 又无法捕获的异常。while True: try: x=int(input(&apos;请输入一个数字：&apos;)) #执行代码 except (ValueError, RuntimeError, TypeError, NameError, SyntaxError, KeyError, IndexError,ZeroDivisionError): print(&apos;请输入一个正确的数字&apos;) #发生异常时执行的代码 else: y=x+1 #没有异常时执行的代码 print(y) finally: #无论异常是否发生都会执行： print(&apos;你最帅&apos;)# finally能用来释放try块中申请的资源 打印异常信息，可用于以后打印日志等12345import tracebacktry: print(1/0)except: traceback.print_exc() #ZeroDivisionError: division by zero lambda匿名函数12345# 用完即释放内存# 用法为：lambda 一个或多个参数: 表达式内容a=lambda x:x+xprint(a(8)) #16 random随机函数123456789101112131415161718import random#[0,1) 的随机数print(random.random()) #[10,100]的随机数print(random.randint(10,100))#[10,100) 步长为5的随机数print(random.randrange(10,100,5)) # 从序列中随机选取一个lst=[11,2,33,1,44]print(random.choice(lst))# 将序列元素随机排序# 把原列表随机排序，没有rutern值random.shuffle(lst) print(lst) 有事您Q我👇","categories":[{"name":"Python语法","slug":"Python语法","permalink":"https://shulu520.com/categories/Python语法/"}],"tags":[{"name":"python","slug":"python","permalink":"https://shulu520.com/tags/python/"}]},{"title":"Python-字符串","slug":"Python-字符串","date":"2021-02-10T00:57:13.000Z","updated":"2021-03-02T13:35:20.898Z","comments":true,"path":"Python语法/Python-字符串/","link":"","permalink":"https://shulu520.com/Python语法/Python-字符串/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 目前所学不可变序列为字符串和元组拼接字符串时join()方法比+效率高字符串查询操作12345678910str1=&apos;shulu520u&apos;print(str1.index(&apos;u&apos;)) #2 第一次出现的位置print(str1.rindex(&apos;u&apos;)) #8 最后一次出现的位置# print(str1.index(&apos;m&apos;)) #substring not found# print(str1.rindex(&apos;m&apos;)) #substring not foundprint(str1.find(&apos;u&apos;)) #2 第一次出现的位置print(str1.rfind(&apos;u&apos;)) #8 最后一次出现的位置print(str1.find(&apos;m&apos;)) #-1 不会报错print(str1.rfind(&apos;m&apos;)) #-1 不会报错 字符串大小写转换12345678910str2=&apos;ShuluIloveYou&apos;print(str2.upper()) #SHULUILOVEYOUprint(str2.lower()) #shuluiloveyouprint(str2.swapcase()) #sHULUiLOVEyOU 大小取反str3=&apos;hu,lu,You&apos;print(str3.title()) #Hu,Lu,You 每一个单词首字母大写，其余小写print(str3.capitalize()) #Hu,lu,you 第一个字符大写，其余小写 字符串对齐操作1234567891011121314str1=&apos;python&apos;# 居中对齐，指定字符串的长度和不够指定长度时的填充内容# 默认填充内容为空格# 若指定长度小于实际长度则返回字符串本身print(str1.center(10,&apos;*&apos;)) #**python**# 左对齐print(str1.ljust(10,&apos;&amp;&apos;)) #python&amp;&amp;&amp;&amp;# 右对齐print(str1.rjust(10,&apos;$&apos;)) #$$$$python# 右对齐，只有一个参数，不到指定长度用0填充print(str1.zfill(10)) #0000python 字符串的劈分操作1234567#split() 通过指定分隔符对字符串进行切片，# 如果第二个参数 num 有指定值，则分割为 num+1 个子字符串。# 返回一个列表，将分隔符换为逗号，默认分隔符为空格str2=&apos;nihaoyaiw&apos;str22=&apos;ni hao ya iw&apos;print(str2.split(&apos;i&apos;)) #[&apos;n&apos;, &apos;haoya&apos;, &apos;w&apos;]print(str22.split()) #[&apos;ni&apos;, &apos;hao&apos;, &apos;ya&apos;, &apos;iw&apos;] 计数指定字符串在原字符串中出现的个数123s3=&apos;shululoveu&apos;print(s3.count(&apos;u&apos;)) #3print(s3.count(&apos;u&apos;,1,4)) #1 指定范围内u出现的次数 rstrip() 删除字符串末尾的指定字符（默认为空格）12345s4=&apos; ss dsds, shu &apos;print(s4.rstrip()) # ss dsds, shus5=&apos; ss dsds, shu***&apos;print(s4.rstrip(&apos;*&apos;)) # ss dsds, shu 删除末尾* lstrip() 删除字符串开头的指定字符（默认为空格）用法同rstrip字符串替换replace(old,new)123s6=&apos;shuluhahaha&apos;print(s6.replace(&apos;u&apos;,&apos;*&apos;)) #sh*l*hahahaprint(s6.replace(&apos;h&apos;,&apos;%&apos;,2)) #s%ulu%ahaha 最多替换2个 len()是内置函数，返回对象的长度（元素个数）。1234# 实参可以是序列（如 string、bytes、tuple、list 或 range 等）# 或集合（如 dictionary、set 或 frozen set 等）。# len()不是字符串类的方法print(len(s6)) #11 字符串连接join()12345678910s7=&apos;swww,lu&apos;print(&apos;@&apos;.join(s7)) #s@w@w@w@,@l@u## 将列表或元组中的字符串拼接成一个字符串ls1=[&apos;shu&apos;,&apos;lu&apos;,&apos;520&apos;]print(&apos;^&apos;.join(ls1)) #shu^lu^520print(&apos;&apos;.join(ls1)) #shulu520t=(&apos;shu&apos;,&apos;lu&apos;,&apos;520&apos;)print(&apos;*&apos;.join(ls1)) #shu*lu*520 字符串的判断1234567s9=&apos;shu520&apos;# 是否全部由字母或数字组成print(s9.isalnum()) #True # 只包含数字s0=&apos;520&apos;print(s0.isdigit()) #True 字符串的比较(字符串有驻留机制)1234567s11=&apos;love&apos;s12=&apos;love&apos;# == 比较的是值的比较print(s11==s12) #True# == 比较的是id的比较print(s11 is s12) #True 字符串的切片操作12345s22=&apos;shululove&apos;print(s22[2]) #uprint(s22[2:5]) #uluprint(s22[::2]) #suuoeprint(s22[::-2]) #eouus 格式化字符串12345678# 使用%做占位符,s表示字符串,d表示数字name=&apos;lu&apos;age=18print(&apos;我叫%s,今年%d岁&apos; %(name,age)) #我叫lu,今年18岁print(f&apos;我叫&#123;name&#125;,今年&#123;age&#125;岁&apos;) #我叫lu,今年18岁print(&apos;我叫&#123;0&#125;，今年&#123;1&#125;岁&apos;.format(name,age)) ##我叫lu,今年18岁 字符串的编码解码12345# encode()str100=&apos;爱&apos;str200=str100.encode()print(str200) #b&apos;\\xe7\\x88\\xb1&apos;print(str200.decode()) #爱 有事您Q我👇","categories":[{"name":"Python语法","slug":"Python语法","permalink":"https://shulu520.com/categories/Python语法/"}],"tags":[{"name":"python","slug":"python","permalink":"https://shulu520.com/tags/python/"}]},{"title":"Python-数据类型","slug":"Python-数据类型","date":"2021-02-09T08:42:25.000Z","updated":"2021-03-02T13:30:29.915Z","comments":true,"path":"Python语法3/Python-数据类型/","link":"","permalink":"https://shulu520.com/Python语法3/Python-数据类型/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 字典{key:value}键值对形式123456#创建方式love=&#123;&apos;name&apos;:&apos;yachan&apos;,&apos;age&apos;:18&#125; #直接花括号print(love,type(love)) #&#123;&apos;name&apos;: &apos;yachan&apos;, &apos;age&apos;: 18&#125; &lt;class &apos;dict&apos;&gt;)student=dict(&#123;&apos;name&apos;:&apos;shulu&apos;,&apos;age&apos;:19&#125;) #内置函数dict(&#123;&#125;)print(student) #&#123;&apos;name&apos;: &apos;shulu&apos;, &apos;age&apos;: 19&#125; 获取字典中的元素12print(love[&apos;name&apos;])print(love[&apos;money&apos;]) #KeyError: &apos;money&apos; 1234print(student.get(&apos;age&apos;))print(student.get(&apos;money&apos;)) #None 不会报错print(student.get(&apos;cat&apos;,&apos;bob&apos;)) #找不到，给一个默认值print(student) #但是不会影响原字典，只是查询的时候给一个反馈 key键的判断12345love=&#123;&apos;name&apos;:&apos;yachan&apos;,&apos;age&apos;:18&#125;print(&apos;age&apos; in love)print(&apos;money&apos; in love)print(&apos;money&apos; not in love) 增加键值对12love[&apos;money&apos;]=8888print(love) 修改键值对12love[&apos;age&apos;]=20print(love) 删除key12del love[&apos;age&apos;]print(love) 清空元素12love.clear()print(love) #&#123;&#125; 获取字典视图1234love=&#123;&apos;name&apos;:&apos;yachan&apos;,&apos;age&apos;:18&#125;print(love.keys())print(type(love.keys()))print(list(love.keys())) #[&apos;name&apos;, &apos;age&apos;] 123print(love.values())print(type(love.values()))print(list(love.values())) #[&apos;yachan&apos;, 18] 1234print(love.items())print(type(love.items()))print(list(love.items())) #得到元组数据类型[(&apos;name&apos;, &apos;yachan&apos;), (&apos;age&apos;, 18)] 字典元素的遍历12345love=&#123;&apos;name&apos;:&apos;yachan&apos;,&apos;age&apos;:18,&apos;money&apos;:88888&#125;for item in love: print(item) #key print(love[item]) print(love.get(item)) 字典生成式zip(a,b)函数加for循环实现12345678k=[&apos;name&apos;,&apos;age&apos;,&apos;money&apos;] #生成的字典是根据键或值短的那一个v=[&apos;yachan&apos;,18,88888,&apos;hahaha&apos;]d=&#123;key:value for key,value in zip(k,v)&#125;print(d) #&#123;&apos;name&apos;: &apos;yachan&apos;, &apos;age&apos;: 18, &apos;money&apos;: 88888&#125;d2=&#123;key.upper():value for key,value in zip(k,v)&#125;print(d2) #&#123;&apos;NAME&apos;: &apos;yachan&apos;, &apos;AGE&apos;: 18, &apos;MONEY&apos;: 88888&#125; 元组()12345678910111213141516love=(&apos;shu&apos;,&apos;money&apos;,88)print(type(love)) #&lt;class &apos;tuple&apos;&gt;#创建多个元组值，可以不用()love2=&apos;shu&apos;,&apos;money&apos;,88 print(type(love2)) #&lt;class &apos;tuple&apos;&gt;#创建一个元组值，必须要逗号不能少love3=(&apos;age&apos;,) love4=&apos;age&apos;print(love3,type(love3)) #(&apos;age&apos;,) &lt;class &apos;tuple&apos;&gt;print(love4,type(love4)) #age &lt;class &apos;str&apos;&gt;#使用内置函数tuple()创建元组love5=tuple((&apos;shu&apos;,&apos;money&apos;,88))print(love5) #(&apos;shu&apos;, &apos;money&apos;, 88) 12345678love6=(&apos;shu&apos;,[&apos;age&apos;,18],&apos;money&apos;)# 元组元素修改注意：列表、字典等才可以修改，# 它的值可以修改，但标识符即内存地址不可以修改# love6[0]=&apos;hahha&apos; # print(love6) #&apos;tuple&apos; object does not support item assignmentlove6[1][0]=&apos;friend&apos; print(love6) #(&apos;shu&apos;, [&apos;friend&apos;, 18], &apos;money&apos;) 遍历元组元素12345love=(&apos;shu&apos;,&apos;money&apos;,88)print(love[2])for item in love: print(item) set集合{}，内置数据结构，没有value的字典123456789101112131415161718# 创建方式1s1=&#123;&apos;shulu&apos;,88,&apos;ya&apos;&#125;print(s1,type(s1)) #&#123;&apos;shulu&apos;, &apos;ya&apos;, 88&#125; &lt;class &apos;set&apos;&gt;# 创建方式2s2=set(range(6))print(s2) #&#123;0, 1, 2, 3, 4, 5&#125;# 创建空集合s9=set()print(s9,type(s9)) #set() &lt;class &apos;set&apos;&gt;s0=&#123;&#125; #不能用空&#123;&#125;创建print(s0,type(s0)) #&#123;&#125; &lt;class &apos;dict&apos;&gt;# 可以对元素去重s3=&#123;1, 3, 5, 2, 2, 4, 4&#125;print(s3) #&#123;1, 2, 3, 4, 5&#125; 集合与其他数据类型转换123456789101112131415#列表转sets4=list(s3) print(s4,type(s4)) #[1, 2, 3, 4, 5] &lt;class &apos;list&apos;&gt;s5=set(s4)print(s5,type(s5)) #&#123;1, 2, 3, 4, 5&#125; &lt;class &apos;set&apos;&gt;#元组转sets6=tuple((range(5))) print(s6,type(s6)) #(0, 1, 2, 3, 4) &lt;class &apos;tuple&apos;&gt;s7=set(s6)print(s7,type(s7)) #&#123;0, 1, 2, 3, 4&#125; &lt;class &apos;set&apos;&gt;#字符串转sets8=set(&apos;Python&apos;) print(s8) #&#123;&apos;h&apos;, &apos;t&apos;, &apos;n&apos;, &apos;P&apos;, &apos;y&apos;, &apos;o&apos;&#125; 无序的 集合元素的判断,集合是无序的123s1=&#123;1,22,33,2&#125;print(&apos;shu&apos; in s1)print(1 not in s1) 集合元素的增加12345678910111213#add方法一次只能添加一个s1.add(88) print(s1)#update方法至少添加一个s1.update((11,21,31)) #将元组转换并添加print(s1)s1.update([&apos;shu&apos;,9]) #将列表转换并添加print(s1) #&#123;1, 2, 33, 9, 11, 21, 22, 88, &apos;shu&apos;, 31&#125;s1.update(&#123;&apos;love&apos;,520&#125;) #添加集合print(s1) #&#123;1, 2, 33, &apos;love&apos;, 520, 9, 11, &apos;shu&apos;, 21, 22, 88, 31&#125; 集合元素的删除123456789101112131415161718s2=&#123;21,33,&apos;yaya&apos;,88&#125;# 删除指定元素s2.remove(21) print(s2) #&#123;88, 33, &apos;yaya&apos;&#125;#remove()被删除元素没有，则抛异常# s2.remove(1)# print(s2) #KeyError: 1#discard()被删除元素有则删除，没有的话不会抛出错误s2.discard(88)print(s2) #&#123;33, &apos;yaya&apos;&#125;s2.discard(500)print(s2) #&#123;33, &apos;yaya&apos;&#125;#pop()没有参数，随机删除一个元素s2.pop()print(s2) clear()清空集合12s2.clear()print(s2) #set() 集合间的关系12345678910111213s1=&#123;0,1,2,3&#125;s2=&#123;3,0,2,1&#125;print(s1==s2) #True 集合是无序的# issubset()判断s3是s1的子集吗s3=&#123;0,1,2&#125; print(s3.issubset(s1)) #True# issuperset()判断s1是s3的超集吗,与子集相反print(s1.issuperset(s3)) #True# isdisjoint()p判断s1与s3没有交集吗print(s1.isdisjoint(s3)) #False 集合间的数学操作,原集合不变12345# 交集s1=&#123;22,1,45,3&#125;s2=&#123;3,0,2,1&#125;print(s1.intersection(s2)) #&#123;1, 3&#125;print(s1 &amp; s2) #&#123;1, 3&#125; 123#并集print(s1.union(s2)) #&#123;0, 1, 2, 3, 45, 22&#125;print(s1 | s2) #&#123;0, 1, 2, 3, 45, 22&#125; 123#差集print(s1.difference(s2)) #&#123;45, 22&#125;print(s2.difference(s1)) #&#123;0, 2&#125; 123#对称差集print(s1.symmetric_difference(s2)) #&#123;0, 2, 22, 45&#125;print(s1 ^ s2) #&#123;0, 2, 22, 45&#125; 有事您Q我👇","categories":[{"name":"Python语法3","slug":"Python语法3","permalink":"https://shulu520.com/categories/Python语法3/"}],"tags":[{"name":"python","slug":"python","permalink":"https://shulu520.com/tags/python/"}]},{"title":"Python-循环与列表","slug":"Python-循环与列表","date":"2021-02-07T01:13:14.000Z","updated":"2021-03-02T13:38:48.365Z","comments":true,"path":"Python语法/Python-循环与列表/","link":"","permalink":"https://shulu520.com/Python语法/Python-循环与列表/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; pass空语句1234567某一段逻辑没有想好，让其先通过a=1b=2if a&gt;b : passelse : print(&apos;sssss&apos;) range()函数的使用1234567891011121314151617range函数的优点：不管range函数表示的整数序列有多长，所有range对象占用的内存空间是相同的，因为仅仅只要存储start，stop，step只有当用到range对象时，才会去计算range对象中的相关元素range函数返回的是一个可迭代对象（类型是对象），常用在for循环中r1=range(10)print(r1) #range(0, 10) 默认从零开始，步长为一#使用list()函数查看列表print(list(r1)) #[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]r2=range(1,10) #指定开始值print(r2) #range(1, 10)print(list(r2)) #[1, 2, 3, 4, 5, 6, 7, 8, 9]r3=range(1,10,2) #指定步长print(r3) #range(1, 10, 2)print(list(r3)) #[1, 3, 5, 7, 9] while循环123456789# 执行N次的话，则需要判断N+1次a=1while a&lt;10 : print(a) a+=1# 选择结构的if与循环结构的while的区别# if是判断一次，条件为True时执行一次# while是判断N+1次,条件为True时执行N次 break1234for i in range(10) : print(i) if i==8 : break #跳出循环 continue12345结束当前循环，进入下一次循环for i in range(10) : if i%2 == 0 : continue print(i) else与while、for、if搭配双层循环1234for i in range(1,10): for j in range(1,i+1): print(i,&apos;*&apos;,j,&apos;=&apos;,i*j,end=&apos; &apos;) print() # 外层打印行数 列表，相当于其他语言中的数组1234567891011121314#第一种方式创建列表用[]ls1=[&apos;shulu&apos;,520,&apos;哈哈哈&apos;]print(ls1)# 第二种方式创建列表用内置函数list([])ls2=list([&apos;shulu&apos;,1314,&apos;hhh&apos;])print(ls2)#按索引获取列表元素ls1=[&apos;shulu&apos;,520,&apos;哈哈哈&apos;]print(ls1[0])## 获取列表元素的索引print(ls1.index(&apos;哈哈哈&apos;))## 指定索引区间获取列表元素的索引print(ls1.index(520,1,5)) 列表切片复制12ls=[1,2,3,4,5,6,7,8]print(ls[2:6:1]) #start:stop:step 列表元素的判断123ls=[1,2,3,4,5,6,7,8]print(1 in ls)print(10 not in ls) 列表元素的遍历12for i in ls: print(i) 向列表添加元素末尾添加,内存地址不变12345678910111213141516171819202122ls=[1,2,3]ls2=[&apos;yachan&apos;,666]print(ls)print(id(ls))## 向末尾添加一个元素ls.append(ls2)print(ls)print(id(ls))## 向列表末尾添加多个元素ls.extend(ls2) #将ls2展开添加到末尾print(ls)## 向任意位置添加一个元素ls.insert(2,520) #start和要添加的元素print(ls)## 切片替换添加，任意位置，多个元素ls3=[11,22,33,44]ls4=[55,66,77]ls3[1:]=ls4 #指定位置,从索引1开始到结束print(ls3) #[11, 55, 66, 77] 删除列表元素1234# remove()ls1=[1,22,3,4]ls1.remove(22) #删除指定元素print(ls1) 12345678#pop()ls2=[1,2,3,4]ls2.pop() #删除最后一个元素print(ls2) #[1, 2, 3]ls3=[1,2,3]ls3.pop(1) #删除指定索引的元素print(ls3) #[1, 3] 1234567# 切片删除ls4=[1,2,3,4,5]#从索引2开始，到索引4结束，左闭右开区间ls5=ls4[2:4] #切出来赋值给ls5print(ls5) #产生一个新的列表对象print(&apos;ls4&apos;,id(ls4)) #2305914778560print(&apos;ls5&apos;,id(ls5)) #2305914779584 123456#不产生新的元素ls6=[1,2,3,4,5]print(id(ls6)) #2095779428480ls6[1:3]=[] #删掉第二三个元素print(ls6)print(id(ls6)) #2095779428480 1234#清空列表元素ls7=[1,2,3,4,5]ls7.clear()print(ls7) 1234#删除列表ls8=[1,2,3,4,5]del ls8print(ls8) #name &apos;ls8&apos; is not defined 列表修改，类似切片替换添加，任意位置，多个元素1234ls3=[11,22,33,44,211,223]ls4=[55,66,77]ls3[1:4]=ls4 #指定位置,从索引1开始到4,左闭右开区间print(ls3) #[11, 55, 66, 77, 211, 223] 1234# 列表修改,修改某一个指定索引的值ls5=[11,22,33,44]ls5[2]=88print(ls5) #[11, 22, 88, 44] 列表元素排序sort(),对原列表排序12345678ls1=[1,22,23,14,55,25,13]print(id(ls1)) #1910309785344ls1.sort() #默认升序print(ls1)print(id(ls1)) #1910309785344ls1.sort(reverse=True) #降序print(ls1) 列表元素排序sorted() 排序后产生一个新的列表，原列表不变1234567#升序ls7=[21,14,66,25,11]print(id(ls7)) #2798832727872ls8=sorted(ls7)print(ls8) #[11, 14, 21, 25, 66] 默认升序print(id(ls8)) #2798832727936print(id(ls7)) #2798832727872 123456#降序ls9=sorted(ls8,reverse=True) #降序print(ls9)print(id(ls9)) #2050346596480print(ls7) #[21, 14, 66, 25, 11]print(id(ls7)) #2798832727872 列表生成表达式1234ls=[i for i in range(1,10)]print(ls) #[1, 2, 3, 4, 5, 6, 7, 8, 9]ls=[i*i for i in range(1,10)]print(ls) #[1, 4, 9, 16, 25, 36, 49, 64, 81] 合并列表123ls1=[1,2,3]ls2=[4,5,6]ls=ls1+ls2 #[1,2,3,4,5,6] 有事您Q我👇","categories":[{"name":"Python语法","slug":"Python语法","permalink":"https://shulu520.com/categories/Python语法/"}],"tags":[{"name":"python","slug":"python","permalink":"https://shulu520.com/tags/python/"}]},{"title":"Python基础","slug":"Python基础","date":"2021-02-03T22:05:24.000Z","updated":"2021-04-14T14:46:37.158Z","comments":true,"path":"Python语法/Python基础/","link":"","permalink":"https://shulu520.com/Python语法/Python基础/","excerpt":"&emsp;&emsp;最帅的人就是我","text":"&emsp;&emsp;最帅的人就是我 Python中字符串前“r”,“u”的作用 字符串前加 u 例：u”我是含有中文字符组成的字符串。” 作用：后面字符串以 Unicode 格式 进行编码，一般用在中文字符串前面，防止因为源码储存格式问题，导致再次使用时出现乱码。 字符串前加 r 例：r”\\n\\n\\n\\n” 表示一个普通生字符串 \\n\\n\\n\\n，而不表示换行了。 作用：去掉反斜杠的转移机制。（特殊字符：即那些，反斜杠加上对应字母，表示对应的特殊含义的，比如最常见的”\\n”表示换行，”\\t”表示Tab等。）应用：常用于正则表达式，对应着re模块。 变量(标识符)开头只能是字母数字或下划线print 函数 打印输出1234print(520)print(1+1)print(&quot;shulu520&quot;)print(&quot;sdsdsd&quot;) 将数据输出到文件中,’a+’意思是文件不存在的话就创建，已经存在的话就追加内容123ft = open(&apos;E:/love.txt&apos;,&apos;a+&apos;) print(&apos;helloworld&apos;,file=ft)ft.close() 不进行换行输出，使用逗号分隔print(11,111,333,&#39;erere&#39;) 转义字符，反斜杠+转义字符的首字母,n newline的首字母print(&#39;shulu\\n520&#39;) 制表符 不太懂print(&#39;hello\\tshulu&#39;)print(&#39;hellooooo\\tshulu&#39;) 覆盖print(&#39;shulu\\r520&#39;) 退格，将u退没了print(&#39;shulu\\b520&#39;) 双反斜杠的应用12print(&apos;https:\\\\shulu520.com&apos;)print(&apos;https:\\\\\\\\shulu520.com&apos;) 引号print(&#39;shulu说:\\&#39;i love you\\&#39;&#39;) 原字符 不让字符串中的转义字符起作用,注意字符串最后一个不能是反斜杠123print(r&apos;shulu\\n520&apos;)print(R&apos;shulu\\n520&apos;)print(R&apos;shulu\\n520\\\\&apos;) 变量直接写，不用声明12345name=&apos;shulu&apos;age=18money=100.888bo=Trueprint(name,age,money,bo) 变量的内存地址，变量类型1234print(id(name),type(name))print(id(age),type(age))print(id(money),type(money))print(id(bo),type(bo)) 类型转换12345678print(type(str(age)))print(type(str(money)))print(float(age),type(float(age)))print(int(money),type(int(money)))print(int(bo),type(int(bo)))print(float(bo),type(float(bo))) 多行注释123&apos;&apos;&apos;这是多行注释&apos;&apos;&apos; input输入函数，接收用户的输入，做提示语运行代码，输入答案回车看看print(input(&#39;你爱我吗&#39;)) 算数运算符，整除print(11//2) 一正一负，整除，向下取整12print(-9//4)print(9//-4) 幂运算print(2**3) 取余print(11%2) 赋值运算符解构赋值12a,b,c = 1,2,3print(a,b,c) 12345交换两个变量的值c,d = 4,5print(&apos;交换之前&apos;,c,d)c,d = d,cprint(&apos;交换之后&apos;,c,d) 比较运算符==,比较的是值，is比较内存地址1234567891011121314a,b,c = 1,2,1print(a==b) print(a&gt;b)print(a&lt;b)print(id(a),id(c))print(a==c)print(a is c) #比较的是内存地址id，此处为Truelt1 = [11,22,33]lt2 = [11,22,33]print(id(lt1),id(lt2))print(lt1==lt2)print(lt1 is lt2) #比较的是内存地址id，此处为Falseprint(lt1 is not lt2) #True 布尔运算算符and，当两个云算数都为True时结果才为True1234a,b=1,2print(a==1 and b==2) #True and True为Trueprint(a==2 and b==2) #False and True为Falseprint(a!=1 and b!=2) #False and False为False or12a,b=1,2print(a!=1 or b==2) not对布尔值取反12c,d=True,Falseprint(not c, not d) in,not in12love=&apos;shulu&apos;print(&apos;s&apos; in love, &apos;x&apos; not in love) 对象的布尔值,使用内置函数bool()查看123456789101112131415以下对象的布尔值为Falseprint(bool(False))print(bool(0))print(bool(0.0))print(bool(&apos;&apos;))print(bool(&quot;&quot;))print(bool(None))print(bool([])) #空列表print(bool(list())) #空列表print(bool(())) #空元组print(bool(tuple())) #空元组print(bool(&#123;&#125;)) #空字典print(bool(dict())) #空字典print(bool(set())) #空集合 分支结构 if elif else123456789score=int(input(&apos;请输入成绩&apos;))if score&gt;=90 and score&lt;=100 : print(&apos;A&apos;)elif score&gt;=80 and score&lt;90 : print(&apos;B&apos;)elif score&lt;80: print(&apos;不合格&apos;)else: print(&apos;成绩有误&apos;) 12345678910可以用数学中的方式来简写score=int(input(&apos;请输入成绩&apos;))if 90&lt;=score&lt;=100 : print(&apos;A&apos;)elif 80&lt;=score&lt;90 : print(&apos;B&apos;)elif score&lt;80: print(&apos;不合格&apos;)else: print(&apos;成绩有误&apos;) if else 条件表达式，双分支结构的简写1234567891011money=1000s=int(input(&apos;请输入取款金额&apos;))if money&gt;=s: money-=s print(&apos;您的余额为：&apos;,money)else: print(&apos;钱不够，快去挣钱呀&apos;)等于下面的代码print(&apos;您的余额为：&apos;+str(money-s) if money&gt;=s else &apos;钱不够，快去挣钱呀&apos;) 模糊匹配12345678910111213141516171819# 用户输入部分搜索内容后，根据这部分内容去模糊匹配，然后列出所有的匹配项，供其再次精确选择# https://www.cnblogs.com/weiman3389/p/6047017.html# 以下代码作者优化的挺好的import redef fuzzyfinder(user_input, collection): suggestions = [] pattern = &apos;.*?&apos;.join(user_input) # Converts &apos;djm&apos; to &apos;d.*?j.*?m&apos; regex = re.compile(pattern) # Compiles a regex. for item in collection: match = regex.search(item) # Checks if the current item matches the regex. if match: suggestions.append((len(match.group()), match.start(), item)) return [x for _, _, x in sorted(suggestions)]lst=[&apos;清华大学&apos;,&apos;北京大学&apos;,&apos;苏州的大学&apos;,&apos;兰州大学&apos;,&apos;经济学院&apos;,&apos;化工学院&apos;]user_input=input(&apos;请输入学校名称：&apos;)fuzzy_result=fuzzyfinder(user_input,lst)print(fuzzy_result) 续行符 \\123456# 当某一段代码太长了，可以这么干s=&apos;你好啊你好啊你好啊你好啊\\ 你好啊你好啊你好啊你好啊你好啊\\ 你好啊你好啊你好啊你好啊你好啊&apos;print(s) 打包成.exe可执行文件123456789name=input(&apos;请输入你的名字：&apos;)age=eval(input(&apos;请输入你的年龄：&apos;))with open(&apos;可执行文件.txt&apos;,&apos;w&apos;) as file: file.write(name+&apos;----&apos;+str(age))while True: answer=input(&apos;退出吗？y/n&apos;) if answer==&apos;y&apos;: break 1234567891011121314# 程序写好之后，进入cmd# 输入 pyinstaller -F 你的.py文件的绝对路径# 如：pyinstaller -F E:\\Users\\lqy\\Desktop\\xuexiPy\\word\\14.py# 这是一个简单的生成一个文本文件的程序，# 如果程序运行中需要用到图片视频等文件时，# 只需将他们放到C:\\Users\\Administrator\\dist这个目录下# 这是可执行文件打包后的位置# 练习时发现，电脑病毒报错，# 打开设置，进入Windows Defender，# 点击病毒和威胁防护，点击‘病毒和威胁防护’设置，将实时保护关闭。# 待软件安装完成之后，再将实时保护关闭即可。 字符串的反向输出12s=&apos;12345678&apos;print(s[::-1]) #87654321 进制转换函数123456789number=888# 转为二进制print(bin(number)) #0b1101111000# 转为八进制print(oct(number)) #0o1570# 转为16进制print(hex(number)) #0x378 常见的datetime日期时间模块123456789101112131415161718192021222324252627# datetime模块重新封装了time模块import datetimetime1=datetime.datetime.now()print(time1) #2021-02-27 18:59:13.885794time2=datetime.date.today()print(time2) #2021-02-27time3=datetime.datetime.today()print(time3) #2021-02-27 18:58:39.614459time4=datetime.datetime.today().timestamp()print(time4) #1614423830.81342# 返回当前日期时间的日期部分：2021-02-27print(datetime.datetime.now().date())# 返回当前日期时间的时间部分：19:13:45.310397print(datetime.datetime.now().time())# delta时间间隔past=datetime.datetime(2017, 4, 16, 21, 21, 20, 871000)now=datetime.datetime.now()delta=now-pastprint(delta) #1412 days, 22:07:46.382359print(delta.days) #1412 有事您Q我👇","categories":[{"name":"Python语法","slug":"Python语法","permalink":"https://shulu520.com/categories/Python语法/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://shulu520.com/tags/Python/"}]},{"title":"sp心得7","slug":"sp心得7","date":"2020-09-13T13:26:53.000Z","updated":"2020-09-13T15:19:41.437Z","comments":true,"path":"sp心得/sp心得7/","link":"","permalink":"https://shulu520.com/sp心得/sp心得7/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 心得最近在学习VCM岗位带控制节点流程图，相对前面初步学习的物料流程图来说还是有些复杂的，当然对于大家来说背背图还是挺顺的。短暂的记忆很容易遗忘，在学完图纸以后及时到现场对比，加强记忆，发现现场与图纸之间的差别，具体的管道阀门分布，熟悉现场工作环境会更好，但由于此前高温天气以及最近的大修，这使得我们在现场的学习时间很短，还有现场噪音太大，人员又多，听不清楚，不过按计划在接下来的时间里我们将会有大量的现场学习时间了，到那时便可发现更多的问题，学到更多的知识。在刚进行的拜师会上，再次见到了自己的师傅。现场学习的时候碰到过师傅，也请教过问题，果然，师傅就是不一样，我能问出的问题人家都能帮我解决，这样比我独自摸索快多了，感觉真好。师傅对我给予厚望，我也充满信心，满怀期待，非常渴望获取知识，提升自身技能与价值，在平凡的岗位上做好每一件小事。 有事您Q我👇","categories":[{"name":"sp心得","slug":"sp心得","permalink":"https://shulu520.com/categories/sp心得/"}],"tags":[{"name":"sp","slug":"sp","permalink":"https://shulu520.com/tags/sp/"}]},{"title":"sp心得6","slug":"sp心得6","date":"2020-09-05T14:03:15.000Z","updated":"2020-09-06T07:30:55.628Z","comments":true,"path":"sp心得/sp心得6/","link":"","permalink":"https://shulu520.com/sp心得/sp心得6/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 挣钱往事&emsp;&emsp;我来自西北农村家庭，一直以来都勤俭节约，独立自主。拿到职业生涯第一笔工资，不禁想起我挣钱的往事。&emsp;&emsp;第一次挣钱的时候我还是七八岁的小孩子。有一次在山上苗圃地里面除草，大人们干活，我就跟在后面，使用的工具也是搞笑，人家都拿的是镰刀，而我则拿的是砍树的大刀，大家都笑我，说我“砍草”来了，包工头看到我的时候，我已经干了好一会儿的活了，看我干的很是卖力，所以就把我留下来了，说是我能坚持干一天的话，就可以给我十块钱，还好，我没让自己失望，默默忍受大家的取笑，坚持“玩”了一天，最后如愿以偿，大家都夸我很乖很懂事，小小年纪便知道挣钱，长大以后肯定了不起。那时候的十块钱对我来说还是很多的，因为平时上学的时候，父母给的零花钱才只有几毛钱，而且也不是天天有零花钱买辣条的，小学在别的村庄，离家比较远，我每天只能拿一点妈妈蒸的干馒头，有钱买辣条的日子就是最开心的一天，那时候的日子总是那么简单。&emsp;&emsp;后来上中学的时候，有一次暑假里，我外出打工，那是我第一次坐火车而且独自出发去别的省份，对于连我们那个小县城都没有走出去过的我来说，内心很是激动与慌张，一路上不停的寻求路人的帮助，还好克服重重困难最终“满载而归”。那时候村里外出打工的人都还很少，我也算是打工的“积极分子”，邻居们看我一个学生都可以出去挣钱，一些人也向我打听外面打工的情况，其实外面需要人手的地方很多，而且干的活很简单，妇女孩子都可以干。如今村里几乎所有能干的年轻人都外出打工了，虽然留下老人孩子生活不太方便，但是我觉得年轻人还是多多外出走走比较好，挣钱养家是一方面，开阔眼界长长见识也很重要。&emsp;&emsp;在大学的假期里，我也积极打工，寒假里同学们大多都回家过年了，而我则找一些活干，原因很简单，想要的东西没钱买，只有通过自己的努力去争取。记得大一那年寒假我去了一家电子厂，虽然工作也很简单，但是对于没怎么碰过电脑的我来说每天都很紧张，面对眼前的二十几台机器，每台都配有一台电脑，那时候我连鼠标都操作起来很是僵硬，却愣是硬着头皮一直干到新学期的开始，挣的钱足够我半个学期的生活费了，我很开心。有一个领导看我的操作很是费劲，性格又比较内向，建议我去学计算机，他告诉我他以前当过海军，如今干这个也算是不同的行业，教我不要担心，年轻人要大胆的去尝试。后来我终于有了自己的电脑，并且学习了一段时间的编程，虽然最终我还是从事了自己的专业领域，那些“花里胡哨”的知识也逐渐地遗忘，但是那些难忘的经历将或多或少的影响我以后的旅途方向。 有事您Q我👇","categories":[{"name":"sp心得","slug":"sp心得","permalink":"https://shulu520.com/categories/sp心得/"}],"tags":[{"name":"sp","slug":"sp","permalink":"https://shulu520.com/tags/sp/"}]},{"title":"sp心得5","slug":"sp心得5","date":"2020-08-30T01:50:59.000Z","updated":"2020-08-30T10:46:03.725Z","comments":true,"path":"sp心得/sp心得5/","link":"","permalink":"https://shulu520.com/sp心得/sp心得5/","excerpt":"&emsp;&emsp;有些东西我们可以抛弃，却无法忘记，它静静地躺在记忆的深处，冷不丁醒来，让你心碎一场，激动一场，感叹一场，让后有沉沉的睡去。","text":"&emsp;&emsp;有些东西我们可以抛弃，却无法忘记，它静静地躺在记忆的深处，冷不丁醒来，让你心碎一场，激动一场，感叹一场，让后有沉沉的睡去。 手机突然坏了&emsp;&emsp;现在的智能手机作为一个主要的生活工具，几乎人手一部，且形影不离，已经融入我们生活的方方面面，没有它，就会寸步难行。&emsp;&emsp;最近我的手机出现了一次问题，令我很不愉快。近期以来天气炎热，我的手机连续使用几个小时，就会出现明显的发烧问题，甚至是发烫，虽然算是某名牌手机，但已经“服役”两年半了，相比朋友们换手机的速度而言，已经很不错的了。&emsp;&emsp;手机刚开始发烫以后往往会出于自我保护的意识，自动关机，而我又要去使用它，所以过一会儿，等它清醒一下就会让它强制开机，继续为我服务。没想到就在前几天的一天下午，它就罢工了，无论我怎么施救，都无法将其唤醒，于是我上网查找各种处理办法，看看还能不能拯救一下，毕竟陪了我那么久，产生感情了嘛，再说换手机也得等到发工资以后才有底气嘛。&emsp;&emsp;结果一直弄到晚上十点半，能尝试的措施都试遍了，结果它依然躺在那里，浑身冰凉。整得我都困了，感觉没希望了，最后迫于无奈，一狠心按下清除数据的按钮，眨眼间，这几年的资料数据便灰飞烟灭了。好在数据清空以后，终于把它从鬼门关拉了回来，只是一切都回到了最初的模样，备忘录里面记下的好多宝贵的心得感悟没了，其他的数据大多存在某网盘里面，我过几天就会备份一遍，所以几乎没有损失，就是这个备忘录内容是手机自带的备份软件备份的，而我忘了开同步了，上一次同步数据是在今年二月份，所以导致这半年多的记录没了，我很难过，那可是我一点一滴记下来的宝贵知识。从此以后可不敢忘记备份数据了。&emsp;&emsp;现在的好多资料都以数据的形式存在于网上，虽然在网络上的数据不一定安全可靠，但却很便捷。手机说坏就坏了，让人难以提防，平日里养成备份重要东西的习惯，碰到问题时便会有备无患，不至于抓狂得无能狂怒，后悔莫及。 有事您Q我👇","categories":[{"name":"sp心得","slug":"sp心得","permalink":"https://shulu520.com/categories/sp心得/"}],"tags":[{"name":"sp","slug":"sp","permalink":"https://shulu520.com/tags/sp/"}]},{"title":"sp心得4","slug":"sp心得4","date":"2020-08-23T12:17:47.000Z","updated":"2020-08-23T13:50:20.944Z","comments":true,"path":"sp心得/sp心得4/","link":"","permalink":"https://shulu520.com/sp心得/sp心得4/","excerpt":"&emsp;&emsp;每一天遇见更好的自己。","text":"&emsp;&emsp;每一天遇见更好的自己。 知识学习本周学习关于辅助单元的知识，内容比较少，但同样重要，我因复习不到位，一些细节知识没有去总结记忆，考试虽然及格了，但是连小组的平均分都没有达到。对我而言，多几分少几分无所谓，但是这次拖了小组的后腿，实在不好意思。以后学习中可不敢马虎大意了。预防感冒最近以来，天气特别炎热，在培训室里面还好，当出去吃饭的时候，就能明显的感觉到巨大的温差，让人很不舒服，每次吃完饭都汗流浃背，热得只想脱掉外套，吹吹空调清爽一下，但是舒服一时痛苦很久，班里同学好多都是因为这样才感冒的，所以自己要格外注意预防感冒，保持身体健康，莫因感冒影响学习。此外得加强体育锻炼，强健体魄，增强体质，提高新陈代谢，提高免疫力，降低疾病的发生。解决近视近视时间很久了，在高三的时候就有明显的视力模糊的现象，但当时并没有配眼镜，直到现在，坐在第一排都看不清，感叹自己书没读多少，视力却模糊了。我意识到这是一个问题，周末赶紧跑了一趟眼镜城，给心灵的窗户装上了玻璃。感觉整个世界都亮清晰了，这种感觉真好。以后得多读书了，不然对不起这扇美丽的窗。裂解率计算关于裂解率的计算，这种问题很简单，但是每次计算都得列出反应式，得知道物质的摩尔质量，有时候忘了还得做加和计算，虽然步骤不多，但我还是觉得烦，所以花了点时间鼓捣了一个在线工具，每次计算只需要输入进料和出料即可，方便至极。它的意义不在于解决了多么重大的问题，而在于唤起了我学以致用的意识，在以后的学习生活中，捕捉更多的灵感。 有事您Q我👇","categories":[{"name":"sp心得","slug":"sp心得","permalink":"https://shulu520.com/categories/sp心得/"}],"tags":[{"name":"sp","slug":"sp","permalink":"https://shulu520.com/tags/sp/"}]},{"title":"sp心得3","slug":"sp心得3","date":"2020-08-16T10:16:12.000Z","updated":"2020-08-23T12:21:01.756Z","comments":true,"path":"sp心得/sp心得3/","link":"","permalink":"https://shulu520.com/sp心得/sp心得3/","excerpt":"&emsp;&emsp;你所担心的事，只有不超过10%会变成现实，其余都是自己吓自己。","text":"&emsp;&emsp;你所担心的事，只有不超过10%会变成现实，其余都是自己吓自己。 学习&emsp;&emsp;本周学习内容为各单元物料流程图，只要对整个工艺流程有个映像，对各个单元具体的流程就容易理解。画流程图同样不可死记硬背，要清楚的知道每股物料的来龙去脉和每一个设备的用途，这样记忆便容易多了。生活&emsp;&emsp;饮食方面，自己的饭量相比以前来说有所增加，依然保持不挑食不浪费的好习惯，回寝室后做几个俯卧撑活动一下筋骨，保持健康的生活习惯。我注意到有的同事为了保持一个好身材而不吃晚饭，对此希望自己以后不必那样做。关于宾馆马桶拉粑粑溅水的问题，这一点自己还不太习惯，真是难以启齿，还得慢慢适应才行。其他&emsp;&emsp;关于饮食卫生，饭前洗手是进食前的重要环节，但是很少有人做到，还有大家都是穿着工作服，有些同事可能来自生产现场，穿的衣服上面比较脏有污物，可能他们自己没有意识到或是习惯了那样，有关领导应该督促改正他们那样的陋习，不注意卫生的话，打饭的时候很可能对饭菜不太“礼貌”，在食堂这样的公众场所，注意卫生不仅仅是个人形象问题，更是有关大家的饮食健康，需要每个人的共同关注。所以建议在打饭前有个洗手环节并确保每个人都能做到，以及不穿脏衣服进食堂，这样做会更好。&emsp;&emsp;关于运输车辆停放，上下班的时候看到公司门口的马路边上有时会停放很多的危化品槽罐车，一个接着一个，马路上各种车辆你来我往，这样子不仅影响交通舒畅，而且存在安全隐患，建议修建专门的运输车辆停放场所。 有事您Q我👇","categories":[{"name":"sp心得","slug":"sp心得","permalink":"https://shulu520.com/categories/sp心得/"}],"tags":[{"name":"sp","slug":"sp","permalink":"https://shulu520.com/tags/sp/"}]},{"title":"sp心得2","slug":"sp心得2","date":"2020-08-09T10:19:04.000Z","updated":"2020-08-16T10:29:06.079Z","comments":true,"path":"sp心得/sp心得2/","link":"","permalink":"https://shulu520.com/sp心得/sp心得2/","excerpt":"&emsp;&emsp;如果你想要过上更精致的生活，就多了解些表象之下的知识。","text":"&emsp;&emsp;如果你想要过上更精致的生活，就多了解些表象之下的知识。 &emsp;&emsp;基础知识培训第二周，从入职到现在有半个月时间了，对这边的生活环境和工作环境逐渐了解了。学习方面。学习了相关的机械设备，并去了现场，直观的感受了一下，感觉挺好，大家都很兴奋，对着高大的反应器和精馏塔互相讨论它们的工作方式和不同的用途。在仓库里见到了一排排各式各样阀门，以前认为那些铁疙瘩都差不多，不就是个开关嘛，当近距离观察甚至上手触摸以后，才知道虽然看起来大同小异，但实际上用途是不一样的。课堂上学习的图纸是二维平面的，虽然看起来很容易理解，但面对真实的设备还是感觉有点陌生，要在前辈的带领下才能准确辨识。面对裂解炉，当看到那里面燃烧的熊熊烈火，当脸庞感受到那股热浪，感觉非常兴奋刺激。第一次背空气呼吸器，大家既好奇又笨手笨脚地不知所措，洋相百出，但那玩意在关键时刻是可以救命的，练习掌握正确的使用方法至关重要。在课上学习之后能动手体验一下，能去现场再看看，加强记忆，巩固知识，在脑子里面就能形成一个画面，根本不用担心记不住而去死记硬背。&emsp;&emsp;生活方面。食堂的饭菜都还不错，肉菜的量很足，味道也不错，像我这种消瘦的身子可以放开了吃，吃饱了才有力气学习干活。作为一个北方人，对面食的喜爱是与生俱来的，是吃各种面条长大的孩子，来到南方工作，生活习惯有所差异，这得慢慢去适应。周末空闲下来的时候，穿越各个小巷街道去寻找，只为吃到一碗美味的面条，可能是自己太挑剔了吧。现在正值酷暑天气，上课总是容易犯困打瞌睡，影响学习，免费提供的茶叶咖啡很快就被一抢而空，要是大家交一点班费，多买一点的话应该就够用了吧。课上犯困还有一个原因是睡眠时间不足，没能养成早睡早起的好习惯，这一点自己还得刻意练习才行。&emsp;&emsp;其他方面。本次小组得分排名倒数第一，作为团队的一员，自己负有一定的责任，坐在第一排占据得天独厚的优势条件，却没能多多表现，为小组争光，实在不好意思。目前各小组的得分差异主要提现在上课回答问题的积极与否，考试成绩都差不多的，其实就上课回答问题这个事，自己是有些顾虑的。中学的时候上课回答问题非常积极，结果有同学反应，意思是学习好的同学不能太嚣张，老师讲啥你都会，那老师一听就不讲了或是粗略的过了，造成的结果就是大多数同学并没有真正的掌握知识，而自己却感觉很得意的样子。我曾愧疚不已，在后来的学习中便很少再抢风头了。虽然现在看来有点陈旧，但过去的影响一直都在。 有事您Q我👇","categories":[{"name":"sp心得","slug":"sp心得","permalink":"https://shulu520.com/categories/sp心得/"}],"tags":[{"name":"sp","slug":"sp","permalink":"https://shulu520.com/tags/sp/"}]},{"title":"现代礼仪","slug":"现代礼仪","date":"2020-07-31T14:12:22.000Z","updated":"2020-08-29T12:13:02.398Z","comments":true,"path":"大学MOOC/现代礼仪/","link":"","permalink":"https://shulu520.com/大学MOOC/现代礼仪/","excerpt":"&emsp;&emsp;不学礼，无以立————孔子","text":"&emsp;&emsp;不学礼，无以立————孔子 &emsp;&emsp;你没有第二次机会给人留下第一印象。 &emsp;&emsp;留心处处皆学问。 礼仪的内涵礼貌：尊敬、重视和有好的态度。礼节：待人接物方面的形式。仪表：精神状态。仪式：约定俗成的共同认可的行为规范。礼仪的实质：敬人敬己、慎独、三分资质，七分打扮。仪容礼仪：面部、颈部、手、皮肤护理 头型，定制发型，不遮眼，不遮耳，不遮颈 面部，每天早晚用洗面奶清洗两遍，保湿，清洁鼻子眼睛嘴唇耳朵下巴，刷牙漱口，保持清新口气 颈部，与面部同等级的护理 手部，避免洗衣粉之类的，或使用手套，洗手液清洗护理，指甲剪断 清理污物，指甲油透明的或肉色的 皮肤，保持愉快的心情，良好的睡眠习惯，睡前洗脸，常喝水，饮食清淡，水果蔬菜，防紫外线 仪表礼仪面部表情 真诚，友善，眼神注视时间三分之二左右，眉毛，微笑 着装礼仪 时间，地点，目的 整洁，整体，不超过三色，个性，鞋子比裤子重要，裤子比上衣重要，里面的衣服比外面的衣服重要 西服 两粒纽扣，站着时候只扣上面的一个，坐下时可以都打开，下面的一粒永远都不要扣，双排扣都得扣上 衬衫，白色最好，里面的衬衫比外面的外套厂1厘米左右 领带，配西服与衬衫 鞋子，皮鞋，深颜色的棉袜，深蓝色黑色 三一定律，黑色的西服皮鞋公文包，褐色的皮带公文包皮鞋 口袋里面不要放太多的东西，腰间不挂钥匙链 女士套裙 套裙要有袜子，鞋子前不露脚趾后不露脚跟，不要黑色的皮短裙 配饰 男士看表，女士看包 数量不超过6个点 同色同质 扬长避短，长型的脸戴耳钉，不戴长链的 戒指戴在中指表示正在恋爱中，已婚的人戴在无名指，独身的小拇指，装饰性的食指 男士，眼镜，皮带，领带，西服皮带3公分 仪态礼仪：形态 站姿 走姿 坐姿 蹲姿 手势生活礼仪家庭 孝敬父母 礼待亲戚朋友 兄弟姐妹常联系 夫妻之间相互欣赏鼓励互相宽容 学校生活礼仪课堂 尊重老师 注重个人形象 教室不进食 认真听讲 发言举手 同学 尊重 有借有还 关心 平等对待 发现别人的优点 学会分享 不要斤斤计较 交友婚恋礼仪 欲知其人，先观其朋 物以类聚，人以群分 近朱者赤，近墨者黑 孟母三迁 广泛交友 坚持原则 完善自我 真诚付出 男性朋友 有男子汉气魄 有君子的风范 讲原则 女性朋友 注重形象 坦诚相待 有容人之心 异性交友 男女有别 互相尊重 光明正大 顾全“大局”，当异性朋友有了对象以后，保持距离 恋爱朋友 表白，首先了解对方是否有了对象，表白直白明确不模糊 拒绝，尊重别人的自尊心，不可以伤害一个喜欢自己的人，拒绝直白明确不模糊 相处，不要终日吵架，不轻易说分手，不要激化矛盾，不翻旧账， 分手，当面把话说清楚，好聚好散，到公共场所，不拖泥带水，避免发生冲突 出行礼仪 行路礼仪：不三五成群挡住别人，不玩手机，注意生命安全 行车礼仪：宁停三分，不抢一秒，一慢二看三通过，不往车窗外扔东西，雨天慢性注意行人 乘坐电梯：面朝电梯门，靠里面站 自动扶梯：要手抓扶梯，不然一旦骤停很危险，靠右边站 乘车礼仪：注意安全 公共场所礼仪","categories":[{"name":"大学MOOC","slug":"大学MOOC","permalink":"https://shulu520.com/categories/大学MOOC/"}],"tags":[{"name":"礼仪","slug":"礼仪","permalink":"https://shulu520.com/tags/礼仪/"}]},{"title":"sp入职培训","slug":"sp入职培训","date":"2020-07-24T15:26:42.000Z","updated":"2020-08-16T10:31:37.918Z","comments":true,"path":"sp入职培训/sp入职培训/","link":"","permalink":"https://shulu520.com/sp入职培训/sp入职培训/","excerpt":"&emsp;&emsp;7月20日正式入职以来至今，为期一周的职前培训，学习了很多的东西，经历了好多事情，生活过的相当充实，丰富多彩，值得回味。","text":"&emsp;&emsp;7月20日正式入职以来至今，为期一周的职前培训，学习了很多的东西，经历了好多事情，生活过的相当充实，丰富多彩，值得回味。 20日，了解工作，认识同事，熟悉环境，转换角色，重新认识自我 21日，进行双选会，面试不同的部门，期待心仪的工作岗位 22日，来到小南湖风景区，安全培训知识学习，加强团队建设，体验农家生活 23日，文化，素养，后勤，认识，6S，等学习 24日，职业安全培训，对生活中的安全问题有了大致的了解，考试，新人才艺表演 感受最深的就是“安全”二字，不但要时刻想着安全，而且还得不断践行在生活中的细节里 有事您Q我👇","categories":[{"name":"sp入职培训","slug":"sp入职培训","permalink":"https://shulu520.com/categories/sp入职培训/"}],"tags":[{"name":"sp","slug":"sp","permalink":"https://shulu520.com/tags/sp/"}]},{"title":"电脑问题处理","slug":"电脑问题处理","date":"2020-06-19T05:20:14.000Z","updated":"2021-03-11T02:22:07.753Z","comments":true,"path":"电脑/电脑问题处理/","link":"","permalink":"https://shulu520.com/电脑/电脑问题处理/","excerpt":"&emsp;&emsp;git fuck 文章写完之后直接上传，这是已经配置好的简化命令。","text":"&emsp;&emsp;git fuck 文章写完之后直接上传，这是已经配置好的简化命令。 软件安装注册时电脑Windows Defender消息显示有病毒，无法进行安装注册打开设置，进入Windows Defender，点击病毒和威胁防护，点击‘病毒和威胁防护’设置，将实时保护关闭。待软件安装完成之后，再将实时保护关闭即可。 博客文章发表出现的问题注意在 “description：” 这里的冒号之后有一个空格，少了这个空格会导致这篇文章无法发表。 Excel 无法打开文件“新建 Microsoft Excel 工作表.xlsx”，因为文件格式或文件扩展名无效 解决方法如下：按Win+R输入regedit，打开注册表1https://blog.csdn.net/learllp/article/details/79723078?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;dist_request_id=229aed61-e516-4d52-bab0-8fb76592087b&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control vscode 更新后自定义背景消失解决方法12本地文件目前的解决方法为：将图片、或图片目录放到vscode扩展目录下，例如windows：C:\\Users\\Administrator.vscode\\extensions\\。然后重新配置下图片目录https://blog.csdn.net/weixin_44470813/article/details/105693969 有事您Q我👇","categories":[{"name":"电脑","slug":"电脑","permalink":"https://shulu520.com/categories/电脑/"}],"tags":[{"name":"computer","slug":"computer","permalink":"https://shulu520.com/tags/computer/"}]},{"title":"壁纸","slug":"壁纸","date":"2020-06-16T08:55:54.000Z","updated":"2020-07-13T13:27:48.719Z","comments":true,"path":"壁纸/壁纸/","link":"","permalink":"https://shulu520.com/壁纸/壁纸/","excerpt":"&emsp;&emsp;嘿嘿嘿","text":"&emsp;&emsp;嘿嘿嘿 必应搜索页面进入必应首页cn.bing.com，点击图片右键查看网页源代码，在第三行可以看到一行js代码，中间有蓝色部分的图片链接，点击进入，浏览器会在新页面打开这张图片，右键图片另存为某地即可，如果觉得好看的话，可以设置为桌面壁纸 有事您Q我👇","categories":[{"name":"壁纸","slug":"壁纸","permalink":"https://shulu520.com/categories/壁纸/"}],"tags":[{"name":"壁纸","slug":"壁纸","permalink":"https://shulu520.com/tags/壁纸/"}]},{"title":"2020开篇","slug":"2020开篇","date":"2020-05-30T16:10:27.000Z","updated":"2020-07-13T10:19:03.967Z","comments":true,"path":"uncategorized/2020开篇/","link":"","permalink":"https://shulu520.com/uncategorized/2020开篇/","excerpt":"&emsp;&emsp;代码之路停下久矣，今晚无聊之时，正好试试手，看看那些花里胡哨的操作还是否记的。","text":"&emsp;&emsp;代码之路停下久矣，今晚无聊之时，正好试试手，看看那些花里胡哨的操作还是否记的。 &emsp;&emsp;哈哈哈哈哈，还好没忘记，不错不错，阔以阔以，往后继续加油哦。 有事您Q我👇","categories":[],"tags":[{"name":"2020","slug":"2020","permalink":"https://shulu520.com/tags/2020/"}]},{"title":"vue常见组件之menu","slug":"vue常见组件之menu","date":"2019-10-05T06:16:47.000Z","updated":"2019-10-05T06:20:38.758Z","comments":true,"path":"vue/vue常见组件之menu/","link":"","permalink":"https://shulu520.com/vue/vue常见组件之menu/","excerpt":"&emsp;&emsp;常见的首页竖条大菜单","text":"&emsp;&emsp;常见的首页竖条大菜单 pc端常见的竖条大菜单 vue中以组件的形式来学习菜单 这里以自己写的menu.vue组件为例 左边的菜单项与右边的细节内容展示项为简单并列的dom结构即可，而非多么复杂的结构 而在数据结构方面可以为嵌套的结构 右边只是一块空的展示区，展示左边的某一块内容细节，左边通过鼠标事件改变数据，从而改变右边展示区的内容。 因为左右两边为并列的dom结构而非父子结构，所以左边的鼠标事件(mouseover等)与右边无法衔接(就是鼠标从左边滑到右边后，右边会消失而不是继续展示，这点类似于鼠标的hover事件，通过鼠标hover维持状态的前提是，鼠标在当前元素以及它的子元素之上停留着)，所以我们通过在左右两边都监听鼠标事件来判断情况。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;template&gt; &lt;div class=\"m-menu\"&gt; &lt;dl class=\"nav\" @mouseleave=\"navLeave\"&gt; &lt;dt&gt;全部分类&lt;/dt&gt; &lt;dd v-for=\"(item, index) in menu\" :key=\"index\" @mouseenter=\"navEnter\" &gt; &lt;i :class=\"item.type\" /&gt;&#123;&#123; item.name &#125;&#125;&lt;span class=\"arrow\" /&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;div v-if=\"kind\" class=\"detail\" @mouseenter=\"detEnter\" @mouseleave=\"detLeave\" &gt; &lt;template v-for=\"(item, index) in curDetail.children\"&gt; &lt;h4 :key=\"index\"&gt; &#123;&#123; item.title &#125;&#125; &lt;/h4&gt; &lt;span v-for=\"(val, idx) in item.child\" :key=\"idx\" &gt; &#123;&#123; val &#125;&#125; &lt;/span&gt; &lt;/template&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; kind: '', menu: [ &#123; type: 'food', name: '美食', children: [ &#123; title: '热门美食', child: ['火锅', '烤串', '啤酒', ' 炸鸡', '小龙虾'] &#125; ] &#125;, &#123; type: 'takeout', name: '外面', children: [ &#123; title: '热门外卖', child: ['黄焖鸡', '炒菜', '花生', '榨菜', '水饺'] &#125; ] &#125; ] &#125; &#125;, computed: &#123; curDetail () &#123; return this.menu.filter(item =&gt; item.type === this.kind)[0] &#125; &#125;, methods: &#123; navEnter (e) &#123; this.kind = e.target.querySelector('i').className &#125;, navLeave () &#123; this.timer = setTimeout(() =&gt; &#123; this.kind = '' &#125;, 150) &#125;, detEnter () &#123; clearTimeout(this.timer) &#125;, detLeave () &#123; this.kind = '' &#125; &#125;&#125;&lt;/script&gt; 有事您Q我👇","categories":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/categories/vue/"}],"tags":[{"name":"component","slug":"component","permalink":"https://shulu520.com/tags/component/"}]},{"title":"vue常见组件之search","slug":"vue常见组件之search","date":"2019-10-05T06:08:47.000Z","updated":"2019-10-05T06:17:36.737Z","comments":true,"path":"vue/vue常见组件之search/","link":"","permalink":"https://shulu520.com/vue/vue常见组件之search/","excerpt":"&emsp;&emsp;vue常见组件之search，即大的电商等网站的大搜索框","text":"&emsp;&emsp;vue常见组件之search，即大的电商等网站的大搜索框 pc端常见的搜索框组件 这里结合element ui来学习 以下是我写的search.vue组件 当输入框获得焦点而未输入内容时，展示热门搜索 当输入框获得焦点且输入内容时，展示相关的内容(请求数据并展示) 以上两者dom结构为并列结构即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;template&gt; &lt;div class=\"search-panel\"&gt; &lt;el-row class=\"m-header-searchbar\"&gt; &lt;el-col :span=\"6\" class=\"left\"&gt; &lt;img src=\"//s0.meituan.net/bs/fe-web-meituan/fa5f0f0/img/logo.png\" alt=\"美团\"&gt; &lt;/el-col&gt; &lt;el-col :span=\"12\" class=\"center\"&gt; &lt;div class=\"wrapper\"&gt; &lt;el-input v-model=\"search\" placeholder=\"搜索商家或地点\" @focus=\"foucs\" @blur=\"blur\" /&gt; &lt;button class=\"el-button el-button--primary\"&gt; &lt;i class=\"el-icon-search\"&gt;&lt;/i&gt; &lt;/button&gt; &lt;dl class=\"hotPlace\" v-if=\"isHotList\"&gt; &lt;dt&gt;热门搜索&lt;/dt&gt; &lt;dd&gt;火锅&lt;/dd&gt; &lt;dd&gt;火锅&lt;/dd&gt; &lt;dd&gt;火锅&lt;/dd&gt; &lt;/dl&gt; &lt;dl class=\"searchList\" v-if=\"isSearchList\"&gt; &lt;dd&gt;小龙虾&lt;/dd&gt; &lt;dd&gt;小龙虾&lt;/dd&gt; &lt;dd&gt;小龙虾&lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;p class=\"suggset\"&gt; &lt;a href=\"\"&gt;故宫&lt;/a&gt; &lt;a href=\"\"&gt;故宫&lt;/a&gt; &lt;a href=\"\"&gt;故宫&lt;/a&gt; &lt;/p&gt; &lt;ul class=\"nav\"&gt; &lt;li&gt; &lt;nuxt-link to=\"/\" class=\"takeout\"&gt;美团外卖&lt;/nuxt-link&gt; &lt;/li&gt; &lt;li&gt; &lt;nuxt-link to=\"/\" class=\"movie\"&gt;猫眼电影&lt;/nuxt-link&gt; &lt;/li&gt; &lt;li&gt; &lt;nuxt-link to=\"/\" class=\"hotel\"&gt;美团酒店&lt;/nuxt-link&gt; &lt;/li&gt; &lt;li&gt; &lt;nuxt-link to=\"/\" class=\"apartment\"&gt;民宿／公寓&lt;/nuxt-link&gt; &lt;/li&gt; &lt;li&gt; &lt;nuxt-link to=\"/\" class=\"business\"&gt;商家入驻&lt;/nuxt-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/el-col&gt; &lt;el-col :span=\"6\" class=\"right\"&gt; &lt;ul class=\"security\"&gt; &lt;li&gt;&lt;i class=\"refund\"&gt;&lt;/i&gt;&lt;p class=\"txt\"&gt;随时退&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;i class=\"single\"&gt;&lt;/i&gt;&lt;p class=\"txt\"&gt;不满意免单&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;i class=\"overdue\"&gt;&lt;/i&gt;&lt;p class=\"txt\"&gt;过期退&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; search: '', isFoucs: false &#125; &#125;, computed: &#123; isSearchList () &#123; return this.isFoucs &amp;&amp; this.search &#125;, isHotList () &#123; return this.isFoucs &amp;&amp; !this.search &#125; &#125;, methods: &#123; foucs () &#123; this.isFoucs = true &#125;, blur () &#123; this.isFoucs = false &#125; &#125;&#125;&lt;/script&gt; 有事您Q我👇","categories":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/categories/vue/"}],"tags":[{"name":"component","slug":"component","permalink":"https://shulu520.com/tags/component/"}]},{"title":"vue技术栈-render和jsx","slug":"vue技术栈-render和jsx","date":"2019-09-24T05:57:16.000Z","updated":"2019-09-24T05:59:24.974Z","comments":true,"path":"vue/vue技术栈-render和jsx/","link":"","permalink":"https://shulu520.com/vue/vue技术栈-render和jsx/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 渲染函数和JSX快速掌握 render-function render函数 h函数 有三个参数：第一个参数为必选参数(要渲染的组件或一个标签的字符串)，后两个为可选参数, 第二个参数为一个配置对象 第三个参数为字符串或数组 即元素要显示的文本内容或子节点 在vue中就是通过render函数将组件挂载到页面上的 渲染根组件APP 1render: h =&gt; h(App) 渲染一个元素div 12345678910render: h =&gt; &#123; return h('div', &#123; attrs: &#123; // 写原生的属性attrs对象 id: 'box' &#125;, style: &#123; // 写原生的样式style对象 color: 'red' &#125; &#125;, 'love')&#125; 渲染一个自己封装好的组件 CountTo 12345678910111213141516171819202122232425262728293031render: h =&gt; &#123; return h(CountTo, &#123; // 向组件中最外层元素绑定一个类名 // 'class': 'love sex', // 可以是字符串 // 'class': ['count-to', true ? 'wrapper' : 'box'], // 可以是数组，里面可以用逻辑表达式绑定类名 'class': &#123; 'number': true // 可以是对象 也可以用逻辑表达式 决定属性的有无 &#125;, attrs: &#123;&#125;, style: &#123;&#125;, props: &#123; // 向组件中传值props对象 endValue: 99999999 &#125;, domProps: &#123;&#125;, on: &#123; // 监听组件中抛出的事件 '组件中抛出的事件名' : val =&gt; &#123; // do something &#125; &#125;, nativeOn: &#123; // 绑定监听原生的点击事件 'click': () =&gt; &#123; console.log('click :', '原生的点击事件'); &#125; &#125;, directives:[], // 自定义指令 scopedSlots: &#123;&#125;, // 作用域插槽 slot: '', // 插槽 key: '', // key ref: '' // ref &#125;)&#125; 子节点必须放到一个数组中 12345678910111213141516171819/* 子节点的添加 */render: h =&gt; h('div', [ h('span', '111'), h('p', '222'),])// 可以这样render: h =&gt; h('div', [ h('ul', &#123; on: &#123; 'click': handleClick &#125;, &#125;,[ h('li', &#123; on: &#123; 'click': handleClick &#125; &#125;) ])]) 在render函数中模仿v-for循环产生元素 12345678910111213141516let arrName = [&#123;name: 'shulu'&#125;, &#123;name: 'yachan'&#125;, &#123;name: 'liuqiuyun'&#125;]// 遍历调用h 函数const getArrName = (h) =&gt; arrName.map((item, index) =&gt; &#123; return h('li', &#123; on: &#123; 'click': handleClick &#125;, key: index &#125;, item.name) &#125;)render: h =&gt; h('div',[ h('ul', getArrName(h))]) 函数式组件和JSX views/render-page.vue中引入List列表组件 123456789101112131415161718192021222324252627282930313233343536// views/render-page.vue 中引入List列表组件&lt;template&gt; &lt;div&gt; &lt;list :items=\"items\" :render=\"renderFunc\"&gt;&lt;/list&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import List from '_c/list' // list文件夹下有 index.js 它引入并导出了List组件export default &#123; name: 'RenderPage', components: &#123; List, &#125;, data () &#123; return &#123; items: [ &#123;name: 'yachan'&#125;, &#123;name: 'shulu'&#125;, &#123;name: 'qiuyun'&#125; ] &#125; &#125;, methods: &#123; handleClick () &#123; console.log('click') &#125;, // 父组件使用时自己传入的标签例如i renderFunc (h, name) &#123; // JSX语法 return ( // 绑定事件 on- 前缀 nativeOn-click &lt;i on-click=&#123;this.handleClick&#125; style=&#123;&#123;color: 'pink'&#125;&#125;&gt;&#123;name&#125;&lt;/i&gt; ) &#125; &#125;&#125;&lt;/script&gt; views/List.vue 12345678910111213141516171819202122232425262728293031// views/List.vue&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=\"(item, index) in items\" :key=\"index\"&gt; &lt;span v-if=\"!render\"&gt;&#123;&#123; item.name &#125;&#125;&lt;/span&gt; &lt;render-dom v-else :render-func=\"render\" :name=\"item.name\"&gt;&lt;/render-dom&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import RenderDom from '_c/render-dom' // 引入函数式组件 shitexport default &#123; name: 'List', components: &#123; // 注册函数式组件 RenderDom &#125;, props: &#123; items: &#123; type: Array, default: () =&gt; [] &#125;, render: &#123; type: Function, default: () =&gt; &#123;&#125; &#125; &#125;&#125;&lt;/script&gt; 函数式组件 1234567891011// 一个普通的对象export default &#123; functional: true, props: &#123; // 接收的值 name: String, renderFunc: Function &#125;, render: (h, ctx) =&gt; &#123; // ctx 上下文环境 return ctx.props.renderFunc(h, ctx.props.name) &#125;&#125; 作用域插槽 属性slot-scope 1&lt;count-to slot-scope=\"count\" :end-value=\"count.number\"&gt;&lt;/count-to&gt; 有事您Q我👇","categories":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/categories/vue/"}],"tags":[{"name":"render","slug":"render","permalink":"https://shulu520.com/tags/render/"},{"name":"jsx","slug":"jsx","permalink":"https://shulu520.com/tags/jsx/"}]},{"title":"vue技术栈-第三方js库的使用","slug":"vue技术栈-第三方js库的使用","date":"2019-09-24T04:20:21.000Z","updated":"2019-09-24T04:23:01.169Z","comments":true,"path":"vue/vue技术栈-第三方js库的使用/","link":"","permalink":"https://shulu520.com/vue/vue技术栈-第三方js库的使用/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 第三方js库的使用 这里以数字渐变的一个第三方js库为依赖，学习简单的组件的封装 CountUp.js 组件中使用id值 这个countup.js库的第一个参数为一个元素或组件的id值 我们知道id值在页面中是唯一的，所以我们的分装的组件要想复用就得使用不同的id this._uid 每一个vue组件都有唯一的标识 _uid, 我们通过计算属性的getter方法就可以拿到他 组件中获取dom 通过id值 通过ref属性 ref属性在元素上则拿到的是这个元素 ref属性在一个组件上则拿到的是这个组件 组件封装基础 新建components/count-to文件夹，存放我们创建的数字渐变的的组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// components/count-to/count-to.vue &lt;template&gt; &lt;div&gt; &lt;span :id=\"eleId\" ref=\"number\"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; CountUp &#125; from 'countup.js' // 引入countup.js库export default &#123; name: 'CountTo', data () &#123; return &#123; counter: &#123;&#125; &#125; &#125;, props: &#123; /* 最终值 */ endValue: &#123; type: Number, required: true &#125;, opations: &#123; // startVal?: number; // number to start at (0) startVal: 0, // decimalPlaces?: number; // number of decimal places (0) decimalPlaces: 0, // duration?: number; // animation duration in seconds (2) duration: 2, // useGrouping?: boolean; // example: 1,000 vs 1000 (true) useGrouping: true, // useEasing?: boolean; // ease animation (true) useEasing: true, // smartEasingThreshold?: number; // smooth easing for large numbers above this if useEasing (999) smartEasingThreshold: 999, // smartEasingAmount?: number; // amount to be eased for numbers above threshold (333) smartEasingAmount: 333, // separator?: string; // grouping separator (',') separator: ',', // decimal?: string; // decimal ('.') decimal: '.', // easingFn: easing function for animation (easeOutExpo) // easingFn?: (t: number, b: number, c: number, d: number) =&gt; number; // formattingFn?: (n: number) =&gt; string; // this function formats result // prefix?: string; // text prepended to result prefix: '', // suffix?: string; // text appended to result suffix: '' // numerals?: string[]; // numeral glyph substitution &#125; &#125;, mounted () &#123; this.$nextTick(() =&gt; &#123; // dom渲染完成之后调用次回调函数 this.counter = new CountUp(this.eleId, this.endValue , this.opations) &#125;) setTimeout(() =&gt; &#123; // 这个start一定要放在setTimeout等有延迟的方法之中调用 this.counter.start() &#125;, 0) &#125;, computed: &#123; /* 第一个参数 元素的id值 */ eleId () &#123; return `count_up_$&#123;this._uid&#125;` // 每一个组件都有唯一的标识 _uid &#125; &#125;, methods: &#123; getNumber () &#123; // 组件中的dom获取操作 const text = this.$refs.number.innerText let num = text.replace(/[\\u4e00-\\u9fa5]/g, '').substring(1) return num &#125; &#125;&#125;&lt;/script&gt; components/count-to/index.js 12345// components/count-to/index.jsimport CountTo from './count-to'export default CountTo// 这样们使用这个组件的时候只需要引入components/count-to即可 创建完了组件，下面我们来使用一下 只需要把以下的组件在页面中展示一下 1234567891011121314151617181920212223242526272829303132333435// 新建一个组件 &lt;template&gt; &lt;div&gt; &lt;count-to class=\"numto\" ref=\"countTo\" :end-value=\"10000.34\" :opations=\"&#123; duration: 10, decimalPlaces: 2, prefix: '金额：', suffix: '元' &#125;\"&gt; &lt;/count-to&gt; &lt;button @click=\"getNum\"&gt;getNum&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import CountTo from '_c/count-to' export default &#123; name: 'count_to', components: &#123; CountTo &#125;, methods: &#123; getNum () &#123; console.log(this.$refs.countTo.getNumber()) // 调用子组件的方法 &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"less\"&gt; .numto&#123; color:red; &#125;&lt;/style&gt; 有事您Q我👇","categories":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/tags/vue/"}]},{"title":"vue技术栈-状态管理vuex进阶2","slug":"vue技术栈-状态管理vuex进阶2","date":"2019-09-24T04:09:09.000Z","updated":"2019-09-24T04:16:06.437Z","comments":true,"path":"vue技术栈-状态管理vuex进阶2/vue技术栈-状态管理vuex进阶2/","link":"","permalink":"https://shulu520.com/vue技术栈-状态管理vuex进阶2/vue技术栈-状态管理vuex进阶2/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; Vuex插件 实现一个简单的本地化存储插件 即浏览器刷新之后状态不会变 123456789101112// store/plugin/saveInlocal.jsexport default (store) =&gt; &#123; // 当 store 初始化后调用 console.log('store初始化了') if (localStorage.state) store.replaceState(JSON.parse(localStorage.state)) store.subscribe((mutation, state) =&gt; &#123; // 每次 mutation 之后调用 // mutation 的格式为 &#123; type, payload &#125; console.log('提交了mutation') localStorage.state = JSON.stringify(state) &#125;)&#125; 1234567// store/index.jsimport saveInLocal from '../store/plugin/saveInLocal'export default new Vuex.Store(&#123; // ... plugins: [ saveInLocal ] // 绑定插件&#125;) Vuex严格模式 不要在发布环境下启用严格模式！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。 在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。 类似于插件，我们可以让构建工具来处理这种情况： 1234const store = new Vuex.Store(&#123; // ... strict: process.env.NODE_ENV !== 'production' // 开发环境开启严格模式调试&#125;) Vuex双向绑定state的某一状态 在计算属性的setter中调用mutation来改变state的状态 123&lt;!-- 双向绑定 --&gt;&lt;input v-model=\"myNameFromState\"/&gt; &lt;p&gt;&#123;&#123; myNameFromState &#125;&#125;&lt;/p&gt; 123456789101112// 任意组件computed: &#123; myNameFromState: &#123; get () &#123; return this.$store.state.myName &#125;, set (value) &#123; // 在计算属性的setter中调用mutation 来改变state this.CHANGE_STATE_MYNAME(value) &#125; &#125;&#125; 123456// store/state.jsconst state = &#123; myName: 'yachan',&#125;export default state 12345678// store/mutations.jsconst mutations = &#123; CHANGE_STATE_MYNAME (state, val) &#123; state.myName = val &#125;&#125;export default mutations 有事您Q我👇","categories":[{"name":"vue技术栈-状态管理vuex进阶2","slug":"vue技术栈-状态管理vuex进阶2","permalink":"https://shulu520.com/categories/vue技术栈-状态管理vuex进阶2/"}],"tags":[{"name":"vuex","slug":"vuex","permalink":"https://shulu520.com/tags/vuex/"}]},{"title":"vue技术栈-状态管理vuex进阶1","slug":"vue技术栈-状态管理vuex进阶1","date":"2019-09-24T04:08:47.000Z","updated":"2019-09-24T04:11:29.316Z","comments":true,"path":"vue/vue技术栈-状态管理vuex进阶1/","link":"","permalink":"https://shulu520.com/vue/vue技术栈-状态管理vuex进阶1/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; vuex之module模块中参数详解 以下以store/module/user.js模块为例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// store/module/user.jsconst state = &#123; sexName: 'yachan mei mei', phoneNumber: 1123&#125;const getters = &#123; addlover: (state) =&gt; &#123; return state.sexName + ' I love you' &#125;, getCode: (state, getters, rootState, rootGetters) =&gt; &#123; // 前两个参数为当前模块的局部的对象，后两个参数为全局的对象 // 通过全局的对象的点操作就可以得到下面每一层级的对象 console.log('state :', state) // 局部 console.log('getters :', getters) // 局部 console.log('getters.addlover :', getters.addlover) // 得到当前模块的getters的某一属性 console.log('rootState :', rootState) // 全局state console.log('rootGetters :', rootGetters) // 全局getters // console.log('rootGetters.nameOnlyLastLetter :', rootGetters.nameOnlyLastLetter) // 得到rootGetters的某一个属性 &#125;&#125;const mutations = &#123; CHANGE_PHONE_NUMBER (state, params) &#123; state.phoneNumber += params &#125;&#125;const actions = &#123; // 查看actions的各个参数 // commit最常用 用于提交mutation someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123; console.log('dispatch :', dispatch) console.log('commit :', commit) console.log('getters :', getters) console.log('rootGetters :', rootGetters) &#125;, // 组合 action 看看dispatch的用处 actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('someMutation') resolve() &#125;, 1000) &#125;) &#125;, // 参数dispatch可以在另外一个 action 中分发其他的action actionB (&#123; dispatch, commit &#125;) &#123; return dispatch('actionA').then(() =&gt; &#123; commit('someOtherMutation') &#125;).catch((err) =&gt; &#123; console.log('err :', err) &#125;) &#125;, // 利用 async / await，我们可以如下组合 action // 假设 getData() 和 getOtherData() 返回的是 Promise async actionC (&#123; commit &#125;) &#123; commit('gotData', await getData()) &#125;, async actionD (&#123; dispatch, commit &#125;) &#123; await dispatch('actionC') // 等待 actionC 完成 commit('gotOtherData', await getOtherData()) &#125;&#125;export default &#123; namespaced: true, // 使用命名空间 state, getters, actions, mutations, modules: &#123; // 还可以嵌套模块 &#125;&#125; 带命名空间的绑定函数 1写起来可能比较繁琐 123456789101112computed: &#123; ...mapState(&#123; a: state =&gt; state.some.nested.module.a, b: state =&gt; state.some.nested.module.b &#125;)&#125;,methods: &#123; ...mapActions([ 'some/nested/module/foo', // -&gt; this['some/nested/module/foo']() 'some/nested/module/bar' // -&gt; this['some/nested/module/bar']() ])&#125; 2简化写法 将模块的空间名称字符串作为第一个参数传递给上述函数 123456789101112computed: &#123; ...mapState('some/nested/module', &#123; a: state =&gt; state.a, b: state =&gt; state.b &#125;)&#125;,methods: &#123; ...mapActions('some/nested/module', [ 'foo', // -&gt; this.foo() 'bar' // -&gt; this.bar() ])&#125; 3创建基于某个命名空间的辅助函数 1234567891011121314151617181920mport &#123; createNamespacedHelpers &#125; from 'vuex'const &#123; mapState, mapActions &#125; = createNamespacedHelpers('some/nested/module')export default &#123; computed: &#123; // 在 `some/nested/module` 中查找 ...mapState(&#123; a: state =&gt; state.a, b: state =&gt; state.b &#125;) &#125;, methods: &#123; // 在 `some/nested/module` 中查找 ...mapActions([ 'foo', 'bar' ]) &#125;&#125; 动态模块注册 在 store 创建之后，你可以使用 store.registerModule 方法注册模块 12&lt;button @click=\"registerModule\"&gt;动态注册模块&lt;/button&gt;&lt;p&gt;&#123;&#123; myMoney &#125;&#125;&lt;/p&gt; 123456789101112131415161718192021// 任意组件import &#123; mapState &#125; from 'vuex'computed: &#123; ...mapState(&#123; myMoney: state =&gt; state.myModule ? state.myModule.myMoney : [] // myModule模块创建完成后获取其状态 &#125;)&#125;,methods: &#123; registerModule () &#123; this.$store.registerModule('myModule', &#123; // 动态创建模块 state: &#123; myMoney: 999999999999 &#125; &#125;) &#125;&#125;// 注册嵌套模块 `nested/myModule`store.registerModule(['nested', 'myModule'], &#123; // ...&#125;) 有事您Q我👇","categories":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/categories/vue/"}],"tags":[{"name":"vuex","slug":"vuex","permalink":"https://shulu520.com/tags/vuex/"}]},{"title":"vue技术栈-状态管理vuex基础","slug":"vue技术栈-状态管理vuex基础","date":"2019-09-24T04:00:36.000Z","updated":"2019-09-24T04:07:37.735Z","comments":true,"path":"vue/vue技术栈-状态管理vuex基础/","link":"","permalink":"https://shulu520.com/vue/vue技术栈-状态管理vuex基础/","excerpt":"&emsp;&emsp;优美的代码要有好的状态管理，美好的人生也是如此。","text":"&emsp;&emsp;优美的代码要有好的状态管理，美好的人生也是如此。 Vuex之state mapGetters,mapState是一些属性之类的 要放到computed里面 全局state的使用123456// 全局的state.jsconst state = &#123; myName: 'yachan' // 记录一个值为myName&#125;export default state 123456789// 任意一个组件&lt;p&gt;Vuex-state.maName:&#123;&#123; myName &#125;&#125;&lt;/p&gt; // 展示一下// 获取myNamecomputed: &#123; myName () &#123; return this.$store.state.myName &#125;&#125; modules模块之内的state的使用12345678910111213// module/user.jsconst state = &#123; sexName: '女神'&#125;const mutations = &#123; &#125;const actions = &#123; &#125;export default &#123; state, mutations, actions&#125; 123456789101112131415// 任意组件&lt;p&gt;Vuex-state.sexName:&#123;&#123; sexName &#125;&#125;&lt;/p&gt; // 展示一下import &#123; mapState &#125; from 'vuex' //引入mapStatecomputed: &#123; // sexName () &#123; // 方式一 // return this.$store.state.user.sexName // &#125; ...mapState(&#123; // 方式二 myName: state =&gt; state.myName, sexName: state =&gt; state.user.sexName &#125;)&#125; 命名空间的使用123456789101112131415// 命名空间的使用// module/user.jsconst state = &#123; sexName: '女神'&#125;const mutations = &#123; &#125;const actions = &#123; &#125;export default &#123; namespaced: true, // 命名空间的使用 state, mutations, actions&#125; 123456789101112131415161718// 任意组件// 方式一// import &#123; createNamespacedHelpers &#125; from 'vuex'// const &#123; mapState &#125; = createNamespacedHelpers('user') // 使用命名空间// computed: &#123;// ...mapState(&#123;// sexName: state =&gt; state.sexName// &#125;)// &#125;// 方式二import &#123; mapState &#125; from 'vuex' computed: &#123; ...mapState('user', &#123; // 这里的第一个参数为模块名 sexName: state =&gt; state.sexName &#125;)&#125; Vuex之getters 有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数： 123456// 例如对列表进行过滤并计数computed: &#123; doneTodosCount () &#123; return this.$store.state.todos.filter(todo =&gt; todo.done).length &#125;&#125; 如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。 Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 Getter 接受 state 作为其第一个参数： 12345678910111213141516// store/getters.jsconst getters = &#123; // 定义一个获取state中的myName的最后一个字母的属性 nameOnlyLastLetter: (state) =&gt; &#123; // 这里是全局可以使用的方法 return state.myName.substr(-1, 1) &#125;&#125;export default getters// 在store/index.js中需要引入，并注入Vuex 这里不再演示// 组件中使用&lt;p&gt;nameOnlyLastLetter: &#123;&#123; nameOnlyLastLetter &#125;&#125;&lt;/p&gt; // 展示...mapGetters(['nameOnlyLastLetter']) // 获取 Vuex之mutations mutation 必须同步执行。 mapActions, mapMutations里面是一些方法 要放到methods里面 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。 以下为一个通过mutations改变state中的myName的小例子: 12345678// store/mutations.jsconst mutations = &#123; CHANGE_STATE_MYNAME (state, val) &#123; state.myName = val &#125;&#125;export default mutations 12345678// 任意的组件中// 展示省略methods: &#123; ...mapMutations(['CHANGE_STATE_MYNAME']), // 拿到CHANGE_STATE_MYNAME这个方法 changeName () &#123; this.CHANGE_STATE_MYNAME('liu yachan') // 调用这个方法并传值去直接改变state中的值 &#125;&#125; 动态往state中添加一个状态 123456789101112import vue from 'vue' // 引入vueconst mutations = &#123; CHANGE_STATE_MYNAME (state, val) &#123; state.myName = val &#125;, ADD_AGE (state) &#123; vue.set(state, 'age', '18') // 使用vue.set(对象，'属性', '属性值') &#125;&#125;export default mutations Vuex之Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 1234567891011// api/app.js// 定义一个异步获取数据的方法export const getHobby = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const err = null setTimeout(() =&gt; &#123; if (!err) resolve(&#123;code: 200, info: &#123;hobby: 'sleep'&#125;&#125;) else reject(err) &#125;) &#125;)&#125; 123456789101112131415161718192021222324// store/actions.jsimport &#123; getHobby &#125; from '@/api/app'const actions = &#123; // updateHobby (&#123; commit &#125;) &#123; // getHobby().then(res =&gt; &#123; // const &#123; info: &#123; hobby &#125; &#125; = res // 解构赋值 // commit('UPDATE_HOBBY', hobby) // 在这里提交mutation 并且传值过去 // &#125;).catch((err) =&gt; &#123; // console.log('err :', err) // &#125;) // &#125; async updateHobby (&#123; commit &#125;) &#123; // ES7的async也行 更好 try &#123; const &#123; info: &#123; hobby &#125; &#125; = await getHobby() commit('UPDATE_HOBBY', hobby) &#125; catch (error) &#123; // 一定要捕获错误 console.log('error :', error) &#125; &#125;&#125;export default actions 12345678910// store/actions.jsimport vue from 'vue'const mutations = &#123; UPDATE_HOBBY (state, val) &#123; state.hobby = val // 在这里直接修改state的属性hobby &#125;&#125;export default mutations 123456789101112131415// 任意组件&lt;p class=\"font-color\"&gt;hobby: &#123;&#123;hobby&#125;&#125;&lt;/p&gt; // 展示&lt;button @click=\"changeHobby\"&gt;changeHobby&lt;/button&gt;imoprt &#123; mapState &#125; from 'vuex'computed: &#123; ...mapState(['hobby']) // 获取hobby&#125;,methods: &#123; changeHobby () &#123; this.updateHobby() // 这里调用action里的方法 &#125;&#125; 有事您Q我👇","categories":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/categories/vue/"}],"tags":[{"name":"vuex","slug":"vuex","permalink":"https://shulu520.com/tags/vuex/"}]},{"title":"vue技术栈-状态管理Bus","slug":"vue技术栈-状态管理Bus","date":"2019-09-24T03:53:10.000Z","updated":"2019-09-24T03:58:43.504Z","comments":true,"path":"vue/vue技术栈-状态管理Bus/","link":"","permalink":"https://shulu520.com/vue/vue技术栈-状态管理Bus/","excerpt":"&emsp;&emsp;好想再见见你……","text":"&emsp;&emsp;好想再见见你…… 状态管理之bus总线 bus即一个空的vue实例 一个中央事件总线bus,可以作为一个简单的组件传递数据,用于解决跨级和兄弟组件通信问题。 在要实现通信的组件间都引入bus，分别触发和监听事件并传递值。 下面是一个兄弟组件间传值的例子： 1234// lib/bus.jsimport Vue from 'vue'export const bus = new Vue() // 创建bus 123456789101112131415161718// views/Email.vue&lt;template&gt; &lt;div&gt; this is email 组件 &lt;input type=\"button\" value=\"点点我\" @click=\"handleClick\"/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; bus &#125; from '@/lib/bus' // 引入busexport default &#123; methods: &#123; handleClick () &#123; bus.$emit('on-click', 'hello-tel') &#125; &#125;&#125;&lt;/script&gt; 1234567891011121314151617181920212223// views/Tel.vue&lt;template&gt; &lt;div&gt; this is tel 组件 &lt;p&gt;value:&#123;&#123; valueFromEmail &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; bus &#125; from '@/lib/bus' // 引入busexport default &#123; data () &#123; return &#123; valueFromEmail: '' &#125; &#125;, created () &#123; bus.$on('on-click', val =&gt; &#123; this.valueFromEmail = val &#125;) &#125;&#125;&lt;/script&gt; 有事您Q我👇","categories":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/categories/vue/"}],"tags":[{"name":"vuex","slug":"vuex","permalink":"https://shulu520.com/tags/vuex/"}]},{"title":"vue技术栈-路由进阶2","slug":"vue技术栈-路由进阶2","date":"2019-09-17T06:51:21.000Z","updated":"2019-09-17T06:52:38.440Z","comments":true,"path":"vue/vue技术栈-路由进阶2/","link":"","permalink":"https://shulu520.com/vue/vue技术栈-路由进阶2/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 完整的导航解析流程 来自官网 导航被触发。 在失活的组件里调用离开守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 路由元信息 定义路由的时候可以配置 meta 字段： 123456789// router.js&#123; path: '/about', name: 'about', component: () =&gt; import('@/views/About'), meta: &#123; // 路由元信息 title: 'about' //页面的title &#125;&#125; 1234// lib/util.jsexport const setTitle = (title) =&gt; &#123; window.document.title = title || 'admin' //默认title为admin&#125; 123456// router/index.js// 全局前置守卫router.beforeEach((to, from, next) =&gt; &#123; // 路由元信息存在时调用设置title的方法 to.meta &amp;&amp; setTitle(to.meta.title) &#125;) 过渡效果 单个路由的过渡 123&lt;transition&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; 一组路由的过渡 1234567891011121314// 例如：App.vue&lt;template&gt; &lt;div id=\"app\"&gt; &lt;div id=\"nav\"&gt; &lt;router-link :to=\"&#123; name: 'home' &#125;\"&gt;Home&lt;/router-link&gt; | &lt;router-link :to=\"&#123; name: 'about' &#125;\"&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;transition-group :name=\"transitionName\"&gt; &lt;router-view key=\"default\"/&gt; &lt;router-view key=\"email\" name=\"email\"/&gt; &lt;router-view key=\"tel\" name=\"tel\"/&gt; &lt;/transition-group&gt; &lt;/div&gt;&lt;/template&gt; 1234567891011121314151617export default &#123; data() &#123; return &#123; transitionName: '', &#125; &#125;, // watch $route 决定使用哪种过渡 watch: &#123; '$route' (to, from) &#123; if (to.name === 'home') &#123; this.transitionName = 'transitionName' &#125; else &#123; this.transitionName = '' &#125; &#125; &#125;&#125; 1234567891011121314151617181920/* 进入 */.transitionName-enter&#123; opacity: 0;&#125;.transitionName-enter-active&#123; transition: opacity 1s ease;&#125;.transitionName-enter-to&#123; opacity: 1;&#125;/* 离开 */.transitionName-leave&#123; opacity: 1;&#125;.transitionName-leave-active&#123; transition: opacity 1s ease;&#125;.transitionName-leave-to&#123; opacity: 0;&#125; 路由懒加载&emsp;&emsp;当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。&emsp;&emsp;如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。 一般用于不常用的页面 12345// 例如404页面&#123; path: '*', // 所有匹配不到的路劲都会走到这里 component: () =&gt; import('@/views/Error_404.vue')&#125; 数据获取 详情见官网 &emsp;&emsp;有时候，进入某个路由后，需要从服务器获取数据。例如，在渲染用户信息时，你需要从服务器获取用户的数据。我们可以通过两种方式来实现： &emsp;&emsp;导航完成之后获取：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示。 &emsp;&emsp;导航完成之前获取：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。 &emsp;&emsp;从技术角度讲，两种方式都不错 —— 就看你想要的用户体验是哪种。 滚动行为&emsp;&emsp;使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。 注意: 这个功能只在支持 history.pushState 的浏览器中可用。 1234567891011// router/index.jsconst router = new Router(&#123; routes, scrollBehavior (to, from, savedPosition) &#123; if (savedPosition) &#123; return savedPosition // 保持原先的滚动位置 &#125; else &#123; return &#123; x: 0, y: 0 &#125; // 想要页面滚到顶部 &#125; &#125;&#125;) 有事您Q我👇","categories":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/categories/vue/"}],"tags":[{"name":"vue-router","slug":"vue-router","permalink":"https://shulu520.com/tags/vue-router/"}]},{"title":"vue技术栈-路由进阶1","slug":"vue技术栈-路由进阶1","date":"2019-09-17T06:49:22.000Z","updated":"2019-09-17T06:50:41.871Z","comments":true,"path":"vue/vue技术栈-路由进阶1/","link":"","permalink":"https://shulu520.com/vue/vue技术栈-路由进阶1/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 路由进阶路由组件传参1 动态路由 传入时props为布尔类型 12345678910111213141516171819202122// router.js 动态路由&#123; path: '/argu/:name', props: true // 布尔形式&#125;// Argue.vue&lt;template&gt; &lt;div&gt; &#123;&#123; name &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; name: &#123; type: String, default: 'yachan' // 默认值不见效果 &#125; &#125;&#125; 路由组件传参2 普通路由 传入时props为对象形式 123456789&#123; path: '/about', props: &#123; // 对象形式 food: 'banana' &#125;&#125;// 对应About.vue的结构同Argu的一样// props接收一下 模板中展示一下 路由组件传参3 普通路由 传入时props为函数形式 123456789&#123; path: '/', props: route =&gt; (&#123; // 函数形式 food: route.query.food // 例如 http://localhost:8080/#/?food=yachan &#125;)&#125;// 对应Home.vue的结构同Argu的一样// props接收一下 模板中展示一下 H5之history模式 默认为哈希模式即路劲中有#号 H5之history模式好看没有#号 12345// router/index.jsexport default new Router(&#123; mode: 'history', // H5 history模式 routes&#125;) 12345// router.js的最后添加&#123; path: '*', // 所有匹配不到的路劲都会走到这里 component: () =&gt; import('@/views/Error_404.vue')&#125; 导航守卫 “导航”表示路由正在发生改变。 即通过跳转或取消的方式守卫导航。 例如：路由跳转前做一些验证，比如登录验证，是网站中的普遍需求。 全局前置守卫 确保要调用 next 方法，否则钩子就不会被 resolved。 123456789101112131415161718// router/index.jsconst router = new Router(&#123; routes&#125;)const HAS_LOGINED = false // 模拟 假设还没有登录router.beforeEach((to, from, next) =&gt; &#123; if (to.name !== 'login') &#123; if (HAS_LOGINED) next() else next(&#123; name: 'login' &#125;) &#125; else &#123; if (HAS_LOGINED) next(&#123; name: 'home' &#125;) else next() &#125;&#125;)export default router 全局后置钩子 然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身 一般用来改变一些跳转前后的样式 1234// 全局后置钩子router.afterEach((to, from) =&gt; &#123; // &#125;) 路由独享的守卫 你可以在路由配置上直接定义 beforeEnter 守卫 1234567891011// router.js&#123; path: '/', name: 'home', component: Home, beforeEnter: (to, from, next) =&gt; &#123; if (from.name === 'about') alert('这是从about页面来的') else alert('这不是从about页面来的') next() // 一定要调用next 钩子 &#125;&#125; 组件内的守卫 可以在路由组件内直接定义以下路由导航守卫： 注意 beforeRouteEnter 是支持给 next 传递回调的唯一守卫 对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了 beforeRouteLeave这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。 12345678910111213141516171819202122232425// 组件内部beforeRouteEnter (to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建 // 不过可以通过回调来解决 // 次回调在页面被渲染完之后才被调用 next(vm =&gt; &#123; // 通过 `vm` 访问组件实例 console.log(vm) //vm即为当前组件实例 this &#125;)&#125;,beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this`&#125;,beforeRouteLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` const leave = confirm('您确定要离开吗？当前编辑的内容还没有被保存') if (leave) next() // 用户点击了确定 则跳转页面 else next(false) // 页面不会跳转&#125; 有事您Q我👇","categories":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/categories/vue/"}],"tags":[{"name":"vue-router","slug":"vue-router","permalink":"https://shulu520.com/tags/vue-router/"}]},{"title":"vue技术栈-路由基础","slug":"vue技术栈-路由基础","date":"2019-09-17T06:45:24.000Z","updated":"2019-09-17T06:48:37.363Z","comments":true,"path":"vue/vue技术栈-路由基础/","link":"","permalink":"https://shulu520.com/vue/vue技术栈-路由基础/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 路由基础路由组件12&lt;router-link&gt;内部封装了a标签&lt;router-link/&gt; &lt;router-view/&gt; 该组件为当前路由跳转展示的区域 动态路由12345678910111213141516// router.js&#123; path: '/argu/:name', //这里注意是 /: component: () =&gt; import('@/views/Argu')&#125;// 在Argu.vue中&lt;template&gt; &lt;div&gt; &#123;&#123; $route.params.name &#125;&#125; &lt;/div&gt;&lt;/template&gt;// 在浏览器窗口http://localhost:8083/#/argu/shulu即可在页面上看到 shulu 嵌套路由1234567891011121314151617181920212223242526// router.js&#123; path: '/parent', component: () =&gt; import('@/views/Parent'), children: [ //children是一个数组 好久不写都忘记了 &#123; path: 'child', //这里直接写路劲的名字即可不要‘/’ component: () =&gt; import('@/views/Child') &#125; ]&#125;// Parent.vue&lt;template&gt; &lt;div&gt; i am parent &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;// Child.vue&lt;template&gt; &lt;div&gt; i am child &lt;/div&gt;&lt;/template&gt; 命名路由12345678910// App.vue原来的样子注意router-link&lt;template&gt; &lt;div id=\"app\"&gt; &lt;div id=\"nav\"&gt; &lt;router-link to=\"/\"&gt;Home&lt;/router-link&gt; | &lt;router-link to=\"/about\"&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; 12345678910111213141516171819// App.vue使用命名路由的样子注意router-link// 首先router.js&#123; path: '/', name: 'home', //这里添加一个name属性 component: Home&#125;// App.vue&lt;template&gt; &lt;div id=\"app\"&gt; &lt;div id=\"nav\"&gt; &lt;router-link :to=\"&#123; name: 'home' &#125;\"&gt;Home&lt;/router-link&gt; | &lt;router-link :to=\"&#123; name: 'about' &#125;\"&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; 命名视图12345678910111213141516171819202122// router.js&#123; path: '/named_view', components: &#123; default: () =&gt; import('@/views/Child'), email: () =&gt; import('@/views/Email'), tel: () =&gt; import('@/views/Tel') &#125;&#125;// App.vue&lt;template&gt; &lt;div id=\"app\"&gt; &lt;div id=\"nav\"&gt; &lt;router-link :to=\"&#123; name: 'home' &#125;\"&gt;Home&lt;/router-link&gt; | &lt;router-link :to=\"&#123; name: 'about' &#125;\"&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;router-view/&gt; //渲染默认路由 &lt;router-view name=\"email\"/&gt; //渲染指定路由 &lt;router-view name=\"tel\"/&gt; //渲染制定路由 &lt;/div&gt;&lt;/template&gt; 编程导航路由 即js操作路由 123456789101112131415161718192021222324252627// Home.vue&lt;template&gt; &lt;div class=\"home\"&gt; &lt;button @click=\"handleClick\"&gt;返回上一级&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// @ is an alias to /srcimport HelloWorld from '@/components/HelloWorld.vue'export default &#123; name: 'home', components: &#123; HelloWorld &#125;, methods: &#123; handleClick () &#123; this.$router.go(-1) //回退 // this.$router.back() 回退 // this.$router.replace() //替换 // this.$router.push() //往历史记录里面添加一条记录 &#125; &#125;&#125;&lt;/script&gt; 重定向和别名 重定向 123456789101112// router.js&#123; path: '/yachan', //重定向 redirect: '/' 方式一 // redirect: &#123; // name: 'home' 方式二 // &#125; // redirect: to =&gt; '/' 方式三&#125; 别名 123456&#123; path: '/', alias: '/home_page', //起一个别名 注意前面有 '/' name: 'home', component: Home&#125; 有事您Q我👇","categories":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/categories/vue/"}],"tags":[{"name":"vue-router","slug":"vue-router","permalink":"https://shulu520.com/tags/vue-router/"}]},{"title":"vue技术栈-配置篇","slug":"vue技术栈-配置篇","date":"2019-09-17T06:39:29.000Z","updated":"2019-09-17T06:40:40.781Z","comments":true,"path":"vue/vue技术栈-配置篇/","link":"","permalink":"https://shulu520.com/vue/vue技术栈-配置篇/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 配置项目项目最外层文件的配置 在项目目录下添加 vue.config.js文件并配置为： 1234567891011121314151617const path = require(\"path\")const resolve = dir =&gt; path.join(__dirname, dir)const BASE_URL = process.env.NODE_ENV === \"production\" ? \"/iview-admin\" : '/'module.exports = &#123; publicPath: BASE_URL, chainWebpack: config =&gt; &#123; config.resolve.alias .set('@', resolve('src'))//别名，以后使用时@就代替src目录路劲 .set(\"_c\", resolve(\"src/components\")) &#125;, productionSourceMap: false, //打不生成.map文件 速度块一些' devServer: &#123; proxy: 'http://localhost:4000' //跨域配置， &#125;,&#125; src目录的文件配置 添加api文件夹 添加config文件夹里面为index.js 添加directive文件夹里面为index.js 添加lib文件夹里面为tool.js(纯工具文件), util.js 添加mock文件夹里面为index.js配置如下： 12345// 首先 npm install mockjs -Dimport Mock from 'mockjs'// export default Mock 添加router文件夹里面为index.js, router.js配置为： 12345678910// index.jsimport Vue from 'vue'import Router from 'vue-router'import routes from './router'Vue.use(Router)export default new Router(&#123; routes&#125;) 123456789101112131415// router.jsimport Home from '@/views/Home'export default [ &#123; path: '/', name: 'home', component: Home &#125;, &#123; path: '/about', name: 'about', component: () =&gt; import(/* webpackChunkName: \"about\" */ '@/views/About') &#125;] 添加store文件夹里面为index.js, state.js, actions.js, mutations.js, module文件夹(里面为user.js等) 123456789101112131415161718// index.jsimport Vue from 'vue'import Vuex from 'vuex'import state from './state'import actions from './actions'import mutations from './mutations'import user from './module/user'Vue.use(Vuex)export default new Vuex.Store(&#123; state, mutations, actions, modules: &#123; // 注意这里是modules复数 user &#125;&#125;) 12345678910111213141516// module/user.jsconst state = &#123;&#125;const mutations = &#123;&#125;const actions = &#123;&#125;export default &#123; state, mutations, actions,&#125; 有事您Q我👇","categories":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/tags/vue/"}]},{"title":"vue技术栈-创建篇","slug":"vue技术栈-创建篇","date":"2019-09-17T06:33:37.000Z","updated":"2019-09-17T06:37:14.752Z","comments":true,"path":"vue/vue技术栈-创建篇/","link":"","permalink":"https://shulu520.com/vue/vue技术栈-创建篇/","excerpt":"&emsp;&emsp;vue技术栈开发实战tallkingData数据可视化前端工程师lison课程学习笔记","text":"&emsp;&emsp;vue技术栈开发实战tallkingData数据可视化前端工程师lison课程学习笔记 创建项目项目初始化创建 经过测试在git bash里面有问题，&gt;这个符号选择配置时切换不起作用，换为cmd窗口之则可以 在一个空的文件夹里面执行 vue create 项目名称 选择手动配置 根据提示选择配置比如vuex等 配置完成后 回车 即可开始创建一个新的项目 下载好依赖之后，根据提示，cd 到项目文件夹，npm run serve 即可开启一个本地服务，和一个线上服务(局域网内可以访问的) 有事您Q我👇","categories":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/tags/vue/"}]},{"title":"vue官方编码规范指南","slug":"vue官方编码规范指南","date":"2019-09-17T06:27:26.000Z","updated":"2019-09-17T06:32:20.963Z","comments":true,"path":"vue/vue官方编码规范指南/","link":"","permalink":"https://shulu520.com/vue/vue官方编码规范指南/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; vue 官方编码风格指南 总结 组件名应多个单词命名避免单个单词名词 组件数据 组件的 data 必须是一个函数 Prop 定义 Prop 定义应该尽量详细 避免 v-if 和 v-for 用在一起在同一个元素 组件名中的单词顺序组件名应该以高级别的单词开头，以描述性的修饰词结尾。多级目录的方式在100+组件时才考虑。 完整单词的组件名 Prop 名大小写 驼峰命名 模板中使用中划线的方式 多个特性的元素应该分多行撰写，每个特性一行 应该把复杂计算属性分割为尽可能多的更简单的属性 样式中慎用元素选择器 多用类名 有事您Q我👇","categories":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/tags/vue/"}]},{"title":"响应式基础","slug":"m-响应式基础","date":"2019-08-29T16:32:30.000Z","updated":"2019-08-29T17:03:23.269Z","comments":true,"path":"responsive/m-响应式基础/","link":"","permalink":"https://shulu520.com/responsive/m-响应式基础/","excerpt":"&emsp;&emsp;你过得好，那就是我最大的幸福。","text":"&emsp;&emsp;你过得好，那就是我最大的幸福。 响应式开发网页布局方式 固定宽度布局：为网页设置一个固定的宽度，通常以px做为长度单位，常见于PC端网页。 流式布局：为网页设置一个相对的宽度，通常以百分比做为长度单位。 栅格化布局：将网页宽度人为的划分成均等的长度，然后排版布局时则以这些均等的长度做为度量单位，通常利用百分比做为长度单位来划分成均等的长度。 响应式布局：通过检测设备信息，决定网页布局方式，即用户如果采用不同的设备访问同一个网页，有可能会看到不一样的内容，一般情况下是检测设备屏幕的宽度来实现。 注：以上几种布局方式并不是独立存在的，实际开发过程中往往是相互结合使用的。 响应式布局-媒体查询 利用媒体查询可以检测到屏幕的尺寸（主要检测宽度），并设置不同的CSS样式，就可以实现响应式的布局。 响应式布局常用于企业的官网、博客、新闻资讯类型网站，这些网站以浏览内容为主，没有复杂的交互。 响应式开发的目的就是:一个网站能够兼容多种终端 响应式开发的原理：媒体查询 常见媒体类型 通过查询screen的宽度来指定某个宽度区间的网页布局。 1234超小屏幕 (移动设备) w&lt;768px 小屏设备 768 &lt;= w &lt;992中等屏幕 992 =&lt; w &lt;1200宽屏设备 1200px以上 w&gt;=1200 书写方式 一般判断最小宽度 并且由小到大 后面的样式覆盖前面的样式 注意and后面空格的添加 123456789101112131415161718192021body&#123; background-color: pink;&#125;@media screen and (min-width: 768px) &#123; body&#123; background-color: red; &#125;&#125;@media screen and (min-width: 992px) &#123; body&#123; background-color: red; &#125;&#125;@media screen and (min-width: 1200px) &#123; body&#123; background-color: red; &#125;&#125;如果按max-width来算的话 就将值从大往小写 另一种书写方式-更好一些 判断引入满足媒体条件的css样式 12&lt;link rel=\"stylesheet\" href=\"a.css\"&gt;&lt;link rel=\"stylesheet\" href=\"a.css\" media=\"screen and (min-width: 992px) and (max-width: 1200px)\" href=\"b.css\"&gt; 有事您Q我👇","categories":[{"name":"responsive","slug":"responsive","permalink":"https://shulu520.com/categories/responsive/"}],"tags":[{"name":"mobile","slug":"mobile","permalink":"https://shulu520.com/tags/mobile/"},{"name":"responsive","slug":"responsive","permalink":"https://shulu520.com/tags/responsive/"}]},{"title":"m-移动端-插件","slug":"m-移动端-插件","date":"2019-08-28T06:50:19.000Z","updated":"2019-08-28T14:15:22.820Z","comments":true,"path":"mobile/m-移动端-插件/","link":"","permalink":"https://shulu520.com/mobile/m-移动端-插件/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 移动端插件的使用swiper.js html 结构： 1234567891011121314151617181920&lt;div class=\"swiper-container\"&gt; &lt;ul class=\"swiper-wrapper clearfix\"&gt; &lt;li class=\"swiper-slide\"&gt; &lt;a href=\"javascript:;\"&gt; &lt;img src=\"./uploads/l1.jpg\" alt=\"\" /&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class=\"swiper-slide\"&gt; &lt;a href=\"javascript:;\"&gt; &lt;img src=\"./uploads/l5.jpg\" alt=\"\" /&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=\"swiper-pagination\"&gt;&lt;/div&gt; &lt;!--分页器。如果放置在swiper-container外面，需要自定义样式。--&gt; &lt;div class=\"swiper-button-prev\"&gt;&lt;/div&gt; &lt;!--左箭头。如果放置在swiper-container外面，需要自定义样式。--&gt; &lt;div class=\"swiper-button-next\"&gt;&lt;/div&gt; &lt;!--右箭头。如果放置在swiper-container外面，需要自定义样式。--&gt;&lt;/div&gt; 常用的配置如下： 12345678910111213141516171819202122232425var mySwiper = new Swiper(\".swiper-container\", &#123; // autoplay: true, speed: 1000, //轮播速度 autoplay: &#123; disableOnInteraction: false //鼠标操作后重新开启自动轮播 &#125;, loop: true, //轮播图片循环 grabCursor: true, //鼠标操作形状 effect: \"cube\", //3D旋转效果 cubeEffect: &#123; slideShadows: true, shadow: true, shadowOffset: 50, //阴影距离 shadowScale: 0.8 //阴影缩放比例 &#125;, pagination: &#123; //分页 即小点点 el: \".swiper-pagination\" &#125;, navigation: &#123; //左右按钮 nextEl: \".swiper-button-next\", prevEl: \".swiper-button-prev\" &#125;&#125;); iscroll.js 为滚动起容器增加 position:relative 或者 absolute 样式。 容器需要超出隐藏 html 结构： 1234567&lt;div id=\"wrapper\"&gt; &lt;ul&gt; &lt;li&gt;&amp;#x26C5;&lt;/li&gt; &lt;li&gt;&amp;#x26C5;&lt;/li&gt; &lt;li&gt;&amp;#x26C5;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 常见配置： 1234567891011121314151617181920212223242526// 在文档加载完成之后window.onload = function() &#123; var myScroll = new IScroll(\"#wrapper\", &#123; mouseWheel: true, // 响应鼠标中建 scrollbars: true, // 显示滚动条 interactiveScrollbars: true // 可拖动的滚动条 &#125;); // scrollTo(x, y, time, easing) 滚动到指定的位置 setTimeout(() =&gt; &#123; myScroll.scrollTo(0, -100, 500, IScroll.utils.ease.elastic); &#125;, 1000); // scrollBy(x, y, time, easing) 可以传递X和Y的值从当前位置进行滚动 setTimeout(() =&gt; &#123; myScroll.scrollBy(0, -200, 1000, IScroll.utils.ease.bounce); &#125;, 2000); // scrollToElement(el, time, offsetX, offsetY, easing) //滚动到指定元素的左上角位置。 // 测试时 无效果啊 var wrapper = document.querySelector(\"#wrapper\"); setTimeout(() =&gt; &#123; myScroll.scrollToElement(wrapper, 1000, 0, 0, IScroll.utils.ease.bounce); console.log(\"1 :\", 1); &#125;, 3000);&#125;; better-scroll.js 基于iscroll.js fastclick.js 直接拿来用就行了 touch 有点透效果 click 有延迟效果 fastclick 则无点透 无延迟 适用于 PC 和移动端 这一段代码是从 github 官网上复制来的： 123456789if (\"addEventListener\" in document) &#123; document.addEventListener( \"DOMContentLoaded\", function() &#123; FastClick.attach(document.body); &#125;, false );&#125; 有事您Q我👇","categories":[{"name":"mobile","slug":"mobile","permalink":"https://shulu520.com/categories/mobile/"}],"tags":[{"name":"mobile","slug":"mobile","permalink":"https://shulu520.com/tags/mobile/"}]},{"title":"mobile-基础","slug":"m-移动端-基础","date":"2019-08-21T04:37:35.000Z","updated":"2019-08-28T07:02:11.157Z","comments":true,"path":"mobile/m-移动端-基础/","link":"","permalink":"https://shulu520.com/mobile/m-移动端-基础/","excerpt":"&emsp;&emsp;情感宣言——世界上最好的事，莫过于一句欣赏，一句懂得。","text":"&emsp;&emsp;情感宣言——世界上最好的事，莫过于一句欣赏，一句懂得。 移动端基础 移动设备与 PC 设备最大的差异在于屏幕，这主要体现在屏幕尺寸和屏幕分辨率两个方面。 屏幕尺寸 通常我们所指的屏幕尺寸，实际上指的是屏幕对角线的长度（一般用英寸来度量） 屏幕分辨率 分辨率则一般用像素来度量 px，表示屏幕水平和垂直方向的像素数，例如 1920*1080 指的是屏幕垂直方向和水平方向分别有 1920 和 1080 个像素点而构成。 长度单位 在 Web 开发中可以使用 px（像素）、em、pt（点）、in（英寸）、cm（厘米）做为长度单位，我们最常用 px（像素）做为长度单位。 我们可以将上述的几种长度单位划分成相对长度单位和绝对长度单位。 例如：iPhone3G/S 和 iPhone4/S 的屏幕尺寸都为 3.5 英寸（in）但是屏幕分辨率却分别为 480320px、960480px，由此我们可以得出英寸是一个绝对长度单位，而像素是一个相对长度单位（像素并没有固定的长度）。 像素密度 PPI 利用勾股定理我们可以计算得出 PPI。 PPI 值的越大说明单位尺寸里所能容纳的像素数量就越多，所能展现画面的品质也就越精细，反之就越粗糙。 Retina 即视网膜屏幕，苹果注册的命名方式，意指具有较高 PPI（大于 320）的屏幕。 思考：在屏幕尺寸（英寸）固定时，PPI 和像素大小的关系？ 结论：屏幕尺寸固定时，当 PPI 越大，像素的实际大小就会越小，当 PPI 越小，像素实际大小就越大。(像素是一个相对长度单位) 设备独立像素 随着技术发展，设备不断更新，出现了不同 PPI 的屏幕共存的状态（如 iPhone3G/S 为 163PPI，iPhone4/S 为 326PPI），像素不再是统一的度量单位，这会造成同样尺寸的图像在不同 PPI 设备上的显示大小不一样。 假设你设计了一个 163·163 的蓝色方块，在 PPI 为 163 的屏幕上，那这个方块看起来正好就是 1·1 寸大小，在 PPI 为 326 的屏幕上，这个方块看起来就只有 0.5*0.5 寸大小了。 做为用户是不会关心这些细节的，他们只是希望在不同 PPI 的设备上看到的图像内容差不多大小，所以这时我们需要一个新的单位，这个新的单位能够保证图像内容在不同的 PPI 设备看上去大小应该差不多，这就是独立像素，在 IOS 设备上叫 PT(Point)，Android 设备上叫 DIP(Device independent Pixel)或 DP。 举例说明就是 iPhone 3G（PPI 为 163）1dp = 1px，iPhone 4（PPI 为 326）1dp = 2px。 我们也不难发现，如果想要 iPhone 3G/S 和 iPhone 4/S 图像内容显示一致，可以把 iPhone 4/S 的尺寸放大一倍（它们是一个 2 倍(@2x)的关系），即在 iPhone3G/S 的上尺寸为 44·44px，在 iPhone4/S 上为 88·88px，我们要想实现这样的结果可以设置 44·44dp，这时在 iPhone3G/S 上代表 44·44px，在 iPhone4/S 上代表 88*88px，最终用可以看到的图像差不多大小。 dp 同 px 是有一个对应（比例）关系的，这个对应（比例）关系是操作系统确定并处理，目的是确保不同 PPI 屏幕所能显示的图像大小是一致的，通过 window.devicePixelRatio 可以获得该比例值。 12// 获取设备独立像素 (像素比)window.devicePixelRatio; dp（或 pt）和 px 并不总是绝对的倍数关系（并不总能保证能够整除），而是 window.devicePixelRatio ~= 物理像素/独立像素，然而这其中的细节我们不必关心，因为操作系统会自动帮我们处理好（保证 1dp 在不同的设备上看上去大小差不多）。 像素 物理像素指的是屏幕渲染图像的最小单位，属于屏幕的物理属性，不可人为进行改变，其值大小决定了屏幕渲染图像的品质，我们以上所讨论的都指的是物理像素。 123// 获取屏幕的物理像素尺寸window.screen.width;window.screen.height; CSS 像素，与设备无关像素，指的是通过 CSS 进行网页布局时用到的单位，其默认值(PC 端)是和物理像素保持一致的（1 个单位的 CSS 像素等于 1 个单位的物理像素），但是我们可通缩放来改变其大小。 我们需要理解的是物理像素和 CSS 像素的一个关系，1 个物理像素并不总是等于一个 CSS 像素，通过调整浏览器缩放比例来改变。 2、3 倍图 为了在像素密度高的设备上图片能够清晰显示，而不是被放大显示(会模糊)，设计师要针对不同的像素比设计不同像素的图片。 在设备独立像素为 2 的设备上使用设计师专门为其设计的图片即可。 调试 模拟调试 真机调试 视口 viewport 视口（viewport）是用来约束网站中最顶级块元素 html 的，即它决定了&lt;html&gt;的大小。 PC 设备 viewport 在 PC 设备上 viewport 的大小取决于浏览器窗口的大小，以 CSS 像素做为度量单位。 通过以往 CSS 的知识，我们都能理解&lt;html&gt;的大小是会影响到我们的网页布局的，而 viewport 又决定了&lt;html&gt;的大小，所以 viewport 间接的决定并影响了我们网页的布局。 123// 获取viewport的大小document.documentElement.clientWidth;document.documentElement.clientHeight; 在 PC 端，我们通过调整浏览器窗口可以改变 viewport 的大小，为了保证网页布局不发生错乱，需要给元素设定较大固定宽度。 移动端 viewport 移动设备屏幕普遍都是比较小的，但是大部分的网站又都是为 PC 设备来设计的，要想让移动设备也可以正常显示网页，移动设备不得不做一些处理，通过上面的例子我们可以知道只要 viewport 足够大，就能保证原本为 PC 设备设计的网页也能在移动设备上正常显示，移动设备厂商也的确是这样来处理的。 在移动设备上 viewport 不再受限于浏览器的窗口，而是允许开发人员自由设置 viewport 的大小，通常浏览 器会设置一个默认大小的 viewport，为了能够正常显示那些专为 PC 设计的网页，一般这个值的大小会大于屏幕的尺寸。 如下图为常见默认 viewport 大小（仅供参考） 从图中统计我们得知不同的移动厂商分别设置了一个默认的 viewport 的值，这个值保证大部分网页可以正常在移动设备下浏览。但是通常会产生缩放和滚动条。 产生缩放和滚动条的原因是什么呢？ 进一步对移动设备的 viewport 进行分析，移动设备上有 2 个 viewport（为了方便讲解人为定义的），分别是 layout viewport 和 ideal viewport。 layout viewport 布局视口 指的是我们可以进行网页布局区域的大小，同样是以 CSS 像素做为计量单位，可以通过下面方式获取 123// 获取layout viewportdocument.documentElement.clientWidth;document.documentElement.clientHeight; 通过前面介绍我们知道，如果要保证为 PC 设计的网页在移动设备上布局不发生错乱，移动设备会默认设置一个较大的 viewport（如 IOS 为 980px），这个 viewport 实际指的是 layout viewport。 ideal viewport 理想视口 设备屏幕区域，（以设备独立像素 PT、DP 做为单位）以 CSS 像素做为计量单位，其大小是不可能被改变，通过下面方式可以获取。 1234567// 获取ideal viewport有两种情形// 新设备window.screen.width;window.screen.height;// 老设备window.screen.width / window.devicePixelRatio;window.screen.height / window.devicePixelRatio; 理解两个 viewport 后, 我们来解释为什么网页会被缩放或出现水平滚动条，其原因在于移动设备浏览器会默认设置一个 layout viewport，并且这个值会大于 ideal viewport，那么我们也知道ideal viewport 就是屏幕区域, layout viewport 是我们布局网页的区域，那么最终 layout viewport 是要显示在 ideal viewport 里的，而 layout viewport 大于 ideal viewport 时，于是就出现滚动条了，那么为什么有的移动设备网页内容被缩放了呢？移动设备厂商认为将网页完整显示给用户才最合理，而不该出现滚动条，所以就将 layout viewport 进行了缩放，使其恰好完整显示在 ideal viewport（屏幕）里，其缩放比例为 ideal viewport / layout viewport。 移动浏览器 移动端开发主要是针对 IOS 和 Android 两个操作系统平台的，除此之外还有 Windows Phone。 移动端主要可以分成三大类，系统自带浏览器、应用内置浏览器、第三方浏览器 系统浏览器： 指跟随移动设备操作系统一起安装的浏览器。 应用内置浏览器： 通常在移动设备上都会安装一些 APP 例如 QQ、微信、微博、淘宝等，这些 APP 里往往会内置一个浏览器，我们称这个浏览器为应用内置浏览器（也叫 WebView），这个内置的浏览器一般功能比较简单，并且客户端开发人员可以更改这个浏览器的某些设置，在我们理实的开发里这个浏览器很重要。 第三方浏览器： 指安装在手机的浏览器如 FireFox、Chrome、360 等等。 在 IOS 和 Android 操作系统上自带浏览器、应用内置浏览器都是基于 Webkit 内核的。 屏幕适配 Viewport 详解 经过分析我们得到，移动页面最理想的状态是，避免滚动条且不被默认缩放处理，我们可以通过设置&lt;meta name=&quot;viewport&quot; content=&quot;&quot;&gt;来进行控制，并改变浏览器默认的 layout viewport 的宽度。 viewport 介绍 是由苹果公司为了解决移动设备浏览器渲染页面而提出的解决方案，后来被其它移动设备厂商采纳，其使用参数如下： 123456789101112131415// 通过设置属性content=\"\"实现，中间以逗号分隔// 例如&lt;meta name=\"viewport\" content=\"width=device-width\"&gt;width 设置layout viewport 宽度，其取值可为数值或者device-width。height 设置layout viewport 高度，其取值可为数值或者device-heightinitital-scale设置页面的初始缩放值，为一个数字，可以带小数。maximum-scale允许用户的最大缩放值，为一个数字，可以带小数。minimum-scale允许用户的最小缩放值，为一个数字，可以带小数。user-scalable是否允许用户进行缩放，值为\"no\"或\"yes\"。注：device-width 和 device-height就是ideal viewport的宽高 viewport 控制缩放 设置&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&quot;&gt;，这时我们发现网页没有被浏览器设置缩放。 设置&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;，这时我们发现网页也没有被浏览器设设置缩放。 当我们设置 width=device-width，也达到了 initial-scale=1 的效果，得知其实 initial-scale = ideal viewport / layout viewport。 两种方式都可以控制缩放，开发中一般同时设置 width=device-width 和 initial-scale=1.0（为了解决一些兼容问题）参见移动前端开发之 viewport 深入理解，即&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; viewport 避免滚动 我们知道，滚动条是 layout viewport 相对于 ideal viewport 的，所以只要设置 layout viewport 小于或等于 ideal viewport，即&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; 盒子宽度设置为百分比的宽度 适配方案百分比宽度 设置&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 设置页面宽度为百分比 12345width 参照父元素的宽度height 参照父元素的高度padding 参照父元素的宽度border 不支持百分比设置margin 参照父元素的宽度 我们发现这种方案最容易理解，但是在设置元素高度时有非常大的局限性。 因为页面的高度是不固定的。 rem 单位移动端触屏事件事件类型123touchstart: 手指触摸屏幕时触发;touchmove: 手指在屏幕上移动时触发;touchend: 手指离开屏幕时触发; TouchEvent 对象1234touches: 位于屏幕上的所有手指的列表targetTouches: 位于该元素上的所有手指的列表changedTouches：touchstart时包含刚与触摸屏接触的触点，touchend时包含离开触摸屏的触点注：没有对比出touches同targetTouches的差异，推荐使用targetTouches Touch 对象123456clientX/Y 手指相对于layout viewport的水平/垂直像素距离pageX/Y 手指相对于layout viewport的水平/垂直像素距离（含滚动）screenX/Y 手指相对于layout viewport的水平/垂直像素距离（含滚动）（未设置viewport时，screenX/Y在Webview中不正确）target 手指最初与屏幕接触时的元素移动开发通常会设置`&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;`，这时这三对坐标值是完全一样的。 有事您Q我👇","categories":[{"name":"mobile","slug":"mobile","permalink":"https://shulu520.com/categories/mobile/"}],"tags":[{"name":"mobile","slug":"mobile","permalink":"https://shulu520.com/tags/mobile/"}]},{"title":"js-ES7","slug":"js-ES7","date":"2019-08-17T08:38:18.000Z","updated":"2019-08-18T06:06:40.156Z","comments":true,"path":"js-ES7/js-ES7/","link":"","permalink":"https://shulu520.com/js-ES7/js-ES7/","excerpt":"&emsp;&emsp;大家都有不一样的难过和快乐 只是我们总是下意识 拿自己的劣势去和别人的优势来比","text":"&emsp;&emsp;大家都有不一样的难过和快乐 只是我们总是下意识 拿自己的劣势去和别人的优势来比 ES7ES7之异步async/await函数 概念：真正意义上去解决异步回调的问题，同步流程表达异步操作 本质：Generator的语法糖 1234567891011语法：async function foo()&#123; await 异步操作; await 异步操作；&#125;特点：1、不需要像Generator去调用next方法，遇到await等待，当前的异步操作完成就往下执行2、返回的总是Promise对象，可以用then方法进行下一步操作3、async取代Generator函数的星号*，await取代Generator的yield4、语意上更为明确，使用简单，经临床验证，暂时没有任何副作用 12345678910111213141516171819202122async function sendXhr(url) &#123; return new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; url, type: 'GET', success: data =&gt; resolve(data), error: error =&gt; resolve(false) //技巧 小聪明 // 若调用reject的话 报错用户看不到 &#125;) &#125;)&#125;async function getNews(url) &#123; let result = await sendXhr(url); if (!result) &#123; alert('暂时没有新闻推送...') return; &#125; let result2 = await sendXhr(url); console.log(result, result2);&#125;getNews('http://localhost:3000/news?id=2') ES7扩展指数运算符**1234指数运算符: **let num = 2 ** 3console.log('num :', num);//8 ES7数组扩展includes12345Array.prototype.includes(value) : 判断数组中是否包含指定valuelet arr = [1, 2, 'abc']console.log(arr.includes('a'))// falseconsole.log(arr.includes('abc'))//true 有事您Q我👇","categories":[{"name":"js-ES7","slug":"js-ES7","permalink":"https://shulu520.com/categories/js-ES7/"}],"tags":[{"name":"ES7","slug":"ES7","permalink":"https://shulu520.com/tags/ES7/"}]},{"title":"js-ES6","slug":"js-ES6","date":"2019-08-17T08:38:04.000Z","updated":"2019-08-18T06:03:33.354Z","comments":true,"path":"js-ES6/js-ES6/","link":"","permalink":"https://shulu520.com/js-ES6/js-ES6/","excerpt":"&emsp;&emsp;我想任何人 在经历时 都不会知道自己正在经历 生平中最幸福的时刻 我们生活中那些被遗漏的美好时光","text":"&emsp;&emsp;我想任何人 在经历时 都不会知道自己正在经历 生平中最幸福的时刻 我们生活中那些被遗漏的美好时光 ES6ES6-2个新的关键字 let/const 块作用域 没有变量提升 不能重复定义 值不可变 const 1234567let a = 2a = 1console.log('a :', a)const B = 4B = 5console.log('B :', B) //报错 常量值不可变 ES6-变量的解构赋值 将包含多个数据的对象(数组)一次赋值给多个变量 数据源: 对象/数组 目标: {a, b}/[a, b] 123456789101112131415161718192021222324//解构 左右两边的数据结构必须一致let obj = &#123; name: 'yachan', sex: '女神', age: 18&#125;let &#123;name, sex&#125; = obj // 对象的解构赋值是按照属性名查找并赋值的console.log('name, sex :', name, sex);//name, sex : yachan 女神function foo (&#123; name, sex &#125;) &#123;//参数为对象时 形参也可以解构赋值 console.log('name, sex :', name, sex)&#125;foo(obj)//name, sex : yachan 女神let arr = [1, 3, 34, 4]let [a, b] = arrlet [,, c, d] = arr //可以用 ','占位// 数组的解构赋值是按下标进行匹配的console.log('a, b :', a, b)//a, b : 1 3console.log('c, d :', c, d);//c, d : 34 4 ES6-各种数据类型的扩展ES6-数值Number的扩展1234561. 二进制与八进制数值表示法: 二进制用0b, 八进制用0o2. Number.isFinite(i) : 判断是否是有限大的数3. Number.isNaN(i) : 判断是否是NaN4. Number.isInteger(i) : 判断是否是整数5. Number.parseInt(str) : 将字符串转换为对应的数值6. Math.trunc(i) : 直接去除小数部分 ES6-字符串String的扩展123456789101112131415161718模板字符串 作用: 简化字符串的拼接 变化的部分使用$&#123;xxx&#125;定义includes(str) : 判断是否包含指定的字符串startsWith(str) : 判断是否以指定字符串开头endsWith(str) : 判断是否以指定字符串结尾repeat(count) : 重复指定次数``` ```jslet str = 'yachanshulu'console.log(str.includes('shu'))//trueconsole.log(str.startsWith('ya'))//trueconsole.log(str.endsWith('lu'))//truelet str2 = str.repeat(2)console.log(str2)//yachanshuluyachanshulu ES6-对象Object的扩展 简化的对象写法 12345678910111213let name = 'Tom';let age = 12;let person = &#123; name, age, getName () &#123; return this.name &#125;, setName (name) &#123; this.name = name &#125;&#125; 将源对象的属性复制到目标对象上 混入 123456789101112131415Object.assign(target, source1, source2..)let obj1 = &#123; name: 'shulu', sex: '女神', getName () &#123; return this.name &#125;&#125;let obj2 = &#123;age: 'shulu', love: '男神'&#125;let o = &#123;&#125;Object.assign(o, obj1, obj2)console.log('o :', o)//o : &#123;name: \"shulu\", sex: \"女神\", getName: ƒ, age: \"shulu\", love: \"男神\"&#125; 判断2个数据 是否完全相等 1234567Object.is(v1, v2)// Object.is()方法底层是按照字符串去判断的console.log('Object.is(NaN, NaN) :', Object.is(NaN, NaN));// Object.is(NaN, NaN) : trueconsole.log('Object.is(0, -0) :', Object.is(0, -0));// Object.is(0, -0) : false 隐式原型属性 123456789101112131415161718192021222324252627__proto__ 属性 ES6规定可以直接修改这个属性let obj1 = &#123;&#125;, obj2 = &#123;money: 99999999&#125;obj1.__proto__ = obj2 让obj2做obj1的原型对象console.log('obj1 :', obj1);console.log('obj1.money :', obj1.money);// obj1 : &#123;&#125;// obj1.money : 99999999``` ### ES6-数组的扩展```js将伪数组对象或可遍历对象转换为真数组Array.from(v) 将一系列值转换成数组Array.of(v1, v2, v3) 找出第一个满足条件返回true的元素find(function(value, index, arr)&#123;return true&#125;) 找出第一个满足条件返回true的元素下标findIndex(function(value, index, arr)&#123;return true&#125;) ES6-函数的扩展 箭头函数 12345678910用来定义匿名函数基本语法: 没有参数: () =&gt; console.log('xxxx') 一个参数: i =&gt; i+2 大于一个参数: (i,j) =&gt; i+j 函数体不用大括号: 函数体只有一条语句或表达式时 默认返回结果 函数体如果有多个语句, 需要用&#123;&#125;包围使用场景: 多用来定义回调函数 箭头函数的this：箭头函数没有自己的this箭头函数的this是定义的时候决定的 如何判断箭头函数this是谁：看外层是否有函数 有的话就 是外层函数的this 而外层函数的this由调用者决定 没有的话 就是window 1234567891011121314151617let obj = &#123; name: 'yachan', age: 18, getName: () =&gt; &#123; //箭头函数 btn1.onclick = () =&gt; &#123; //箭头函数 console.log(this) &#125; &#125;&#125;obj.getName()//windowobj.getAge = () =&gt; &#123; //与getName的定义一样 btn2.onclick = () =&gt; &#123; console.log(this) &#125;&#125;obj.getAge()//window 形参的默认值 123456定义形参时指定其默认的值function getPoint (x = 0, y = 0) &#123; console.log('x, y :', x, y);&#125;getPoint()//x, y : 0 0getPoint(22, 33) //x, y : 22 33 扩展运算符… 12345678910111213141516171819//rest(可变)参数//通过形参左侧的...来表达, 取代arguments的使用function getNumber (a, ...value) &#123; console.log(a) value.forEach((item, index) =&gt; &#123; console.log(item) &#125;)&#125;getNumber(1, 2, 67)//扩展运算符(...) 可以分解出数组或对象中的数据let arr1 = [1, 6]let arr2 = [2, 3, 4, 5]let arr3 = [...arr1, ...arr2]arr3.sort((x, y) =&gt; x - y)console.log(arr3);//[1, 2, 3, 4, 5, 6] ES6深度克隆deepClone12345678910111213141516171819202122232425262728293031323334353637383940414243// 检测数据类型function checkedType (target) &#123; return Object.prototype.toString.call(target).slice(8, -1) // Object.prototype.toString.call() 返回值[Object xxx]&#125;// 深度克隆function deepClone (target) &#123; let result, //最终返回值 targetType = checkedType(target) //要克隆的目标对象的数据类型 if (targetType === 'Object') &#123; result = &#123;&#125; //初始化为一个空对象 &#125;else if (targetType === 'Array') &#123; result = [] //初始化为一个空数组 &#125;else &#123; return target &#125; // 能走到这里说明要克隆的对象的数据类型为对象或者数组 // 遍历目标对象 for (let i in target) &#123; // 枚举对象则i为key // 枚举数组则i为index if (target.hasOwnProperty(i)) &#123;//目标对象自身的属性 不要原型对象上的属性 let value = target[i] if (checkedType(value) === 'Object' || 'Array') &#123; result[i] = deepClone(value)//递归方法 &#125;else &#123; result[i] = value &#125; &#125; &#125; return result&#125;// 测试代码let arr = [1, &#123;name: 'shulu', age: 18&#125;, [2, 3, &#123;sex: '女神'&#125;]]let cloneArr = deepClone(arr)cloneArr[1].name = 'yachan'cloneArr[2][2].sex = '男生'console.log('cloneArr :', cloneArr);console.log('arr :', arr);// 结果互不干扰 ES6之Symbol一种新的原始数据类型1234567891011121314151617181920212223ES5中对象的属性名都是字符串，容易造成重名，污染环境Symbol：概念：ES6中的添加了一种原始数据类型symbol(已有的原始数据类型：String, Number, boolean, null, undefined, 对象)特点： 1、Symbol属性对应的值是唯一的，解决命名冲突问题 2、Symbol值不能与其他数据进行计算，包括同字符串拼串 3、for in, for of遍历时不会遍历symbol属性。使用： 1、调用Symbol函数得到symbol值 let symbol = Symbol(); let obj = &#123;&#125;; obj[symbol] = 'hello'; 2、传参标识 let symbol = Symbol('one'); let symbol2 = Symbol('two'); console.log(symbol);// Symbol('one') console.log(symbol2);// Symbol('two') 3、内置Symbol值 * 除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。 - Symbol.iterator * 对象的Symbol.iterator属性，指向该对象的默认遍历器方法(后边讲) ES6之set/Map容器结构 容器: 能保存多个数据的对象, 同时必须具备操作内部数据的方法 任意对象都可以作为容器使用, 但有的对象不太适合作为容器使用(如函数) Set的特点: 保存多个value, value是不重复 ====&gt;数组元素去重 Map的特点: 保存多个key–value, key是不重复, value是可以重复的 1234567891011121314API Set()/Set(arr) //arr是一维数组 add(value) delete(value) clear(); has(value) size Map()/Map(arr) //arr是二维数组 set(key, value) delete(key) clear() has(key) size set 12345678910111213let set = new Set([1, 2, 2, 1, 3])console.log('set :', set) //Set(3) &#123;1, 2, 3&#125;console.log('set.size :', set.size);console.log('set.has(2) :', set.has(2));//trueset.add(8)console.log('set :', set);//Set(4) &#123;1, 2, 3, 8&#125;set.delete(1)console.log('set :', set);//&#123;2, 3, 8&#125;set.clear()console.log('set :', set);//&#123;&#125; map 12345678910111213141516//map里面放二维数组 内数组的第一项为key 第二项为valuelet map = new Map([['name', 'shulu'], ['age', 18]])console.log('map :', map)//Map(2) &#123;\"name\" =&gt; \"shulu\", \"age\" =&gt; 18&#125;console.log('map.size :', map.size); //2map.set('sex', '女神')console.log('map :', map);//Map(3) &#123;\"name\" =&gt; \"shulu\", \"age\" =&gt; 18, \"sex\" =&gt; \"女神\"&#125;map.delete('age')console.log('map :', map);//&#123;\"name\" =&gt; \"shulu\", \"sex\" =&gt; \"女神\"&#125;console.log(map.has('name'));//truemap.clear()console.log('map :', map);//Map(0) &#123;&#125; ES6异步1之Promise 解决回调地狱(回调函数的层层嵌套, 编码是不断向右扩展, 阅读性很差) 能以同步编码的方式实现异步调用 在es6之前原生的js中是没这种实现的, 一些第三方框架(jQuery)实现了promise ES6中定义实现API: 12345678910111213141516// 1. 创建promise对象let promise = new Promise((resolve, reject) =&gt; &#123; // 做异步的操作 if(成功) &#123; // 调用成功的回调 resolve(result); &#125; else &#123; // 调用失败的回调 reject(errorMsg); &#125; &#125;) // 2. 调用promise对象的then()promise.then((result) =&gt; &#123; console.log(result)&#125;, (errorMsg) =&gt; &#123; console.log(errorMsg) &#125;) ES6之iterator遍历器指针对象 概念： iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制 作用： 123为各种数据结构，提供一个统一的、简便的访问接口；使得数据结构的成员能够按某种次序排列ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费。 工作原理： 123456创建一个指针对象，指向数据结构的起始位置。第一次调用next方法，指针自动指向数据结构的第一个成员接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员每调用next方法返回的是一个包含value和done的对象，&#123;value: 当前成员的值,done: 布尔值&#125; value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束。 当遍历结束的时候返回的value值是undefined，done值为true 原生具备iterator接口的数据(可用for of遍历) 1234561、Array2、arguments3、set容器4、map容器5、String…… 值得注意的是普通对象{}是不具有iterator接口的 即无法用for..of 来遍历 模拟实现iterator指针对象 12345678910111213141516171819202122232425自定义iterator生成指针对象function mockIterator(arr) &#123; let nextIndex = 0; return &#123; next: function () &#123; return nextIndex&lt;arr.length?&#123;value: arr[nextIndex++], done: false&#125;:&#123;value: undefined, done: true&#125; &#125; &#125;&#125;let arr = [1,2,3,4,5];let iteratorObj = mockIterator(arr);console.log(iteratorObj.next());console.log(iteratorObj.next());console.log(iteratorObj.next());console.log(iteratorObj.next());console.log(iteratorObj.next());console.log(iteratorObj.next());// &#123;value: 1, done: false&#125;// &#123;value: 2, done: false&#125;// &#123;value: 3, done: false&#125;// &#123;value: 4, done: false&#125;// &#123;value: 5, done: false&#125;// &#123;value: undefined, done: true&#125; ES6之for–of循环 可以遍历任何容器 set/map等 数组/类数组 对象 (这个有点不太会) 伪/类对象 字符串 可迭代的对象 arguments 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 遍历字符串let str = 's2wn'for (const iterator of str) &#123; console.log('iterator :', iterator);&#125;// 遍历数组let arr = [1, 2, 'ss']for (const iterator of arr) &#123; console.log('iterator :', iterator);&#125;// 遍历argumentsfunction forArguments () &#123; for (const iterator of arguments) &#123; console.log('iterator :', iterator); &#125;&#125;forArguments(1, 2, 3)//1//2 //3 // 遍历类数组let btns = document.getElementsByClassName('btn')for (const iterator of btns) &#123; console.log('btns :', btns);&#125;// HTMLCollection(3) [div.btn, div.btn, div.btn]// HTMLCollection(3) [div.btn, div.btn, div.btn]// HTMLCollection(3) [div.btn, div.btn, div.btn]// 遍历set容器let set = new Set([1, 2, 3])for (const i of set) &#123; console.log('i :', i);&#125;// 1// 2// 3// 遍历map容器let map = new Map([['name', 'shulu'], ['age', 18], ['sex', '女神']])for (const i of map) &#123; console.log('i :', i);&#125;// [\"name\", \"shulu\"]// [\"age\", 18]// [\"sex\", \"女神\"] ES6异步2之Generator函数 相比promise函数解决回调地狱的方法要好一些 调用Generator函数会返回一个遍历器对象即iterator 123456789101112131415161718概念： 1、ES6提供的解决异步编程的方案之一 2、Generator函数是一个状态机，内部封装了不同状态的数据， 3、用来生成遍历器对象 4、可暂停函数(惰性求值), yield可暂停，next方法可启动。每次返回的是yield后的表达式结果特点： 1、function 与函数名之间有一个星号 2、内部用yield表达式来定义不同的状态 例如： function* generatorExample()&#123; let result = yield 'hello'; // 状态值为hello yield 'generator'; // 状态值为generator &#125; 3、generator函数返回的是指针对象(即前面讲的iterator)，而不会执行函数内部逻辑 4、调用next方法函数内部逻辑开始执行，遇到yield表达式停止，返回&#123;value: yield后的表达式结果/undefined, done: false/true&#125; 5、再次调用next方法会从上一次停止时的yield处开始，直到最后 6、yield语句返回结果通常为undefined， 当调用next方法时传参内容会作为启动时yield语句的返回值。 ES6之class类 用 class 定义类 用 constructor() 定义构造方法(相当于构造函数) 一般方法: xxx () {} 必须这么写 用extends来定义子类 继承父类 用super()来调用父类的构造方法 子类方法自定义: 将从父类中继承来的方法重新实现一遍 js中没有方法重载(方法名相同, 但参数不同)的语法 123456789101112131415161718192021222324252627class Person &#123; // 类的构造方法 constructor(name, age) &#123; this.name = name this.age = age &#125; // 类的一般方法 showInfo () &#123; console.log(`my name is $&#123;this.name&#125;.`); console.log(`I am $&#123;this.age&#125; years old.`); &#125;&#125;class starPerson extends Person &#123; constructor (name, age, salary) &#123; super(name, age)//调用父类的构造方法 this.salary = salary &#125; showSalary () &#123; console.log(`my salary is $&#123;this.salary&#125; ￥`); &#125;&#125;let star = new starPerson('yachan', 18, 9999999999)console.log('star :', star);star.showInfo()star.showSalary() ES6之模块化 看js模块化部分 有事您Q我👇","categories":[{"name":"js-ES6","slug":"js-ES6","permalink":"https://shulu520.com/categories/js-ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://shulu520.com/tags/ES6/"}]},{"title":"js-ES5","slug":"js-ES5","date":"2019-08-17T08:37:44.000Z","updated":"2019-08-18T05:58:19.658Z","comments":true,"path":"js-ES5/js-ES5/","link":"","permalink":"https://shulu520.com/js-ES5/js-ES5/","excerpt":"&emsp;&emsp;时间会变魔术——生命之旅是一个不断发现的过程，在每个年龄段都会有它独特的景致。","text":"&emsp;&emsp;时间会变魔术——生命之旅是一个不断发现的过程，在每个年龄段都会有它独特的景致。 理解ES 全称: ECMAScript js语言的规范 我们用的js是它的实现 js的组成 ECMAScript(js基础) 扩展–&gt;浏览器端 BOM DOM 扩展–&gt;服务器端 Node.js ES的几个重要的版本 ES5 09年发布 ES6 15年发布 也叫ES2015 ES7 16年发布 也叫ES2016 ES5ES5-严格模式12345678910111213141516171819202122232425运行模式: 正常(混杂)模式与严格模式应用上严格式: 'strict mode';作用: 使得Javascript在更严格的条件下运行 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 消除代码运行的一些不安全之处，保证代码运行的安全需要记住的几个变化 声明定义变量必须用var 禁止自定义的函数中的this关键字指向全局对象 创建eval作用域(就像函数作用域一样), 更安全``` ## ES5-JSON对象* 作用: 用于在json对象/数组与js对象/数组相互转换* JSON.stringify(obj/arr) 将js对象(数组)转换为json对象(数组)```jsvar obj = &#123; name: 'shulu', age: 18&#125;var arr = ['shu', 'lu', 520]console.log(JSON.stringify(obj)) //&#123;\"name\":\"shulu\",\"age\":18&#125;console.log(JSON.stringify(arr)); //[\"shu\",\"lu\",520] JSON.parse(json) 将json对象(数组)转换为js对象(数组) ES5-Object扩展12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Object.create(prototype[, descriptors]) : 创建一个新的对象以指定对象为原型创建新的对象指定新的属性, 并对属性进行描述 value : 指定值 writable : 标识当前属性值是否是可修改的, 默认为true enumerable: 是否可被for in枚举 默认false get方法: 用来得到当前属性值的回调函数 set方法: 用来监视当前属性值变化的回调函数var obj = &#123; name: 'shulu', age: 18&#125;var o = &#123;&#125;o = Object.create(obj, &#123; sex: &#123; value: '女神', //属性值 writable: true, //可写可修改 enumerable: true ,//可被for in枚举 configurable: true, //可删除 可配置的属性 &#125;&#125;)function iterator () &#123; for (const key in o) &#123; if (o.hasOwnProperty(key)) &#123; console.log('key :', key) &#125; &#125;&#125;iterator() // key: sexdelete o.sexconsole.log('o :', o) //o: &#123;&#125;var o2 = &#123;&#125;// 以字面量方式创建的空对象就相当于:o2 = Object.create(Object.prototype)``` ```jsObject.defineProperties(object, descriptors) : 为指定对象定义扩展多个属性var obj = &#123; firstName: 'shu', lastName: 'lu',&#125;Object.defineProperties(obj, &#123; fullName: &#123; //联想vue中的计算属性 get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, set: function (data) &#123; var names = data.split(' ') this.firstName = names[0] this.lastName = names[1] &#125; &#125; &#125;)console.log(obj.fullName)// shu luobj.fullName = 'love you'console.log(obj.fullName)// love you 对象的本身就有的的两个方法 get set 1234obj&#123; get propertyName () &#123;...&#125;, set propertyName () &#123;...&#125;,&#125; 1234567891011121314151617var obj = &#123; firstName: 'shu', lastName: 'lu', get fullName () &#123; return this.firstName + ' ' + this.lastName &#125;, set fullName (data) &#123; var names = data.split(' ') this.firstName = names[0] this.lastName = names[1] &#125;&#125;console.log(obj.fullName);// shu luobj.fullName = 'love you'console.log(obj.fullName);// love you//结果和Object.defineProperties()一样 ES5-Array扩展1234567891011121314得到值在数组中的第一个下标Array.prototype.indexOf(value) 得到值在数组中的最后一个下标Array.prototype.lastIndexOf(value) 遍历数组Array.prototype.forEach(function(item, index)&#123; &#125;) 遍历数组 返回一个新的数组 返回加工之后的新数组 变量接收返回值Array.prototype.map(function(item, index)&#123; return &#125;) 遍历数组 过滤出一个新的子数组 返回条件为true的值组成的子数组 变量接收返回值Array.prototype.filter(function(item, index)&#123; return &#125;) 12345678910111213141516171819var arr = [1, 2, 34, 32, 12]arr.forEach(function (item, index) &#123; console.log(item, index);&#125;)// 1 0// 2 1// 34 2// 32 3// 12 4var arr2 = arr.map(function (item, index) &#123; return item += 10&#125;)console.log('arr :', arr2) //[11, 12, 44, 42, 22]var arr3 = arr.filter(function (item, index) &#123; return item &gt; 3&#125;)console.log('arr3 :', arr3);//[34, 32, 12] ES5-Function扩展12345678Function.prototype.bind(obj) 将函数内的this绑定为obj, 并将函数返回 并不会立即调用函数面试题: 区别bind()与call()和apply()fn.bind(obj, 66) 指定函数中的this, 并返回函数, 第二个参数直接传, 常用于指定回调函数的thisfn.call(obj, 66) 指定函数中的this, 并调用函数, 第二个参数直接传fn.apply(obj, [66]) 指定函数中的this, 并调用函数, 第二个参数为数组形式 demo 12345678910111213141516171819202122232425262728293031function foo1 (data) &#123; console.log('this :', this) console.log('data :', data)&#125;function foo2 (data) &#123; console.log('this :', this) console.log('data :', data)&#125;function foo3 (data) &#123; console.log('this :', this) console.log('data :', data)&#125;var obj = &#123; name: 'yachan', sex: '女神'&#125;var bar = foo1.bind(obj, 18)bar()//this : &#123;name: \"yachan\", sex: \"女神\"&#125; //data : 18foo2.call(obj, 19)//this : &#123;name: \"yachan\", sex: \"女神\"&#125; //data : 19foo3.apply(obj, [20])//this : &#123;name: \"yachan\", sex: \"女神\"&#125;//data : 20// bind常用于指定回调函数的thissetTimeout(function () &#123; console.log('this :', this) //this : &#123;name: \"yachan\", sex: \"女神\"&#125;&#125;.bind(obj), 1000) ES5-Date扩展 Date.now() : 得到当前时间值 有事您Q我👇","categories":[{"name":"js-ES5","slug":"js-ES5","permalink":"https://shulu520.com/categories/js-ES5/"}],"tags":[{"name":"ES5","slug":"ES5","permalink":"https://shulu520.com/tags/ES5/"}]},{"title":"ajax-跨域-jsonp","slug":"ajax-跨域-jsonp","date":"2019-08-11T14:21:34.000Z","updated":"2019-08-12T04:45:52.096Z","comments":true,"path":"ajax-跨域/ajax-跨域-jsonp/","link":"","permalink":"https://shulu520.com/ajax-跨域/ajax-跨域-jsonp/","excerpt":"&emsp;&emsp; 这世界很美——我要变成这个世界的一部分，变成哪些努力的人的一部分，变成这个人世界依旧美好的一部分。","text":"&emsp;&emsp; 这世界很美——我要变成这个世界的一部分，变成哪些努力的人的一部分，变成这个人世界依旧美好的一部分。 ajax跨域之jsonp同源策略&emsp;&emsp;同源策略是浏览器的一种安全策略，所谓同源请求url地址中的协议、域名、端口都相同，只要其中之不同就是跨域 跨域常用方法jsonp原理 jsonp仅仅支持get请求 静态script标签的src实现进行跨域请求不常用 存在的问题： 必须保证加载的顺序 不方便传递参数 动态创建script标签，通过标签的src属性发送请求常用 123456789101112var script = document.createElement('script')script.src = 'http://taobao.com/data.php?callback=foo&amp;name=shulu&amp;age=18'var head = document.getElementsByTagName('head')[0]head.appendChild(script)// 前端定义函数function foo (data) &#123; console.log('data :', data)&#125;// 服务器返回一个【函数调用】即 foo(实参)// ?callback=foo 通过这样设置后 函数名字就有前端决定// 'callback' 这个字符串必须与后端一致 即有后端决定 jQuery中的jsonp&emsp;&emsp;jQuery中将jsonp的方法封装到了$.ajax()的方法中 使用方法跟$.ajax()差不多注意点： 12345678dataType: 'jsonp' //必须指定为jsonpjsonp: 'cb' //若后端获取回调函数的名字时用cb这个变量，//这里就要指定为'cb',来迎合后端，一般情况下，为'callback'jsonpCallback: 'foo'//自定义回调函数的名字，,即callback这个键的值//jQuery默认会生成一个很长的名字 12345678910111213$.ajax(&#123; type: 'get', url: 'http://taobao.com/data.php?callback=foo&amp;name=shulu&amp;age=18', dataType: 'jsonp', jsonp: 'cb', jsonpCallback: 'foo', success: function (data) &#123; console.log(data) &#125;, error: function (error) &#123; console.log(error) &#125;&#125;) 模仿实现jQuery中的jsonp1234567891011121314151617181920212223242526272829303132333435363738394041function ajax (obj) &#123; let defaults = &#123; url: '#', dataType: 'jsonp', jsonp: 'callback', data: &#123;&#125;, success: function (data) &#123; console.log(data) &#125; &#125; for (const key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; defaults[key] = obj[key] &#125; &#125; // 默认的回调函数名称 1.1.11为jquery的版本号 let cbName = 'jQuery' + ('1.1.11' + Math.random().replace(/\\D/g,'') + '_' + (new Date().getTime())) if (defaults.jsonpCallback) &#123; cbName = defaults.jsonpCallback &#125; // 定义回调函数 给window上添加一个方法 window[cbName] = function (data) &#123; defaults.success(data) &#125; // 处理参数 拼接成字符串参数 let param = '' for (const key in defaults.data) &#123; if (defaults.data.hasOwnProperty(key)) &#123; param += key + '=' + defaults.data[key] + '&amp;' param = '&amp;' + param &#125; &#125; let script = document.createElement('script') script.src = defaults.url + '?' + defaults.jsonp + '=' + cbName + param let head = document.getElementsByTagName('head')[0] head.appendChild(script)&#125; 模仿jQuery中的ajax中封装的jsonp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107function ajax (obj) &#123; let defaults = &#123; type: 'get', url: '#', async: true, dataType: 'jsonp', jsonp: 'callback', data: &#123;&#125;, success: function (data) &#123; console.log(data) &#125; &#125; for (const key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; defaults[key] = obj[key] &#125; &#125; if (defaults.dataType === 'jsonp') &#123; ajax4jsonp(defaults) &#125; else &#123; ajax4json(defaults) &#125; function ajax4jsonp (defaults) &#123; // 默认的回调函数名称 1.1.11为jquery的版本号 let cbName = 'jQuery' + ('1.1.11' + Math.random().replace(/\\D/g,'') + '_' + (new Date().getTime())) if (defaults.jsonpCallback) &#123; cbName = defaults.jsonpCallback &#125; // 定义回调函数 给window上添加一个方法 window[cbName] = function (data) &#123; defaults.success(data) &#125; // 处理参数 拼接成字符串参数 let param = '' for (const key in defaults.data) &#123; if (defaults.data.hasOwnProperty(key)) &#123; param += key + '=' + defaults.data[key] + '&amp;' param = '&amp;' + param &#125; &#125; let script = document.createElement('script') script.src = defaults.url + '?' + defaults.jsonp + '=' + cbName + param let head = document.getElementsByTagName('head')[0] head.appendChild(script) &#125; function ajax4json (defaults) &#123; // 1 创建Ajax对象 let xhr = new XMLHttpRequest() // 处理defaults.data 将对象形式参数拼接成参数字符串 // 即 name=yachan&amp;age=18 的形式 let param = '' for (const key in defaults.data) &#123; if (defaults.data.hasOwnProperty(key)) &#123; param += key + '=' + defaults.data[key] + '&amp;' &#125; &#125; // 去掉最后一个&amp;符号 if (param) &#123; param = param.substring(0, param.length - 1) &#125; // 若为get请求 则直接往url后面拼接参数 if (defaults.type === 'get') &#123; defaults.url += '?' + encodeURI(param) //编码中文 防止出现乱码 &#125; // 若为post请求 let data = null if (defaults.type === 'post') &#123; data = param // 设置请求头(必须设置) xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded') &#125; // 2 准备发送 设置发送参数 xhr.open(defaults.type, defaults.url, defaults.async) // 3 发送请求 执行发送动作 xhr.send(data) // 若为同步请求 不经过回调函数 if (!defaults.async) &#123; if (defaults.dataType === 'json') &#123; return JSON.parse(xhr.responseText) &#125;else&#123; return xhr.responseText &#125; &#125; // 4 指定回调函数(异步) 处理服务器返回值 xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (shr.status === 200) &#123; let data = xhr.responseText if (defaults.dataType === 'json') &#123; data = JSON.parse(data) &#125; defaults.success(data) &#125; &#125; &#125; &#125;&#125; jsonp案例之百度智能搜索提示12345&lt;div id=\"container\"&gt; &lt;input type=\"text\" id=\"keyword\" name=\"keyword\" placeholder=\"请输入搜索内容……\"&gt; &lt;input type=\"button\" value=\"百度一下\" id=\"query\"&gt; &lt;div id=\"info\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617#container&#123; width: 400px; height: 300px; background-color: #ccc; margin: 100px auto; text-align: center&#125;#keyword&#123; width: 300px;&#125;input&#123; height: 30px; font-size: 18px&#125;#query&#123; width: 80px;&#125; 1234567891011121314151617181920212223$(function () &#123; $('#keyword').keyup(function () &#123; var ul = document.createElement('ul') var info = document.getElementById('info') info.innerHTML = '' //清空之前的内容 var kw = $(this).val() $.ajax(&#123; url: 'https://www.baidu.com/sugrec?pre=1&amp;p=3&amp;ie=utf-8&amp;json=1&amp;prod=pc&amp;from=pc_web&amp;sugsid=1458,21089,29522,29518,29099,29568,28833,29221,22160', jsonp: 'cb', data: &#123;wd: kw&#125;, dataType: 'jsonp', success: function (data) &#123; var query = data.g for (let i = 0; i &lt; query.length; i++) &#123; var li = document.createElement('li') li.innerText = query[i].q ul.appendChild(li) &#125; info.appendChild(ul) &#125; &#125;) &#125;)&#125;) 有事您Q我👇","categories":[{"name":"ajax-跨域","slug":"ajax-跨域","permalink":"https://shulu520.com/categories/ajax-跨域/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"https://shulu520.com/tags/ajax/"},{"name":"jsonp","slug":"jsonp","permalink":"https://shulu520.com/tags/jsonp/"}]},{"title":"ajax","slug":"ajax","date":"2019-08-11T03:56:12.000Z","updated":"2019-08-11T04:01:58.829Z","comments":true,"path":"ajax/ajax/","link":"","permalink":"https://shulu520.com/ajax/ajax/","excerpt":"&emsp;&emsp;全力以赴——全力以赴就是想尽所有的办法，用尽所有的资源。","text":"&emsp;&emsp;全力以赴——全力以赴就是想尽所有的办法，用尽所有的资源。 ajax即XMLHttpRequest&emsp;&emsp;Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。&emsp;&emsp;Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。&emsp;&emsp;传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 原生ajax1234567891011// 创建XMLHttpRequestvar xhr = new XMLHttpRequest()// 准备发送请求 请求方式 地址 是否异步xhr.open('get', 'xxx.com/data', true) //true异步// 执行发送动作xhr.send(null)// 指定回调函数xhr.onreadystatechange = function () &#123; &#125; jQuery中的ajax1234567891011$.ajax(&#123; type: '请求方式', url: '请求地址', dataType: 'json', success: function (data) &#123; // do something &#125;, error: function (data) &#123; // do something &#125;&#125;) 模仿封装jQuery中的ajax123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function ajax (obj) &#123; // Ajax默认参数 let defaults = &#123; type: 'get', data: &#123;&#125;, url: '#', dataType: 'text', async: true, success: function (data) &#123; console.log(data) &#125; &#125; // 遍历obj对象 覆盖defaults对象 没有覆盖的即为默认值 for (const key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; defaults[key] = obj[key] &#125; &#125; // 1 创建Ajax对象 let xhr = new XMLHttpRequest() // 处理defaults.data 将对象形式参数拼接成参数字符串 // 即 name=yachan&amp;age=18 的形式 let param = '' for (const key in defaults.data) &#123; if (defaults.data.hasOwnProperty(key)) &#123; param += key + '=' + defaults.data[key] + '&amp;' &#125; &#125; // 去掉最后一个&amp;符号 if (param) &#123; param = param.substring(0, param.length - 1) &#125; // 若为get请求 则直接往url后面拼接参数 if (defaults.type === 'get') &#123; defaults.url += '?' + encodeURI(param) //编码中文 防止出现乱码 &#125; // 若为post请求 let data = null if (defaults.type === 'post') &#123; data = param // 设置请求头(必须设置) xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded') &#125; // 2 准备发送 设置发送参数 xhr.open(defaults.type, defaults.url, defaults.async) // 3 发送请求 执行发送动作 xhr.send(data) // 若为同步请求 不经过回调函数 if (!defaults.async) &#123; if (defaults.dataType === 'json') &#123; return JSON.parse(xhr.responseText) &#125;else&#123; return xhr.responseText &#125; &#125; // 4 指定回调函数(异步) 处理服务器返回值 xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (shr.status === 200) &#123; let data = xhr.responseText if (defaults.dataType === 'json') &#123; data = JSON.parse(data) &#125; defaults.success(data) &#125; &#125; &#125;&#125; 有事您Q我👇","categories":[{"name":"ajax","slug":"ajax","permalink":"https://shulu520.com/categories/ajax/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"https://shulu520.com/tags/ajax/"}]},{"title":"js-Regex","slug":"js-正则表达式","date":"2019-08-10T08:14:36.000Z","updated":"2019-08-10T08:20:50.217Z","comments":true,"path":"Regex/js-正则表达式/","link":"","permalink":"https://shulu520.com/Regex/js-正则表达式/","excerpt":"&emsp;&emsp;淡定的人生不寂寞——繁华过后是寂寞，绚烂过后是平淡，保持淡定的人，一定是最美丽最幸福的人。","text":"&emsp;&emsp;淡定的人生不寂寞——繁华过后是寂寞，绚烂过后是平淡，保持淡定的人，一定是最美丽最幸福的人。 正则表达式&emsp;&emsp; 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 正则表达式的作用 给定的字符串是否符合正则表达式的过滤逻辑(匹配) 可以通过正则表达式，从字符串中获取我们想要的特定部分(提取) 强大的字符串替换能力(替换) 正则表达式的组成&emsp;&emsp; 普通字符&emsp;&emsp; 特殊字符(元字符)：正则表达式中有特殊意义的字符 常用元字符串 元字符 说明 \\d 匹配数字 \\D 匹配任意非数字的字符 \\w 匹配字母或数字或下划线 \\W 匹配任意不是字母，数字，下划线 \\s 匹配任意的空白符 \\S 匹配任意不是空白符的字符 . 匹配除换行符以外的任意单个字符 ^ 表示匹配行首的文本(以谁开始) $ 表示匹配行尾的文本(以谁结束) 限定符 限定符 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 其它1234567891011121314[] 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思[^] 匹配除中括号以内的内容\\ 转义符| 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱() 从两个直接量中选择一个，分组 eg：gr(a|e)y匹配gray和grey()作为分组来使用，获取分组匹配到的结果用Regex.$1 $2 $3....来获取var reg = /(\\d&#123;4&#125;)-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;/;if (reg.test(dateStr)) &#123; console.log(RegExp.$1);&#125;[\\u4e00-\\u9fa5] 匹配汉字 任意一个汉字 正则表达式的方法Regexp对象 有两个&emsp;&emsp; test()检测 布尔值&emsp;&emsp; exec()提取 只返回一个匹配到的结果 若要提取多个值则得循环进行提取 String对象 有四个&emsp;&emsp; match()提取多个内容 返回一个数组 &emsp;&emsp; replace(reg, 替换字符)替换&emsp;&emsp; replace的参数可以是函数而不是字符串，每个匹配都会调用该函数，它返回的字符串将作为替换的文本使用。 &emsp;&emsp; split(delimiter, limit) 切割字符串 返回一个字符串数组 1234567split()方法可以把调用它的字符串分解为一个字串数组，使用的分隔符是它的参数。参数：delimiter：字符串或者正则表达式，从该参数指定的地方分割字符串。limit：指定返回数组的最大长度，如果没有设置该参数，则整个字符串都会被分割。 &emsp;&emsp; search() 查找并且返回第一个匹配字串的第一个字符的位置。如果没有找到任何匹配的字串，则返回-1。 非贪婪模式 ?表示&emsp;&emsp; 所谓的”贪婪”的意思就是，如果符合要求就一直往后匹配，一直到无法匹配为止，这就是贪婪模式。&emsp;&emsp; 所谓的非贪婪模式就是一旦匹配到合适的就结束，不在继续匹配下去了。 12345贪婪模式的标示符：+，？，*，&#123;n&#125;,&#123;n,&#125;,&#123;n,m&#125;非贪婪模式: +？，？？，*？？，&#123;n&#125;?，&#123;n,&#125;?,&#123;n,m&#125;? 有事您Q我👇","categories":[{"name":"Regex","slug":"Regex","permalink":"https://shulu520.com/categories/Regex/"}],"tags":[{"name":"Regex","slug":"Regex","permalink":"https://shulu520.com/tags/Regex/"}]},{"title":"js-obj-clone","slug":"js-面向对象-深度克隆","date":"2019-08-10T07:04:03.000Z","updated":"2019-08-17T08:34:28.348Z","comments":true,"path":"deepClone/js-面向对象-深度克隆/","link":"","permalink":"https://shulu520.com/deepClone/js-面向对象-深度克隆/","excerpt":"&emsp;&emsp;步履不停——只管走过去，不要都逗留着去采了花朵来保存，因为一路上花朵会继续开放。","text":"&emsp;&emsp;步履不停——只管走过去，不要都逗留着去采了花朵来保存，因为一路上花朵会继续开放。 深度克隆数据类型 数据分为基本的数据类型(String, Number, boolean, Null, Undefined)和对象数据类型 基本数据类型：特点： 存储的是该对象的实际数据 对象数据类型：特点： 存储的是该对象在栈中引用，真实的数据存放在堆内存里 复制数据基本数据类型存放的就是实际的数据，可直接复制12let number2 = 2;let number1 = number2; 克隆数据：对象/数组 区别： 浅拷贝/深度拷贝 1234判断： 拷贝是否产生了新的数据还是拷贝的是数据的引用知识点：对象数据存放的是对象在栈内存的引用，直接复制的是对象的引用let obj = &#123;username: 'kobe'&#125;let obj1 = obj; // obj1 复制了obj在栈内存的引用 常用的拷贝技术 12345671. arr.concat(): 数组浅拷贝2. arr.slice(): 数组浅拷贝3. Object.assign() 对象浅拷贝4. JSON.parse(JSON.stringify(arr/obj)): 数组或对象深拷贝, 但不能处理函数数据5. 浅拷贝包含函数数据的对象/数组6. 深拷贝包含函数数据的对象/数组 深度克隆123456789101112131415161718192021222324252627282930313233343536373839404142// 检测数据类型function checkedType (target) &#123; return Object.prototype.toString.call(target).slice(8, -1) // Object.prototype.toString.call() 返回值[Object xxx]&#125;// 深度克隆function deepClone (target) &#123; let result, //最终返回值 targetType = checkedType(target) //要克隆的目标对象的数据类型 if (targetType === 'Object') &#123; result = &#123;&#125; //初始化为一个空对象 &#125;else if (targetType === 'Array') &#123; result = [] //初始化为一个空数组 &#125;else &#123; return target &#125; // 能走到这里说明要克隆的对象的数据类型为对象或者数组 // 遍历目标对象 for (let i in target) &#123; // 枚举对象则i为key // 枚举数组则i为index if (target.hasOwnProperty(i)) &#123;//目标对象自身的属性 不要原型对象上的属性 let value = target[i] if (checkedType(value) === 'Object' || 'Array') &#123; result[i] = deepClone(value)//递归方法 &#125;else &#123; result[i] = value &#125; &#125; &#125; return result&#125;// 测试代码let arr = [1, &#123;name: 'shulu', age: 18&#125;, [2, 3, &#123;sex: '女神'&#125;]]let cloneArr = deepClone(arr)cloneArr[1].name = 'yachan'cloneArr[2][2].sex = '男生'console.log('cloneArr :', cloneArr);console.log('arr :', arr); 有事您Q我👇","categories":[{"name":"deepClone","slug":"deepClone","permalink":"https://shulu520.com/categories/deepClone/"}],"tags":[{"name":"clone","slug":"clone","permalink":"https://shulu520.com/tags/clone/"}]},{"title":"js-inherit","slug":"js-面向对象-继承","date":"2019-08-07T08:27:59.000Z","updated":"2019-08-18T07:08:48.291Z","comments":true,"path":"js-oop/js-面向对象-继承/","link":"","permalink":"https://shulu520.com/js-oop/js-面向对象-继承/","excerpt":"&emsp;&emsp;坚持下去——哪有什么天才，坚持做你喜欢的事情，这本身就是一种天赋。","text":"&emsp;&emsp;坚持下去——哪有什么天才，坚持做你喜欢的事情，这本身就是一种天赋。 一：原型继承–适合继承父类原型上的-方法 即把父类构造函数的一个实例赋值给子类构造函数作为原型对象 实现demo1234567891011121314151617181920212223242526// 父类function Person (name, age, sex) &#123; this.name = name this.age = age this.sex = sex&#125;Person.prototype.test = function () &#123; console.log('Person父类原型上的方法test')&#125;// 子类function Student (score) &#123; this.score = score&#125;// 子类构造函数的原型对象初始化时只能传一次值// 所以后面子类实例化时无法设置继承自父类构造函数的参数Student.prototype = new Person('ls', 18, '男')Student.prototype.constructor = Student //修正constructor的指向var student1 = new Student(80)var student2 = new Student(90)console.dir(student1) //name等属性都设置不了console.dir(student2) //name等属性都设置不了console.log('student1.test() :', student1.test()) //可以调用 原型继承的缺点：&emsp;&emsp;继承时无法设置父类构造函数的参数，即无法个性化继承来的属性值&emsp;&emsp;还有：父类原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！ 二：借用构造函数(假继承)–适合继承父类构造函数的-属性 在子类构造函数中使用call执行父类构造函数 demo实现12345678910111213141516171819202122232425function Person (name, age, sex) &#123; this.name = name this.age = age this.sex = sex&#125;Person.prototype.test = function () &#123; console.log('Person父类原型上的方法')&#125;function Student (name, age, sex, score) &#123; Person.call(this, name, age, sex) this.score = score&#125;var s1 = new Student('娅蝉', 18, '女', 99)var s2 = new Student('秋云', 22, '男', 66)console.log('s1 :', s1) //okconsole.log('s2 :', s2) //okconsole.log('s1.test :', s1.test) //undefined console.log('s1.test() :', s1.test()) //报错// 因为test方法在父类的原型对象上，只有其实例才可以调用// 子类借用父类构造函数，并没有生成实例去调用父类原型上的方法 借用构造函数的缺点： 显而易见的，子类实例继承不了父类原型上的方法 三：组合继承=原型继承+借用构造函数1234567891011121314151617181920212223function Person (name, age, sex) &#123; this.name = name this.age = age this.sex = sex&#125;Person.prototype.test = function () &#123; return 'Person父类原型上的方法'&#125;function Student (name, age, sex, score) &#123; Person.call(this, name, age, sex) this.score = score&#125;Student.prototype = new Person()Student.prototype.constructor = Student //修正constructor的指向var s3 = new Student('娅蝉', 18, '女', 99)var s4 = new Student('秋云', 22, '男', 66)console.log('s1 :', s3) //okconsole.log('s2 :', s4) //okconsole.log('s3.test() :', s3.test()) //ok 组合继承的优化–寄生组合式继承&emsp;&emsp;1. 在借用构造函数中，已经继承到了父类的属性，所以原型继承中只继承父类的方法就行了 12将 Student.prototype = new Person()优化为：Student.prototype = Person.prototype &emsp;&emsp;2. 经过上一次优化后，将父类原型对象的值(地址值)赋给子类，此时父类子类的原型对象为同一个对象，修改其中的一个另一个也会跟着变。给子类原型添加某方法，父类原型也有了这个方法，这显然不是我们想要的结果。 &emsp;&emsp;3. Object.create()方法创建一个新对象，使用现有的对象(当作参数)来提供新创建的对象的proto。这里不是直接引用Parent.prototype，而是借助它创建一个新的对象，从而实现父子构造函数原型对象的隔离。 最佳版本： 12最优解为：Student.prototype = Object.create(Person.prototype) 测试 12345678910111213141516171819202122232425262728function Person (name, age, sex) &#123; this.name = name this.age = age this.sex = sex&#125;Person.prototype.test = function () &#123; console.log('hello,' + this.name)&#125;function Student (name, age, sex, score) &#123; Person.call(this, name, age, sex) this.score = score&#125;Student.prototype = Object.create(Person.prototype)Student.prototype.constructor = StudentStudent.prototype.sayHi = function () &#123; console.log('hi,' + this.name);&#125;var s3 = new Student('娅蝉', 18, '女', 99)var s4 = new Student('秋云', 22, '男', 66)console.log('s3 :', s3)console.log('s4 :', s4)s3.test()s4.sayHi() //完美 扩展-Object.cerate方法的实现123456function createObject (obj) &#123; function F () &#123;&#125; F.prototype = obj return new F()&#125;//亲测有效 四：ES6之calss类继承 用 class 定义类 用 constructor() 定义构造方法(相当于构造函数) 一般方法: xxx () {} 必须这么写 用extends来定义子类 继承父类 用super()来调用父类的构造方法 子类方法自定义: 将从父类中继承来的方法重新实现一遍 js中没有方法重载(方法名相同, 但参数不同)的语法 123456789101112131415161718192021222324252627class Person &#123; // 类的构造方法 constructor(name, age) &#123; this.name = name this.age = age &#125; // 类的一般方法 showInfo () &#123; console.log(`my name is $&#123;this.name&#125;.`); console.log(`I am $&#123;this.age&#125; years old.`); &#125;&#125;class starPerson extends Person &#123; constructor (name, age, salary) &#123; super(name, age)//调用父类的构造方法 this.salary = salary &#125; showSalary () &#123; console.log(`my salary is $&#123;this.salary&#125; ￥`); &#125;&#125;let star = new starPerson('yachan', 18, 9999999999)console.log('star :', star);star.showInfo()star.showSalary() 有事您Q我👇","categories":[{"name":"js-oop","slug":"js-oop","permalink":"https://shulu520.com/categories/js-oop/"}],"tags":[{"name":"inherit","slug":"inherit","permalink":"https://shulu520.com/tags/inherit/"}]},{"title":"js-BOM-web-api","slug":"js-组成-BOM-web-api","date":"2019-08-03T10:55:18.000Z","updated":"2019-08-12T14:57:09.867Z","comments":true,"path":"js-BOM/js-组成-BOM-web-api/","link":"","permalink":"https://shulu520.com/js-BOM/js-组成-BOM-web-api/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; BOM模态框操作 alert() 只有确定按钮 confirm() 可带提示文本 确定取消按钮 prompt() 可带提示文本 带文本输入框 确定取消按钮 12345678910if (window.confirm(\"Do you really want to leave?\")) &#123; alert(\"Thanks for Visiting!\")&#125;let sign = prompt(\"你是什么星座的?\")if (sign == \"天蝎座\")&#123; alert(\"哇! 我也是天蝎座的耶!\")&#125; window.prompt('你觉得很幸运吗?','是的') 默认为是的 window页面加载&emsp;&emsp;window.onload() 当页面加载完成执行 当页面完全加载所有内容（包括图像、脚本文件、CSS 文件等）执行&emsp;&emsp;window.onunload() 当用户退出页面时执行 浏览器窗口活跃监听-页面失去焦点获得焦点123456789 window.onblur = function () &#123; document.title = '欢迎你嗷~~^-^' setTimeout(() =&gt; &#123; document.title = '原来的title' &#125;, 1000);&#125; window.onfocus = function () &#123; document.title = '别离开我嘛^-^'&#125; location对象 location对象是window对象下的一个属性. location可以获取或者设置浏览器地址栏的URL URL 统一资源定位符 (Uniform Resource Locator, URL) URL的组成 12345678910111213scheme://host:port/path?query#fragmentscheme:通信协议 常用的http,ftp,maito等host:主机 服务器(计算机)域名系统 (DNS) 主机名或 IP 地址。port:端口号 整数，可选，省略时使用方案的默认端口，如http的默认端口为80。path:路径 由零或多个'/'符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。query:查询 可选，用于给动态网页传递参数，可有多个参数，用'&amp;'符号隔开，每个参数的名和值用'='符号隔开。例如：name=zsfragment:信息片断 字符串，锚点. 1234567891011let url = document.createElement('a');url.href = 'https://developer.mozilla.org/en-US/search?q=URL#search-results-close-container';console.log(url.href); // https://developer.mozilla.org/en-US/search?q=URL#search-results-close-containerconsole.log(url.protocol); // https:console.log(url.host); // developer.mozilla.orgconsole.log(url.hostname); // developer.mozilla.orgconsole.log(url.port); // (blank - https assumes port 443)console.log(url.pathname); // /en-US/searchconsole.log(url.search); // ?q=URLconsole.log(url.hash); // #search-results-close-containerconsole.log(url.origin); // https://developer.mozilla.org history对象 back() forward() go() window.navigator对象&emsp;&emsp;window.navigator.userAgent 通过userAgent可以判断用户浏览器的类型&emsp;&emsp;window.navigator.platform 通过platform可以判断浏览器所在的系统平台类型. 高度宽度offset偏移量 client可视区 scroll滚动条 screen屏幕 body身上 12345678910111213网页可见区域宽：document.body.clientWidth 网页可见区域高：document.body.clientHeight 网页被卷去的高：document.body.scrollTop 网页被卷去的左：document.body.scrollLeft 网页正文全文宽：document.body.scrollWidth 网页正文全文高：document.body.scrollHeight 浏览器上边框距离屏幕上边框：window.screenTop 浏览器左边框距离屏幕左边框：window.screenLeft 屏幕分辨率的高：window.screen.height 屏幕分辨率的宽：window.screen.width element元素身上 123456789101112131415161718192021222324252627clientWidth和clientHeight：元素的可视部分宽度和高度即content宽 + padding(有则加上两边padding) - 滚动条宽(有则减去就行)clientLeft和clientTop：元素的border部分宽度和高度offsetParent：用于获取定位的父级元素offsetWidth和offsetHeight：整个容器的宽高,以一个外人的角度看即元素的border+padding+content的宽度和高度该属性和其内部的内容是否超出元素大小无关，只和本来设置的border以及width和height有关。offsetLeft参照最近的定位父级，没有则参照body即定位父级的border-left + 自身定位的left + 自身的margin-leftscrollWidth子元素整个宽 + 自身padding-leftscrollTop和scrollLeft：这对元素是可读写的，指的是当元素其中的内容超出其宽高的时候，元素被卷起的宽度和高度。 demo瀑布流123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;瀑布流&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #box &#123; position: relative; margin: 0 auto &#125; img &#123; width: 220px; display: block; &#125; .item &#123; box-shadow: 2px 2px 2px #999; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"box\"&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/0.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/1.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/22.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/3.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/4.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/5.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/6.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/7.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/8.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/9.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/10.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/11.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/12.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/13.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/14.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/15.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/16.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/17.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/18.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/19.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/20.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/21.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/22.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/1.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/0.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/11.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/10.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/14.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/20.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;img style=\"width:200px\" src=\"waterfall/17.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var box = document.getElementById('box'); var items = box.children; // 定义每一列之间的间隙 为10像素 var gap = 10; window.onload = function () &#123; // 一进来就调用一次 waterFall(); // 封装成一个函数 function waterFall() &#123; // 1- 确定列数 = 页面的宽度 / 图片的宽度 var pageWidth = getClient().width; var itemWidth = items[0].offsetWidth; var columns = parseInt(pageWidth / (itemWidth + gap)); var arr = []; for (var i = 0; i &lt; items.length; i++) &#123; if (i &lt; columns) &#123; // 2- 确定第一行 items[i].style.top = 0; items[i].style.left = (itemWidth + gap) * i + 'px'; arr.push(items[i].offsetHeight); &#125; else &#123; // 其他行 // 3- 找到数组中最小高度 和 它的索引 var minHeight = arr[0]; var index = 0; for (var j = 0; j &lt; arr.length; j++) &#123; if (minHeight &gt; arr[j]) &#123; minHeight = arr[j]; index = j; &#125; &#125; // 4- 设置下一行的第一个盒子位置 // top值就是最小列的高度 + gap items[i].style.top = arr[index] + gap + 'px'; // left值就是最小列距离左边的距离 items[i].style.left = items[index].offsetLeft + 'px'; // 5- 修改最小列的高度 // 最小列的高度 = 当前自己的高度 + 拼接过来的高度 + 间隙的高度 arr[index] = arr[index] + items[i].offsetHeight + gap; &#125; &#125; &#125; // 页面尺寸改变时实时触发 var timer = null; window.onresize = function () &#123; //节流操作 clearTimeout(timer); timer = setTimeout(function () &#123; waterFall(); // console.log(1); &#125;, 200); &#125;; // 当加载到第30张的时候 var timer1 = null; window.onscroll = function () &#123; clearTimeout(timer1); //节流操作 timer1 = setTimeout(function () &#123; if (getClient().height + getScrollTop() &gt;= items[items.length - 1].offsetTop) &#123; // 模拟 ajax 获取数据 var datas = [ \"waterfall/ac83da565dfbb2ba9d8df0e8b360f0ee.jpg\", \"waterfall/c452a945a2649696beb03d892176d031.jpg\", \"waterfall/ac83da565dfbb2ba9d8df0e8b360f0ee.jpg\", \"waterfall/c452a945a2649696beb03d892176d031.jpg\", \"waterfall/ac83da565dfbb2ba9d8df0e8b360f0ee.jpg\" ]; for (var i = 0; i &lt; datas.length; i++) &#123; var div = document.createElement(\"div\"); div.className = \"item\"; div.innerHTML = '&lt;img style=\"width:200px\" src=\"' + datas[i] + '\" alt=\"\"&gt;'; box.appendChild(div); &#125; waterFall(); &#125; &#125;, 200); &#125;; &#125;; // clientWidth 处理兼容性 function getClient() &#123; return &#123; width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth, height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight &#125; &#125; // scrollTop兼容性处理 function getScrollTop() &#123; return window.pageYOffset || document.documentElement.scrollTop; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 有事您Q我👇","categories":[{"name":"js-BOM","slug":"js-BOM","permalink":"https://shulu520.com/categories/js-BOM/"}],"tags":[{"name":"BOM","slug":"BOM","permalink":"https://shulu520.com/tags/BOM/"}]},{"title":"js-DOM","slug":"js-组成-DOM-基本操作","date":"2019-08-03T10:53:10.000Z","updated":"2019-08-12T15:03:29.355Z","comments":true,"path":"DOM/js-组成-DOM-基本操作/","link":"","permalink":"https://shulu520.com/DOM/js-组成-DOM-基本操作/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; dom获取 JS获取DOM元素的方法（8种） 123456789通过ID获取 getElementById通过name属性 getElementsByName通过标签名 getElementsByTagName通过类名 getElementsByClassName获取html的方法 document.documentElement获取body的方法 document.body通过选择器获取一个元素 querySelector通过选择器获取一组元素 querySelectorAll html属性操作dataset H5自定义属性操作&emsp;&emsp;在通过dataset添加自定义属性的时候，不能带有”data-“。浏览器会自动添加data-。&emsp;&emsp;data-前缀后面的属性名称也可以带有连字符。&emsp;&emsp;当使用dataset属性进行动态操作的时候，需要转换连字符为驼峰写法，结果显示为连字符。 123456添加自定义属性 并赋值div.dataset.shulu=\"舒璐\";div.dataset.lqyLove = \"哈哈哈\" //想要lqy-love写法，但得驼峰写法，最终显示为lqy-love 浏览器查看结果为：&lt;div data-shulu=\"舒璐\" data-lqy-love=\"哈哈哈\"&gt;&lt;/div&gt; getAttribute/setAttribute属性操作 getAttribute() 获取标签行内属性 setAttribute() 设置标签行内属性 removeAttribute() 移除标签行内属性 如果一个属性可能不存在于指定的元素上，在调用 getAttribute() 之前，你应该使用 element.hasAttribute() 来检测该属性是否存在。 dataset与getAttribute/setAttribute的区别: getAttribute和setAttribute方法也可以设置和获取元素的属性，主要区别如下： 上述两方法更加博爱，无论是否符合data-*语法格式，都可以顺利获取或者设置。 dataset则是专门针对符合HTML5规范的自定义属性的管理，更加方便。 dataset属性返回值是DOMStringMap对象，也就是说针对DOMStringMap对象的操作，然后影响到HTML元素，而getAttribute/setAttribute方法则是针对字符串的操作。 获取操作样式属性 获取元素的行间样式属性 element.style.样式属性 读取的样式是最终样式属性 getComputedStyle(element, 样式属性) 取相应属性值得时候都是采用的 CSS 驼峰式写法. element.style 既支持读也支持写，我们通过 element.style 即可改写元素的样式。 而 getComputedStyle 仅支持读并不支持写入。我们可以通过使用 getComputedStyle 读取样式，通过 element.style 修改样式 12345获取最终样式属性方法function getComputed (ele, prop) &#123; return ele.currentStyle ? ele.currentStyle(prop) : window.getComputedStyle(ele, null)[prop]&#125; classList 类名操作 add()：添加样式类。 item()：返回指定索引的样式类。 remove()：删除指定样式类。 toggle()：切换样式类 contains() 检查是否包含某属性 1234567891011app.classList.add('love')console.log(app.classList.item(0))app.classList.remove('lqy')document.addEventListener('click', () =&gt; &#123; app.classList.toggle('love')&#125;)console.log( app.classList.contains('shulu')) 节点操作 appendChild() insertBefore() removeChild() replaceChild() 1234567891011var body = document.body;var div = document.createElement('div');body.appendChild(div);var firstEle = body.children[0];body.insertBefore(div, firstEle);body.removeChild(firstEle);var text = document.createElement('p');body.replaceChild(text, div); 节点/元素层级获取 节点包括了text文本节点等 元素只是就是HTML元素 12345678910let app = document.getElementById('app') console.log(app.parentNode) // 父节点console.log(app.childNodes) // 子节点集合console.log(app.children) // 子元素console.log(app.nextSibling) // 下一个兄弟节点console.log(app.previousSibling) // 下一个兄弟节点console.log(app.firstChild) // 第一个子节点console.log(app.lastChild) // 最后一个子节点console.log(app.nextElementSibling) // 下一个兄弟元素console.log(app.previousElementSibling) // 上一个兄弟元素 Dom事件##基本概念 Dom事件级别 123Dom 0级事件：element.onclick = function() &#123;...&#125;Dom 2级事件：element.addEventListener('click', function() &#123;...&#125;)Dom 3级事件：element.addEventListener('keyup', function() &#123;...&#125;) 鼠标事件 键盘事件 Dom事件模型 事件捕获 由上到下 事件冒泡 由下到上 Dom事件流 捕获阶段 由上到下 目标阶段 冒泡阶段 由下到上 描述Dom事件捕获的具体流程123456window document html (用js获取html标签：document.documentElement) body ... 目标元素 捕获阶段触发事件 addEventListener的第三个参数为true即可12345678910111213span.addEventListener('click', () =&gt; &#123; console.log('span') console.log('以上事件为捕获阶段触发的')&#125;, true)window.addEventListener('click', () =&gt; &#123; console.log('window')&#125;, true)document.addEventListener('click', () =&gt; &#123; console.log('document')&#125;, true)document.documentElement.addEventListener('click', () =&gt; &#123; console.log('html')&#125;, true) 冒泡阶段触发事件12345678910111213window.addEventListener('click', () =&gt; &#123; console.log('window')&#125;)document.addEventListener('click', () =&gt; &#123; console.log('document')&#125;)document.documentElement.addEventListener('click', () =&gt; &#123; console.log('html')&#125;)span.addEventListener('click', () =&gt; &#123; console.log('以下事件为冒泡阶段触发的') console.log('span')&#125;) Event对象的常见应用123456789101112131415161718192021222324event.preventDefault() 阻止默认事件event.stopPropagation() 阻止事件冒泡event.stopImmediatePropagation() 阻止事件冒泡并且阻止相同事件的其他侦听器被调用。event.currentTarget 事件的当前目标。它总是指向事件绑定的元素。通常为父元素。代理事件的元素。event.target 触发事件的对象 (某个DOM元素) 的引用。通常为子元素。 常见如 event.target.nodeName.toLowerCase() == 'li'const p = document.querySelector('p');p.addEventListener(\"click\", (event) =&gt; &#123; alert(\"我是p元素上被绑定的第一个监听函数\"); &#125;, false);p.addEventListener(\"click\", (event) =&gt; &#123; alert(\"我是p元素上被绑定的第二个监听函数\"); event.stopImmediatePropagation(); //执行stopImmediatePropagation方法,阻止click事件冒泡,并且阻止p元素上绑定的其他click事件的事件监听函数的执行.&#125;, false);p.addEventListener(\"click\",(event) =&gt; &#123; alert(\"我是p元素上被绑定的第三个监听函数\"); // 该监听函数排在上个函数后面，该函数不会被执行&#125;, false); 自定义事件 创建一个自定义事件 123456789let myevent = new Event('custom')// 监听事件btn.addEventListener('custom', () =&gt; &#123; alert('custom事件触发了')&#125;)// 触发事件 自定义触发条件setTimeout(() =&gt; &#123; btn.dispatchEvent(myevent)&#125;,1000) 有事您Q我👇","categories":[{"name":"DOM","slug":"DOM","permalink":"https://shulu520.com/categories/DOM/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"https://shulu520.com/tags/DOM/"}]},{"title":"js-ECMAScript","slug":"js-组成-ES-语法基础","date":"2019-08-02T04:27:13.000Z","updated":"2019-08-12T15:11:35.205Z","comments":true,"path":"ECMAScript/js-组成-ES-语法基础/","link":"","permalink":"https://shulu520.com/ECMAScript/js-组成-ES-语法基础/","excerpt":"&emsp;&emsp;珍惜自己——何必为昨天的泪，打湿今天的阳光。","text":"&emsp;&emsp;珍惜自己——何必为昨天的泪，打湿今天的阳光。 运算符的优先级 圆括号 最高 () 成员访问 . 和[] 后置递增和递减 a++ 和 a– 逻辑非、一元正号和负号、前置递增和递减 !a +a -a ++a –a 以及typeof 幂运算 2**3 乘法 除法 取模 a*3 a/3 a%3 加减法 a+3 a-3 关系运算符 大于小于 大于等于 小于等于 以及instanceof 相等运算符 == != === !== 逻辑运算符 先逻辑与&amp;&amp; 后逻辑非|| 条件运算符 (三目) … ? … : … 赋值运算符 = += -= *= /= %= switch 该语句在比较值时使用的是全等操作符, 因此不会发生类型转换 #布尔类型的隐式转换 流程控制语句会把后面的值隐式转换成布尔类型 转换为true 非空字符串 非0数字 true 任何对象 转换成false 空字符串 0 false null undefined continue和break break:立即跳出整个循环，即循环结束，开始执行循环后面的内容（直接跳到大括号） continue:立即跳出当前循环，继续下一次循环（跳到i++的地方） 123456789let sum = 0for (let i = 0; i &lt; 10; i++) &#123; if (i % 2 == 0) continue sum += i&#125;alert(sum) 代码调试过去调试js的方式 alert() console.log() 断点调试 断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。 调试步骤1浏览器中按F12--&gt;sources--&gt;找到需要调试的文件--&gt;在程序的某一行设置断点 调试中的相关操作1234567Watch: 监视，通过watch可以监视变量的值的变化，非常的常用。点击右上角的+号即可添加要监视的变量。F10: 程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。F11：程序单步执行，还会进入函数一步步执行F8：跳到下一个断点处，如果后面没有断点了，则程序执行结束。 tips:监视变量，不要监视表达式，因为监视了表达式，那么这个表达式也会执行。 代码调试的能力非常重要，只有学会了代码调试，才能学会自己解决bug的能力。初学者不要觉得调试代码麻烦就不去调试，知识点花点功夫肯定学的会，但是代码调试这个东西，自己不去练，永远都学不会。 #词法作用域 变量的作用域是在定义时决定而不是执行时决定，也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。 js预解析 JavaScript代码的执行是由浏览器中的JavaScript解析器来执行的。JavaScript解析器执行JavaScript代码的时候，分为两个过程：预解析过程和代码执行过程 预解析过程： 把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值。 把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用。 先提升var，再提升function new关键字 构造函数 ，是一种特殊的函数。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。 构造函数用于创建一类对象，首字母要大写。 构造函数要和new一起使用才有意义。 new在执行时会做四件事情 1234new会在内存中创建一个新的空对象new 会让this指向这个新的对象执行构造函数 目的：给这个新对象加属性和方法new会返回这个新对象 简单数据类型 Number、String、Boolean、Undefined、Null Number类型 数值范围 1234最小值：Number.MIN_VALUE，这个值为： 5e-324最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308无穷大：Infinity无穷小：-Infinity 数值判断 123- NaN：not a number- NaN 与任何值都不相等，包括他本身- isNaN: is not a number String类型 字符串长度length属性用来获取字符串的长度 str面试题 判断一个字符串中出现次数最多的字符，统计这个次数 123456789101112131415161718let str = 'abachgabdjsabas'let obj = &#123;&#125;for (let i = 0; i &lt; str.length; i++) &#123; let item = [str[i]] obj[item] ? obj[item]++ : obj[item] = 1&#125;let max = obj[0], char = ''for (const key in obj) &#123; if (max &lt; obj[key]) &#123; max = obj[key] char = key &#125;&#125;console.log('char :', char);console.log('max :', max); Boolean类型 Boolean字面量：true和false，区分大小写 计算机内部存储：true为1，false为0 Undefined和Null undefined表示一个声明了没有赋值的变量，变量只声明的时候值默认是undefined null表示一个空，变量的值如果想为null，必须手动设置 字面量 在源代码中一个固定值的表示法。 复杂数据类型 Object 数据类型转换 如何使用谷歌浏览器，快速的查看数据类型？ 字符串的颜色是黑色的，数值类型是蓝色的，布尔类型也是蓝色的，undefined和null是灰色的 转换成字符串类型 toString() 12var num = 5;console.log(num.toString()); String() 1String()函数存在的意义：有些值没有toString()，这个时候可以使用String()。比如：undefined和null 拼接字符串方式 num + “”，当 + 两边一个操作符是字符串类型，一个操作符是其它类型的时候，会先把其它类型转换成字符串再进行字符串拼接，返回字符串 转换成数值类型 Number() 1Number()可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回NaN parseInt() 12var num1 = parseInt(\"12.3abc\"); // 返回12，如果第一个字符是数字会解析直到遇到非数字结束var num2 = parseInt(\"abc123\"); // 返回NaN，如果第一个字符不是数字或者符号就直接返回NaN parseFloat() 1234parseFloat()把字符串转换成浮点数parseFloat()和parseInt非常相似，不同之处在与parseFloat会解析第一个. 遇到第二个.或者非数字结束如果解析的内容里只有整数，解析成整数 +，-0等运算 1234var str = '500';console.log(+str); // 取正console.log(-str); // 取负console.log(str - 0); // number: 500 转换成布尔类型 Boolean() 120 ''(空字符串) null undefined NaN 会转换成false 其它都会转换成true Date对象 创建 Date 实例用来处理日期和时间。 Date 对象基于1970年1月1日（世界标准时间）起的毫秒数。 1234// 获取当前时间，UTC世界时间，距1970年1月1日（世界标准时间）起的毫秒数var now = new Date();console.log(now.valueOf()); // 获取距1970年1月1日（世界标准时间）起的毫秒数或now.getTime() Date构造函数的参数 毫秒数 1498099000356 new Date(1498099000356) 日期格式字符串 ‘2015-5-1’ new Date(‘2015-5-1’) 年、月、日 new Date(2015, 4, 1) // 月份从0开始 日期格式化方法1234567toString() // 转换成字符串valueOf() // 获取毫秒值// 下面格式化日期的方法，在不同浏览器可能表现不一致，一般不用toDateString()toTimeString()toLocaleDateString()toLocaleTimeString() 获取日期指定部分12345678910getTime() // 返回毫秒数和valueOf()结果一样， // valueOf()内部调用的getTime()getMilliseconds() getSeconds() // 返回0-59getMinutes() // 返回0-59getHours() // 返回0-23getDay() // 返回星期几 0周日 6周6getDate() // 返回当前月的第几天getMonth() // 返回月份，***从0开始***getFullYear() //返回4位的年份 如 2016 案例 写一个函数，格式化日期对象，返回yyyy-MM-dd HH:mm:ss的形式 123456789101112131415161718192021222324252627let nowDate = new Date()function formatDate(d) &#123; function getTowNum (num) &#123; return num = num &lt; 10 ? '0' + num : num &#125; //如果date不是日期对象，返回 if (!d instanceof Date) &#123; return; &#125; let year = d.getFullYear(), month = d.getMonth() + 1, date = d.getDate(), hour = d.getHours(), minute = d.getMinutes(), second = d.getSeconds(); month = getTowNum(month) date = getTowNum(date) hour = getTowNum(hour) minute = getTowNum(minute) second = getTowNum(second) return year + '-' + month + '-' + date + ' ' + hour + ':' + minute + ':' + second;&#125;console.log('formatDate(nowDate) :', formatDate(nowDate)); 计算时间差，返回相差的天/时/分/秒12345678910111213141516171819function getInterval(start, end) &#123; // interval间距 let day, hour, minute, second, interval; interval = end - start; interval /= 1000; // 得到秒数 day = Math.round(interval / 60 /60 / 24); hour = Math.round(interval / 60 /60 % 24); minute = Math.round(interval / 60 % 60); second = Math.round(interval % 60); return &#123; day: day, hour: hour, minute: minute, second: second &#125;&#125;let futureDate = new Date(2020, 6, 15)console.log('getInterval(nowDate, futureDate) :', getInterval(nowDate, futureDate)); 数组与字符串的转换123456let arr = [1,2,3,4]let str = 'shululqy'console.log('arr.toString() :', arr.toString());console.log('arr.join() :', arr.join());console.log('str.split(',') :', str.split('').join('')); 面试-反转数组12345678910111213141516function myReverse(arr) &#123; if (!arr || arr.length == 0) &#123; return []; &#125; for (var i = 0; i &lt; arr.length / 2; i++) &#123; var tmp = arr[i]; arr[i] = arr[this.length - i - 1]; arr[arr.length - i - 1] = tmp; &#125; return arr;&#125;var array = ['a', 'b', 'c'];console.log(myReverse(array));console.log(array.reverse()); 面试123456789101112131415161718// 找到数组中每一个a出现的位置var array = ['c', 'a', 'z', 'a', 'x', 'a'];function getPosition (array, n) &#123; let arr = [] for (let i = 0; i &lt; array.length; i++) &#123; //if (n === array[i]) &#123; // arr.push(i) //&#125; n === array[i] &amp;&amp; arr.push(i) &#125; let position = arr.map( item =&gt; item + 1).toString() return position&#125;console.log( getPosition(array, 'a')); //2,4,6 面试-编写方法-数组去重1234567891011121314var array = ['c', 'a', 'z', 'a', 'x', 'a'];function uni (array) &#123; let arr = [] for (let i = 0; i &lt; array.length; i++) &#123; if (arr.indexOf(array[i]) === -1) &#123; //indexOf === -1 就是没找到 arr.push(array[i]) &#125; &#125; return arr&#125;console.log('uni(array) :', uni(array)); 有事您Q我👇","categories":[{"name":"ECMAScript","slug":"ECMAScript","permalink":"https://shulu520.com/categories/ECMAScript/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://shulu520.com/tags/es6/"}]},{"title":"npm","slug":"npm","date":"2019-07-31T15:09:04.000Z","updated":"2019-07-31T15:30:03.078Z","comments":true,"path":"npm/npm/","link":"","permalink":"https://shulu520.com/npm/npm/","excerpt":"&emsp;&emsp;随意切换 npm 镜像源。","text":"&emsp;&emsp;随意切换 npm 镜像源。 nrm（node registry manager） nrm 可以解决 npm 镜像访问慢的问题，还可以对各个 npm 的镜像进行速度测试，随意切换 npm 镜像源。 安装 nrm npm install nrm -g nrm 是 npm 的一个模块，我们可以直接使用 npm 进行安装。 对镜像源进行测速 nrm test 我们可以使用 nrm 对 npm 的源进行测速，然后使用当前网络下最快的源。 *代表当前源，从我目前的网速来看，这几个源的状态都还不错，我还是使用 npm 源，因为不会有一些奇怪的 bug 产生。根据你的网速自行选择，如果 npm 源速度不错的话，还是建议使用 npm 源，其次才是 cnpm 和 taobao。 切换源 nrm use taobao 我们在切换源之前要知道具体的源对应的链接，这个时候如果去网上找的话，那就太麻烦了，nrm 也就没什么作用了。 我们切换源的时候，直接使用简称就可以.这个时候再通过 nrm ls 查看源的列表，就会发现我们切换成功了。 有事您Q我👇","categories":[{"name":"npm","slug":"npm","permalink":"https://shulu520.com/categories/npm/"}],"tags":[{"name":"nrm","slug":"nrm","permalink":"https://shulu520.com/tags/nrm/"}]},{"title":"H5-newApi","slug":"H5-newApi","date":"2019-07-31T08:43:44.000Z","updated":"2019-08-18T12:49:58.993Z","comments":true,"path":"H5/H5-newApi/","link":"","permalink":"https://shulu520.com/H5/H5-newApi/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; online网络状态 我们可以通过window.navigator.onLine来检测，用户当前的网络状况，返回一个布尔值， 但是不同浏览器会存在差异. 所以HTML5 给我们提供了2个事件: online和offline 1234567891. 当网络连接到时候 弹出 p 显示网络连接 然后消失window.addEventListener('online', function() &#123; $(\".tips\").text(\"网络已连接\").fadeIn(500).delay(1000).fadeOut();&#125;)2. 当网络断开到时候 弹出 p 显示网络已断开 然后消失window.addEventListener('offline', function() &#123; $(\".tips\").text(\"哎呀，网络断开了\").fadeIn(500).delay(1000).fadeOut();&#125;) dom.requestFullScreen()全屏显示 全屏显示可以是任意元素 H5 API 存在兼容性问题 ie9 + 即使高版本浏览器有兼容性问题 不同浏览器需要添加不同的前缀 webkit moz o ms 1234/* 注意兼容性问题 全屏显示伪类选择器 */div:-webkit-full-screen &#123; background-color: pink;&#125; 123456&lt;div&gt; &lt;img src=\"pic1.png\" height=\"300\" alt=\"\"&gt; &lt;button id=\"full\"&gt;全屏显示&lt;/button&gt; &lt;button id=\"cancelFull\"&gt;取消全屏&lt;/button&gt; &lt;button id=\"isFull\"&gt;是否全屏&lt;/button&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031let div = document.querySelector(\"div\");// 1 单击全屏显示document.querySelector(\"#full\").onclick = function() &#123;// 能力检测 做一个兼容性的解决方法 if(div.requestFullScreen) &#123; // 正常浏览器 div.requestFullScreen(); &#125; else if (div.webkitRequestFullScreen) &#123; // webkit 内核 div.webkitRequestFullScreen(); &#125; else if (div.mozRequestFullScreen) &#123; // moz div.mozRequestFullScreen(); &#125; else if (div.msRequestFullscreen) &#123; // ms 微软 这里面有个坑 别掉进去了 div.msRequestFullscreen(); // ms 里面这样写msRequestFullscreen() s是小写的 &#125; else &#123; // 欧朋 div.oRequestFullScreen(); &#125;&#125;// 2 取消全屏 跟元素没有关系 跟 document有关系document.querySelector(\"#cancelFull\").onclick = function() &#123; document.webkitCancelFullScreen(); // document 退出全屏&#125;// 3 是否全屏显示document.querySelector(\"#isFull\").onclick = function() &#123; alert(document.webkitIsFullScreen); // webkit是否存在 全屏状态&#125; input type=file文件读取并显示demo-可以把上传的文件，文本内容显示到页面？12&lt;input type=\"file\" multiple &gt; //multiple可选择多个文件&lt;div&gt;&lt;/div&gt; 1234567891011121314151617181. 上传我们的文件 let file = document.querySelector(\"input\");let div = document.querySelector(\"div\");当input发生改变的时候 下拉菜单 select 也是这个事件 onchangefile.onchange = function() &#123; console.log(this.files); // 上传文件组成的集合 2. 选择我们要的文件， 进行读取文件里面的内容 let reader = new FileReader(); // 初始化一个文件读取对象reader reader.readAsText(this.files[0]); // 读取this.files[0] 第一个文件对象 3. 读取完毕把读取的内容显示到页面中 reader.onload = function() &#123; div.innerHTML = this.result; //result存储着读取后的内容，这里为文本 &#125;&#125; 上传完毕图片显示缩略图(自己写img的宽高)到页面上123456789101112131415161718&lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;&quot; multiple &gt; &lt;img src=&quot;&quot; alt=&quot;&quot; width=&quot;100&quot;&gt;let file = document.querySelector(&quot;input&quot;);let img = document.querySelector(&quot;img&quot;);file.onchange = function() &#123; let reader = new FileReader(); reader.readAsDataURL(this.files[0]); reader.onload = function() &#123; console.log(this.result); // result为 data: URL 即base64格式的字符串 img.src = this.result; // 把读取的内容赋值给图片 src &#125;&#125; files对象 由于HTML5中我们可以通过为表单元素添加multiple属性，因此我们通过input上传文件后得到的是一个files对象（伪数组形式）。 FileReader对象 FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容. let reader = new FileReader; 可以实例化一个对象 实例方法 FileReader.readAsDataURL() 读取结果为data: URL格式的字符串 FileReader.readAsText() 读取结果为文本字符串 事件监听 onload 当读取完成时触发 属性 result 文件读取结果内容 地理定位 谷歌地理位置定位navigator.geolocation，咱们不用 百度地图 百度地图api 有地理名片等等好多的功能 拖拽 在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。 draggable 属性：就是标签元素要设置draggable=true，否则不会有效果 注意：链接和图片默认是可拖动的，不需要 draggable 属性。 csdn 拖拽和释放 拖拽：drag 释放：drop 拖拽指的是鼠标点击源对象后一直移动对象不松手，一但松手即释放了 拖拽API的相关事件 拖拽API总共就是7个函数！！ 被拖动的源对象可以触发的事件： ondragstart：源对象开始被拖动 ondrag：源对象被拖动过程中(鼠标可能在移动也可能未移动) ondragend：源对象被拖动结束 拖动源对象可以进入到上方的目标对象可以触发的事件： ondragenter：目标对象被源对象拖动着进入 ondragover：目标对象被源对象拖动着悬停在上方 ondragleave：源对象拖动着离开了目标对象 ondrop：源对象拖动着在目标对象上方释放/松手 在拖动的源对象事件和目标对象事件间传递数据 HTML5为所有的拖动相关事件提供了一个新的属性： e.dataTransfer { } 数据传递对象 用于在源对象和目标对象的事件间传递数据 源对象上的事件处理中保存数据： e.dataTransfer.setData( k, v ); k-v必须都是string类型 目标对象上的事件处理中读取数据： let v = e.dataTransfer.getData( k ); HTML5新增的文件操作对象： File： 代表一个文件对象 FileList： 代表一个文件列表对象，类数组 FileReader：用于从文件中读取数据 FileWriter：用于向文件中写出数据 相关函数： 1234567891011121314div.ondrop = function(e)&#123; let file = e.dataTransfer.files[0]; //找到拖放的文件 let reader = new FileReader(); //创建文件读取器 reader.readAsURLData(file); //读取文件内容 reader.onload = function()&#123; //读取完成 img.src = reader.result; //使用读取到的数据 &#125;&#125; demo-从桌面(客户端电脑)拖拽上传头像 好玩好玩 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//样式#container &#123; border: 1px solid #aaa; border-radius: 3px; padding: 10px; margin: 10px; min-height: 400px;&#125;//dom&lt;h3&gt;请拖动您的照片到下方方框区域&lt;/h3&gt;&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;//javascript//监听document的drop事件——取消其默认行为：在新窗口中打开图片document.ondragover = function(e)&#123; e.preventDefault(); //使得drop事件可以触发&#125;document.ondrop = function(e)&#123; e.preventDefault(); //阻止在新窗口中打开图片，否则仍然会执行下载操作！！！&#125;//监听div#container的drop事件，设法读取到释放的图片数据，显示出来container.ondragover = function(e)&#123; e.preventDefault();&#125;container.ondrop = function(e)&#123; console.log(&apos;客户端拖动着一张图片释放了...&apos;) //当前的目标对象读取拖放源对象存储的数据 //console.log(e.dataTransfer); //显示有问题 //console.log(e.dataTransfer.files.length); //拖进来的图片的数量 let f0 = e.dataTransfer.files[0]; //console.log(f0); //文件对象 File //从文件对象中读取数据 let fr = new FileReader(); //fr.readAsText(f0); //从文件中读取文本字符串 fr.readAsDataURL(f0); //从文件中读取URL数据 fr.onload = function()&#123; console.log(&apos;读取文件完成&apos;) console.log(fr.result); let img = new Image(); img.src = fr.result; //URL数据 container.appendChild(img); &#125;&#125; demo-元素单向拖动1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//样式div &#123; width: 200px; height: 200px; border: 1px solid red; float: left; margin: 10px;&#125;div:nth-child(2) &#123; border: 1px solid green;&#125;p &#123; height: 25px; background-color: pink; line-height: 25px; text-align: center;&#125;//dom&lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot; draggable=&quot;true&quot;&gt;拖拽内容1&lt;/p&gt; &lt;p id=&quot;p2&quot; draggable=&quot;true&quot;&gt;拖拽内容2&lt;/p&gt;&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;//javascriptlet obj = null; // 用于存放我们拖放对象 源对象document.ondragstart = function(event) &#123; obj = event.target; // 把当前对象给 obj 然后追加到 新目标对象里面就阔以了&#125;let target = document.querySelector(&quot;#div2&quot;);target.ondragover = function(e) &#123; // 如果想要触发 ondrop 事件 则需要在over 里面 阻止 默认行为 return false; // e.preventDefault()&#125;target.ondrop = function() &#123; // 目标对象. appendChild(源对象) this.appendChild(obj); // 拖拽的时候 ，不用删除原来的 &#125; demo-垃圾箱效果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//stylediv &#123; width: 200px; height: 200px; border: 1px solid red; float: left; margin: 10px;&#125;div:nth-child(2) &#123; width: 300px; line-height: 200px; text-align: center; border: 1px solid green;&#125;p &#123; height: 25px; background-color: pink; line-height: 25px; text-align: center; margin-top: 5px;&#125;//dom&lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot; class=&quot;drag&quot; draggable=&quot;true&quot;&gt;拖拽内容1&lt;/p&gt; &lt;p id=&quot;p2&quot; class=&quot;drag&quot; draggable=&quot;true&quot;&gt;拖拽内容2&lt;/p&gt; &lt;p id=&quot;p3&quot; class=&quot;drag&quot; draggable=&quot;true&quot;&gt;拖拽内容3&lt;/p&gt;&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;垃圾箱&lt;/div&gt;//js let dragList = document.querySelectorAll(&apos;.drag&apos;);//找到全部p元素for(let i=0; i&lt;dragList.length; i++)&#123; //遍历p元素 let p = dragList[i]; p.ondragstart = function(e) &#123; e.dataTransfer.setData(&apos;PlaneID&apos;,this.id);//保存数据--该img元素的id console.log(&apos;this.id :&apos;, this.id); //元素的id属性值 &#125;&#125;let target = document.querySelector(&quot;#div2&quot;);target.ondragover = function(e) &#123; return false; // e.preventDefault()&#125;target.ondrop = function(e) &#123; //删除被拖动的源对象 let id = e.dataTransfer.getData(&apos;PlaneID&apos;);//得到数据--id值 let p = document.getElementById(id); //根据id值找到相关的元素 p.parentNode.removeChild(p); //从父元素中删除子节点&#125; demo-来回拖动元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//csssection&#123; border: 1px solid red; width: 606px; height: 202px;&#125;div &#123; width: 200px; height: 200px; border: 1px solid red; float: left;&#125;div:nth-child(2) &#123; border: 1px solid green;&#125;div:nth-child(3)&#123; border: 1px solid blue;&#125;p &#123; height: 25px; background-color: pink; line-height: 25px; text-align: center; margin-bottom: 5px;&#125;//dom&lt;section id=&quot;section&quot;&gt; &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot; draggable=&quot;true&quot;&gt;拖拽内容1&lt;/p&gt; &lt;p id=&quot;p2&quot; draggable=&quot;true&quot;&gt;拖拽内容2&lt;/p&gt; &lt;p id=&quot;p3&quot; draggable=&quot;true&quot;&gt;拖拽内容3&lt;/p&gt; &lt;p id=&quot;p4&quot; draggable=&quot;true&quot;&gt;拖拽内容4&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt;&lt;/section&gt;//js let section = document.getElementById(&apos;section&apos;)section.ondragstart = function(event) &#123; // 当我们开始拖拽的时候，就存储数据 // 记录 当前源对象的id 名字 event.dataTransfer.setData(&quot;dragId&quot;, event.target.id); &#125; section.ondragover = function(e) &#123; return false; // e.preventDefault()&#125; section.ondrop = function(event) &#123; // 获取 dataTransfer里面的数据 var id = event.dataTransfer.getData(&quot;dragId&quot;); event.target.appendChild(document.getElementById(id)); // 因为我们追加的 源对象p id 只是id名字，需要通过id 获取元素 追加到目标对象里面 // 所以我们 document.getElementById(id)&#125; storage本地存储 随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案。 存储特性 设置、读取方便、页面刷新不丢失数据 容量较大，sessionStorage约5M、localStorage约20M 只能存储字符串，可以将对象JSON.stringify() 编码后存储 方法详解 setItem(key, value) 设置存储内容 getItem(key) 读取存储内容 removeItem(key) 删除键值为key的存储内容 clear() 清空所有存储内容 window.sessionStorage 生命周期为关闭浏览器窗口 在同一个窗口(页面)下数据可以共享 即小范围 短周期 window.localStorage 永久生效，除非手动删除 关闭页面也会存在 可以多窗口（页面）共享（同一浏览器可以共享） 即大范围 长周期 其它新的存储方案 WebSQL IndexDB demo-window.sessionStorage12345678910111213141516171819202122232425262728293031323334353637383940&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;br /&gt;&lt;br /&gt;&lt;button id=&quot;setData&quot;&gt;设置数据&lt;/button&gt;&lt;button id=&quot;getData&quot;&gt;获取数据&lt;/button&gt;&lt;button id=&quot;delData&quot;&gt;删除数据&lt;/button&gt;&lt;button id=&quot;getAge&quot;&gt;getAge&lt;/button&gt;var username = document.querySelector(&quot;#username&quot;);// 点击按钮存取数据 window.sessionStorage.setItem(&quot;age&quot;, 18);window.sessionStorage.setItem(&quot;address&quot;, &quot;北京&quot;);getAge.onclick = function () &#123; alert(window.sessionStorage.getItem(&quot;address&quot;))&#125;document.querySelector(&quot;#setData&quot;).onclick = function() &#123;// 点击之后得到 username 里面值 var val = username.value; // 存储数据 // window.sessionStorage.setItem(key, value) 设置存储内容 window.sessionStorage.setItem(&quot;username&quot;, val);&#125; // 点击按钮获得数据 document.querySelector(&quot;#getData&quot;).onclick = function() &#123; // 获得数据 // window.sessionStorage.getItem(key) 读取存储内容 alert(window.sessionStorage.getItem(&quot;username&quot;)) ;&#125;document.querySelector(&quot;#delData&quot;).onclick = function() &#123; // window.sessionStorage.removeItem(key) 删除键值为key的存储内容 // window.sessionStorage.removeItem(&quot;username&quot;); // 删除所有的 数据 window.sessionStorage.clear();&#125; demo-window.localStorage123456789101112131415161718192021222324&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;br /&gt;&lt;br /&gt;&lt;button id=&quot;setData&quot;&gt;设置数据-userName&lt;/button&gt;&lt;button id=&quot;getData&quot;&gt;获取数据-userName&lt;/button&gt;&lt;button id=&quot;delData&quot;&gt;删除数据-userName&lt;/button&gt;var username = document.querySelector(&quot;#username&quot;); window.localStorage.setItem(&quot;age&quot;, 18); window.localStorage.setItem(&quot;address&quot;, &quot;北京&quot;);document.querySelector(&quot;#setData&quot;).onclick = function() &#123; var val = username.value; window.localStorage.setItem(&quot;username&quot;, val);&#125;document.querySelector(&quot;#getData&quot;).onclick = function() &#123; alert(window.localStorage.getItem(&quot;username&quot;)) ;&#125;document.querySelector(&quot;#delData&quot;).onclick = function() &#123; window.localStorage.removeItem(&quot;username&quot;); // 删除所有的 数据 // window.localStorage.clear(); 这个清楚要慎用 &#125; manifest-appcache应用缓存 HTML5中我们可以轻松的构建一个离线（无网络状态）应用，只需要创建一个cache manifest文件。 缓存优势 可配置需要缓存的资源 网络无连接应用仍可用 本地读取缓存资源，提升访问速度，增强用户体验 减少请求，缓解服务器负担 缓存清单 一个普通文本文件，其中列出了浏览器应缓存以供离线访问的资源，推荐使用.appcache为后缀名 例如我们创建了一个名为demo.appcache的文件，然后在需要应用缓存在页面的根元素(html)添加属性manifest=”demo.appcache”，路径要保证正确。 manifest文件格式 顶行写CACHE MANIFEST CACHE: 换行 指定我们需要缓存的静态资源，如.css、image、js等 NETWORK: 换行 指定需要在线访问的资源，可使用通配符 FALLBACK: 换行 当被缓存的文件找不到时的备用资源 缓存其它知识 CACHE: 可以省略，这种情况下将需要缓存的资源写在CACHE MANIFEST 可以指定多个CACHE: NETWORK: FALLBACK:，无顺序限制 ＃表示注释，只有当demo.appcache文件内容发生改变时或者手动清除缓存后，才会重新缓存。 chrome 可以通过chrome://appcache-internals/工具和离线（offline）模式来调试管理应用缓存 demo-图片缓存1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot; manifest=&quot;study.appcache&quot;&gt; &lt;!-- study.appcache 引入 缓存清单 --&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;缓存&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;images/img1.jpg&quot; &gt; &lt;img src=&quot;images/img2.jpg&quot; &gt; &lt;img src=&quot;images/img3.jpg&quot; &gt; &lt;img src=&quot;images/img4.jpg&quot; &gt;&lt;/body&gt;&lt;/html&gt; 缓存清单study.appcache文件 1234567891011121314151617181920212223242526CACHE MANIFEST# 上面必须是第一行 CACHE:#此部分写需要缓存的资源 （#是注释的意思）./images/img1.jpg./images/img2.jpg./images/img3.jpg./images/img4.jpgNETWORK:#此部分要写需要有网络才可访问的资源，无网络不访问./images/img1.jpg./images/img2.jpg#*FALLBACK:#当访问不到某个资源的情况下，自动由另一个资源替换./images/img4.jpg ./images/img5.jpg audio/video-多媒体 w3c 方法： load() 重新加载音频/视频元素 play() 开始播放音频/视频 pause() 暂停当前播放的音频/视频 属性： autoplay 设置或返回是否在加载完成后随即播放音频/视频 controls 设置或返回音频/视频是否显示控件（比如播放/暂停等） currentSrc 返回当前音频/视频的 URL currentTime 设置或返回音频/视频中的当前播放位置（以秒计） duration 返回当前音频/视频的长度（以秒计） ended 返回音频/视频的播放是否已结束 loop 设置或返回音频/视频是否应在结束时重新播放 paused 设置或返回音频/视频是否暂停 等等 事件： oncanplay 当浏览器可以播放音频/视频时 ontimeupdate 当目前的播放位置已更改时 ended 当目前的播放列表已结束时 error 当在音频/视频加载期间发生错误时 progress 当浏览器正在下载音频/视频时 等等 大神博客video.js 有事您Q我👇","categories":[{"name":"H5","slug":"H5","permalink":"https://shulu520.com/categories/H5/"}],"tags":[{"name":"H5-newApi","slug":"H5-newApi","permalink":"https://shulu520.com/tags/H5-newApi/"}]},{"title":"H5-Document-header","slug":"H5-Document-header","date":"2019-07-31T08:43:12.000Z","updated":"2019-07-31T08:52:52.929Z","comments":true,"path":"H5/H5-Document-header/","link":"","permalink":"https://shulu520.com/H5/H5-Document-header/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; HTML5头部分 文档元数据 元数据（Metadata）含有页面的相关信息，包括样式、脚本及数据，能帮助一些软件（例如 搜索引擎、浏览器 等等）更好地运用和渲染页面。对于样式和脚本的元数据，可以直接在网页里定义，也可以链接到包含相关信息的外部文件。 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;/&gt; &lt;title&gt;shulu&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;/&gt; &lt;meta name=&quot;description&quot; content=&quot;网站描述内容&quot;/&gt; &lt;meta name=&quot;keywords&quot; content=&quot;网站关键字&quot;/&gt;&lt;/head&gt; 文档版本类型声明 HTML5的文档类型，参照淘宝网 &lt;!DOCTYPE html&gt; 规定网页内容使用的语言 简体中文，参照淘宝网 &lt;html lang=&quot;zh-CN&quot;&gt; 字符设定 万国语，参照淘宝网 &lt;meta charset=&quot;utf-8&quot;&gt; 强制IE浏览器渲染方式 对于IE浏览器，如果用户安装了GCF，则使用GCF来渲染页面，如果未安装GCF则使用最高版本的IE内核来进行渲染。 Google Chrome Frame(谷歌内嵌浏览器框架GCF) 参照淘宝网 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;/&gt; title 网站的标题 网站描述内容&lt;meta name=&quot;description&quot; content=&quot;网站描述内容&quot;/&gt; 网站关键字&lt;meta name=&quot;keywords&quot; content=&quot;网站关键字&quot;/&gt; 视口设置1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;/&gt; 有事您Q我👇","categories":[{"name":"H5","slug":"H5","permalink":"https://shulu520.com/categories/H5/"}],"tags":[{"name":"H5-Document-header","slug":"H5-Document-header","permalink":"https://shulu520.com/tags/H5-Document-header/"}]},{"title":"H5-Element","slug":"H5-Element","date":"2019-07-29T12:45:36.000Z","updated":"2019-07-31T08:52:18.290Z","comments":true,"path":"H5/H5-Element/","link":"","permalink":"https://shulu520.com/H5/H5-Element/","excerpt":"&emsp;&emsp; HTML5是Web中核心语言HTML的新规范，现在先学习H5的基础部分-H5新元素。","text":"&emsp;&emsp; HTML5是Web中核心语言HTML的新规范，现在先学习H5的基础部分-H5新元素。 先学习HTML常见的元素标签 HTML（英文Hyper Text Markup Language的缩写）中文译为“超文本标签语言”，主要是通过HTML标签对网页中的文本、图片、声音等内容进行描述。 MDN-HTML-Element html标签： 作用所有HTML中标签的一个根节点。 head标签： 作用：用于存放：title,meta,base,style,script,link 注意在head标签中我们必须要设置的标签是title title标签： 作用：让页面拥有一个属于自己的标题。 body标签： 作用：页面在的主体部分，用于存放所有的HTML标签： h系列标题标签 单词缩写:head头部即标题 为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即&lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;和&lt;h6&gt; 注意：h1 标签因为重要，尽量少用, 一般h1都是给logo使用。 p段落标签 单词缩写:paragraph段落 是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。 div span标签 div、span 是没有语义的，是我们网页布局主要的2个盒子。 div 就是division的缩写，分割，分区的意思。 span, 跨度，跨距；范围 img图像标签 单词缩写：image图像 src属性用于指定图像文件的路径和文件名，他是img标签的必需属性。 a链接标签锚点定位 单词缩写:anchor 的缩写 。基本解释 锚, 铁锚. 在HTML中创建超链接非常简单，只需用标签环绕需要被链接的对象即可. 123456789101112131415161718192021222324&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt;href：用于指定链接目标的url地址，当为标签应用href属性时，它就具有了超链接的功能。 Hypertext Reference的缩写。意思是超文本引用target：用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，_blank为在新窗口中打开方式。注意：1.外部链接 需要添加 http:// www.baidu.com2.内部链接 直接链接内部页面名称即可 比如 &lt; a href=&quot;index.html&quot;&gt; 首页 &lt;/a &gt;3.如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=&quot;#&quot;)，表示该链接暂时为一个空链接。4.不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。锚点定位:通过创建锚点链接，用户能够快速定位到目标内容。创建锚点链接分为两步：1.使用href=”#id名“链接文本创建链接文本。2.使用相应的id名标注跳转目标的位置。 注释标签 在HTML中还有一种特殊的标签——注释标签。如果需要在HTML文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。其基本语法格式如下：​ 1&lt;!-- 注释语句 --&gt; 注释内容不会显示在浏览器窗口中，但是作为HTML文档内容的一部分，也会被下载到用户的计算机上，查看源代码时就可以看到。 ul无序列表 无序列表的各个列表项之间没有顺序级别之分，是并列的。 123&lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。&lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。 ol有序列表 所有特性基本与ul 一致。但是实际工作中，较少用 ol . 自定义列表（理解） 定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。 用的还可以： 12345678910&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ...&lt;/dl&gt; Web组件元素 slot 插槽 template HTML内容模板 table表格标签 存在即是合理的。表格的现在还是较为常用的一种标签，但不是用来布局，常见为处理表格式数据。 MDN-table 123456789101112131415161718192021222324252627282930313233创建简单的表格&lt;table&gt; &lt;tr&gt; &lt;th colspan=&quot;3&quot;&gt;表头文本会加粗居中&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;table: 用于定义一个表格。tr: 用于定义表格中的一行，必须嵌套在table标签中，在 table 中包含几对 tr，就有几行表格。td：用于定义表格中的单元格，必须嵌套在tr标签中，一对 tr中包含几对td，就表示该行中有多少列（或多少个单元格）。th: 表头标签,表头一般位于表格的第一行或第一列，其文本加粗居中.注意：1. &lt;tr&gt;&lt;/tr&gt;中只能嵌套&lt;td&gt;&lt;/td&gt;2. &lt;td&gt;&lt;/td&gt;标签，他就像一个容器，可以容纳所有的元素表格结构（了解）在使用表格进行布局时，可以将表格划分为头部、主体和页脚（页脚因为有兼容性问题，此处不在赘述）&lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部。&lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主体。合并单元格跨行合并：rowspan 跨列合并：colspan表格不要纠结于外观，那是CSS 的作用。 form表单标签(掌握) 现实中的表单，类似我们去银行办理信用卡填写的单子。目的是为了收集用户信息。 在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时也需要表单。 在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。 表单控件：包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 提示信息：一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。 表单域：他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 input标签 控件(重点) 表单 &lt;input&gt;类型type,如果未指定此属性，则采用的默认类型为text. 以下为type属性的常见类型： 1234567891011121314151617181920212223242526checkbox： 复选框。使用 checked 属性指示控件是否被选择。file：此控件可以让用户选择文件。使用 accept 属性可以定义控件可以选择的文件类型。password：一个值被遮盖的单行文本字段。使用 maxlength 指定可以输入的值的最大长度 。radio：单选按钮。在同一个”单选按钮组“中，所有单选按钮的 name 属性使用同一个值。reset：用于将表单所内容设置为空的按钮。submit：用于提交表单的按钮。tel: HTML5新类型，tel类型的元素用于让用户输入和编辑电话号码。其中最明显的就是移动浏览器— 特别是在手机上 — 可能会选择提供为输入电话号码而优化的自定义键盘。使用电话号码的特定输入类型也使添加自定义验证和处理电话号码更方便。email输入邮箱格式search搜索框（体现语义化） 全局 &lt;input&gt; 属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152type 要呈现的控件类型.accept 如果该元素的 type 属性的值是file,则该属性表明了服务器端可接受的文件类型；否则它将被忽略。autocomplete HTML5新属性这个属性表示这个控件的值是否可被浏览器自动填充。autofocus HTML5这个布尔属性允许您指定的表单控件在页面加载时具有焦点（自动获得焦点）checked如果该元素的type属性的值为radio或者checkbox,则该布尔属性的存在与否表明了该控件是否是默认选择状态.disabled这个布尔属性表示此表单控件不可用。特别是在禁用的控件中，click 事件将不会被分发 。并且，禁用的控件的值在提交表单时也不会被提交。max HTML5 此项目的最大（数字或日期时间）值，且不得小于其最小值（min属性）值。min HTML5 此项目的最小（数字或日期时间）值，且不得大于其最大值（最大属性）值。minlength 元素值的长度 属性为输入的最小长度;maxlength HTML5 元素值的长度如果 type 的值是text, email, search, password, tel, 或 url，那么这个属性指明了用户最多可以输入的字符个数（按照Unicode编码方式计数）.译者注:ie10+name控件的名称，与表单数据一起提交。pattern HTML5检查控件值的正则表达式.。pattern必须匹配整个值，而不仅仅是某些子集.。使用title属性来描述帮助用户的模式.。当类型属性的值为text, search, tel, url 或 email时，此属性适用，否则将被忽略。译者注:ie10+placeholder HTML5提示用户输入框的作用。required HTML5这个属性指定用户在提交表单之前必须为该元素填充值. multiple 多文件上传，input type=filesize控件的初始大小。可以使用 size 属性来控制输入框的物理大小value控件的初始值. 此属性是可选的.list提供建议值 input 元素造型, 你可以使用各种与颜色相关的属性来设置input元素的样式。与文本输入相关的元素特有的一个不常见的特性是CSS caret-color属性，该属性允许你设置用于绘制文本输入插入符的颜色. input的demo-输入电话号码1234567891011121314151617181920212223242526272829&lt;style&gt; #telNo&#123; caret-color: red; /* 插入光标的颜色 */ &#125; #telNo:invalid+span:after &#123; position: absolute; content: &apos;✖&apos;; padding-left: 5px; color: #8b0000; &#125; #telNo:valid+span:after &#123; position: absolute; content: &apos;✓&apos;; padding-left: 5px; color: #009000; &#125;&lt;/style&gt;&lt;form &gt; &lt;fieldset&gt; //控件组 效果就是一个边框线 &lt;legend&gt;输入电话号码&lt;/legend&gt; //内容相关说明 &lt;label for=&quot;telNo&quot;&gt;Phone number: &lt;/label&gt; &lt;input id=&quot;telNo&quot; size=&quot;12&quot; autofocus name=&quot;telNo&quot; type=&quot;tel&quot; placeholder=&quot;请输入电话号码&quot; maxlength=&quot;11&quot; required list=&quot;defaultTels&quot; pattern=&quot;^(0|86|17951)?(13[0-9]|15[012356789]|166|17[3678]|18[0-9]|14[57])[0-9]&#123;8&#125;$&quot;&gt; &lt;span class=&quot;validity&quot;&gt;&lt;/span&gt; &lt;datalist id=&quot;defaultTels&quot;&gt; //选项建议列表 &lt;option value=&quot;13161122239&quot;&gt; &lt;option value=&quot;15161122239&quot;&gt; &lt;/datalist&gt; &lt;/fieldset&gt;&lt;/form&gt; label标签(理解) label 标签为 input 元素定义标注（标签）。 作用：用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点. 如何绑定元素呢？for 属性规定 label 与哪个表单元素绑定。 123&lt;label for=&quot;male&quot;&gt;Male&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; value=&quot;male&quot;&gt; textarea控件(文本域) 如果需要输入大量的信息.通过textarea控件可以轻松地创建多行文本输入框. 123&lt;textarea cols=&quot;每行中的字符数&quot; rows=&quot;显示的行数&quot;&gt; 文本内容&lt;/textarea&gt; select下拉菜单标签12345&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt;&lt;/select&gt; form表单域 在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。 123&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单名称&quot;&gt; 各种表单控件……&lt;/form&gt; 常用属性： Action 在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址。 method 用于设置表单数据的提交方式，其取值为get或post。 name 用于指定表单的名称，以区分同一个页面中的多个表单。 注意：每个表单都应该有自己表单域。 HTML5 新标签 XHTML属于XML，是HTML进行XML严格化的结果 HTML5不属于XML，比XHTML宽松，比如input属性checked直接写这样就行了,而不用写checked=”checked”。 HTML标签的语义化 所谓标签语义化，就是指标签的含义。 为什么要有语义化标签 方便代码的阅读和维护 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容 使用语义化标签会具有更好地搜索引擎优化 核心：合适的地方给一个最为合理的标签。 语义是否良好： 当我们去掉CSS之后，网页结构依然组织有序，并且有良好的可读性。 不管是谁都能看懂这块内容是什么。 遵循的原则：先确定语义的HTML ，再选合适的CSS。 HTML5样式标签 em 语义化的标签表强调，而i标签是纯样式的标签，表斜体，H5不推荐使用，一般用来做图标。 H5常用结构新标签 header：定义文档的页眉 nav：定义导航链接的部分 footer：定义文档或节的页脚 article：标签规定独立的自包含内容 section：定义文档中的节（section、区段） aside：定义其所处内容之外的内容,如广告 article 元素表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。 section 表示文档中的一个区域（或节），比如，内容中的一个专题组，一般来说会有包含一个标题（heading）。一般通过是否包含一个标题 (h1-h6 元素) 作为子节点来辨识每一个section。 audio标签 多媒体 用于在文档中表示音频内容。 autoplay 自动播放 controls 是否显不默认播放控件 loop 循环播放 更多关于audio的内容查看本博客H5-audio专栏部分。 video标签 多媒体 HTML5通过video标签来解决音频播放的问题。 autoplay 自动播放 controls 是否显示默认播放控件 loop 循环播放 width 设置播放窗口宽度 height 设置播放窗口的高度 更多关于video的内容查看本博客H5-video专栏部分。 有事您Q我👇","categories":[{"name":"H5","slug":"H5","permalink":"https://shulu520.com/categories/H5/"}],"tags":[{"name":"H5-Element","slug":"H5-Element","permalink":"https://shulu520.com/tags/H5-Element/"}]},{"title":"browser-core","slug":"browser-core","date":"2019-07-28T13:15:31.000Z","updated":"2019-07-28T14:17:27.294Z","comments":true,"path":"browser/browser-core/","link":"","permalink":"https://shulu520.com/browser/browser-core/","excerpt":"&emsp;&emsp;了解主流浏览器的核心-内核，为了应付面试，也有助于我们在不同内核的浏览器中测试网页的渲染效果。","text":"&emsp;&emsp;了解主流浏览器的核心-内核，为了应付面试，也有助于我们在不同内核的浏览器中测试网页的渲染效果。 browser主流浏览器及其内核 浏览器内核是浏览器的核心，也称“渲染引擎”，用来解释网页语法并渲染到网页上。 浏览器内核决定了浏览器该如何显示网页内容以及页面的格式信息。 不同的浏览器内核对网页的语法解释也不同，因此网页开发者需要在不同内核的浏览器中测试网页的渲染效果。 browser国际市场 1994年诞生IE浏览器； IE浏览器内核：Trident内核，也是俗称的IE内核； 1995年诞生Opera浏览器； Opera浏览器内核：最初是自己的Presto内核，后来加入谷歌大军，从Webkit又到了Blink内核； 2003年诞生Safari浏览器； Safari浏览器内核：Webkit内核； 2004年诞生Firefox浏览器； Firefox浏览器内核：Gecko内核，俗称Firefox内核； 2008年诞生Chrome浏览器； Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，2013年以后到现在是Blink内核； browser国内市场 360浏览器、 猎豹浏览器内核：IE+Chrome双内核； 搜狗、 遨游、 QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）； 百度浏览器、 世界之窗内核：IE内核； 2345浏览器内核：好像以前是IE内核，现在也是IE+Chrome双内核了； UC浏览器内核：这个众口不一，UC说是他们自己研发的U3内核，但好像还是基于Webkit和Trident，还有说是基于火狐内核。 移动端的浏览器内核 移动端的浏览器内核主要说的是系统内置浏览器的内核。 目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等。 其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit。 Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink。 Windows Phone 8 系统浏览器内核是 Trident。 browser有关说明 大家的误解，一直认为的chrome内核就是由苹果公司最先选择的算是KHTML引擎的分支-Webkit，这大概是苹果公司至今说不清道不明的伤痛吧~~chromium fork 自开源引擎 webkit，却把 WebKit 的代码梳理得可读性提高很多。 2013年4月3日，谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器内核 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实Blink引擎就是也就是Webkit的分支，就像Webkit是KHTML的分支一样。Blink引擎现在是谷歌公司与Opera Software共同研发。 win10 edge浏览器 EdgeHTML内核; 据有关消息，微软即将发布的新版 Edge 浏览器很可能同时包含谷歌的 Blink 和 自身的Trident两个浏览器内核，方便浏览器给那些为 IE 设计的网站提供向后兼容性。换句话说，就是要把未来的Windows 10默认浏览器替换成只是换了一个皮肤的Chrome。采用Chromium内核的Edge浏览器测试版已经放出了安装包。在用完之后，我最惊叹的一点，就是它能做得多么像是Chrome。这款Edge基本上可以让一个习惯使用Chrome的用户无缝切换，菜单布局，功能设置等等分毫不差。为了做到体验上的完全对接，Edge这一测试版甚至连浏览器标签页一行、后退前进等按钮和地址栏一行和书签栏一行的高度都做到了跟Chrome平齐。 还有在手机微信上内嵌的浏览器，因为它采用QQ浏览器的X5内核，同时因为跟微信深度耦合，并且要调用很多通过微信实现的系统能力，所以出现了有些网页必须专门适配微信的局面。 Web标准（重点） 通过了解以上浏览器的内核不同，我们知道他们工作原理、解析肯定不同，显示就会有差别。通过web标准的约束，尽量使同一套代码在不同的浏览器有相同的结构、表现和行为。 Web 标准的好处 让Web的发展前景更广阔 内容能被更广泛的设备访问 更容易被搜寻引擎搜索 降低网站流量费用 使网站更易于维护 提高页面浏览速度 Web 标准构成 Web标准不是某一个标准，而是由W3C和其他标准化组织制定的一系列标准的集合。 主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。 结构标准：结构用于对网页元素进行整理和分类，主要包括XML和XHTML两个部分。 样式标准：表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS。 行为标准：行为是指网页模型的定义及交互的编写，主要包括DOM和ECMAScript两个部分。 有事您Q我👇","categories":[{"name":"browser","slug":"browser","permalink":"https://shulu520.com/categories/browser/"}],"tags":[{"name":"browser","slug":"browser","permalink":"https://shulu520.com/tags/browser/"}]},{"title":"sass","slug":"css3-sass","date":"2019-07-27T14:41:58.000Z","updated":"2019-07-27T14:49:55.327Z","comments":true,"path":"sass/css3-sass/","link":"","permalink":"https://shulu520.com/sass/css3-sass/","excerpt":"&emsp;&emsp;学习使用css预处理器sass让我们更爽地敲css代码。","text":"&emsp;&emsp;学习使用css预处理器sass让我们更爽地敲css代码。 css预处理器-sass介绍 sass使用ruby语言编写，下载使用有些不方便，使用cnpm成功率高 vscode 下载EasySass运行插件。 注意：下载的是node-sass, sass的文件后缀是.scss 项目是npm init 过的 cnpm install node-sass 编写.scss后缀的文件后，自动会生成对应文件名的.css文件,以及压缩过的对应文件名的.min.css文件 css预处理器的作用 帮助我们更好的组织css代码 提高代码的复用率 提升可维护性 sass嵌套 选择器之间可以嵌套 反映层级和约束 sass变量-$ 复用常用的个别属性 123456789//定义变量$fontSize: 18px;$bgColor: red;//使用变量.child&#123; font-size: $font-size + 2px; background-color: $bgColor; &#125; sass运算 支持加减乘除多种运算。 1font-size: $font-size + 2px; sass混入-Mixin 复用css代码片段 1234567891011121314151617$color: pink;$bgColor: blue;$fontSize: 18px;//定义混入//注意：这里base是一个代码片段的名字@mixin base($color, $h, $bgc, $fontSize)&#123; color: $color; height: $h; background: $bgc; font-size: $fontSize;&#125;//使用混入.wrap&#123; @include base(yellow, 300px, $bgColor, $fontSize)&#125; sass继承-extend 复用css代码片段 生成的样式中，样式片段没有重复 @extend会增加选择器之间的联系，然后把他们堆在一起。 123456789// 一个普通的类就是一个extend.button&#123; color: yellow;&#125;// 使用extendh2&#123; @extend .button;&#125; sass中mixin的优缺点 优点：@mixin主要的优势就是它能够接受参数。 优点：还能直接给@mixin传递样式片段。 缺点：生成的代码会变得肿胀。 sass中extend的优缺点 优点：生成的样式中，样式片段没有重复。 缺点：@extend会增加选择器之间的联系，然后把他们堆在一起。被继承的选择器和继承别人的选择器可能会在样式表的不同位置，这就导致维护困难，放置顺序，或者需要差异化的一些问题。 缺点：@extend命令不够灵活。不能向它传递参数，它原本是啥样就是啥样。 sass中mixin vs extend @mixin和@extend都能帮助你模块化代码，然后更加方便地在样式表中复用一些样式片段。 从结果上看，mixin是直接把代码复制过来，而extend是将有公共样式的选择器提取出来，用分组选择器把他们放在一起。 你可能会问，到底什么时候使用@mixin，什么时候使用@extend? 总结：在大作数情况下@mixin会比@extend更好，但是它们俩都有自己的一席之地。当样式和选择器之间的关系在某些方面比较紧密的时候，使用@extend。除此之外，你可以使用@mixin在任何地方。 sass循环-loop 生成一些复杂有规律的代码片段 123456//直接使用for循环，生成各自宽度的col-1 ~ col-12的css代码片段。@for $i from 1 to 12 &#123; .col-#&#123;$i&#125;&#123; width: 1000px/12*$i; &#125;&#125; sass文件模块化@import123@import &quot;./header&quot;; .scss后缀可以省略@import &quot;./nav&quot;; @import &quot;./footer&quot; sass中css预处理器框架 Compass 提供现成的mixin, 类似js类库，封装常用功能。 有事您Q我👇","categories":[{"name":"sass","slug":"sass","permalink":"https://shulu520.com/categories/sass/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/tags/css3/"},{"name":"sass","slug":"sass","permalink":"https://shulu520.com/tags/sass/"}]},{"title":"less","slug":"css3-less","date":"2019-07-27T14:33:18.000Z","updated":"2019-07-27T14:53:24.854Z","comments":true,"path":"less/css3-less/","link":"","permalink":"https://shulu520.com/less/css3-less/","excerpt":"&emsp;&emsp;学习使用css预处理器less让我们更爽地敲css代码。","text":"&emsp;&emsp;学习使用css预处理器less让我们更爽地敲css代码。 css预处理器-less介绍 less使用nodejs编写，下载使用都方便 vscode 下载EasyLess运行插件。 项目是npm init 过的 npm i less 即可使用 编写.less后缀的文件后，自动会生成对应文件名的.css文件 css预处理器的作用 帮助我们更好的组织css代码 提高代码的复用率 提升可维护性 less嵌套 选择器之间可以嵌套 反映层级和约束 less变量-@ 复用常用的个别属性 123456789//定义变量@font-size: 18px;@bgColor: red; //使用变量.child&#123; font-size: @font-size + 2px; background-color: @bgColor; &#125; less运算 支持加减乘除多种运算。 less混入-Mixin 复用常用的css代码片段 1234567891011121314151617@color: pink;@bgColor: blue;@fontSize: 18px;//定义混入//注意：这里.base是一个类名.base(@color, @h, @bgc, @fontSize)&#123; color: @color; height: @h; background: @bgc; font-size: @fontSize;&#125;//使用混入.wrap&#123; .base(yellow, 300px, @bgColor, @fontSize)&#125; less继承-extend 复用css代码片段 生成的样式中，样式片段没有重复 &amp;:extend()会增加选择器之间的联系，然后把他们堆在一起。 123456789// 一个普通的类就是一个extend.box&#123; color: @color;&#125;// 使用extendh2&#123; &amp;:extend(.box);&#125; less中mixin和extend的优缺点 同sass中的一样，参考sass部分 less循环 生成一些复杂有规律的代码片段 less中没有循环的方法,但是我们可以在mixin中使用递归方法模拟循环。 12345678910//在mixin中使用递归方法模拟循环。.gen-col(@n) when (@n &gt; 0) &#123; .gen-col(@n - 1); .col-@&#123;n&#125; &#123; width: 1000px/12*@n; &#125;&#125;//调用循环，生成各自宽度的col-1 ~ col-12的css代码片段。.gen-col(12); less文件模块化@import123@import &quot;./header&quot;; .less后缀可以省略@import &quot;./nav&quot;; @import &quot;./footer&quot;; less中css预处理器框架 Lesshat EST(百度大牛编写) 提供现成的mixin, 类似js类库，封装常用功能。 EST的介绍使用 est 是一个基于 Less 的样式工具库，帮助您更轻松地书写 Less 代码。 est 提供了一系列方便快捷的 mixin，只在调用时才输出代码。est 不希望提供直接给 HTML 调用的类名，用「样式类」污染 HTML 代码的语义。当然您也可以根据自己的项目需求基于 est 搭建样式类库，提供类名接口来进行快速开发。 官网教程 123456789101112131415161718192021222324252627282930313233使用 Git 获取代码：git clone https://github.com/ecomfe/est.git然后在 Less 代码中引入。@import &quot;est/src/all.less&quot;;官网导航介绍：variables 全局变量设置。normalize 用来归一化不同浏览器下的页面样式。reset 进行全局样式重置。即 .global-reset()shapes 提供绘制基本形状的功能effects 提供预设视觉效果。layout 提供常见的基础布局。grid 帮助生成自定义的栅格布局。 clockhand 提供顺时针简写的功能。typography 文字排版相关功能。util 常用辅助类工具函数。compatibility 提供基础的兼容性封装。// ...your own awesome less code starts here... 有事您Q我👇","categories":[{"name":"less","slug":"less","permalink":"https://shulu520.com/categories/less/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/tags/css3/"},{"name":"less","slug":"less","permalink":"https://shulu520.com/tags/less/"}]},{"title":"css3-BFC","slug":"css3-BFC","date":"2019-07-22T14:18:55.000Z","updated":"2019-07-22T14:25:12.691Z","comments":true,"path":"css3/css3-BFC/","link":"","permalink":"https://shulu520.com/css3/css3-BFC/","excerpt":"&emsp;&emsp;BFC就是页面上的一个独立容器，容器里面的元素不会影响到外面的元素，反之亦然。学习页面布局，css-BFC的知识要重点掌握。","text":"&emsp;&emsp;BFC就是页面上的一个独立容器，容器里面的元素不会影响到外面的元素，反之亦然。学习页面布局，css-BFC的知识要重点掌握。 BFC-块级格式化上下文BFC规则、特性 Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻box的margin会发生重叠 BFC的区域不会与float box的重叠，紧贴着浮动盒子的边缘 计算BFC的高度时，浮动元素也参与计算。 BFC就是页面上的一个独立容器，容器里面的元素不会影响到外面的元素，反之亦然。 块级元素的BFC创立条件 float属性不为none position属性为absolute或fixed display属性为inline-block、table相关、flex overflow属性不为visible(以上最常用的是overflow: hidden, 副作用少) BFC的用途 清除浮动: 这时可以让父元素生成BFC，即解决子因子元素浮动而父级高度塌陷问题 解决外边距合并问题：假设有两个p元素，可以在其中一个p上包裹容器，然后触发其BFC，这样两个p就不在同一个BFC，因此就不会发生重叠 自适应两栏布局: 即左边盒子浮动，右边盒子触发BFC 有事您Q我👇","categories":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/categories/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/tags/css3/"}]},{"title":"css3-flex","slug":"css3-flex","date":"2019-07-18T13:58:53.000Z","updated":"2019-07-19T03:30:43.584Z","comments":true,"path":"css3/css3-flex/","link":"","permalink":"https://shulu520.com/css3/css3-flex/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; flex 规定了弹性元素如何伸长或缩短以适应flex容器中的可用空间。 Flexbox即 Flexible Box Module（弹性盒模型） Flexbox同一时间只能控制行或列中的一个维度。对于二维控制需要 grid网格布局。 主轴 即X轴方向(默认) 侧轴 即Y轴方向(默认) 侧轴垂直于主轴 flex 各个属性父元素-伸缩容器 display: flex; 声明使用伸缩布局 flex-direction: row(默认); 定义了主轴的方向(正方向或反方向)。 1234flex-direction: row; x轴方向flex-direction: row-reverse; -X轴方向flex-direction: column; Y轴方向flex-direction: column-reverse; -Y轴方向 justify-content 主轴上项目的对齐方式。 1234567justify-content: center; 居中排列 justify-content: start; 从行首起始位置开始排列 justify-content: end; 从行尾位置开始排列 justify-content: space-between; 均匀排列每个元素 首个元素放置于起点，末尾元素放置于终点 justify-content: space-around; 均匀排列每个元素 每个元素周围分配相同的空间 justify-content: space-evenly; 均匀排列每个元素 每个元素之间的间隔相等 align-items 侧轴上项目的对齐方式–针对单行即子元素只有一行(不换行) 1234align-items: center; align-items: start;align-items: end; align-items: stretch; 拉伸子元素的高度以适应父元素的高度(子元素不给高度的情况) align-content 侧轴上项目的对齐方式–针对多行即子元素有多行(换行) 12345678align-content: center; 将项目放置在中点 align-content: start; 最先放置项目 align-content: end; 最后放置项目 align-content: space-between; 均匀分布项目 第一项与起始点齐平，最后一项与终止点齐平 align-content: space-around; 均匀分布项目 项目在两端有一半大小的空间align-content: space-evenly; 均匀分布项目 项目周围有相等的空间 align-content: stretch; 均匀分布项目 拉伸‘自动’-大小的项目以充满容器 flex-wrap 是否允许子元素换行显示 123flex-wrap: nowrap; 默认不换行flex-wrap: wrap; 换行flex-wrap: wrap-reverse; 换行并反向显示 12345678910111213141516//demo 水平垂直对齐三条属性就搞定html,body&#123; height: 100%;&#125;body&#123; display: flex; justify-content: center; align-items: center;&#125;#app&#123; width: 300px; height: 300px; background-color: red;&#125;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; flex-flow 简写属性 弹性流 flex-direction 和 flex-wrap 属性的简写 子元素-伸缩项目 flex: 1或2等无单位的数值，表示这个子元素占几份父元素的空间，当然子元素也可以指定宽度。简写属性， 是flex-grow、 flex-shrink 和 flex-basis 的简写。 order: -1或1、2等无单位的数值，表示子元素的排列顺序，数值越小排列越靠前 justify-self: 对齐主轴方向的某个项目 align-self 对齐侧轴方向的单个项目 扩展css属性 min-width: 如500px; 盒子可伸缩最小宽度 max-width: 如1000px; 盒子可伸缩最大宽度 有事您Q我👇","categories":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/categories/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/tags/css3/"}]},{"title":"css3-animation","slug":"css3-animation","date":"2019-07-18T04:34:45.000Z","updated":"2019-07-18T09:35:11.408Z","comments":true,"path":"css3/css3-animation/","link":"","permalink":"https://shulu520.com/css3/css3-animation/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 动画定义 关键帧@keyframes1234567891011@keyframes animiationName&#123; keyframes-selector&#123; css-style; &#125;&#125;animiationName:必写项，定义动画的名称keyframes-selector：必写项，动画持续时间的百分比,两个状态点的时候，可以用from、to,多组动画状态时使用百分比。 from：0% to：100%css-style：css声明 动画使用 animation animation属性是一个简写属性形式: （可以用来描述可动画的属性） 可动画属性的列表：https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties 简写属性animation1234567891011121314animation： animation-name 动画名称 animation-duration 持续时间 animation-timing-function 速度曲线 (同过渡) animation-delay 延时执行 animation-iteration-count 执行次数 animation-direction 动画方向 animation-fill-mode 设置动画在执行之前和之后如何将样式应用于其目标。值forwards可以使其保持最终状态而不是恢复到原始状态(默认) animation-play-state 设置动画状态 running 当前动画正在运行。 paused 当前动画以被停止。 在每个动画定义中，顺序很重要：可以被解析为 的第一个值被分配给animation-duration, 第二个分配给 animation-delay。 无缝滚动 有事您Q我👇","categories":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/categories/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/tags/css3/"},{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"css3-transform","slug":"css3-transform","date":"2019-07-18T04:33:48.000Z","updated":"2019-07-18T04:40:59.724Z","comments":true,"path":"css3/css3-transform/","link":"","permalink":"https://shulu520.com/css3/css3-transform/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; transform transform 属性 , 只对 block 级元素生效！ transform 2D旋转 rotate1234transform:rotate(angle/弧度); 正值:顺时针旋转 rotate(360deg/2Π)负值:逆时针旋转 rotate(-360deg/-2Π)只能设单值。正数表示顺时针旋转，负数表示逆时针旋转 平移 translate12345678910X方向平移:transform: translateX(tx)Y方向平移:transform: translateY(ty) 二维平移：transform: translate(tx[, ty])； 如果ty没有指定，它的值默认为0。 可设单值，也可设双值。正数表示XY轴正向位移，负数为反向位移。设单值表示只X轴位移，Y轴坐标不变，例如transform: translate(100px);等价于transform: translate(100px,0);百分比：translateX(50%) 向右平移自己宽度的一半 拓展-定位的盒子居中对齐-优美写法 定位的盒子居中对齐优美写法 123456789101112131415//样式#app&#123; position: absolute; top: 50%; //父级高度的50% left: 50%; transform: translate(-50%, -50%);//自己宽高的50%，无需手动计算 width: 300px; height: 300px; background-color: deeppink;&#125;//dom结构&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 定位的盒子居中对齐传统写法 1234567891011121314151617181920212223242526272829303132写法一：/* #app&#123; position: absolute; top: 50%; left: 50%; margin-top: -150px; margin-left: -150px; width: 300px; height: 300px; background-color: deeppink;&#125; */写法二：/*#app&#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto; width: 300px; height: 300px; background-color: deeppink;&#125; */ 倾斜 skew123456789101112131415transform:skewX(45deg);X方向倾斜:transform: skewX(angle) skewX(45deg):参数值以deg为单位 代表与y轴之间的角度Y方向倾斜:transform: skewY(angle) skewY(45deg):参数值以deg为单位 代表与x轴之间的角度二维倾斜:transform: skew(ax[, ay]); 如果ay未提供，在Y轴上没有倾斜 skew(45deg,15deg):参数值以deg为单位 第一个参数代表与y轴之间的角度 第二个参数代表与x轴之间的角度 单值时表示只X轴扭曲，Y轴不变，如transform: skew(30deg);等价于 transform: skew(30deg, 0); 考虑到可读性，不推荐用单值，应该用transform: skewX(30deg);。skewY表示只Y轴扭曲，X轴不变 正值:拉正斜杠方向的两个角 负值:拉反斜杠方向的两个角 缩放 scale123456789101112131415transform:scale(2);X方向缩放:transform: scaleX(sx); Y方向缩放:transform: scaleY(sy);二维缩放 :transform: scale(sx[, sy]); (如果sy 未指定，默认认为和sx的值相同) 要缩小请设0.01～0.99之间的值，要放大请设超过1的值。例如缩小一倍可以transform: scale(.5); 放大一倍可以transform: scale(2);如果只想X轴缩放，可以用scaleX(.5)相当于scale(.5, 1)。同理只想Y轴缩放，可以用scaleY(.5)相当于scale(1, .5)正值:缩放的程度负值:不推荐使用（有旋转效果）单值时表示只X轴,Y轴上缩放粒度一样，如transform: scale(2);等价于transform: scale(2,2); 基点的变换 transform-origin transform-origin 属性让你更改一个元素变形的基点。 12345678910 一个值：必须是&lt;length&gt;，&lt;percentage&gt;，或 left, center, right, top, bottom关键字中的一个。 两个值：其中一个必须是&lt;length&gt;，&lt;percentage&gt;，或left, center, right关键字中的一个。另一个必须是&lt;length&gt;，&lt;percentage&gt;，或top, center, bottom关键字中的一个。 三个值：前两个值和只有两个值时的用法相同。第三个值必须是&lt;length&gt;。它始终代表Z轴偏移量。 transform 3D3D缩放1234transform: scaleZ(number)transform: scale3d(scaleX,scaleY,scaleZ); 如果只设置scaleZ(number)，你会发现元素并没有被扩大或压缩，scaleZ(number)需要和translateZ(length)配合使用，number乘以length得到的值，是元素沿Z轴移动的距离，从而使得感觉被扩大或压缩 3D旋转123456789CSS3中的3D旋转主要包括四个功能函数rotateX(angle) rotateY(angle) rotateZ(angle)等价于rotate(angle) rotate3d(x,y,z,angle)x, y, z分别接受一个数值(number),用来计算矢量方向(direction vector)，矢量方向是三维空间中的一条线, 从坐标系原点到x, y, z值确定的那个点，元素围绕这条线旋转angle指定的值 3D平移 translateZ 它不能是百分比 值 12345transform: translateZ(length)是3D Transformaton特有的，其他两个2D中就有translateZ 它不能是百分比 值transform: translate3d(translateX,translateY,translateZ); 景深perspective 景深是指相机对焦点前后相对清晰的成像范围。在光学中，尤其是录影或是摄影，是一个描述在空间中，可以清楚成像的距离范围。虽然透镜只能够将光聚 到某一固定的距离，远离此点则会逐渐模糊，但是在某一段特定的距离内，影像模糊的程度是肉眼无法察觉的，这段距离称之为景深。 简单的理解，景深就是我们的肉眼距离显示器的距离，景深越大，元素离我们越远，效果就不好，在我们CSS3中，perspective用于激活一个3D空间，属性值就是景深大小（默认none无景深） 应用景深的元素称为“舞台元素”，舞台元素的所有后代元素都会受影响，（如果后代元素中也添加了perspective属性，效果会叠加而不是覆盖） perspective、perspective-origin设置在父元素上，对后代元素起作用。 1234567891011transform: perspective(depth);depth的默认值是none，可以设置为一个长度值，这个长度是沿着Z轴距离坐标原点的距离。1000px被认为是个正常值若使用perspective()函数，那么他必须被放置在transform属性的首位，如果放在其他函数之后，则会被忽略perspective: depth;同perspective()函数一样，depth的默认值是none，可以设置为一个长度值，这个长度是沿着Z轴距离坐标原点的距离。他们唯一的区别是，perspective属性是被用于元素的后代元素，而不是元素本身；就是说，为某个元素设置perspective属性后，是对这个元素的子元素起作用，而不是这个元素本身。perspective-origin同perspective属性，也是设置在父元素上，对后代元素起作用。 这个属性来设置你在X, Y轴坐标确定的那个点来看这个元素，Z轴是被perspective属性设置的 1000px被认为是个正常值 若使用perspective()函数，那么他必须被放置在transform属性的首位，如果放在其他函数之后，则会被忽略 perspective属性是设置在容器被作用于后代元素，而不是容器元素本身 backface-visibility 此功能某些浏览器尚在开发中 属性 backface-visibility 指定当元素背面朝向观察者时是否可见。 visible 背面朝向用户时可见。 hidden 背面朝向用户时不可见。 transform-style 此功能某些浏览器尚在开发中 属性 transform-style 设置元素的子元素是位于 3D 空间中还是平面中。 flat 设置元素的子元素位于该元素的平面中。 preserve-3d 指示元素的子元素应位于 3D 空间中。 灭点 指的是立体图形各条边的延伸线所产生的相交点。透视点的消失点 有事您Q我👇","categories":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/categories/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/tags/css3/"},{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"css3-transition","slug":"css3-transition","date":"2019-07-17T03:24:42.000Z","updated":"2019-07-17T03:26:52.242Z","comments":true,"path":"css3/css3-transition/","link":"","permalink":"https://shulu520.com/css3/css3-transition/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 过渡 transition简写属性transition transition是一个简写属性 CSS 过渡 由简写属性 transition 定义是最好的方式，可以避免属性值列表长度不一，节省调试时间 默认值： transition-delay: 0s 属性规定了在过渡效果开始作用之前需要等待的时间。 transition-duration: 0s 属性以秒或毫秒为单位指定过渡动画所需的时间。 transition-property: all 默认值为 all，表示所有可被动画的属性都表现出过渡动画 transition-timing-function: ease 通过这个函数会建立一条加速度曲线，因此在整个transition变化过程中，变化速度可以不断改变 transition-timing-function属性值 ease：（加速然后减速）默认值，ease函数等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0). linear：（匀速），linear 函数等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0). ease-in：(加速)，ease-in 函数等同于贝塞尔曲线(0.42, 0, 1.0, 1.0). ease-out：（减速），ease-out 函数等同于贝塞尔曲线(0, 0, 0.58, 1.0). ease-in-out：（加速然后减速），ease-in-out 函数等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) cubic-bezier： 贝塞尔曲线 step-start：等同于steps(1,start) step-end：等同于steps(1,end) steps(,[,[start|end]]?) 第一个参数：必须为正整数，指定函数的步数 第二个参数：指定每一步的值发生变化的时间点（默认值end） 当属性值的列表长度不一致时 要过渡的属性的个数与对应的给出的时间列表长度不一致时，不够的时候，关于时间的会重复列表，关于transition-timing-function的时候使用的是默认值ease 超出的情况下是会被全部截掉的 检测过渡是否完成–争对属性而言的 当过渡完成时触发一个事件，在符合标准的浏览器下，这个事件是 transitionend, 在 WebKit 下是 webkitTransitionEnd 每一个拥有过渡的属性在其完成过渡时都会触发一次transitionend事件 在transition完成前设置 display: none，事件同样不会被触发 注意 在transition属性中，各个值的书写顺序是很重要的：第一个可以解析为时间的值会被赋值给transition-duration，第二个可以解析为时间的值会被赋值给transition-delay 关于时间要带单位 推荐抒写顺序 过渡时间 过渡样式 过渡形式 延迟时间 兼容性 transition 可以不用厂商前缀，不过鉴于标准刚刚稳定，对于基于 Webkit的浏览器仍然需要厂商前缀。如果想兼容旧版本的浏览器那么也需要厂商前缀（例如Firefox 15 及之前版本, Opera 12 及之前版本) 拓展-贝塞尔曲线 以物理学的角度看：贝塞尔曲线是一条位移时间曲线，其斜率表示速度。 transition: 3s all cubic-bezier(0.445, 0.05, 0.55, 0.95) 0s 有事您Q我👇","categories":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/categories/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/tags/css3/"},{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"css3-new-ui","slug":"css3-new-ui","date":"2019-07-16T14:46:52.000Z","updated":"2019-07-26T08:05:49.862Z","comments":true,"path":"css3/css3-new-ui/","link":"","permalink":"https://shulu520.com/css3/css3-new-ui/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 新增文本样式opacity 透明度，性能高 值为0~1 rgba rgba(0, 0, 0, .5) 颜色表示，a表示透明度 可以实现以前不能实现的样式—背景透明文字不透明 文字阴影 text-shadow: 1px 1px 1px pink, 1px 1px 1px orange; 参数为 x、y轴方向偏移阴影，以及模糊值，颜色 可以叠加阴影，第一个在最上面 浮雕文字 元素模糊123h1&#123; filter: blur(5px)&#125; 模糊背景 文字描边 只有webkit内核才支持：-webkit-text-stroke（准确的来说不能算是css3的东西，但需要大家知道） 123div&#123; -webkit-text-stroke: pink 5px;&#125; 文字排版 direction:控制文字的方向 一定要配合unicode-bidi:bidi-override;来使用 1234div&#123; direction: rtl; 从右向左 unicode-bidi: bidi-override;&#125; 单行文本溢出显示省略号123456// 前提是这个元素不是靠内容撑开的div&#123; white-space: nowrap; 首先不换行 overflow: hidden; 溢出隐藏 text-overflow: ellipsis; 文本显示省略号&#125; 多行文本溢出显示省略号123456789101112131415p&#123; position: relative; height: 40px; 高度为行高的整数倍，防止超出的文字露出 line-height: 20px; overflow: hidden; 溢出隐藏&#125;p:after&#123; 将::after换为:after兼容ie8 content: &quot;...&quot;; position: absolute; right: 0; bottom: 0; padding-left: 40px; background: linear-gradient(to right, transparent, #fff 55%); 添加渐变背景可避免文字只显示一半&#125; 盒模型新增样式 img、input属于行内替换元素。 替换元素就是浏览器根据元素的标签和属性，来决定元素的具体显示内容 替换元素一般有内在尺寸，所以具有width和height，可以设定。 图片居中demo用容器的伪元素给图片做一个兄弟元素(高度=容器的高度，inline-block)，并让他两个基线对齐，就实现了图片的垂直居中 123456789101112131415161718192021//样式#app&#123; width: 500px; height: 500px; border: 1px solid red; text-align: center;&#125;#app::after&#123; content: &quot;&quot;; display: inline-block; height: 100%; vertical-align: middle;&#125;img&#123; vertical-align: middle;&#125;//dom结构&lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./love.gif&quot; alt=&quot;shulu&quot;&gt;&lt;/div&gt; 盒模型阴影 box-shadow box-shadow: 5px 5px 5px 5px pink 即x偏移量 | y偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 可以做不占空间的边框。这个也挺好。 demo 一个元素生成哆啦A梦的图，即是这个元素的多个不同的阴影的叠加效果，配合border-radius，以及前后的两个伪元素。 倒影 -webkit-box-reflect 设置元素的倒影（准确的来说不能算是css3的东西，但需要大家知道） 倒影的方向 第一个值，above, below, right, left 倒影的距离 第二个值，长度单位 渐变 第三个值 123img&#123; -webkit-box-reflect: left&#125; resize 该属性允许你控制一个元素的可调整大小性。 一定要配合overflow：auto使用 both 允许用户在水平和垂直方向上调整元素的大小。 horizontal 水平方向 vertical 垂直方向 1234567#text&#123; width: 100px; height: 100px; background-color: pink; overflow: auto; resize: both;&#125; box-sizing 该属性用于更改用于计算元素宽度和高度的默认的 CSS 盒子模型。可以使用此属性来模拟不正确支持CSS盒子模型规范的浏览器的行为。 box-sizing 属性用于更改用于计算元素宽度和高度的默认的 CSS 盒子模型。可以使用此属性来模拟不正确支持CSS盒子模型规范的浏览器的行/列为。 默认值：content-box 不可继承 1234567content-box默认值，标准盒子模型。 width 与 height 只包括内容的宽和高， 不包括边框（border），内边距（padding），外边距（margin）。注意: 内边距, 边框 &amp; 外边距 都在这个盒子的外部。 比如. 如果 .box &#123;width: 350px&#125;; 而且 &#123;border: 10px solid black;&#125; 那么在浏览器中的渲染的实际宽度将是370px;尺寸计算公式： width = 内容的宽度， height = 内容的高度。 宽度和高度都不包含内容的边框（border）和内边距（padding）。 123456border-boxwidth 和 height 属性包括内容，内边距和边框，但不包括外边距。这是当文档处于 Quirks模式 时Internet Explorer使用的盒模型。这里的维度计算为： width = border + padding + 内容的 width， height = border + padding + 内容的 height。 新增UI样式圆角 border-radius 传统的圆角生成方案，必须使用多张图片作为背景图案 CSS3圆角的出现，使得我们再也不必浪费时间去制作这些图片了，而且还有其他多个优点： 12345678910111213* 减少维护的工作量。图片文件的生成、更新、编写网页代码，这些工作都不再需要了。* 提高网页性能。由于不必再发出多余的HTTP请求，网页的载入速度将变快。* 增加视觉可靠性。某些情况下（网络拥堵、服务器出错、网速过慢等等），背景图片会下载失败，导致视觉效果不佳。CSS3就不会发生这种情况. 注意 百分比值在旧版本的 Chrome 和 Safari 中不支持。(fixed in Sepember 2010)在 11.50 版本以前的 Opera 中实现有问题。Gecko 2.0 (Firefox 4) 版本前实现不标准：水平半轴和垂直半轴都相对于盒子模型的宽度。在旧版本的 iOS (iOS 5 之前) 和 Android 中 (WebKit 532 之前) 不支持。 扩展-绝对定位模拟固定定位 固定定位在ie6以及移动端的兼容性不太好，故需要模拟实现 html,body,#wrap三者的高度都为100%，即都等于文档视口的高度。 默认滚动条在document上，可以设置在一个全局的容器#wrap(高度=视口的高度，overflow: auto)身上 初始包含块：是一个与视窗等大小、等位置的矩形，滚动默认滚动条它会跟着动 body作为父级(没有定位)，绝对定位的元素是相对于这个初始包含块定位的 禁止系统滚动条后，初始包含块便不会再动了 这样绝对定位的元素也不会动了，即模拟了固定定位的效果 demo 123456789101112131415161718192021222324252627282930//样式html,body&#123; height: 100%; /* 禁止系统滚动条 */ overflow: hidden;&#125;#wrap&#123; /* 将滚动条设置到我们的容器上 */ height: 100%; overflow-y: auto;&#125;#app&#123; /* 为了撑开容器看到滚动条 */ height: 3000px;&#125;#red&#123; /* 绝对定位的元素，实现了固定定位的效果 */ position: absolute; top: 0; left: 0; width: 100px; height: 100px; background-color: red;&#125;//dom结构&lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;red&quot;&gt;&lt;/div&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/div&gt; 边框图片 border-image 属性允许在元素的边框上绘制图像。这使得绘制复杂的外观组件更加简单，使用 border-image 时，其将会替换掉 border-style 属性所设置的边框样式如实线solid。 123456border-image-source: url(./love.jpg) 图片border-image-slice: 百分比该属性会通过规范将图片明确的分割为9个区域：四个角，四边以及中心区域。图片见 MDNborder-image-width: 定义图像边框宽度。 border-image-outset: 定义边框图像可超出边框盒的大小border-image-repeat: 定义图片如何填充边框。stretch(拉伸),repeat，round（平铺） css2背景 background-color background-image background-position background-repeat 1234repeat-x repeat-y repeat no-repeat css3背景新增 background-origin设置背景渲染的起始位置 123border-boxpadding-box(默认)content-box background-clip 设置背景裁剪位置 -webkit-background-clip 按文字剪贴背景(文字有透明才行) background-size 设置背景图片大小 background 是CSS简写属性，用来集中设置各种背景属性。 线性渐变-背景图片渐变 background-image: linear-gradient(red,blue); 为了创建一个线性渐变，你需要设置一个起始点和一个方向（指定为一个角度）。你还要定义终止色。终止色就是你想让浏览器去平滑的过渡过去，并且你必须指定至少两种，当然也会可以指定更多的颜色去创建更复杂的渐变效果。 默认从上到下发生渐变 linear-gradient(red,blue); 改变渐变方向：（top bottom left right） linear-gradient(to 结束的方向,red,blue); 使用角度 linear-gradient(角度,red,blue); 颜色节点的分布（第一个不写为0%，最后一个不写为100%） linear-gradient(red 长度或者百分比,blue 长度或者百分比); 重复渐变 repeating-linear-gradient(60deg,red 0,blue 30%); 径向渐变-背景图片渐变 background-image: radial-gradient(red,blue); radial-gradient() 函数创建一个，用来展示由原点（渐变中心）辐射开的颜色渐变 默认均匀分布 radial-gradient(red,blue); 不均匀分布 radial-gradient(red 50%,blue 70%); 改变渐变的形状 radial-gradient(circle ,red,blue) circle ellipse（默认为椭圆） 渐变形状的大小 radial-gradient(closest-corner circle ,red,blue) closest-side 最近边 farthest-side 最远边 closest-corner 最近角 farthest-corner 最远角（默认值） 改变圆心 radial-gradient(closest-corner circle at 10px 10px,red,blue); 剪切元素 clip-path 该属性可以创建一个只有元素的部分区域可以显示的剪切区域。区域内的部分显示，区域外的隐藏。剪切区域是被引用内嵌的URL定义的路径或者外部svg的路径，或者作为一个形状例如circle()。 配合svg实现ios圆角 有事您Q我👇","categories":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/categories/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/tags/css3/"},{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"哲学","slug":"哲学","date":"2019-07-16T05:42:24.000Z","updated":"2019-07-16T05:54:53.370Z","comments":true,"path":"哲学/哲学/","link":"","permalink":"https://shulu520.com/哲学/哲学/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 有事您Q我👇","categories":[{"name":"哲学","slug":"哲学","permalink":"https://shulu520.com/categories/哲学/"}],"tags":[{"name":"philosophy","slug":"philosophy","permalink":"https://shulu520.com/tags/philosophy/"}]},{"title":"电影学","slug":"电影学","date":"2019-07-16T05:42:07.000Z","updated":"2019-07-16T05:49:04.657Z","comments":true,"path":"电影学/电影学/","link":"","permalink":"https://shulu520.com/电影学/电影学/","excerpt":"&emsp;&emsp;人生苦短，我只看经典电影。","text":"&emsp;&emsp;人生苦短，我只看经典电影。 有事您Q我👇","categories":[{"name":"电影学","slug":"电影学","permalink":"https://shulu520.com/categories/电影学/"}],"tags":[{"name":"movie","slug":"movie","permalink":"https://shulu520.com/tags/movie/"}]},{"title":"心理学","slug":"心理学","date":"2019-07-16T05:41:18.000Z","updated":"2020-10-20T15:33:36.432Z","comments":true,"path":"心理学/心理学/","link":"","permalink":"https://shulu520.com/心理学/心理学/","excerpt":"&emsp;&emsp;生活，不就是解决一个又一个难事儿嘛，没什么大不了的，过去了就好了。","text":"&emsp;&emsp;生活，不就是解决一个又一个难事儿嘛，没什么大不了的，过去了就好了。 心理学语录&emsp;&emsp;心理学家研究发现，人在帮助别人的时候，自己也容易获得快乐。委屈难过的时候，不如去做一件善事，帮助别人会让你觉得自己同样有能力做一些有价值的事情。&emsp;&emsp;人生不可能永远是坦途，复杂让我们烦恼忧愁，浮躁让我们不堪一击，邋遢让我们表里不一。简是幸福，静是根本，净是福气。世事变幻，人生最难得的就是这三个字。简，是幸福的真谛；静，是立身的根本；净，是家庭的福气。人生做到简、静、净，而后幸福、立身、家和，如此，足矣。&emsp;&emsp;心理学家认为，人们一般接受了一个要求后，对后续递进的要求就有更多的理解与宽容，这就是“登门槛效应”对人的影响。老实人带给人的安全感就是给予了他人一种向下依赖的感觉，随着时间的改变或者人性的不同，很容易就变成了索取，这种索取获得的导致的结果常常是老实人的失去。&emsp;&emsp;“不要去追一匹马，用追马的时间种草，待到来年春暖花开之时就会有一批骏马任君选择。”&emsp;&emsp;不光是事业，爱情也是如此。最好的爱不过是一场相互吸引，费尽心思准备浮夸的表白却不见行动，倒不如用心经营出一个更好的自己。&emsp;&emsp;大家都想靠近光，你不要追着光跑得气喘吁吁，你要去成为那束光。青春如棋，落子无悔，不要去追一匹马，用追马的时间种草，静盼来年。&emsp;&emsp;一小孩搬石头，父亲在旁边鼓励：孩子，只要你全力以赴，一定搬得起来！最终孩子未能搬起石头，他告诉父亲：我已经拼尽全力了！父亲答：你没有拼尽全力，因为我在你旁边，你都没请求我的帮助！——全力以赴就是想尽所有办法，用尽所有可用资源。 有事您Q我👇","categories":[{"name":"心理学","slug":"心理学","permalink":"https://shulu520.com/categories/心理学/"}],"tags":[]},{"title":"生活中的经济学","slug":"经济学","date":"2019-07-16T05:28:58.000Z","updated":"2020-12-28T14:34:36.627Z","comments":true,"path":"经济学/经济学/","link":"","permalink":"https://shulu520.com/经济学/经济学/","excerpt":"&emsp;&emsp;物以稀为贵。","text":"&emsp;&emsp;物以稀为贵。 经济学语录&emsp;&emsp;用机会成本来解释人生的选择，用沉没成本来形容不能挽回的过去；用投入和产出来衡量我们的收益，用资源禀赋来对自己进行客观评价；很多曾经美好的东西，随着岁月流逝而不在再，那是因为边际效益递减。&emsp;&emsp;很多问题的根源在于利益，利益的根源在于资源。我对你有权利，在于我具备你想得到的资源。所以我们想要提升自己的魅力，首先要创造别人所需要的东西。感情方面，想要一个人对你好，不在于你对他有多好，而是你有能够吸引、抓住他的地方，有别人所不具备的优点和魅力。&emsp;&emsp;人类欲望的无限性造成了资源的稀缺性。经济物品的稀缺性并不意味着它是稀少的，而是指它不可以免费得到。如果你以“获取资源”的态度来看这个世界，你会发现很多原来让你讨厌的事，其实并不讨厌，你也能让更多本不相关的事物发生链接。&emsp;&emsp;你就是一个普通人，你改变命运的方式只有一种，那就是拥有一技之长，干好手头的工作，赚到真正属于你的钱，然后再去保护好它们。&emsp;&emsp;我和几位校友吃饭，其中一位是深圳某投资公司的老总，风度翩翩，讲文明懂礼貌。我们点了菜，很久没上，服务员态度还贼差，其中一位校友吼了服务员两嗓，那老总马上制止，还向服务员道歉。我一开始觉得这人修为很高，后来服务员出去后，那老总说：“我们在明，人家在暗，把别人惹毛了，给你菜里面动动手脚，还不是我们吃亏？”那时我突然有点感悟：与其把这种态度归为修养，倒不如看成是一种理智行为，为的是自己不受损失。一件事情的走向，往往不是由对错决定的，而是由参与者的共识决定的。&emsp;&emsp;需求定理的例外：穷人看着钱买东西，富人看着东西花钱。即需求定理在某些领域内对富人不管用。&emsp;&emsp;品牌的秘密：名牌产品给人信赖感。名牌包包，名牌大学等。并非由产品质量而是由其他因素引起的排斥现象称为经济领域的歧视。&emsp;&emsp;注意力经济俗称眼球经济，谁吸引的眼球多，谁的身价自然高。&emsp;&emsp;成功人士的经济学特点：积极思考，理性行动。你遇到的事情不是最重要的，重要的是你如何对待它。成功人士总是在不停的学习，阅读书籍，勤于学习技能和寻找良师益友。&emsp;&emsp;在物质层面上，一个社会如果控制了更高级的生产活动，从长期看来它的社会财富会更多。那是因为，如果你今年用很便宜的价格买到了钢铁和酒，作为消费者，你确实是赚了。但是，若果从 10 年或者 50 年的跨度来看，如果能够自己生产钢铁和酒的话，你和你的孩子们会生活的更好。如果你不仅可以买钢铁而是可以生产钢铁，那么你更容易制造机器。如果你能够制造机器，你就更容易制造发动机，机器人和飞行器。如果你能够制造发动机，机器人和飞行器，那么你的孩子和孙子就更有可能制造出更高级的产品进而在未来几十年获得更好的收入。&emsp;&emsp;我们做任何选择都是有机会成本的，你去学习并参加了一项证书考试，必然要放弃相当一部分在你自 己最擅长的、最喜欢的领域所投人的时间、精力、金钱等资源。我们也很容易发现，任何一种学习都是开始的时候收效很大，但学到较高的程度后都会觉得要再获得进步就比较困难了，需要花费比原来更多的时间、精力等资源才能进步-点点。任何一门证书的学习也是一样， 尽管它主要消耗的是时间资源，但这种时间资源的投入越来越高，而收效却是越来越少，如果你不是真的日常工作需要如此大量使用这项技能的话，你的这些投入基本上是没有意义的，除非这是你的兴趣爱好，那另当别论。&emsp;&emsp;你要想在某一学科获得进步 ,就必须更多地投人时间以及与之配套的金钱、精力等资源，这样势必进一步挤占本来具有 “比较优势”的另外一门学科的学习资源。如此恶性循环，最终导致的结果是，你早先投入某项学习里的成本所形成的比较优势，在逐步缺乏学习资源支持的情况下也在逐步流失，而你原本不具有“比较优势”的“一项证书的考核”却吸收了你极大的学习资源。因为如果你是学英语专业的，与金融学专业的学生相比你在“金融精算师”方面不具有任何“ 比较优势”，所以你要达到和他们一样的专业水平的话，必须要付出更为高昂的投入总成本，成本越高，越不具有市场竞争力。与此同时，由于你在你原本具有“比较优势”的英语方面学习投入的减少，导致你与其他英语专业的同学相比，你的英语的“比较优势”也在丧失，最坏的结果就是，两边的比较优势都在下降。&emsp;&emsp;我们保持我们自己的“比较优势”，不能随便地受到周围的浮夸宣传的影响，。 一会儿去考什么会计资格证书，一会儿去考什么计算机二级，这样只会无谓地浪费自己的时间、精力、金钱，抬高自己包括机会成本在内的总成本，使自己进一步丧失市场竞争力。教育培训的投人要有的放矢，以进一步提高自己的“比较优势”为目的，而不是盲目的，随波逐流的。&emsp;&emsp;其实，每个人都有自己最独特的一面，发掘自己这种独特的一面，进而充分发挥出自己的比较优势，你就可以扭转乾坤，立于不败。没有一一个人在所有方面都是杰出的，人总有擅长与不擅长的地方，正所谓术业有专攻，没必要为自己的短处而闷闷不乐甚至自卑，发挥自己的比较优势，让自己展现应有的光芒。&emsp;&emsp;边际效用递减规律 一次，杰夫的一个朋友查理来看望他。老朋友的到来令杰夫感到非常高兴，便用鲜美可口的烤牛肉来招待他。杰夫叫服务员端来了-块牛肉。查理切下一小块放入口中，细细地品味了一番。牛肉外酥里嫩，十分爽口，所以查理很快就把第一块烤 牛肉吃光了。于是杰夫又叫服务员端来了5块牛肉，查理又拿着刀叉吃了起来。吃第二块牛肉，觉得味道尚可，但没有第一块好吃，吃第三块….才吃了几口，就咽不下去了。这时，查理忽然感到“杰夫烤牛肉”的味道也不过如此。&emsp;&emsp;上述例子说明，尽管牛肉的质量相同，但你会感觉到第一块牛肉又香又嫩，而第三块牛肉则味同嚼蜡，所以吃第一块牛肉与第三块牛肉的感觉是不同的。这就是边际效用递减规律。&emsp;&emsp;在门格尔看来，人们在财货数量有限的情况下，不能使全部欲望都得到满足，他们只能根据欲望的重要性进行分配，首先满足最重要的和较重要的欲望，而在一系列能被满足的欲望中，总有一个是最后被满足的最不重要的、意义最小的、处在满足和不满足边缘上的欲望，即它是随时会随财货量的减少而首先被放弃掉而得不到满足的欲望。这时各种欲望的满足程度达到一-致。这种欲望可称为边际欲望，而满足这种边际欲望的能力就是边际效用。&emsp;&emsp;我的看法：对消费者来说，同一时间，消费同一物品的边际效用是递减的。那么作为商家，虽然可以以“第二件半价”等手段促进消费，但是这么做，会使消费者的满足程度降低，进而降低对本产品的欲望需求。短时间内看，商家会赚钱，从长远来看，不利于这种商品的销售，对长久利益有损失。&emsp;&emsp;你是一家公司的老板，你有两种支付员工报酬的方式。一种方式你可以给员工支付定额的高薪，另一种方式你可以给员工相对低一些的工资，但是时不时地给他们一些奖励。客观来讲，你的工司第一种方式中花的钱更多，但是你的员工会在第二种方式中更高兴，而这个时候公司花的钱还更少。&emsp;&emsp;利用互补品的经济学原理还可以给公司带来运营上的收益。美国早期的城市电车系统就是一个很好的例子。早期的电车运营商们投入了庞大的资金来修建专门的道路网络,可让他们万万没有想到的是,虽然电车在上下班的时候客流量很大,但高峰期之外却很少会有人搭乘电车。毫无疑问,这种客流量的不均衡性大大降低了运营商们的盈利能力。为了提高非高峰期的客流量,运营商们想到了一个绝妙的主意:他们决定在市中心之外修建娱乐公园。到1901年,美国有超过一半的市区交通公司都修建了类似的公园。这些公园不仅增加了电车的客流量,它们还提高了发电机的使用率,从而大大提高了电车运营商们的资本效率。&emsp;&emsp;我们会发现一种非常奇怪的事情，你在高档的精品屋里打7折买来的东西，在外面一般的商场里价格却与自己买的基本差不多。因为你被打折的手法诱惑了，你只获得了过多的消费者剩余心理的满足，而付出的是自己的真金白银。&emsp;&emsp;商家想方设法把消费者剩余转化为利润的例子在日常生活中比比皆是，当你在水果摊看到刚上市的荔枝时，新鲜饱满的荔枝激起了你强烈的购买欲望，并且这种欲望溢于言表。卖水果的人看到你看中了他的荔枝，他会考虑以较高的价格卖给你。其实，你对荔枝的较强的购买欲望，表明你愿意支付更高的价格，从而有更多的消费者剩余。所以，当你询问价格的时候，他会故意提高价格，由于你的消费者剩余较多，或许你对这个价格还挺满意，便毫不犹豫地把荔枝买了下来。结果，你的消费者剩余转化为水果摊主的利润。&emsp;&emsp;这个例子告诉我们在购买商品时应该如何维护自身利益的一些经验，比如，当我们想购头某种商品时，不要眼睛直勾勾地看着这件商品，不妨表现出无所谓的态度，甚至表现出对该商品的“不满”，这样，商家以为你不太想买，就不敢提高价格。&emsp;&emsp;新裤子。穿上裤子，又觉得皮鞋的式样不般配，只好又去买双新皮鞋。回到家才发现，原本只想花几十块钱，最后却花了好几百。&emsp;&emsp;又比如说，买到套三室两厅的新住宅之后，自然要好好装修一番。首先是铺上大理石或木地板，然后以黑白木封墙，再安装像样的吊灯;四壁豪华之后，自然还想配上一些高档家具。而一旦住上了这样的高档住宅，出入时显然不能再穿旧衣烂衫，必定要穿“ 拿得出手”的衣服与鞋袜。如此这般下去，所有这一切，都只是为了跟这套房子配套。&emsp;&emsp;其实，应该警惕这种预料之外的开支。还没有到月末，就发现这个月已经大大超支，原因是买了许多不在计划之中的“狄德罗商品”。再比如原本计划得好好的日程安排，却由此被弄得乱七八糟。&emsp;&emsp;配套效应给我们一种启示:对于那些非必须的东西尽量不要。因为你接受了一件，那么外界的和心理的压力会使你不断地接受更多非必须的东西。&emsp;&emsp;在购物之中要格外小心那些与商品本身质量、价格、品牌等无关的纯粹的环境因素。如果想去购买一些好吃的糖果时，发现它的广告语和装饰字都用着圆润可爱的字体，那你可要注意了。你对这些糖果的享乐偏好有可能被这些字体放大，导致购买超出你计划的糖果量。在这种情况下，你就需要平衡一下自己的购买欲望了。&emsp;&emsp;我们的研究还为那些控制不住自己的人提供了方法。比如，想减肥的人可以在好吃的东西上面贴上一些方方正正的文字标签，利用方正字体去抵消美食的享乐性，从而在一定程度上帮助你控制自己。&emsp;&emsp;对商家来说，字体也可以成为“助攻”销售的工具，为享乐产品搭配上一些柔滑又线条感十足的文字或标识，可能会让本想买它们的消费者变得更有冲动去购买。最关键的是，调整文字内容的字体，几乎是一种没有成本的营销策略。&emsp;&emsp;总之，我们的研究提供了一个有趣的视角，让人思考那些与商品本身无关的纯粹的环境因素，如何悄无声息地影响人们的买买买。&emsp;&emsp;穷困的孩子每天少一块钱吃喝，其体格和智力的发育就会同一般营养健全的孩子相差甚远，可能在很大程度上影响其一生的生命质量。&emsp;&emsp;从一定的角度看，市场经济是无情的，有时甚至是无耻的，因为市场追逐的是自身的利益，收入、资金和财富都流向高效益的地方，落后的地方只会让自己的资源、财富、人才流向发达地区。任何个体、群体或地区，一旦在某一一个方面( 如金钱、名誉、地位等)获得成功和进步，就会产生-种积累优势，就会有更多的机会取得更大的成功和进步。而贫穷的人只能越来越穷。这就容易形成“马太效应”。马太效应来自于《圣经》中的一个故事。个国王远行前，交给3个仆人每人1枚金币，吩咐他们:“你们去做生意，等我回来时，再来见我。”国王回来时，第一一个仆人说:“主人，你交给我1枚金币，我已赚了10枚金币。”于是国王奖励了他10座城邑。第二个仆人报告说:“主人，你给我的1枚金币，我已赚了5枚。”于是国王便奖励了他5座城邑。第三个仆人报告说:“主人，你给我的1枚金币，我一-直包在手巾里，一直没有拿出来。”于是国王命令将第三个仆人的那枚金币赏给第一个仆人，并且说:“凡有的，还要加给他，叫他多余;没有的，连他所有的，也要夺过来。”这就是马太效应的故事。&emsp;&emsp;一日你拥有得越多，你也就发展得越快，你拥有得越少，你发展得就越慢。小小的差距经过一段时间的变化和发展，会形成天壤之别，经济的发展、技术的进步、知识的增长、能力的增强、收入的增长都是以几何级数递增的。于是，弱者更弱，强者更强，形成“马太效应”。&emsp;&emsp;节俭的事例在我们生活中再常见不过了，特别是上了年纪的父辈、祖辈们。他们每每看到剩饭总会说:都不知道我们小时候吃的啥，你看你们剩的。&emsp;&emsp;剩饭该勉强吃下还是该扔掉，值得思考。一方面从小我们就接受“谁知盘中餐，粒粒皆辛苦”的教育，家长大多告诫孩子，将碗里的饭菜吃光。即使现在外出做客，也常听到有人相劝“多吃多吃，免得浪费”。从经济学角度分析，剩饭是吃下还是扔掉，二者都是浪费。做熟的饭菜若不便保存及交换便是沉没成本，这是一笔已经付出的开支，无论做什么选择都不可能将熟饭再变成生米。&emsp;&emsp;另一方面， 当我们深刻领悟了吃饭吃到撑死的定律，也就是边际收益(效用)递减规律后，我们会发现许多生活哲学，就能得出结论:吃剩饭实在不是一个明智之举。 吃得太多，已经味同嚼蜡，毫无享受美食之感，自然也就边际效用递减了，根本谈不上是强身壮体。相反，如果剩饭变质，吃出毛病，赔上医药费不说，还得让身体和精神双倍受损。边际效用递减规律是一个普遍的基本规律，在经济学、生物学、物理学、心理学方面都成立。我们让大家了解这种思维方式，并非是要大家对每一件事都去精确地计算其中的收益成本，而是让大家明白其中所包含的生活哲理。(理性的人在决策时应忽略沉没成本的存在和注意边际效用递减的规律。)&emsp;&emsp;沉没成本决定了人们如果看待过去，边际成本决定了人们如何对待现在，机会成本则决定了人们如何面对未来。&emsp;&emsp;边际，就是增量的意思。既然表达的是增量，那么它背后的深层含义是什么？就是趋势。边际成本的思想告诉我们，个人成长也好，财富自由也好，我们应当去发掘那些边际成本足够低的路径。&emsp;&emsp;随着时间的推移，我们的工作经验会越来越多，做事的效率会越来越高，因此完成一件工作所需要耗费的时间和精力会越来越少，这就是一种边际成本下降的典型路径。之所以说边际成本决定了你的现在，就是说你现在做的每件事，是否朝着边际成本逐渐降低的方向在推进，将很大程度决定你做这件事的回报和未来的爆发力。&emsp;&emsp;如果你只是在做机械的重复性工作，那恭喜你，一辈子都和财富自由无望，也不太可能实现自己爆发式的成长。如果你做的事情，有在未来获得高回报但不需要再投入的可能，那么恭喜你，你正走在一条可能爆发的路上。&emsp;&emsp;因此，对边际成本理解的深刻程度，会直接决定你现在会做什么样的事情。人们习惯的思维模式，是如果我去做这件事，失败了会损失什么?这是典型的会计成本的思维模式。在这种思维模式下，人们会极力最小化潜在损失，最小化风险。&emsp;&emsp;机会成本的思维模式是这样的：如果我不去做这件事，我可能会失去什么？是不是正好反过来？机会成本的思维，即是更多看到未来的思维，是一种基于战略的思维。会让我们做选择时，更加基于大格局大战略，来分析各个选项的优劣，而不仅仅是风险和损失。&emsp;&emsp;如果一个人特别看重机会成本，就不会特别计较眼前的得失。面对未来会显得更加有勇气去做一些新的尝试，因为他们害怕失去未来可能的机会，这种失去带来的成本，才是他们不可承受的（相较于去冒险可能面临的失败后的会计成本）。&emsp;&emsp;机会成本也是人们为什么总在提倡要花时间去做那些「重要但不紧急的事情」，因为它们的机会成本足够大。&emsp;&emsp;比如你长期不学习不看书的机会成本就是那个“更好的自己”，长期不运动的机会成本就是一个“更健康的自己”，长期不深入思考和复盘反思的机会成本就是那个”独立和深刻的自己”。要知道，人们最后悔的事，是「我本可以」。&emsp;&emsp;一个身体健康的人，往往比一个身体不健康的人更容易快乐;一个精神健康的人，有较好的自我调适能力和人际关系处理能力，心情愉快的时候会比精神不健康的人多。同时，身体健康和精神健康又是互相影响、互相依存的。可以说，健康带给我们的舒适感，并不是虚无缥缈的，它和食物、 水样， 是我们生活中较为基本的需求之一，当然， 这种需求的层次比单纯生存的需求层次要高。生存需求得到满足后，人们才会有健康需求，才会花费时间和财富，为自己的健康进行投资，从而享受健康带来的舒适和快乐。&emsp;&emsp;人是一种有价值的资本，个人的人力资本是经济增长和财富创造的源泉，也是个人财富的源泉。一个健康的人才能正常地从事工作，创造财富，或者说，健康的人比不健康的人工作效率更高，劳动价值更大。教育带来了知识和技能，却不能代替健康。作为人力资本的重要组成部分，健康影响着人力资本的产出，它使一个人工作的时间增多，工作效率提高，间接地参与了社会生产和再生产，正是因为这样，健康的人比不健康或亚健康的人，其人力资本价值更大，潜在的财富更多。而不健康的人，由于生命的风险更大，其人力资本价值会降低，因为，不健康的人，其人力资本发挥的作用会受到其健康状况的制约，甚至于自己创造的一部分财富被不健康的身体耗费。所以，健康是个人的真正财富。毕竟有了健康的身体，即使暂时财富比较少，也可以通过自己的劳动创造更多的财富;而不健康的人，即使财富多，也可能因为健康差的原因，使自己的财富被医疗费或生命风险剥夺。&emsp;&emsp;那么，健康的价值有没有一个量化的标准?健康保险的引入，为健康的估价提供了一个有力的依据。从世界范围来看，在健康保险比较发达的国家和地区，健康保险的投保金额等于人们享受医疗服务的限度。人们认为自己的健康价值多少，就会投保相应的保额，为自己的健康买单。 有事您Q我👇","categories":[{"name":"经济学","slug":"经济学","permalink":"https://shulu520.com/categories/经济学/"}],"tags":[{"name":"economics","slug":"economics","permalink":"https://shulu520.com/tags/economics/"}]},{"title":"css3-font","slug":"css3-font","date":"2019-07-14T07:06:41.000Z","updated":"2019-07-16T14:50:00.248Z","comments":true,"path":"css3/css3-font/","link":"","permalink":"https://shulu520.com/css3/css3-font/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 位图vs矢量图位图 位图图像（bitmap），亦称为点阵图像或栅格图像，是由称作像素（图片元素）的单个点组成的。这些点可以进行不同的排列和染色以构成图样。当放大位图时，可以看见赖以构成整个图像的无数单个方块。扩大位图尺寸的效果是增大单个像素，从而使线条和形状显得参差不齐。然而，如果从稍远的位置观看它，位图图像的颜色和形状又显得是连续的。用数码相机拍摄的照片、扫描仪扫描的图片以及计算机截屏图等都属于位图。位图的特点是可以表现色彩的变化和颜色的细微过渡，产生逼真的效果，缺点是在保存时需要记录每一个像素的位置和颜色值，占用较大的存储空间。常用的位图处理软件有Photoshop（同时也包含矢量功能） 矢量图 矢量图[vector]，也叫做向量图，简单的说，就是缩放不失真的图像格式。矢量图是通过多个对象的组合生成的，对其中的每一个对象的纪录方式，都是以数学函数来实现的，也就是说，矢量图实际上并不是象位图那样纪录画面上每一点的信息，而是纪录了元素形状及颜色的算法，当你打开一付矢量图的时候，软件对图形象对应的函数进行运算，将运算结果[图形的形状和颜色]显示给你看。无论显示画面是大还是小，画面上的对象对应的算法是不变的，所以，即使对画面进行倍数相当大的缩放，其显示效果仍然相同[不失真]。 位图与矢量图的区别 最大的区别，矢量图形与分辨率无关，可以将它缩放到任意大小和以任意分辨率在输出设备上打印出来，都不会影响清晰度，而位图是由一个一个像素点产生，当放大图像时，像素点也放大了，但每个像素点表示的颜色是单一的，所以在位图放大后就会出现咱们平时所见到的马赛克状。 位图表现的色彩比较丰富，可以表现出色彩丰富的图象，可逼真表现自然界各类实物；而矢量图形色彩不丰富，无法表现逼真的实物，矢量图常常用来表示标识、图标、Logo等简单直接的图像。 由于位图表现的色彩比较丰富，所以占用的空间会很大，颜色信息越多，占用空间越大，图像越清晰，占用空间越大；由于矢量图形表现的图像颜色比较单一，所以所占用的空间会很小。 字体图标的好处 图片不但增加了总文件的大小，还增加了很多额外的”http请求”，这都会大大降低网页的性能的。图片还有一个缺点就是不能很好的进行“缩放”，因此，有时候在“响应式设计”中需要使用图像的最好解决方案就是不去使用图片。 很容易任意地缩放； 很容易地改变颜色； 很容易地产生阴影； 可以拥有透明效果； 一般来说，有先进的浏览器支持； 可以使用CSS来装饰（可以得到CSS很好支持）； 可以快速转化形态（做出一些变化，如 :hover等）； 可以做出跟图片一样可以做的事情（改变透明度、旋转度，等）； 本身体积更小，但携带的信息并没有削减。 不用每次修改都还得重新切图替换。 自定义字体1234567891011121314//样式@font-face&#123; font-family: &apos;自定义的名字&apos;; src: url(&apos;../font/字体名称.eot&apos;); src:url(&apos;../font/字体名称.woff&apos;) format(&apos;woff&apos;), url(&apos;../font/字体名称.ttf&apos;) format(&apos;truetype&apos;), url(&apos;../font/字体名称.svg&apos;) format(&apos;svg&apos;);&#125; h1&#123; font-size:36px; color:#ccc; font-family: &quot;自定义的名字&quot;; &#125; 字体图标 字体图标就是运用了css3的自定义字体 有专门的网站可以做字体 常使用阿里巴巴字体图标库 有事您Q我👇","categories":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/categories/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/tags/css3/"},{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"css3-selectors","slug":"css3-selectors","date":"2019-07-14T03:44:38.000Z","updated":"2019-07-16T14:59:29.056Z","comments":true,"path":"css3/css3-selectors/","link":"","permalink":"https://shulu520.com/css3/css3-selectors/","excerpt":"&emsp;&emsp;走到世界尽头。那风从哪里吹来，云又将飘向哪儿，世界的尽头在何方，想知道答案，唯有往前走。","text":"&emsp;&emsp;走到世界尽头。那风从哪里吹来，云又将飘向哪儿，世界的尽头在何方，想知道答案，唯有往前走。 css的全称 Cascading Style Sheets CSS3选择器规范地址：https://www.w3.org/TR/2011/REC-css3-selectors-20110929/ CSS3选择最新选择器规范: https://www.w3.org/TR/selectors 样式表的组成 规则—&gt;选择器+声明块 —&gt;css属性+css属性值组成的键值对 浏览器读取选择器的顺序 从右往左 即从小范围开始找 属性继承：有的属性有继承性有的没有，学习选择器时要注意到这一点 继承：html元素可以从父元素那里继承一部分css属性，即使当前元素没有定义该属性。 比如：color有继承性 而border没有 基本选择器 通配符选择器 * { margin: 0; padding: 0; border: none; } 元素选择器 body { background: #eee; } 类选择器 .list { list-style: square; } ID选择器 #list { width: 500px; margin: 0 auto; } 后代选择器 .list li { margin-top: 10px; background: #abcdef; } 基本选择器扩展 子元素选择器 12#wrap &gt; .inner &#123;color: pink;&#125;也可称为直接后代选择器,此类选择器只能匹配到直接后代，不能匹配到深层次的后代元素 相邻兄弟选择器 12#wrap #first + .inner &#123;color: #f00;&#125;它只会匹配紧跟着的兄弟元素 通用兄弟选择器 12#wrap #first ~ div &#123; border: 1px solid;&#125;它会匹配所有的兄弟元素(不需要紧跟) 选择器分组 12h1,h2,h3&#123;color: pink;&#125; 此处的逗号我们称之为结合符 属性选择器存在和值属性选择器 [attr]：该选择器选择包含 attr 属性的所有元素，不论 attr 的值为何。 [attr=val]：该选择器仅选择 attr 属性被赋值为 val 的所有元素。 [attr~=val]：表示带有以 attr 命名的属性的元素，并且该属性是一个以空格作为分隔的值列表，其中至少一个值为val。 子串值属性选择器 [attr|=val] : 选择attr属性的值是val（包括val）或以val-开头的元素。 [attr^=val] : 选择attr属性的值以val开头（包括val）的元素。 [attr$=val] : 选择attr属性的值以val结尾（包括val）的元素。 [attr*=val] : 选择attr属性的值中包含字符串val的元素。 伪类与伪元素选择器 伪类：其出现是为了拿到元素的一些状态 伪元素：其出现是为了拿到css tree以外的元素 链接伪类 注意:link，:visited，:target是作用于链接元素的！ :link 表示作为超链接，并指向一个未访问的地址的所有锚 :visited 表示作为超链接，并指向一个已访问的地址的所有锚 :target 代表一个特殊的元素，它的id是URI的片段标识符 使用 :target实现最简单的选项卡 demo 123456789101112131415161718192021//样式：div&#123; width: 100px; height: 100px; color: red; background: #ccc; font-size: 33px; display: none;&#125;:target&#123; display: block;&#125;//dom结构&lt;a href=&quot;#div1&quot;&gt;div1&lt;/a&gt;&lt;a href=&quot;#div2&quot;&gt;div2&lt;/a&gt;&lt;a href=&quot;#div3&quot;&gt;div3&lt;/a&gt;&lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt;&lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt; 动态伪类 注意:hover，:active基本可以作用于所有的元素！ :hover 表示悬浮到元素上 :active 表示匹配被用户激活的元素（点击按住时） 由于a标签的:link和:visited可以覆盖了所有a标签的状态， 所以当:link，:visited，:hover，:active同时出现在a标签 身上时 :link和:visited不能放在最后！！！ 隐私与:visited选择器 只有下列的属性才能被应用到已访问链接： color background-color border-color 表单相关伪类 :enabled 匹配可编辑的表单 :disable 匹配被禁用的表单 :checked 匹配被选中的表单 :focus 匹配获焦的表单 demo单选按钮:checked 12345678910111213141516171819202122232425262728293031323334353637//样式：label&#123; position: relative; display: block; width: 100px; height: 100px; border-radius: 50%; overflow: hidden; border: 1px solid &#125;label &gt; span&#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0&#125;input:checked + span&#123; background-color: red;&#125;.float&#123; float: left;&#125;//dom结构&lt;label class=&quot;float&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;love&quot;&gt; &lt;span&gt;&lt;/span&gt;&lt;/label&gt;&lt;label class=&quot;float&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;love&quot;&gt; &lt;span&gt;&lt;/span&gt;&lt;/label&gt;&lt;label class=&quot;float&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;love&quot;&gt; &lt;span&gt;&lt;/span&gt;&lt;/label&gt; 结构性伪类 index的值从1开始计数！！！！ index可以为变量n(只能是n) index可以为even odd .wrap ele:nth-child(index) 表示匹配#wrap中第index的子元素 这个子元素必须是ele .wrap ele:nth-of-type(index) 表示匹配#wrap中第index的ele子元素 除此之外:nth-child和:nth-of-type有一个很重要的区别！！ nth-of-type以元素为中心！！！ :nth-child(index)系列 12345:nth-child(index)系列 :first-child:last-child:nth-last-child(index):only-child (相当于:first-child:last-child 或者 :nth-child(1):nth-last-child(1) :nth-of-type(index)系列 123456789:nth-of-type(index)系列:first-of-type:last-of-type:nth-last-type(index):only-of-type (相当于:first-of-type:last-of-type 或者 :nth-of-type(1):nth-last-of-type(1)``` - :not 非 :not 非面试题：常用来做前后边框div &gt; a:not(:last-of-type){ border-right: 1px solid} 12345678910111213141516171819- :empty(内容必须是空的，有空格都不行，有attr没关系)- :nth-child选择要求相对严格些- :nth-of-type选择要求相对宽松些- 在一个容器中只有一种子元素则二者没什么区别## 伪元素- ::after 常用来清除浮动- ::before- ::firstLetter- ::firstLine- ::selection 鼠标选中后的自定义样式## css声明的优先级### 选择器的特殊性- 选择器的特殊性由选择器本身的组件确定，特殊性值表述为4个部分，如 0,0,0,0- 一个选择器的具体特殊性如下确定： 通配符选择器的特殊性为0,0,0,0对于选择器中的给定的各个元素和伪元素，加0,0,0,1对于选择器中给定的各个类属性，属性选择，或伪类，加 0,0,1,0对于选择器中给定的ID属性值，加 0,1,0,0内联声明的特殊性都是1,0,0,0 结合符对选择器特殊性没有一点贡献继承没有特殊性 123456 - 特殊性 1,0,0,0 大于所有以0开头的特殊性(不进位)- 选择器的特殊性最终都会授予给其对应的声明- 如果多个规则与同一个元素匹配，而且有些声明互相冲突时，特殊性越大的越占优势- **注意：id选择器和属性选择器** div[id=”test”]（0,0,1,1） 和 #test（0,1,0,0） ` 重要声明 !important 有时某个声明比较重要，超过了所有其他声明，css2.1就称之为重要声明 并允许在这些声明的结束分号之前插入 !important 来标志 必须要准确的放置 !important 否则声明无效。 !important 总是要放在声明的最后，即分号的前面 标志为 !important的声明并没有特殊的特殊性值，不过要与非重要声明分开考虑。 实际上所有的重要声明会被浏览器分为一组，重要声明的冲突会在其内部解决 非重要声明也会被分为一组，非重要声明的冲突也会在其内部解决 如果一个重要声明与非重要声明冲突，胜出的总是重要声明 样式继承 继承没有特殊性，甚至连0特殊性都没有 0特殊性要比无特殊性来的强 也就是说通配符选择器的样式比继承来的样式特殊性高 css样式来源 css样式的来源大致有三种 创作人员 读者 用户代理 css样式权重 读者的重要声明 即用户的操作 创作人员的重要声明 即我猿 创作人员的正常声明 读者的正常声明 用户代理的声明 即浏览器 层叠样式表 找出所有相关的规则，这些规则都包含一个选择器 计算声明的优先级 先按来源排序 在按选择器的特殊性排序 最终按顺序 有事您Q我👇","categories":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/categories/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/tags/css3/"},{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"axios","slug":"ajax-axios","date":"2019-07-04T09:57:25.000Z","updated":"2019-07-04T10:02:34.296Z","comments":true,"path":"axios/ajax-axios/","link":"","permalink":"https://shulu520.com/axios/ajax-axios/","excerpt":"&emsp;&emsp;每一个不曾起舞的日子，都是对生命的一种辜负。","text":"&emsp;&emsp;每一个不曾起舞的日子，都是对生命的一种辜负。 axios 基于promise用于浏览器和node.js的http客户端 特点 支持浏览器和node.js 支持promise 能拦截请求和响应 能转换请求和响应数据 能取消请求 自动转换JSON数据 浏览器端支持防止CSRF(跨站请求伪造) 1npm i axios 12345678910111213141516171819202122/* 发起一个GET请求 */// 可以参数直接拼接axios.get(&apos;/user?ID=12345&apos;) .then((result) =&gt; &#123; console.log(result) &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;)// 或者这样axios.get(&apos;/user&apos;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then((result) =&gt; &#123; console.log(result) &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;) 123456789101112/* 发起一个POST请求 */axios.post(&apos;/user&apos;, &#123; name: &apos;shulu&apos;, age: &apos;18&apos;&#125;).then((result) =&gt; &#123; console.log(result)&#125;).catch((err) =&gt; &#123; console.log(err)&#125;) 1234567/* 同时发起多个请求 */ let sendArr = [axios.get(&apos;/user/123&apos;), axios.get(&apos;/user/123/pions&apos;)]axios.all(sendArr) .then(axios.spread((resA, resB) =&gt; &#123; // 这里就可以拿到响应resA, resB&#125;)) 123456789101112131415/* 一些最最常用的请求配置项 */// 公共 URLaxios.defaults.baseURL = &apos;https://some-domain.com/api/&apos; // 定义POST请求中请求主体向服务器发送内容的格式，这里是项目中常用的格式// 这里似乎有点问题，得再看看axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;// 添加一个响应拦截器// 直接将响应的结果过滤得到我们最想要的data即响应主体数据axios.interceptors.response.use(res =&gt; res.data)// 自定义对HTTP响应状态码的处理axios.defaults.validateStatus = (status =&gt; &#123;……&#125;) 有事您Q我👇","categories":[{"name":"axios","slug":"axios","permalink":"https://shulu520.com/categories/axios/"}],"tags":[]},{"title":"tcp","slug":"tcp","date":"2019-06-25T15:37:04.000Z","updated":"2019-06-25T15:46:44.549Z","comments":true,"path":"tcp/tcp/","link":"","permalink":"https://shulu520.com/tcp/tcp/","excerpt":"&emsp;&emsp;什么时候，我们之间才会握手呢。","text":"&emsp;&emsp;什么时候，我们之间才会握手呢。 tcp 三次握手 我们来聊聊三次握手，我们看到这个问题的时候，第一个疑问是，啥叫握手？俩机器之间怎么还能握手呢？我怎么没发现我家电脑有手？ 第二个疑问是，为啥要三次？两次不行吗？我觉得握一下就行了~为啥要握三次？流氓~那么现在我们有没有清楚为什么不能是两次握手了呢？ 我们假设现在有A 和 B 两个之间要进行通信往来。 第一次握手只能让B知道A能发，第二次握手让A知道了B能收能发，但是这个时候B还不知道A能收，所以A需要发出信息，证明自己收到了B的回复~所以必须要三次才能让两台机器都知道对方能收能发。 tcp四次挥手 以一句话来说明四次挥手的根本目的，四次挥手核心就在于四个时间节点，分别是： A告诉B发完了， B告诉A知道发完了，(接收还需要一段时间的) B告诉A收完了， A告诉B知道收完了。 有事您Q我👇","categories":[{"name":"tcp","slug":"tcp","permalink":"https://shulu520.com/categories/tcp/"}],"tags":[{"name":"net","slug":"net","permalink":"https://shulu520.com/tags/net/"}]},{"title":"js-design-mode-others","slug":"js-design-mode-others","date":"2019-06-25T03:52:31.000Z","updated":"2019-06-25T12:12:40.449Z","comments":true,"path":"js-design-mode/js-design-mode-others/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-others/","excerpt":"","text":"&emsp;&emsp; &lt;!–more– 中介者模式 代码演示 // 执行者(前线士兵)class Receiver { exec() { console.log(‘前线士兵 执行命令’) }} // 命令对象(由鼓手传递 开打开打！！！)class Command { constructor(receiver) { this.receiver = receiver } cmd() { console.log(‘命令对象开始传递 “开打开打！！！”‘) this.receiver.exec() }} // 发布命令者(将军)class Invoker { constructor(command) { this.command = command } invoke() { console.log(‘发布命令: 开打开打！！！’) this.command.cmd() }}// 士兵let soldier = new Receiver()// 鼓手let drummer = new Command(soldier)// 将军let general = new Invoker(drummer)// 将军发布命令general.invoke() ` 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"js-design-mode-prototype","slug":"js-design-mode-prototype","date":"2019-06-24T09:19:51.000Z","updated":"2019-06-24T09:23:34.853Z","comments":true,"path":"js-design-mode/js-design-mode-prototype/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-prototype/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 简单示例123456789101112131415161718192021const prototype = &#123; getName() &#123; return `first-name: $&#123;this.firstName&#125;, last-name: $&#123;this.lastName&#125;` &#125;, say() &#123; console.log(&apos;love you&apos;) &#125;&#125;// 克隆自己，生成一个新的对象// Object.create()用到了原型模式的思想// 基于一个原型创建一个对象let x = Object.create(prototype)x.lastName = &apos;shulu&apos;x.firstName = &apos;lqy love&apos;x.say() //love youconsole.log(&apos;x.getName() :&apos;, x.getName())//打印为 x.getName() : first-name: lqy love, last-name: shulu 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"js-design-mode-state","slug":"js-design-mode-state","date":"2019-06-24T02:24:23.000Z","updated":"2019-06-24T05:53:45.524Z","comments":true,"path":"js-design-mode/js-design-mode-state/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-state/","excerpt":"&emsp;&emsp;莫辜负这仅有一次的人生。","text":"&emsp;&emsp;莫辜负这仅有一次的人生。 状态模式介绍 一个对象有状态变化 每次状态变化都会触发一个逻辑 不能总是用if…else来控制 交通信号灯不同颜色的变化 场景 有限状态机(finite) 有限个状态，以及在这些个状态之间的变化 开源的库 javascript-state-machine 写一个简单的Promise 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// 收藏/取消收藏例子import StateMachine from &apos;javascript-state-machine&apos;// 初始化状态机模型let fsm = new StateMachine(&#123; init: &apos;收藏&apos;, transitions: [ &#123; name: &apos;doStore&apos;, from: &apos;收藏&apos;, to: &apos;取消收藏&apos; &#125;, &#123; name: &apos;deleteStore&apos;, from: &apos;收藏&apos;, to: &apos;取消收藏&apos; &#125; ], methods: &#123; // 监听执行收藏 onDoStore() &#123; console.log(&apos;收藏成功&apos;)// 可以post请求 updateText() &#125;, // 监听取消收藏 onDeleteStore() &#123; console.log(&apos;已经取消收藏&apos;)// 可以post请求 updateText() &#125; &#125;import StateMachine from &apos;javascript-state-machine&apos;// 初始化状态机模型let fsm = new StateMachine(&#123; init: &apos;收藏&apos;, transitions: [ &#123; name: &apos;doStore&apos;, from: &apos;收藏&apos;, to: &apos;取消收藏&apos; &#125;, &#123; name: &apos;deleteStore&apos;, from: &apos;收藏&apos;, to: &apos;取消收藏&apos; &#125; ], methods: &#123; // 监听执行收藏 onDoStore() &#123; console.log(&apos;收藏成功&apos;)// 可以post请求 updateText() &#125;, // 监听取消收藏 onDeleteStore() &#123; console.log(&apos;已经取消收藏&apos;)// 可以post请求 updateText() &#125; &#125;&#125;)// 更新按钮的文案function updateText () &#123; btn.text(fsm.state)&#125;let btn = document.getElementById(&apos;btn&apos;)btn.onclick = function () &#123; if (fsm.is(&apos;收藏&apos;)) &#123; fsm.doStore() //这里的函数名与前面的name对应 &#125; else &#123; fsm.deleteStore() &#125;&#125;// 初始化文案updateText()&#125;)// 更新按钮的文案function updateText () &#123; btn.text(fsm.state)&#125;let btn = document.getElementById(&apos;btn&apos;)btn.onclick = function () &#123; if (fsm.is(&apos;收藏&apos;)) &#123; fsm.doStore() //这里的函数名与前面的name对应 &#125; else &#123; fsm.deleteStore() &#125;&#125;// 初始化文案updateText() 设计原则验证 将状态对象和主题对象分离，状态的变化逻辑单独处理 符合开放封闭原则 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"js-design-mode-iterator","slug":"js-design-mode-iterator","date":"2019-06-23T13:48:55.000Z","updated":"2019-06-23T15:37:43.560Z","comments":true,"path":"js-design-mode/js-design-mode-iterator/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-iterator/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 介绍 顺序访问一个集合 使用者无需知道内部的结构(封装) 菜鸟教程 代码实现(自己写的初级的 后面es6提供的完善的 for of)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 迭代器(遍历器)class Iterator &#123; constructor(container) &#123; this.list = container.list this.index = 0 &#125; next() &#123; if (this.hasNext()) &#123; return this.list[this.index++] &#125; return null &#125; hasNext() &#123; if (this.index &gt;= this.list.length) &#123; return false &#125; return true &#125;&#125;// 迭代器的容器class Container &#123; constructor(list) &#123; this.list = list &#125; getIterator() &#123; return new Iterator(this) &#125;&#125;let arr = [1,2,3,4,5,6]let container = new Container(arr)let iterator = container.getIterator()while (iterator.hasNext()) &#123; console.log(&apos;iterator.next() :&apos;, iterator.next());&#125;/* iterator.next() : 1 iterator.next() : 2 iterator.next() : 3 iterator.next() : 4 iterator.next() : 5 iterator.next() : 6 */ es6 Iterator 有序集合的数据如: Array Map Set String TypedArray arguments Nodelist 以上数据类型，都有[Symbol.iterator]这个属性 属性值是函数，执行函数返回一个迭代器 这个迭代器就有next方法可以顺序迭代子元素 可以运行Array.prototype[Symbol.iterator]来测试 注意 object 不是有序集合 可以用Map代替 for of12345678910111213141516171819202122232425262728293031323334353637383940414243//封装一个简单的each方法function each (data) &#123; //data是可遍历的 即data[Symbol.iterator]有值 for(let item of data) &#123; console.log(&apos;item :&apos;, item) &#125;&#125;// 测试几种可遍历的数据类型let str = &apos;love&apos;let arr = [1,2,3,4]let map = new Map()map.set(0, &quot;zero&quot;)map.set(1, &quot;one&quot;)let set = new Set([6,7,8,9])each(str)each(arr)each(map)each(set)/* item : l item : o item : v item : e item : 1 item : 2 item : 3 item : 4 item : [ 0, &apos;zero&apos; ] item : [ 1, &apos;one&apos; ] item : 6 item : 7 item : 8 item : 9*/ Map 数据结构 Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。 一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 一个 for…of 循环在每次迭代后会返回一个形式为[key，value]的数组。 一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。 Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。 你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。 Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。 Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。虽然 ES5 开始可以用 map = Obj- ect.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。 Map 在涉及频繁增删键值对的场景下会有些性能优势。 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"js-design-mode-observer","slug":"js-design-mode-observer","date":"2019-06-22T14:45:37.000Z","updated":"2019-06-22T15:21:53.677Z","comments":true,"path":"js-design-mode/js-design-mode-observer/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-observer/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 介绍 前端运用最广泛的设计模式 当一个对象被修改时，则会自动通知它的依赖对象。 注意，不一定是一对多哦，也可以一对一的。 菜鸟教程 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 主题，保存状态，状态发生变化后触发所有观察者对象class Subject &#123; constructor() &#123; this.state = 0 this.observers = [] &#125; getState() &#123; return this.state &#125; setState(state) &#123; this.state = state this.notifyAllObservers() &#125; // 通知所有的观察者 notifyAllObservers() &#123; this.observers.forEach((observer) =&gt; &#123; observer.update() &#125;) &#125; // 添加新的观察者 attach(observer) &#123; this.observers.push(observer) &#125;&#125;// 观察者class Observer &#123; constructor(name, subject) &#123; this.name = name this.subject = subject this.subject.attach(this) &#125; update() &#123; console.log(`$&#123;this.name&#125; updated, now-state:$&#123;this.subject.getState()&#125;`); &#125;&#125;// 测试let s = new Subject()let o1 = new Observer(&apos;o1&apos;, s)let o2 = new Observer(&apos;o2&apos;, s)let o3 = new Observer(&apos;o3&apos;, s)s.setState(1) s.setState(2)s.setState(3)/* //打印结果 o1 updated, now-state:1 o2 updated, now-state:1 o3 updated, now-state:1 o1 updated, now-state:2 o2 updated, now-state:2 o3 updated, now-state:2 o1 updated, now-state:3 o2 updated, now-state:3 o3 updated, now-state:3*/ 使用场景 网页事件绑定 Promise jQuery callbacks nodejs 自定义事件 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"js-design-mode-proxy","slug":"js-design-mode-proxy","date":"2019-06-21T12:36:54.000Z","updated":"2019-06-21T13:39:53.002Z","comments":true,"path":"js-design-mode/js-design-mode-proxy/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-proxy/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 代理模式简介 菜鸟教程 科学上网 明星经纪人 使用场景 网页事件代理 jQuery的 $.proxy() es6的proxy 代码实现明星经纪人 1234567891011121314151617181920212223242526272829303132333435363738394041// 明星let star = &#123; name: &apos;shulu&apos;, age: &apos;18&apos;, phone: &apos;star: 18366666666&apos;&#125;// 经纪人let agent = new Proxy(star, &#123; get(target, key) &#123; if (key === &apos;phone&apos;) &#123; // 返回经纪人(代理)的电话 return &apos;agent: 12353434343&apos; &#125; if (key === &apos;price&apos;) &#123; // 明星不报价，由经纪人报价 return &apos;agent: 1232323$&apos; &#125; return target[key] &#125;, set(target, key, val) &#123; if (key === &apos;customPrice&apos;) &#123; if (val &lt; 10000) &#123; // 最低价格 throw new Error(&apos;价格太低！&apos;) &#125;else&#123; target[key] = val return true &#125; &#125; &#125;&#125;)console.log(&apos;agent.name :&apos;, agent.name) //agent.name : shuluconsole.log(&apos;agent.age :&apos;, agent.age) //agent.age : 18console.log(&apos;agent.phone :&apos;, agent.phone) //agent.phone : agent: 12353434343console.log(&apos;agent.price :&apos;, agent.price) //agent.price : agent: 1232323$agent.customPrice = 1212 //价格太低！agent.customPrice = 100000 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"js-this","slug":"this","date":"2019-06-21T09:30:57.000Z","updated":"2019-08-10T08:27:31.308Z","comments":true,"path":"this/this/","link":"","permalink":"https://shulu520.com/this/this/","excerpt":"&emsp;&emsp;认识我自己。","text":"&emsp;&emsp;认识我自己。 this&emsp;&emsp;当前执行代码的环境对象 mdn权威解释 全局环境&emsp;&emsp;无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。 函数环境&emsp;&emsp;在函数内部，this的值取决于函数被调用的方式。&emsp;&emsp;如果要想把 this 的值从一个环境传到另一个，就要用 call 或者apply 方法。方法来源即Function.prototype.call Function.prototype.bind&emsp;&emsp;使用 call 和 apply 函数的时候，如果传递给 this 的值不是一个对象，JavaScript 会尝试使用内部 ToObject 操作将其转换为对象。 &emsp;&emsp;箭头函数&emsp;&emsp;它的this即它外层函数的this。 &emsp;&emsp;作为对象的方法&emsp;&emsp;当函数作为对象里的方法被调用时，它们的 this是调用该函数的对象。 &emsp;&emsp;原型链中的 this &emsp;&emsp;对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么this指向的是调用这个方法的对象，就像该方法在对象上一样。&emsp;&emsp; getter 与 setter 中的 this 相同的概念也适用于当函数在一个 getter 或者 setter 中被调用。用作 getter 或 setter 的函数都会把 this 绑定到设置或获取属性的对象。作为构造函数 &emsp;&emsp; 当一个函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象。作为一个DOM事件处理函数 &emsp;&emsp; 当函数被用作事件处理函数时，它的this指向触发事件的元素。 &emsp;&emsp; setTimeout 关于”this”的问题 &emsp;&emsp; 当你向 setTimeout() (或者其他定时器函数)传递一个函数时,该函数中的this指向跟你的期望可能不同。 &emsp;&emsp; 解释： &emsp;&emsp; 由setTimeout()调用的代码运行在与所在函数完全分离的执行环境上。这会导致，这些代码中包含的 this 关键字在非严格模式会指向 window (或全局)对象，严格模式下为 undefined，这和所期望的this的值是不一样的。 &emsp;&emsp; 即定时器函数是一个异步宏任务，在事件循环中会被分配到对应的任务队列中去等待执行，故执行栈即执行上下文环境即this不是你以为的原来的了。 Function.prototype.call() 函数的一种调用方法 Function构造函数的原型对象上的call方法 该方法接受的是一个参数列表：如 1， 2， 3 语法 fun.call(thisArg, arg1, arg2, …) 参数 thisArg 在 fun 函数运行时指定的 this 值。 if(thisArg == undefined|null) this = window， if(thisArg == number|boolean|string) this == new Number()|new Boolean()| new String() arg1, arg2, … 指定的参数列表。 返回值 使用调用者提供的 this 值和参数调用该函数的返回值。若该方法没有返回值，则返回 undefined。 call方法的应用 call() 提供新的 this 值给当前调用的函数/方法。 可以使伪数组调用数组的方法 Function.prototype.apply() 函数的一种调用方法 Function构造函数的原型对象上的call方法 该方法接受的是一个参数数组：如 [1, 2, 3] apply 与 call() 非常相似，不同之处在于提供参数的方式。apply方法的应用调用Math对象的max方法求数组的最大值1234var numbers = [5, 6, 2, 3, 7];var max = Math.max.apply(null, numbers);console.log('max :', max); 用 apply 将数组添加到另一个数组1234var array = ['a', 'b'];var items = [0, 1, 2];array.push.apply(array, items);console.log(array);// [ 'a', 'b', 0, 1, 2 ] Function.prototype.bind() bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。 返回值 返回一个原函数的拷贝，并拥有指定的this值和初始参数。 bind方法的应用配合setTimeout绑定this12345678910var obj = &#123; name: 'yc', getName: function () &#123; setTimeout(function () &#123; console.log('this.name :', this.name) &#125;.bind(this), 1000) &#125;&#125;obj.getName() //this.name : yc 有事您Q我👇","categories":[{"name":"this","slug":"this","permalink":"https://shulu520.com/categories/this/"}],"tags":[{"name":"this","slug":"this","permalink":"https://shulu520.com/tags/this/"}]},{"title":"js-design-mode-decorator","slug":"js-design-mode-decorator","date":"2019-06-20T09:02:00.000Z","updated":"2019-06-20T16:27:09.287Z","comments":true,"path":"js-design-mode/js-design-mode-decorator/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-decorator/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 介绍 菜鸟教程 大牛解读es7装饰器 为对象添加功能 不改变其原有的结构和功能 代码演示 画圆 12345678910111213141516171819202122232425class Circle &#123; draw() &#123; console.log(&apos;画一个圆&apos;) &#125;&#125;class Decorator &#123; constructor(circle) &#123; this.circle = circle &#125; draw() &#123; this.circle.draw() this.setRedBorder(this.circle) &#125; setRedBorder(circle) &#123; console.log(&apos;给圆设置红色的边框&apos;) &#125;&#125;// 测试let circle = new Circle()circle.draw() //画一个圆let dec = new Decorator(circle)dec.draw() //画一个圆 给圆设置红色的边框 装饰器 ES7 中的 decorator 同样借鉴了python语法糖，不过依赖于 ES5 的 Object.defineProperty 方法 。 Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 Object.defineProperty(obj, prop, descriptor) obj：要在其上定义属性的对象。 prop：要定义或修改的属性的名称。 descriptor：将被定义或修改的属性描述符。 返回值：被传递给函数的对象。 属性描述符 对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。 数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。 存取描述符是由 getter-setter 函数对描述的属性。 描述符必须是这两种形式之一；不能同时是两者。 数据描述符和存取描述符均具有以下可选键值: configurable 可修改 布尔值 enumerable 可枚举 布尔值 value 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。 writable 可写 布尔值 get 一个给属性提供 getter 的方法 set 一个给属性提供 setter 的方法 Object.assign Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 语法 Object.assign(target, …sources)参数 target 目标对象。 sources 源对象。 返回值 目标对象。 core-decorators装饰器库的使用 安装插件 12345678910111213141516171819202122npm install --save-dev @babel/plugin-proposal-class-properties npm install --save-dev @babel/plugin-proposal-decoratorsnpm install --save-dev babel-plugin-transform-decorators-legacynpm install --save-dev core-decorators当然还有以下依赖的支持&quot;dependencies&quot;: &#123; &quot;@babel/core&quot;: &quot;^7.4.4&quot;, &quot;@babel/plugin-proposal-class-properties&quot;: &quot;^7.4.4&quot;, &quot;@babel/plugin-proposal-decorators&quot;: &quot;^7.4.4&quot;, &quot;@babel/preset-env&quot;: &quot;^7.4.4&quot;, &quot;babel-loader&quot;: &quot;^8.0.5&quot;, &quot;babel-plugin-transform-decorators-legacy&quot;: &quot;^1.3.5&quot;, &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;, &quot;core-decorators&quot;: &quot;^0.20.0&quot;&#125; .babelrc文件的配置 12345678910111213141516171819202122&#123; &quot;presets&quot;: [ [&quot;@babel/preset-env&quot;, &#123; &quot;useBuiltIns&quot;: &quot;usage&quot;,// 在每个文件中使用polyfill时，为polyfill添加特定导入。利用捆绑器只加载一次相同的polyfill。 &quot;modules&quot;: false,// 启用将ES6模块语法转换为其他模块类型，设置为false不会转换模块。 &quot;targets&quot;: &#123; //浏览器兼容 &quot;browsers&quot;: &quot;last 2 versions, not ie &lt;= 9&quot; &#125; &#125;] ], &quot;plugins&quot;: [ [ &quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;legacy&quot;: true &#125; ], [&quot;@babel/plugin-transform-runtime&quot;, &#123; &quot;helpers&quot;: false &#125;] ]&#125; 简单使用 1 123456789101112131415import &#123; readonly &#125; from &apos;core-decorators&apos;class Demo &#123; @readonly sayName() &#123; console.log(&apos;shulu&apos;) &#125;&#125;let demo = new Demo()demo.sayName() //shuludemo.sayName = function () &#123; console.log(&apos;lqy love shulu&apos;) //Uncaught TypeError: Cannot assign to read only property &apos;sayName&apos; of object &apos;#&lt;Demo&gt;&apos;&#125; 简单使用 2 123456789101112import &#123; deprecate &#125; from &apos;core-decorators&apos;class Demo &#123; @deprecate(&apos;此方法即将废除&apos; ,&#123;url: &apos;https://shulu520.com&apos;&#125;) getName() &#123; console.log(&apos;lqy&apos;) &#125;&#125;let demo = new Demo()demo.getName() //lqy DEPRECATION Demo#getName: 此方法即将废除 See https://shulu520.com for more details. 还有多种好用的方法…… 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"js-design-mode-adapter","slug":"js-design-mode-adapter","date":"2019-06-20T07:13:22.000Z","updated":"2019-06-20T08:58:06.199Z","comments":true,"path":"js-design-mode/js-design-mode-adapter/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-adapter/","excerpt":"&emsp;&emsp;江南的雨季，西北的惆怅。感君一回顾，思君朝与暮。","text":"&emsp;&emsp;江南的雨季，西北的惆怅。感君一回顾，思君朝与暮。 设计模式之适配器介绍 菜鸟教程 适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 代码演示 12345678910111213141516171819class OldStandard &#123; oldRequest() &#123; return &apos;老式标准插头&apos; &#125;&#125;class Adapter &#123; constructor() &#123; this.standard = new OldStandard() &#125; newRequest() &#123; let info = this.standard.oldRequest() return `新标准插头---&gt;适配器---&gt;$&#123;info&#125;` &#125;&#125;let adater = new Adapter()let res = adater.newRequest()console.log(&apos;res :&apos;, res) //res : 新标准插头---&gt;适配器---&gt;老式标准插头 经典案例 vue的computed计算属性 设计原则验证 将旧接口和使用者分离 开放封闭原则 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"js-design-mode-singleton","slug":"js-design-mode-singleton","date":"2019-06-20T04:07:58.000Z","updated":"2019-06-20T07:48:51.527Z","comments":true,"path":"js-design-mode/js-design-mode-singleton/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-singleton/","excerpt":"&emsp;&emsp;I love the World.","text":"&emsp;&emsp;I love the World. 单例模式介绍 菜鸟教程 系统中唯一被使用 一个类只有一个实例 私有化构造函数，外部不能new 只能内部new !!!!! instance实例是唯一被new出来的对象 代码演示123456789101112131415161718192021222324252627class SingleObject &#123; login() &#123; console.log(&apos;login&apos;) &#125; &#125;// 静态方法SingleObject.getInstance = (function() &#123; let instance return function() &#123; if (!instance) &#123; instance = new SingleObject() &#125; return instance &#125;&#125;)()let obj1 = SingleObject.getInstance()obj1.login() //loginlet obj2 = SingleObject.getInstance()obj2.login() //loginconsole.log(&apos;obj1===obj2 :&apos;, obj1===obj2) //obj1===obj2 : truelet obj3 = new SingleObject() //外部不能new,但是无法完全控制console.log(&apos;obj3===obj1 :&apos;, obj3===obj1) //obj3===obj1 : false 单例模式使用场景 jQuery 的 $ 模拟登录框 购物车 vuex react 中的store 代码实现登录框 12345678910111213141516171819202122232425262728293031323334353637383940414243class LoginForm &#123; constructor () &#123; this.state = &apos;hide&apos; &#125; show () &#123; if (this.state === &apos;show&apos;) &#123; console.log(&apos;已经显示&apos;) return &#125; this.state = &apos;show&apos; console.log(&apos;已经登录成功&apos;) &#125; hide () &#123; if (this.state === &apos;hide&apos;) &#123; console.log(&apos;已经隐藏&apos;) return &#125; this.state = &apos;hide&apos; console.log(&apos;已经隐藏成功&apos;) &#125;&#125;// 静态方法LoginForm.getInstance = (() =&gt; &#123; let instance return () =&gt; &#123; if (!instance) &#123; instance = new LoginForm() &#125; return instance &#125;&#125;)()let login1 = LoginForm.getInstance()login1.show() //已经登录成功let login2 = LoginForm.getInstance()login2.show() //已经显示login2.hide() //已经隐藏成功console.log(&apos;login1===login2 :&apos;, login1===login2)// login1===login2 : true// 这就说明login1 和login2是同一个实例 设计原则验证 符合单一职责原则，只实例化唯一的对象 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"hotkey-vscode","slug":"hotkey-vscode","date":"2019-06-19T09:04:23.000Z","updated":"2019-06-19T09:09:12.816Z","comments":true,"path":"hotkey/hotkey-vscode/","link":"","permalink":"https://shulu520.com/hotkey/hotkey-vscode/","excerpt":"&emsp;&emsp;如果你想要个和现在不同的人生，就必须去做你从未做过的事情。努力之后最坏的结果是失败，但不尝试的结果则是无止境的懊悔、怀疑和平庸。","text":"&emsp;&emsp;如果你想要个和现在不同的人生，就必须去做你从未做过的事情。努力之后最坏的结果是失败，但不尝试的结果则是无止境的懊悔、怀疑和平庸。 vscode 常用快捷键 上下移动一行： Alt+Up 或 Alt+Down 向上或向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down 同时选中所有匹配： Ctrl+Shift+L Ctrl+D 下一个匹配的也被选中 Alt + 单击 ：插入光标 Ctrl + F2 选择当前字的所有出现 ctrl shift k 删除整行 ctrl shift a 多行注释 ctrl f 当前文件内搜索相关代码，终于找到这个功能了，哈哈，右上角会有弹框，其中有前后箭头，表示搜索的代码上一次、下一次出现的位置，点击直接会跳转到相应的位置，并且侧边上有相应的位置标识。 ctrl - 整体缩小 ctrl = 整体放大 文件/首选项/设置 搜索zoom 根据配置 可以更精细的对大小进行操作 ctrl 加滚轮 col 选第一个 即console.log()的快捷键 且效果很棒 有事您Q我👇","categories":[{"name":"hotkey","slug":"hotkey","permalink":"https://shulu520.com/categories/hotkey/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://shulu520.com/tags/vscode/"}]},{"title":"js-design-mode-factory","slug":"js-design-mode-factory","date":"2019-06-19T08:43:18.000Z","updated":"2019-06-20T07:51:24.264Z","comments":true,"path":"js-design-mode/js-design-mode-factory/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-factory/","excerpt":"&emsp;&emsp;愿你做一个快乐的小仙女。","text":"&emsp;&emsp;愿你做一个快乐的小仙女。 介绍 菜鸟教程 代码实现 方法定义 12345678910111213141516// Product产品生产流水线class Product &#123; constructor (name) &#123; this.name = name &#125; getName () &#123; return `my name is $&#123;this.name&#125;` &#125;&#125;// Creator 工厂class Creator &#123; create (name) &#123; return new Product(name) &#125;&#125; 测试 123456789101112131415161718192021/* 普通调用 用户直接面对某一流水线，要产品 用户每次拿产品都得直接与产品流水线打交道*/ // 书写极其麻烦const p1 = new Product(&apos;phone&apos;)const p2 = new Product(&apos;book&apos;)console.log(&apos;p1 :&apos;, p1)console.log(&apos;p2 :&apos;, p2)/* 工厂函数 用户直接面对生产厂家，要产品 也就是说，用户无需知道其内部复杂生产过程*/// 工厂函数将生产流水线封装起来，只对外暴露接口供用户使用const creator = new Creator()//实例化一个工厂const pa = creator.create(&apos;boy&apos;)const pb = creator.create(&apos;girl&apos;)console.log(&apos;pa :&apos;, pa)console.log(&apos;pb :&apos;, pb) 工厂函数的例子 jQuery react.createElement vue异步组件 验证设计原则 构造函数和创建者分离 符合开放封闭原则 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"js-design-mode-design-philosophy","slug":"js-design-mode-design-philosophy","date":"2019-06-18T09:21:30.000Z","updated":"2019-06-19T06:19:59.568Z","comments":true,"path":"js-design-mode/js-design-mode-design-philosophy/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-design-philosophy/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; unix/linux设计哲学 小即是美 让每一个程序只做好一件事 快速建立原型 利于快速迭代 舍弃高效率而取可移植性 复用性 采用纯文本来存贮数据 可读性好 软件复用 使用shell脚本 避免强制性的用户界面 让每个程序都称为过滤器 中间件 允许用户定制环境 个性化 操作系统内核小而轻量化 使用小写字母并简写 沉默是金 没有消息是最好的消息 各部分之和大于整体 模块化 寻求90%的解决方案 不必追求完美 SOLID 五大设计原则 S 单一职责原则 每个程序之做好一件事 功能太复杂就拆分，每个部分保持独立 O 开放封闭原则 对扩展开放 对修改封闭 增加需求时 扩展新代码 而非修改已有的代码 L 李氏置换原则 子类能覆盖父类 父类能出现的地方子类就能出现 I 接口独立原则 保持接口的单一独立 避免出现胖接口 D 依赖导致原则 面向接口编程，依赖于抽象而不依赖于具体 使用方只关注接口 而不关注具体类的实现 为什么使用面向对像 面向对象 – 数据结构化 对于计算机 结构化才是简单的 编程 应该简单抽象 UML 类图 即统一建模语言 箭头表示依赖关系， 指向谁即依赖谁 泛化 即继承 空心箭头 由子类指向父类 关联 即引用 实心箭头 由引用者指向被引用者 类图 即一个表格 三行格子 第一格为类 构造函数 第二行为 属性：类型 第三行为 方法：返回值 23种设计模式总览 创建型 工厂模式 单例模式 原型模式 结构型 适配器模式 装饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 行为型 策略模式 模板方法模式 观察者模式 迭代器模式 职责链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式 面试题之弟弟打车12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Car 普通车 class Car &#123; constructor (name, number) &#123; this.name = name this.number = number &#125;&#125;// 慢车class SlowCar extends Car &#123; constructor(name, number) &#123; super(name, number) this.price = 1 &#125;&#125;// 快车class FastCar extends Car &#123; constructor(name, number) &#123; super(name, number) this.price = 2 &#125;&#125;// 旅途行程 （假定行程为5公里）class Trip &#123; constructor(car) &#123; this.car = car &#125; start () &#123; console.log(`行程开始，名称：$&#123;this.car.name&#125;,车牌号：$&#123;this.car.number&#125;`) &#125; end () &#123; console.log(`行程结束，一共$&#123;this.car.price * 5&#125;元`) &#125;&#125;//测试let car = new FastCar(&apos;兰博基尼&apos;, 18)let trip = new Trip(car)trip.start() //行程开始，名称：兰博基尼,车牌号：18trip.end() //行程结束，一共10元 面试题之停车场 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124// 车class Car &#123; constructor (num) &#123; this.num = num &#125;&#125;// 摄像头class Camera &#123; shot (car) &#123;//拍摄 return &#123; num: car.num, inTime: Date.now() &#125; &#125;&#125;// 出口显示屏class Screen &#123; show (car, inTime) &#123; console.log(`车牌号：$&#123;car.num&#125;`) console.log(`停车时间：$&#123;Date.now() - inTime&#125;`) &#125;&#125;// 停车场class Park &#123; constructor (floors) &#123; this.floors = floors || [] this.camera = new Camera() this.screen = new Screen() this.carList = &#123;&#125; // 存储摄像头拍摄的车辆信息 &#125; in (car) &#123; // 通过摄像头获取信息 const info = this.camera.shot(car) // 停到某个停车位 const i = Number.parseInt(Math.random() * 100 % 100) // 某一层 const j = Number.parseInt(Math.random() * 3) const place = this.floors[j].places[i] place.in() //车已停入某一车位 // 记录信息 info.place = place this.carList[car.num] = info &#125; out (car) &#123; // 获取车辆信息 const info = this.carList[car.num] // 将对应的停车位清空 info.place.out() // 显示时间 this.screen.show(car, info.inTime) // 删除记录 // info = null &#125; emptyNum () &#123; return this.floors.map(floor =&gt; &#123; return `第$&#123;floor.index&#125;层有$&#123;floor.emptyPlaceNum()&#125;个空位` &#125;).join(&apos;\\n&apos;) &#125;&#125;// 楼层class Floor &#123; constructor (index, places) &#123; this.index = index this.places = places || [] &#125; emptyPlaceNum () &#123; let num = 0 this.places.forEach(place =&gt; &#123; if (place.empty) &#123; num += 1 &#125; &#125;) return num &#125;&#125;// 车位class Place &#123; constructor () &#123; this.empty = true &#125; in () &#123; this.empty = false &#125; out () &#123; this.empty = true &#125;&#125;// 测试// 初始化停车场const floors = []for (let i = 0; i &lt; 3; i++) &#123; const places = [] for (let j = 0; j &lt; 100; j++) &#123; places[j] = new Place() &#125; floors[i] = new Floor(i + 1, places)&#125;const park = new Park(floors)// 初始化车辆const car1 = new Car(18)const car2 = new Car(22)const car3 = new Car(36)console.log(`$&#123;park.emptyNum()&#125;`)console.log(`第一辆车进入`)park.in(car1)console.log(`$&#123;park.emptyNum()&#125;`)console.log(`第二辆车进入`)park.in(car2)console.log(`$&#123;park.emptyNum()&#125;`)console.log(`第一辆车离开`)park.out(car1)console.log(`$&#123;park.emptyNum()&#125;`)console.log(`第二辆车离开`)park.out(car2)console.log(`$&#123;park.emptyNum()&#125;`) 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"js-design-mode-oop","slug":"js-design-mode-oop","date":"2019-06-18T02:58:30.000Z","updated":"2019-06-18T10:06:00.834Z","comments":true,"path":"js-design-mode/js-design-mode-oop/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-oop/","excerpt":"&emsp;&emsp;you are my baby.","text":"&emsp;&emsp;you are my baby. webpack的配置 以支持es6的新语法 npm install webpack webpack-cli –save-dev –registry=https://registry.npm.taobao.org 在package.json中 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack --config ./webpack.dev.config.js --mode development&quot;&#125;即在命令行里面运行npm run dev 即可运行webpack 的配置文件 我们更改了配置文件的默认名字 在这里指定他的配置文件为 ./webpack.dev.config.js 即可 npm install webpack-dev-server html-webpack-plugin –save-dev –registry=https://registry.npm.taobao.org 将package.json中的webpack 改为webpack-dev-server 即为开启一个运行本地服务器 babel的es6语法插件解析 npm install –save-dev babel-loader @babel/core @babel/preset-env –registry=https://registry.npm.taobao.org npm install –save-dev @babel/polyfill @babel/plugin-transform-runtime –registry=https://registry.npm.taobao.org class 类 即模板 封装 继承 多态 123456789101112131415//创建类（构造函数）class Person &#123; constructor (name) &#123; //属性 特征 this.name = name &#125; getName () &#123; //方法 函数 return this.name &#125;&#125;//创建对象（实例）let p = new Person(&apos;shulu&apos;)alert(p.getName()) es6面向对象之继承123456789101112131415161718192021222324252627282930// 父类class Person &#123; constructor (name, age) &#123; this.name = name, this.age = age &#125; getName () &#123; return `my name is $&#123;this.name&#125;` &#125; getAge () &#123; return `my age is $&#123;this.age&#125;` &#125;&#125;// 子类 // 继承父类的属性、方法 并添加自己的属性和方法class Student extends Person &#123; constructor (name, age, number) &#123; super(name, age) this.number = number &#125; study () &#123; return `my number is $&#123;this.number&#125;, and i am studying` &#125;&#125;let s = new Student(&apos;shulu&apos;, 18, 23)alert(s.getName())alert(s.getAge())alert(s.study()) es6面向对象之封装 public 完全开放 protected 对子类开放 private 对自己开发 es6 尚不支持， 用typescript来演示trpescript网站测试代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 父类class Person &#123; name //公开的属性 age protected weight //受保护的属性，只有自己和子类可以访问，实例对象可以访问 constructor (name, age) &#123; this.name = name, this.age = age, this.weight = &apos;120&apos; &#125; getName () &#123; return `my name is $&#123;this.name&#125;` &#125; getAge () &#123; return `my age is $&#123;this.age&#125;` &#125; &#125;// 子类 // 继承父类的属性、方法 并添加自己的属性和方法class Student extends Person &#123; number //公开的属性 private boyfriend //自己的私有的属性，只有自己才可以访问，自己的实例都不能用 constructor (name, age, number) &#123; super(name, age) this.number = number this.boyfriend = &apos;lqy&apos; &#125; study () &#123; return `my 学号 is $&#123;this.number&#125;, and i am studying` &#125; getBoyfriend () &#123; return `my boyfriend is $&#123;this.boyfriend&#125;` &#125; getWeight () &#123; return `my weight is $&#123;this.weight&#125;` &#125;&#125;let s = new Student(&apos;shulu&apos;, 18, 23)alert(s.getWeight()) //可以正常访问alert(s.boyfriend()) //报错 girlfriend只能在Student 里面自己使用 es6面向对象之多态 多个子类可以继承一个父类，并扩展自己的方法 1234567891011121314151617181920212223242526272829303132333435363738// 父类class Person &#123; constructor (name) &#123; this.name = name &#125; getName () &#123; return `my name is $&#123;this.name&#125;` &#125;&#125;// 子类A class StudentA extends Person &#123; constructor (name, number) &#123; super(name) this.number = number &#125; study () &#123; return `my 学号 is $&#123;this.number&#125;, and i am studying` &#125;&#125;// 子类Bclass StudentB extends Person &#123; constructor (name, number) &#123; super(name) this.number = number &#125; study () &#123; return `my 学号 is $&#123;this.number&#125;, and i am studying` &#125;&#125;let s1 = new StudentA(&apos;shulu&apos;, 18)let s2 = new StudentB(&apos;lqy&apos;, 19)alert(s1.getName())alert(s1.study())alert(s2.getName())alert(s2.study()) 面向对像实现jQuery的例子1234567891011121314151617181920212223242526272829class jQuery &#123; constructor (selector) &#123; let dom = Array.from(document.querySelectorAll(selector)) let len = dom ? dom.length : 0 dom.forEach((item, index) =&gt; &#123; this[index] = item &#125;) this.len = len this.selector = selector || &apos;&apos; &#125; append (node) &#123; &#125; addClass (className) &#123; &#125; html (data) &#123; &#125; // 好多的方法……&#125;window.$ = function (selector) &#123; return new jQuery(selector)&#125;let $p = $(&apos;p&apos;) // p 标签选择器console.log($p)console.log($p.addClass) 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"responsive-sites","slug":"responsive-sites","date":"2019-06-16T11:23:58.000Z","updated":"2019-06-17T14:42:54.231Z","comments":true,"path":"responsive-sites/responsive-sites/","link":"","permalink":"https://shulu520.com/responsive-sites/responsive-sites/","excerpt":"&emsp;&emsp;梦终有你。","text":"&emsp;&emsp;梦终有你。 视口 布局视口 就像一本书 大小固定 如960px 是设计图纸的大小 可视视口 就像放大镜 在它上面可以移动缩放 是设备屏幕的大小 在这两种视口下，用户需要通过滑动缩放来查看整个页面的不同部分。 理想视口 为了解决以上的问题而制定的视口。是布局视口在一个设备上的最佳尺寸。即让布局视口等于可视视口。 大牛博客视口相关说明 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;/&gt; 爬虫协议robots.txt 把“robots.txt”放在你网站的根目录，并确保他能让访问者（如搜索引擎）访问到。 Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”，网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。 1234User-agent: *Disallow: /admin/Sitemap: https://shulu520.com/sitemap.xmlSitemap: https://shulu520.com/sitemap.hxml 关于humans.txthumans.txt官网 这是什么？ 这是一个TXT文件，其中包含参加该网页设计和建立的人们的信息。 为什么是一个TXT？ 这是因为TXT是一种快速和容易建立的档案格式，而且不是一种有侵扰性的格式。 很多时候业主并不希望作者在为他设计的网站签名，以为这样会降低其功能。 以我们这种方式可以从外部快速便利、经济实惠的显示证明网站作者（不是指网站的主人）。 humans.txt官网格式 12345/* TEAM *//* THANKS *//* SITE */ 项目目录的一些有用的文件 robots.txt humans.txt .editorConfig(编辑器风格配置) .gitignore LICENSE.txt(版权声明，协议是否开源) README.md(项目简介 使用方式 相关链接) CHANGLOG(说明版本更新相关) html页面重要内容 以前没有注意到的细节知识做一总结。 1234567891011121314151617181920网站内的语言为汉语，参考自淘宝网。&lt;html lang=&apos;zh-CN&apos;&gt;&lt;/html&gt;这意味着，会强制浏览器按照最新的标准去渲染。添加”chrome=1“将允许站点在使用了谷歌浏览器内嵌框架（Chrome Frame）的客户端渲染，对于没有使用的，则没有任何影响。&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;/&gt;告诉浏览器启用理想视口来展示页面。不允许用户进行缩放。&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=0&quot; /&gt;条件注释：在body标签下争对IE低版本浏览器的更新提示信息： &lt;!--[if lt IE 8]&gt; &lt;style&gt;html,body&#123;overflow:hidden;height:100%&#125;&lt;/style&gt; &lt;div&gt; &lt;p&gt;您的浏览器版本老的可笑，请到点击下面任一链接更新，以获取最佳的浏览体验。&lt;/p&gt; &lt;a href=&quot;https://www.google.cn/intl/zh-CN/chrome/browser/desktop/&quot; &quot; target=&quot;_blank&quot;&gt;谷歌 Chrome&lt;/a&gt; &lt;a href=&quot;http://www.uc.cn/ucbrowser/download/&quot; target=&quot;_blank&quot;&gt;UC 浏览器&lt;/a&gt;&quot; &lt;a href=&quot;http://browsehappy.com&quot;&gt;各大浏览器更新网站(外网) &lt;/div&gt; &lt;![endif]--&gt; logo 说明 像logo这样重要的图片最好以img标签的形式嵌入页面。 其他的不太重要的图片可以考虑background的形式引入。 样式重置 传统css样式重置resets.css 性能不佳 H5标准的样式重置 GitHub 3万多star npm install normalize.css css单位 px 1px=1像素 em 相对长度单位 em的相对参照物为 父元素的font-size值 em 具有继承的特点 当没有设值时，浏览器的默认em 1em=16px em的缺点 容易错乱 rem 相对长度单位 参照物为HTML根元素 其固定不变 计算简单 没有设值时，浏览器的默认值 1rem=16px 设置 font-size: 62.5% 那么 1rem = 10px css3 的一些样式 文本选中后的样式设置 1234::selection &#123; background-color: pink; text-shadow: none&#125; calc的使用例子 width: calc(33.33333333% - 2rem) css3 box-sizing属性 border-box，border和padding计算入width之内，其实就是怪异模式了 box-sizing: border-box box-sizing:border-box; 将正常的width height的作用范围延申至border的地方。 也就是说，对元素指定宽度和高度包括了 padding 和 border 。 正常的元素宽高给定后，增加padding border他们会往外面阔展大小。 加了这个属性后，再增加padding border 此时元素内容区会向里面缩进。 清除浮动 当元素设置float浮动后，该元素就会脱离文档流并向左/向右浮动，直到碰到父元素或者另一个浮动元素，浮动元素会造成父元素高度塌陷，所以当我们设置float后，需进行相应的清除浮动操作。 清除浮动的原理 触发BFC BFC 块级格式化上下文 一个HTML元素要创建BFC，则满足下列的任意一个或多个条件即可： 1.float的值不是none。2.position的值不是static或者relative。3.display的值是inline-block、table-cell、flex、table-caption或者inline-flex4.overflow的值不是visible BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列 清除浮动方式一 使用额外的标签clear:both 原理：在浮动元素下面添加一个空标签，在这个标签中设置clear：both； 优点：简单，浏览器兼容性好； 缺点：增加页面的标签，造成页面混乱； 方式二 使用overflow属性 原理：父元素定义overflow:hidden，此时，浏览器会自动检查浮动区域的高度； 优点：简单，无需增加新的标签； 缺点：不能和position配合使用，因为超出的尺寸的会被隐藏 方式三 使用伪元素:after清除浮动 原理：原理同方法一有点类似，在元素最后定义一个空的内容，然后让该空的内容来清除浮动； 优点：无需额外的标签，浏览器兼容性好，是目前用的最多的一种清除浮动的方法之一； 缺点：代码稍微复杂点，初学者可能不太能理解其原理； 方式四 推荐 老外大师推荐 12345.clearfix:before,.clearfix:after&#123; content: &apos; &apos;; display: table;&#125; line-height 注意事项 在使用rem 的单位设置时会有点问题 建议使用px的单位 diaplay: inline-block 注意事项 将元素设置为inline-block即行内块元素 多个inline-block元素会排列为一行 对外显示为行内元素 对内为块级元素的特性 带来的问题： 各个元素间会出现一条小缝隙 即是元素间的空白字符 两个标签之间看不见的东西 解决方法： 将元素排列为一行 或去掉元素后面的闭合标签 将闭合标签放到下一个标签的开头部分 还有好多种方法 雪碧图的使用 CSS雪碧 即CSS Sprite，也有人叫它CSS精灵，是一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分 CSS雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。该图片使用CSS background和background-position属性渲染。 省略号的设置12345.box&#123; text-overflow: ellipsis; overflow: hidden; white-space: nowrap;&#125; 有事您Q我👇","categories":[{"name":"responsive-sites","slug":"responsive-sites","permalink":"https://shulu520.com/categories/responsive-sites/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"express","slug":"express","date":"2019-06-12T01:34:23.000Z","updated":"2019-06-12T01:37:23.416Z","comments":true,"path":"express/express/","link":"","permalink":"https://shulu520.com/express/express/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 有事您Q我👇","categories":[{"name":"express","slug":"express","permalink":"https://shulu520.com/categories/express/"}],"tags":[{"name":"zhuf","slug":"zhuf","permalink":"https://shulu520.com/tags/zhuf/"}]},{"title":"cookie-js","slug":"cookie-js","date":"2019-06-11T15:13:25.000Z","updated":"2019-06-11T15:24:47.123Z","comments":true,"path":"cookie/cookie-js/","link":"","permalink":"https://shulu520.com/cookie/cookie-js/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 转载 原文链接运用JS设置cookie、读取cookie、删除cookieJavaScript是运行在客户端的脚本，因此一般是不能够设置Session的，因为Session是运行在服务器端的。 而cookie是运行在客户端的，所以可以用JS来设置cookie. 假设有这样一种情况，在某个用例流程中，由A页面跳至B页面，若在A页面中采用JS用变量temp保存了某一变量的值，在B页面的时候，同样需要使用JS来引用temp的变量值，对于JS中的全局变量或者静态变量的生命周期是有限的，当发生页面跳转或者页面关闭的时候，这些变量的值会重新载入，即没有达到保存的效果。解决这个问题的最好的方案是采用cookie来保存该变量的值，那么如何来设置和读取cookie呢？ 首先需要稍微了解一下cookie的结构，简单地说：cookie是以键值对的形式保存的，即key=value的格式。各个cookie之间一般是以“;”分隔。 JS设置cookie: 假设在A页面中要保存变量username的值(“jack”)到cookie中,key值为name，则相应的JS代码为： document.cookie=”name=”+username; JS读取cookie: 假设cookie中存储的内容为：name=jack;password=123 则在B页面中获取变量username的值的JS代码如下： var username=document.cookie.split(“;”)[0].split(“=”)[1]; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//JS操作cookies方法! //写cookies function setCookie(name, value) &#123; var Days = 30; var exp = new Date(); exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 1000); document.cookie = name + &quot;=&quot; + escape(value) + &quot;;expires=&quot; + exp.toGMTString();&#125;//读取cookiesfunction getCookie(name) &#123; var arr, reg = new RegExp(&quot;(^| )&quot; + name + &quot;=([^;]*)(;|$)&quot;); if ((arr = document.cookie.match(reg))) return unescape(arr[2]); else return null;&#125;//删除cookiesfunction delCookie(name) &#123; var exp = new Date(); exp.setTime(exp.getTime() - 1); var cval = getCookie(name); if (cval != null) document.cookie = name + &quot;=&quot; + cval + &quot;;expires=&quot; + exp.toGMTString();&#125;//使用示例setCookie(&quot;name&quot;, &quot;hayden&quot;);alert(getCookie(&quot;name&quot;));//如果需要设定自定义过期时间//那么把上面的setCookie 函数换成下面两个函数就ok;//程序代码function setCookie(name, value, time) &#123; var strsec = getsec(time); var exp = new Date(); exp.setTime(exp.getTime() + strsec * 1); document.cookie = name + &quot;=&quot; + escape(value) + &quot;;expires=&quot; + exp.toGMTString();&#125;function getsec(str) &#123; alert(str); var str1 = str.substring(1, str.length) * 1; var str2 = str.substring(0, 1); if (str2 == &quot;s&quot;) &#123; return str1 * 1000; &#125; else if (str2 == &quot;h&quot;) &#123; return str1 * 60 * 60 * 1000; &#125; else if (str2 == &quot;d&quot;) &#123; return str1 * 24 * 60 * 60 * 1000; &#125;&#125;//这是有设定过期时间的使用示例：//s20是代表20秒//h是指小时，如12小时则是：h12//d是天数，30天则：d30setCookie(&quot;name&quot;, &quot;hayden&quot;, &quot;s20&quot;); 转载 原文链接 有事您Q我👇","categories":[{"name":"cookie","slug":"cookie","permalink":"https://shulu520.com/categories/cookie/"}],"tags":[]},{"title":"Promise-zhuf","slug":"Promise-zhuf","date":"2019-06-10T13:26:00.000Z","updated":"2019-06-11T15:35:14.048Z","comments":true,"path":"Promise/Promise-zhuf/","link":"","permalink":"https://shulu520.com/Promise/Promise-zhuf/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; js执行顺序优先级 scncfunction –&gt; micro task –&gt; macro task 同步代码 scncfunction 微任务 micro task 宏任务 macro task 微任务 micro task Process.nextTick 把当前任务放到主栈的最后执行 Promise(async await) 宏任务 macro task 回调函数 ajax 事件绑定 node 中的 fs 三种定时器 setImmediate (nodejs独有) setTimeout setInterval 123setImmediate (() =&gt; &#123; console.log(&apos;shulu&apos;)&#125;) Promise 三种状态 进行中 成功 失败 Promise.all([promise1, promise2, promise3]).then(() =&gt; {……}).catch(){……} 即promise1,2,3都成功则执行then的成功方法，有一个失败则走catch方法。 es6 class 类 class 的本质是 function。 在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。 它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法 constructor 方法是类的默认方法，创建类的实例化对象时被调用 class 的实例化必须通过 new 关键字。 123456789101112class Promise &#123; //constructor 创建类的实例化对象时被调用 constructor () &#123; &#125; //这里写原型上的方法 then() catch()&#125; 手写Promise实现 有事您Q我👇","categories":[{"name":"Promise","slug":"Promise","permalink":"https://shulu520.com/categories/Promise/"}],"tags":[{"name":"zhuf","slug":"zhuf","permalink":"https://shulu520.com/tags/zhuf/"}]},{"title":"git-linux","slug":"git-linux","date":"2019-06-09T03:23:05.000Z","updated":"2019-06-10T06:07:03.393Z","comments":true,"path":"git/git-linux/","link":"","permalink":"https://shulu520.com/git/git-linux/","excerpt":"&emsp;&emsp;终有一天，我会出现在你的眼前。","text":"&emsp;&emsp;终有一天，我会出现在你的眼前。 个人本地操作篇 显示目录或文件 ls -s / ls -a -s 文件列表 -a 包括隐藏文件 cd cd / cd ../ 可以直接拖动文件进入目录 创建文件夹 mkdir + shulu 创建空文件 touch + lqy 编辑文件 方式一 vim/vi + lqy A或I 键进入插入模式 编辑完成后 Esc 然后:wq 即可保存退出 方式二 向指定的文件输入内容 echo xxx &gt; shulu.txt shulu.txt若不存在则创建 每次编辑都会覆盖之前的内容 查看文件中的内容 cat lqy 删除文件或文件夹 一旦删除 不可恢复 rm + name -rf -r 递归删除 -f 强制删除 -rf 以上二者都有 git status 查看当前文件处于哪一个区域 红色：在工作区 绿色：在暂存区 看不见：已经提交到历史区，三区保持一致了 暂存区删除文件操作 只要新add一下新的内容 即可覆盖前面暂存区不好的代码 根据提示： (use “git reset HEAD …” to unstage) 即git reset HEAD &lt;要删除的file&gt; 或git rm –cached &lt;要删除的file&gt; 代码回滚 一 暂存区回滚 一步回滚操作 将暂存区文件撤回来覆盖工作区新写的不好的代码 git checkout &lt;要撤回的file&gt; (注意 . 表示所有的文件) 暂存区的文件依然在，只是将其拿出来覆盖新写的不好的代码 工作区和暂存区 状态保持一致了 两步回滚操作 git reset HEAD &lt;要删除的file&gt; 把当前暂存区的内容删掉，此时暂存区的内容为上一次add的内容 git checkout 将上一次add的内容拿回来覆盖工作区的不好的代码 代码回滚 二 历史版本回滚 git log 版本信息 若出现了 提交的信息最后有一个end 按Q键即可退出 git reset –hard &lt;版本id&gt; 三区保持一致了 .gitignore文件 添加不用git管理的文件 ctrl + L 清屏 团队协作篇 创建远程仓库 最好创建一个README.md文件 这样远程就会有一个master的分支 有利于后续的操作 创建本地仓库初始化本地仓库连接远程仓库这操作不常用 mkdir repository git init git remote add origin git@github.com:lqyasl/git-zhuf.git git clone 常用 一步操作等于以上三步操作 git clone git@github.com:lqyasl/git-zhuf.git 不同开发者之间的配合 假设有a b 两个开发者不冲突的情况 a b 两人提交修改的是不同的文件 提交之前最好git pull origin master 拉取远程仓库的内容 然后再git push origin master 推送到远程产生冲突的情况 两人同时对相同的文件都做了不一样的修改 解决冲突 若直接弹出vim的内容 正常退出即可 即 输入a 然后按Esc 再按 :wq 若显示MERGEING 则删掉那些特殊符号 ，修改好后退出 无分支开发模式 即只有一个master 分支分支开发模式 新开一个分支即可 git checkout -b deva 即可创建一个deva分支 并且切换到这个分支上 新创建分支的特点：本地master内容会自动同步到deva分支上 在deva分支上完事后 git add . git commit -m ‘……’ git stash 保存当前的工作进度。会分别对暂存区和工作区的状态进行保存 关于这一步操作后面有说明 git checkout master git merge deva git pull origin master git push origin master git stash &amp; git stash pop git stash 保存当前的工作进度。会分别对暂存区和工作区的状态进行保存. git stash pop 恢复工作现场。 软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。 当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交。 并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？ 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来(先git add . 到暂存区 然后 git stash 藏起来)，等以后回来恢复现场后继续工作。 总结： 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除bug分支； 当手头工作没有完成时，先把工作现场git stash一下，然后去bug分支修复bug，修复后，再回到之前的分支git stash pop，将工作现场恢复。 有事您Q我👇","categories":[{"name":"git","slug":"git","permalink":"https://shulu520.com/categories/git/"}],"tags":[{"name":"zhuf","slug":"zhuf","permalink":"https://shulu520.com/tags/zhuf/"}]},{"title":"webpack-mooc","slug":"webpack-mooc","date":"2019-06-01T15:54:12.000Z","updated":"2019-06-07T03:00:27.318Z","comments":true,"path":"webpack/webpack-mooc/","link":"","permalink":"https://shulu520.com/webpack/webpack-mooc/","excerpt":"&emsp;&emsp;只要有想见的人，就不是孤身一人。","text":"&emsp;&emsp;只要有想见的人，就不是孤身一人。 开始 node 安装 webpack 安装 初始化文件夹 npm init 打包符合node规范的项目 或 npm init -y 生成默认初始化的文件夹 全局安装webpack 不推荐 因为各个项目依赖的webpack版本可能不一样 npm uninstall webpack webpack-cli -g 卸载webpack npm install webpack webpack-cli -D 推荐在项目中独立安装 npm info webpack 打印输出webpack的信息 可以查看你想要的版本是否存在 安装你所需要的版本就行了 npm i webpack@版本号 webpack-cli -D webpack 默认的打包配置文件为webpack.config.js 开始配置 webpack.config.js初步配置 新建webpack.config.js文件 新建src目录 放我们的源代码 webpack.config.js配置如下： 123456789101112//nodejs引入path模块 为commonjs规范const path = require(&apos;path&apos;)module.exports = &#123; mode: development, // 指定运行环境 entry: &apos;./src/index.js&apos;, // 入口文件 output: &#123; // 出口文件 //被编译到你指定的输出路径的文件夹中 path: path.resolve(_dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; //指定打包生成的文件名字 &#125;&#125; package.json 配置scripts命令 简化命打包令为 npm run bundle 12345&#123; &quot;scripts&quot;: &#123; &quot;bundle&quot;: &quot;webpack&quot; //npm run bundle 执行webpack命令 &#125;,&#125; 不同安装的webpack打包形式 未配置scriptsnpx webpack 要打包的文件 配置scripts后npm run bundle 即可 配置打包图片 loader 所谓 loader 只是一个导出为函数的 JavaScript 模块。让 webpack 能够去处理那些非 JavaScript 文件 (webpack 自身只理解 JavaScript) loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块， 然后你就可以利用 webpack 的打包能力，对它们进行处理。 12345678910111213141516171819202122232425const path = require(&apos;path&apos;)module.exports = &#123; mode: &apos;development&apos;, entry: &#123; main: &apos;./src/index.js&apos; &#125;, module: &#123; rules: [&#123; test: /\\.(jpg|png|gif)$/,//用于标识出应该被对应的 loader 进行转换的某个或某些文件。 use: &#123;//表示进行转换时，应该使用哪个 loader。 loader: &apos;url-loader&apos;, // loader: &apos;file-loader&apos;, options: &#123; //配置项 name: &apos;[name].[ext]&apos;,//以原来的名字和后缀打包生成文件名 outputPath: &apos;images/&apos;,//打包生成的文件放到dist/images/ limit: 2048 //当图片的大小在2kb以下时直接打包成base64的图片嵌入js文件中 &#125; &#125; &#125;] &#125;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;&#125; 样式loader css-loader 处理各个css文件间的关系 style-loader 将增加一个style标签并插入css文件然后挂载到head标签中 处理sass文件 npm install sass-loader node-sass -D loader 的执行顺序 从下到上 从右到左 处理less文件 首先npm install less –save-dev 再npm i -D less-loader 123456789101112module: &#123; rules: [&#123; test: /\\.scss$/, use: [&#123; loader: &quot;style-loader&quot; // 将 JS 字符串生成为 style 节点 &#125;, &#123; loader: &quot;css-loader&quot; // 将 CSS 转化成 CommonJS 模块 &#125;, &#123; loader: &quot;sass-loader&quot; // 将 Sass 编译成 CSS &#125;] &#125;]&#125; 自动添加前缀loader 使用Can I Use中的值为CSS规则添加供应商前缀。 Autoprefixer将使用基于当前浏览器流行度和属性支持的数据为您应用前缀。 npm i -D postcss-loader npm i -D autoprefixer 123456//配置新建postcss.config.jsmodule.exports = &#123; plugins: [ require(&apos;autoprefixer&apos;) ]&#125; 123456789//然后配置webpack.config.js&#123; test: /\\.css$/, use: [ &apos;style-loader&apos;, &#123; loader: &apos;css-loader&apos;, options: &#123; importLoaders: 1 &#125; &#125;, &apos;postcss-loader&apos; ]&#125; css-loader 常用的配置 当less(sass)等文件中再引入其他的less(sass)文件时，默认是不会打包引入的文件的， 配置opations 中 importLoaders: 2 后，则会通过’less-loader’, ‘postcss-loader’ 这两个loader的打包 { loader: ‘css-loader’, options: { importLoaders: 2, modules: true //模块化 }},‘less-loader’,‘postcss-loader’ css 打包的模块化 模块中需要哪个样式文件 引入即可import style from ‘./avator.less’ 使用:如 img.classList.add(style.avator) 在avator.less样式中自己写的叫avator的classname 123options: &#123; modules: true //开启css模块化&#125; 字体的引入iconfont file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录。 这就是说，我们可以将它们用于任何类型的文件，包括字体。 src/font一般需要 中如下几种正则中的字体文件 iconfont.css文件，在需要字体的地方引入样式即可 src: url(‘./font/iconfont.eot?t=155948’) url(‘./font/iconfont.ttf?t=155948’) 其中./font为自己加的路劲 其中有个base64格式的路劲不用变 1234test: /\\.(woff|woff2|eot|ttf|svg)$/,use: [ &apos;file-loader&apos;] plugin 插件的使用 html-webpack-plugin插件的使用 npm install –save-dev html-webpack-plugin HtmlWebpackPlugin 插件的作用： 会在打包结束后自动生成一个html文件，并把打包生成的js文件自动引入html文件 plugin的作用：在webpack运行到某个时刻的时候，帮我门做一些在事情 就像vue中的生命周期钩子函数 12345678//webpack.config.js中plugins: [ new HtmlWebpackPlugin(&#123; title: &quot;my html template&quot;, //自定义title 默认为webpack app filename: &quot;myindex.html&quot;, //自定义文件名 默认为index.html template: &quot;src/index.html&quot; //以此为模板创建html &#125;)] clean-webpack-plugin 清除旧的打包的文件 1var &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;) 123plugins: [ new CleanWebpackPlugin(),//打包前删除前面旧的dist文件] entry1234entry: &#123; main: &apos;./src/index.js&apos;, sub: &apos;./src/index.js&apos; //再打包生成一个js文件&#125;, output12345output: &#123; publicPath: &apos;https://cdn.abc.com&apos;,//公共前缀路劲如cdn filename: &apos;[name].js&apos;, //以entry的key值作为打包生成的文件名 path: path.resolve(__dirname, &apos;dist&apos;)&#125;, SourceMap 再打包生成main.js文件之后如果代码里出现错误，它会将main.js中错误出现的地方与源码之间做一映射，告诉我们源码中错误出现在哪里，以便我们快速定位bug出处 错误代码使用chrome调试工具直接显示在index.js?b635这个文件打开即可看到源码里面错误出现的位置 123devtool: &apos;cheap-module-eval-source-map&apos;,//development模式推荐使用devtool: &apos;cheap-module-source-map&apos;,//production模式推荐使用 使用WebpackDevServer提升开发效率 npm install webpack-dev-server -D 在webpack.config.js 12345678910111213devServer: &#123; contentBase: &apos;./dist&apos;,//开启一个服务器运行dist里面的内容 open: true ,//自动在浏览器里打开 /* //vue中就是配置的这样的代理 proxy: &#123; &apos;/api&apos;: &apos;http://localhost:3000&apos;//当用户访问api这个地址时proxy将其转到localhost:3000这个地址 &#125;, */ port: 8888//必要时可以自定义端口&#125;, 在 package.json 123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server&quot; //npm run start 开启服务器 自动刷新 目前最常用的 打包生成的dist文件直接放到内存里运行 速度更快&#125;, HotModuleReplacementPlugin 热模块更新1234567891011121314var webpack = require(&apos;webpack&apos;)//配置devServer: &#123; contentBase: &apos;./dist&apos;, open: true, hot: true, //代码更新时只会更新最新变化的部分 不会全部刷新一遍 hotOnly: true&#125;, //配置plugins: [ new webpack.HotModuleReplacementPlugin()] 使用 Babel 处理 ES6 语法1npm install --save-dev babel-loader babel-core babel-preset-env 123456&#123; test: /\\.js$/, include: &apos;../src&apos; , // 指定匹配文件的范围 exclude: /node_modules/, loader: &apos;babel-loader&apos;&#125; Tree Shaking 概念详解 把一个模块里面的没有用到的方法摇晃掉 去掉 不打包 如果对一些文件不使用此功能 则配置 package.json 添加 配置 “sideEffects”: [‘不使用此功能的文件’] .babelrc文件配置如下 123456789101112&#123; &quot;presets&quot;: [ [ &quot;env&quot; ,&#123; &quot;targets&quot;: &#123; &quot;chrome&quot;: &quot;67&quot;, &#125;, &quot;useBuiltIns&quot;: &quot;usage&quot; &#125; ] ]&#125; Develoment 和 Production 模式的区分打包 新建webpack.dev.js 开发环境 新建webpack.common.js 公共代码 新建webpack.prod.js 生产环境 详见简书配置 Webpack 和 Code Splitting 代码分割 将外来库的方法与业务逻辑代码分开打包 SplitChunksPlugin 配置参数详解 weback.common.js 1234567891011121314151617181920212223242526optimization: &#123;//优化 splitChunks: &#123; chunks: &apos;all&apos;,//同步异步代码都分割 minSize: 30000,//30kb 分割的最小限度配合cacheGroups //maxSize: 50000,//不常用 minChunks: 1,//当一个模块至少被使用了多少次的时候才代码分割 maxAsyncRequests: 5,//假设有多个库要进行分割，但这里只做分割5个 maxInitialRequests: 3,//不用修改 默认就行了 automaticNameDelimiter: &apos;~&apos;,//组和文件之间的连接符 name: true, cacheGroups: &#123;//缓存组 vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/,//在node_modules里面匹配 priority: -10,//优先级和default的优先级作比较， // 若这里的高那么就将符合上面要求的文件打包放到vender组 //filename: &apos;vender.js&apos; &#125;, default: &#123; // minChunks: 2, priority: -20, reuseExistingChunk: true ,//入一个文件已经在之前的步骤中打包过了，那这里就不用再打包了 filename: &apos;common.js&apos; &#125; &#125; &#125;&#125;, Lazy Loading 和 chunk 是什么 懒加载 即当时机成熟的时候再加载代码 promise 必须要有catch() 捕获错误 chunk表示一个文件，默认情况下webpack的输入是一个入口entry文件，输出output也是一个文件，这个文件就是一个chunk，chunkId就是产出时给每个文件一个唯一标识id，chunkhash就是文件内容的md5值，name就是在entry中指定的key值。 123//安装插件npm install --save-dev @babel/plugin-syntax-dynamic-import 12345678910111213141516//src/index.jsasync function getComponent () &#123; const &#123; default: _ &#125; = await import(&apos;lodash&apos;)//异步按需引入lodash函数库 var dom = document.createElement(&apos;div&apos;) dom.innerHTML = _.join([&apos;hello&apos;, &apos;shulu&apos;, &apos;lqy&apos;, &apos;love&apos;, &apos;you&apos;], &apos;^_^&apos;) return dom&#125;document.addEventListener(&apos;click&apos;, () =&gt; &#123; getComponent().then((dom) =&gt; &#123; document.body.appendChild(dom) &#125;).catch((err) =&gt; &#123; console.log(err) &#125;)&#125;) 123456789101112131415//.babelrc&#123; &quot;presets&quot;: [ [ &quot;env&quot; ,&#123; &quot;targets&quot;: &#123; &quot;chrome&quot;: &quot;67&quot;, &#125;, &quot;useBuiltIns&quot;: &quot;usage&quot; &#125; ] ], &quot;plugins&quot;: [&quot;@babel/plugin-syntax-dynamic-import&quot;,]//配置插件&#125; 123456//事实上webpack.common.js的配置如下即可optimization: &#123; splitChunks: &#123; chunks: &apos;all&apos;//同步异步代码都分割 &#125;&#125;, css 模块的分割打包 目前不支持模块热跟新 故在生产环境使用好一些 将webpack.common.js中的css配置文件分别拿到webpack.dev.js 和webpack.prod.js 12345678extract-text-webpack-plugin还不能支持webpack4.0.0以上的版本。 解决办法： npm install -–save-dev extract-text-webpack-plugin@next 会下载到+ extract-text-webpack-plugin@4.0.0-beta.0 然后打包就正常了//npm install --save-dev extract-text-webpack-pluginnpm install --save-dev extract-text-webpack-plugin@next 1234567891011121314151617181920212223242526//webpack.prod.jsconst ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;)//配置module: &#123; rules: [ &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: [&apos;css-loader&apos;, &apos;postcss-loader&apos;] &#125;) &#125;, &#123; test: /\\.less$/, use: ExtractTextPlugin.extract(&#123; fallback: &apos;style-loader&apos;, //如果需要，可以在 sass-loader 之前将 resolve-url-loader 链接进来 use: [&apos;css-loader&apos;, &apos;less-loader&apos;, &apos;postcss-loader&apos;] &#125;) &#125; ]&#125;,plugins: [ new ExtractTextPlugin(&quot;styles.css&quot;),] 12345//package.json 对css文件不使用tree shaking&quot;sideEffects&quot;: [ &quot;*.css&quot;], 12345678//webpack.common.jsoptimization: &#123; usedExports: true, //模块中只引入使用了的方法(函数) splitChunks: &#123; chunks: &apos;all&apos; &#125;&#125;, 将打包后的css压缩代码 1npm i -S optimize-css-assets-webpack-plugin 1234567//webpack.prod.jsconst OptimizeCSSAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;)optimization: &#123; minimizer: [new OptimizeCSSAssetsPlugin(&#123;&#125;)],&#125;, webpack Library库webpack PWA 的打包TypeScript 的打包配置WebpackDevServer 请求转发 devServer.proxy的配置 开发环境development 12345678910111213141516devServer: &#123; proxy: &#123;//代理 &quot;/api&quot;: &#123; //将所有对/api的请求转发到http://shulu520.com/test.json target: &quot;http://shulu520.com/test.json&quot;, //在开发中当后端/api还没有做好时，将路劲变为love.json, 做好后，将这里配置注释掉即可，就不用改源码了 pathRewrite: &#123;&quot;^/api&quot; : &quot;love.json&quot;&#125;, //默认不支持https的 配置后即可支持 secure: false //如果希望代理多个特定路径到同一个目标，可以这样使用 context: [&quot;/auth&quot;, &quot;/api&quot;], &#125;&#125; webpack 打包优化 跟上技术的迭代 工具的更新 在尽可能少的模块上应用loader 约束loader的应用范围 123456&#123; test: /\\.js$/, include: path.resolve(__diename, &apos;./src&apos;) exclude: /node_modules/, loader: &apos;babel-loader&apos;&#125; 尽可能少的使用plugin 并确保可靠 官网的推荐 resolve 配置项 参数的合理配置 123456//webpack.common.jsresole: &#123; alias: &#123;// 别名 简化长路劲 Child: path.resolve(__dirname, &apos;./src/a/b/c/Child&apos;) &#125;&#125; 自己编写 Loader 实现代码的装饰 loader 是转译模块源代码的转换规则。 loader 被编写为，接受源代码作为参数的函数， 并返回这些转换过的新版本代码. 手写 pluginbundler 源码编写 (模块分析) 有事您Q我👇","categories":[{"name":"webpack","slug":"webpack","permalink":"https://shulu520.com/categories/webpack/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"js-advance-four","slug":"js-advance-four","date":"2019-05-31T02:57:20.000Z","updated":"2019-08-09T09:11:20.458Z","comments":true,"path":"js-advance/js-advance-four/","link":"","permalink":"https://shulu520.com/js-advance/js-advance-four/","excerpt":"&emsp;&emsp;这世界为何有这么可爱的人儿，儿童节快乐哦","text":"&emsp;&emsp;这世界为何有这么可爱的人儿，儿童节快乐哦 线程与进程 进程: 程序的一次执行, 它占有一片独有的内存空间 可以通过windows任务管理器查看进程 线程: 是进程内的一个独立执行单元 是程序执行的一个完整流程 是CPU的最小的调度单元 关系 一个进程至少有一个线程(主) 程序是在某个进程中的某个线程执行的 应用程序必须运行在某个进程的某个线程上 一个进程中至少有一个运行的线程: 主线程, 进程启动后自动创建 一个进程内的数据可以供其中的多个线程直接共享 多个进程之间的数据是不能直接共享的 线程池(thread pool): 保存多个线程对象的容器, 实现线程对象的反复利用 何为多进程与多线程? 多进程运行: 一应用程序可以同时启动多个实例运行 多线程: 在一个进程内, 同时有多个线程运行 比较单线程与多线程? 多线程优点：能有效提升CPU的利用率缺点：创建多线程开销 线程间切换开销 死锁与状态同步问题 单线程优点：顺序编程简单易懂缺点：效率低 JS是单线程还是多线程? js是单线程运行的 但使用H5中的 Web Workers可以多线程运行 浏览器运行是单进程还是多进程? 有的是单进程 firefox 老版IE 有的是多进程 chrome 新版IE 如何查看浏览器是否是多进程运行的呢? 任务管理器 —&gt; 进程 浏览器内核 支撑浏览器运行的最核心的程序 不同的浏览器可能不一样 Chrome, Safari : webkit firefox : Gecko IE: Trident 360,搜狗等国内浏览器: Trident + webkit 浏览器内核模块组成 主线程 js引擎模块 : 负责js程序的编译与运行 html,css文档解析模块 : 负责页面文本的解析 DOM/CSS模块 : 负责dom/css在内存中的相关处理 布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象) 分线程 定时器模块 : 负责定时器的管理 DOM事件模块 : 负责事件的管理 网络请求模块 : 负责Ajax请求 js线程 js是单线程执行的(回调函数也是在主线程) H5提出了实现多线程的方案: Web Workers 只能是主线程更新界面 定时器问题: 定时器并不真正完全定时 如果在主线程执行了一个长时间的操作, 可能导致延时才处理 事件处理机制(图) 代码分类 初始化执行代码: 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码 回调执行代码: 处理回调逻辑 js引擎执行代码的基本流程: 初始化代码===&gt;回调代码 模型的2个重要组成部分: 事件管理模块 回调队列 模型的运转流程 执行初始化代码, 将事件回调函数交给对应模块管理 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行 H5 Web Workers 可以让js在分线程执行 Worker 计算斐波那契数列的例子 12345678910//在主线程 创建一个Worker实例对象 var worker = new Worker(&apos;worker.js&apos;) // 其中worker.js为worker文件路劲 // 绑定接收消息的监听 worker.onmessage = function (event) &#123; //通信的数据都在event.data里面 alert(event.data) &#125; // 向分线程发送消息 worker.postMessage(number) 123456789101112// 在分线程 斐波那契数列function fibonacci(n) &#123; //递归调用 return n&lt;=2 ? 1 : fibonacci(n-1) + fibonacci(n-2) &#125;this.onmessage = function (event) &#123; var number = event.data console.log(&apos;分线程接收到主线程发送的数据: &apos;+number) var result = fibonacci(number)//计算斐波那契数列 postMessage(result)&#125; / 分线程中this不再是window 而是另一个全局对象 其有onmessage,postMessage等方法 故在这里可以直接调用 而不可以直接调用window的方法 如alert() // alert is not defind document 方法 等 可以更新页面的方法都不可以调用 只有主线程才可以跟新界面 / 问题: worker内代码不能操作DOM更新UI 不是每个浏览器都支持这个新特性 不能跨域加载JS 慢一点 数据传输过程 来我QQ撩我哦👇","categories":[{"name":"js-advance","slug":"js-advance","permalink":"https://shulu520.com/categories/js-advance/"}],"tags":[{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"js-advance-three","slug":"js-advance-three","date":"2019-05-30T10:42:14.000Z","updated":"2019-05-30T15:43:30.456Z","comments":true,"path":"js-advance/js-advance-three/","link":"","permalink":"https://shulu520.com/js-advance/js-advance-three/","excerpt":"&emsp;&emsp;想起你，内心充满欢喜O(∩_∩)O","text":"&emsp;&emsp;想起你，内心充满欢喜O(∩_∩)O 对象的创建模式 Object构造函数模式 套路: 先创建空Object对象, 再动态添加属性/方法 适用场景: 起始时不确定对象内部数据 问题: 语句太多 123var obj = new Object()obj.name = &apos;Tom&apos;obj.setName = function(name)&#123;this.name=name&#125; 对象字面量模式 套路: 使用{}创建对象, 同时指定属性/方法 适用场景: 起始时对象内部数据是确定的 问题: 如果创建多个对象, 有重复代码 1234var obj = &#123; name : &apos;Tom&apos;, setName : function(name)&#123;this.name = name&#125;&#125; 工厂函数模式 套路: 通过工厂函数动态创建对象并返回 适用场景: 需要创建多个对象 问题: 对象没有一个具体的类型, 都是Object类型 即通过instanceof判断得到的都是Object类型 类型不够具体 人和🐶均为同一类型 用的不多 只是比较经典 返回一个对象的函数===&gt;工厂函数 联系真实工厂 12345678910function createPerson(name, age) &#123; var obj = &#123; name: name, age: age, setName: function (name) &#123; this.name = name &#125; &#125; return obj&#125; 构造函数模式 套路: 自定义构造函数, 通过new创建实例对象 适用场景: 需要创建多个类型确定的对象 问题: 每个对象都有相同的数据, 浪费内存 123456function Person(name, age) &#123; this.name = name; this.age = age; this.setName = function(name)&#123;this.name=name;&#125;;&#125;new Person(&apos;tom&apos;, 12); 组合模式 (构造函数+原型) 套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上 适用场景: 需要创建多个类型确定的对象 123456function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.setName = function(name)&#123;this.name=name;&#125;;new Person(&apos;tom&apos;, 12); 继承模式 原型链继承 : 得到方法 12345678function Parent() &#123;&#125;Parent.prototype.test = function()&#123;&#125;;function Child() &#123;&#125;Child.prototype = new Parent(); //子类型的原型指向父类型实例Child.prototype.constructor = Child //修正constructor属性重新指向子构造函数var child = new Child(); //有test() 借用构造函数 : 得到属性(假继承) 1234567function Parent(xxx)&#123;this.xxx = xxx&#125;Parent.prototype.test = function()&#123;&#125;;function Child(xxx,yyy)&#123; Parent.call(this, xxx);//借用构造函数 this.Parent(xxx)&#125;var child = new Child(&apos;a&apos;, &apos;b&apos;); //child.xxx为&apos;a&apos;, 但child没有test() 组合继承 (原型链继承+构造函数) 利用原型链实现对父类型对象的方法继承 利用call()借用父类型构建函数初始化相同属性 12345678910function Parent(xxx)&#123;this.xxx = xxx&#125;Parent.prototype.test = function()&#123;&#125;function Child(xxx,yyy)&#123; Parent.call(this, xxx)//借用构造函数 this.Parent(xxx)&#125;Child.prototype = new Parent() //得到test()Child.prototype.constructor = Child //修正constructor属性var child = new Child(); //child.xxx为&apos;a&apos;, 也有test() new一个对象背后做了些什么? 创建一个空对象 给对象设置proto, 值为构造函数对象的prototype属性值 this.proto = Fn.prototype 执行构造函数体(给对象添加属性/方法) 来我QQ撩我哦👇","categories":[{"name":"js-advance","slug":"js-advance","permalink":"https://shulu520.com/categories/js-advance/"}],"tags":[{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"hotkey-listary","slug":"hotkey-listary","date":"2019-05-28T15:21:39.000Z","updated":"2019-05-28T15:39:24.343Z","comments":true,"path":"hotkey/hotkey-listary/","link":"","permalink":"https://shulu520.com/hotkey/hotkey-listary/","excerpt":"&emsp;&emsp;人生如逆旅，我亦是行人。","text":"&emsp;&emsp;人生如逆旅，我亦是行人。 listary 最常用的快捷键 alt A 打开listary 双击 ctrl 打开listary bing 必应搜索 bd 百度一下 百度网盘 zh 知乎搜索 ctrl N 向下切换选中的目录 ctrl P 向上切换选中的目录 双击桌面 打开listary选项 在任意文件夹/目录下双击 打开listary选项 可以选命令打开cmd &emsp;&emsp;未完待续…… 来我QQ撩我哦👇","categories":[{"name":"hotkey","slug":"hotkey","permalink":"https://shulu520.com/categories/hotkey/"}],"tags":[{"name":"listary","slug":"listary","permalink":"https://shulu520.com/tags/listary/"}]},{"title":"hotkey-windows","slug":"hotkey-windows","date":"2019-05-27T04:24:05.000Z","updated":"2019-05-27T04:46:38.907Z","comments":true,"path":"hotkey/hotkey-windows/","link":"","permalink":"https://shulu520.com/hotkey/hotkey-windows/","excerpt":"&emsp;&emsp; 👉Q我吧","text":"&emsp;&emsp; 👉Q我吧 windows 最常用快捷键 ctrl w 关闭当前网页 f2键 ：选中后按f2键即可重命名文件，另一种方法，点一下文件名，稍等，再点一下，即可重命名 f4: 重复上步操作 f5: 刷新桌面 刷新网页 f11: 全屏显示网页 shift : 省略号 shift + 数字6 （表示六个点） …… 书名号 shift + &lt;&gt; (小于大于） 分隔号 单独按 数字1 前面的键 《简 · 爱》 Alt + 单击拖动 为矩形选择 AlT + f4 关闭当前程序 删除 选中后 按delete 永久删除 选中后 shift +delete 截屏 PrtSc 截全屏 Alt +PrtSc 截当前窗口 ctrl alt delete 任务管理器 windows 打开开始菜单 ctrl shift n 新建文件夹 window e 打开文件资源管理器 alt tab 切换窗口 window d 回到桌面 &emsp;&emsp;学到了再来补充😝 👉点这里，进入QQ交流","categories":[{"name":"hotkey","slug":"hotkey","permalink":"https://shulu520.com/categories/hotkey/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://shulu520.com/tags/windows/"}]},{"title":"js-advance-two","slug":"js-advance-two","date":"2019-05-25T15:06:08.000Z","updated":"2019-05-30T15:49:15.430Z","comments":true,"path":"js-advance/js-advance-two/","link":"","permalink":"https://shulu520.com/js-advance/js-advance-two/","excerpt":"","text":"&emsp;&emsp;又是元气满满的一天😝,文章链接失效，又好了。有惊无险 来我QQ撩我哦👇 原型与原型链 所有函数都有一个特别的属性: prototype : 显式原型属性 所有实例对象都有一个特别的属性: proto : 隐式原型属性 当然所有函数也都有一个特别的属性： proto : 隐式原型属性 且所有函数的 隐式原型 都一样 都等于Function的显式原型 函数的显式原型指向的对象默认是空Object实例对象(但Object不满足) 123console.log(Fn.prototype instanceof Object) // trueconsole.log(Object.prototype instanceof Object) // falseconsole.log(Function.prototype instanceof Object) // true 所有函数都是Function的实例(包含Function自身) 1console.log(Function.__proto__===Function.prototype) Object的原型对象是原型链尽头 1console.log(Object.prototype.__proto__) // null 1234567891011121314151617// 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)console.log(Date.prototype, typeof Date.prototype)function Fun () &#123;//alt + shift +r(重命名rename)&#125;console.log(Fun.prototype) // 默认指向一个Object空对象(没有我们的属性)// 原型对象中有一个属性constructor, 它指向函数对象console.log(Date.prototype.constructor===Date)console.log(Fun.prototype.constructor===Fun)//给原型对象添加属性(一般是方法) ===&gt;实例对象可以访问Fun.prototype.test = function () &#123; console.log(&apos;test()&apos;)&#125;var fun = new Fun()fun.test() 显式原型与隐式原型的关系 函数的prototype: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象 实例对象的proto: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值 原型对象即为当前实例对象的父对象 原型链 所有的实例对象都有proto属性, 它指向的就是原型对象 这样通过proto属性就形成了一个链的结构—-&gt;原型链 当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找 当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作,如果当前对象中没有此属性, 直接添加此属性并设置其值 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上 面试题1 1234567891011121314function A () &#123; ...&#125;A.prototype.n = 1var b = new A()A.prototype = &#123; n: 2, m: 3&#125;var c = new A()console.log(b.n, b.m, c.n, c.m) // 1 undifind 2 3 面试题2 12345678910111213141516function F ()&#123;&#125; Object.prototype.a = function()&#123; console.log(&apos;a()&apos;)&#125;Function.prototype.b = function()&#123; console.log(&apos;b()&apos;)&#125;var f = new F()f.a()f.b() // 找不到,可以看原型链图进行分析F.a()F.b() instanceof是如何判断的? 表达式: A instanceof B 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false Function是通过new自己产生的实例 123456789101112131415161718/*案例1 */function Foo() &#123; &#125;var f1 = new Foo()console.log(f1 instanceof Foo) // trueconsole.log(f1 instanceof Object) // true/*案例2 */console.log(Object instanceof Function) // trueconsole.log(Object instanceof Object) // trueconsole.log(Function instanceof Function) // trueconsole.log(Function instanceof Object) // truefunction Foo() &#123;&#125;console.log(Object instanceof Foo) // false 执行上下文与执行上下文栈 变量提升与函数提升 变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined) 函数提升: 在函数定义语句之前, 就执行该函数 先执行变量提升, 再执行函数提升 123function a() &#123;&#125;var aconsole.log(typeof a) // &apos;function&apos; 123456789101112var c = 1function c(c) &#123; console.log(c) var c = 3&#125;c(2) // 报错 c is not a function过程解析： var c fun c c = 1 c(2) 理解 执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性 执行上下文栈: 用来管理产生的多个执行上下文 分类: 全局: window 函数: 对程序员来说是透明的 生命周期 全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡 函数 : 调用函数时产生, 函数执行完时死亡 包含哪些属性: 全局 : 用var定义的全局变量 ==&gt;undefined 使用function声明的函数 ===&gt;function this ===&gt;window 函数 用var定义的局部变量 ==&gt;undefined 使用function声明的函数 ===&gt;function this ===&gt; 调用函数的对象, 如果没有指定就是window 形参变量 ===&gt;对应实参值 arguments ===&gt;实参列表的伪数组 执行上下文 创建和初始化的过程 全局执行上下文: 在全局代码执行前最先创建一个全局执行上下文(window) 收集一些全局变量, 并初始化 var定义的全局变量==&gt;undefined, 添加为window的属性 function声明的全局函数==&gt;赋值(fun), 添加为window的方法 this==&gt;赋值(window) 开始执行全局代码 函数执行上下文: 在调用函数时, 在执行函数体之前，先创建一个函数执行上下文对象(虚拟的, 存在于栈中) 收集一些局部变量, 并初始化 形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性 arguments==&gt;赋值(实参列表), 添加为执行上下文的属性 var定义的局部变量==&gt;undefined, 添加为执行上下文的属性 function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法 this==&gt;赋值(调用函数的对象) 开始执行函数体代码 执行上下文栈 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象 在全局执行上下文(window)确定后, 将其添加到栈中(压栈) 在函数执行上下文创建后, 将其添加到栈中(压栈) 在当前函数执行完后,将栈顶的对象移除(出栈) 当所有的代码执行完后, 栈中只剩下window 12345678910var a = 10var bar = function (x) &#123; var b = 5 foo(x + b)&#125;var foo = function (y) &#123; var c = 5 console.log(a + c + y)&#125;bar(10) 产生执行上下文的个数 = (N)函数调用次数 + 1 面试题 整个过程中产生了几个执行上下文? 5 依次输出什么? gb: undefined fb: 1 fb: 2 fb: 3 fe: 3 fe: 2 fe: 1 ge: 1 123456789101112console.log(&apos;gb: &apos;+ i)var i = 1foo(1)function foo(i) &#123; if (i == 4) &#123; return &#125; console.log(&apos;fb:&apos; + i) foo(i + 1) // 递归调用: 在函数内部调用自己 console.log(&apos;fe:&apos; + i)&#125;console.log(&apos;ge: &apos; + i) 作用域与作用域链 理解: 作用域: 一块代码区域, 在编码时就确定了, 不会再变化 作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量 产生作用域的个数 = (N)定义函数的个数 + 1 分类: 全局 函数 js没有块作用域(在ES6之前) 作用 作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突 作用域链: 查找变量 区别作用域与执行上下文 作用域: 静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了 执行上下文: 动态的, 执行代码时动态创建, 当执行结束消失 联系: 执行上下文环境是在对应的作用域中的 面试题 12345678910111213141516var x = 10; function fn() &#123; console.log(x); &#125; function show(f) &#123; var x = 20; f(); &#125; show(fn); // 10 /* 解析：作用域在函数创建的时候就确定了，一旦确定就不会变化了 */ 1234567891011121314151617var fn = function () &#123; console.log(fn) &#125; fn() // fn函数体 var obj = &#123; fn2: function () &#123; console.log(fn2) &#125; &#125; obj.fn2() // fn2 is not defind /* 解析： 首先在fn2函数作用域里面找fn2 没有 然后再全局作用域找 也没有 故报错 若为this.fn2 则可以 */ 作用域链和原型链的用处 作用域链用来找变量 原型链用来找方法 在全局直接找一个不存在的方法 a is not defined 而通过window.a 则为undifind 闭包 如何产生闭包? 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包 闭包到底是什么? 使用chrome调试查看 会调试的程序员至少不是初级程序员 理解一: 闭包是嵌套的内部函数(绝大部分人) 初步认识 理解二: 包含被引用变量(函数)的对象(极少数人) 高级认识 注意: 闭包存在于嵌套的内部函数中 产生闭包的条件 函数嵌套 内部函数引用了外部函数的数据(变量/函数) 产生闭包的个数 等于外部函数调用的次数 12345678910//三个button按钮for (var i = 0,length=btns.length; i &lt; length; i++) &#123; (function (j) &#123; var btn = btns[j] btn.onclick = function () &#123; alert(&apos;第&apos;+(j+1)+&apos;个&apos;) &#125; &#125;)(i) &#125;// 共产生三个闭包 因为外部函数共调用了三次，每一闭包内部都保存了各自的变量 常见的闭包 将函数作为另一个函数的返回值 将函数作为实参传递给另一个函数调用 闭包生命周期 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用) 死亡: 在嵌套的内部函数成为垃圾对象时 12345678910111213function fn1() &#123; //此时闭包就已经产生了(函数提升, 内部函数对象已经创建了) var a = 2 function fn2 () &#123; a++ console.log(a) &#125; return fn2&#125;var f = fn1() //f来接收fn2f() // 3f() // 4f = null //闭包死亡(包含闭包的函数对象成为垃圾对象) 作用: 延长局部变量的生命周期 让函数外部能操作内部的局部变量 写一个闭包程序 1234567891011function fn1() &#123; var a = 2 function fn2() &#123; a++ console.log(a) &#125; return fn2&#125;var f = fn1()f()f() 闭包应用: 模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为 循环遍历加监听 JS框架(jQuery)大量使用了闭包 缺点: 变量占用内存的时间可能会过长 可能导致内存泄露 解决: 及时释放 : f = null; //让内部函数对象成为垃圾对象 面试题1 123456789101112131415161718192021222324//代码片段一var name = &quot;The Window&quot;;var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); // the window//代码片段二var name2 = &quot;The Window&quot;;var object2 = &#123; name2 : &quot;My Object&quot;, getNameFunc : function()&#123; var that = this; return function()&#123; return that.name2; &#125;; &#125;&#125;;alert(object2.getNameFunc()()); // my object 内存溢出与内存泄露 内存溢出 一种程序运行出现的错误 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误 内存泄露 占用的内存没有及时释放 内存泄露积累多了就容易导致内存溢出 常见的内存泄露: 意外的全局变量 没有及时清理的计时器或回调函数 闭包 &gt;👉点这里，进入QQ交流","categories":[{"name":"js-advance","slug":"js-advance","permalink":"https://shulu520.com/categories/js-advance/"}],"tags":[{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"js-advance-one","slug":"js-advance-one","date":"2019-05-24T06:13:53.000Z","updated":"2019-05-27T04:54:45.525Z","comments":true,"path":"js-advance/js-advance-one/","link":"","permalink":"https://shulu520.com/js-advance/js-advance-one/","excerpt":"能够让你后悔的从来不是你做过的事而是你想做却没有去做的事👉Q我吧","text":"能够让你后悔的从来不是你做过的事而是你想做却没有去做的事👉Q我吧 数据类型的分类和判断 基本(值)类型 Number —– 任意数值 ——– typeof String —– 任意字符串 —— typeof Boolean —- true/false —– typeof undefined — undefined —– typeof/=== null ——– null ———- === 对象(引用)类型 Object —– 任意对象 —– typeof/instanceof Array —— 一种特别的对象(数值下标)—– instanceof Function —- 一种特别的对象(可以执行，内部数据是有序的) —– typeof 判断 typeof ——– 返回数据类型的字符串表达 不能判断 null和object ， object和array instanceof —- 判断对象的具体类型 a instanceof b 即a是否是b构造函数的一个实例 === ———— 可以判断 undefined 和 null 名词解释 实例 实例对象 类型 类型对象 即构造函数 undefined与null的区别? undefined代表定义未赋值 nulll定义并赋值了, 只是值为null 什么时候给变量赋值为null呢? 初始赋值, 表明将要赋值为对象 结束前, 让对象成为垃圾对象(被垃圾回收器回收) 严格区别变量类型与数据类型? 数据的类型 基本类型 对象类型 变量的类型(变量内存值的类型) 基本类型: 保存就是基本类型的数据 引用类型: 保存的是地址值 数据,变量, 内存的理解 什么是数据? 在内存中可读的, 可传递的保存了特定信息的’东东’ 一切皆数据, 函数也是数据 在内存中的所有操作的目标: 数据 什么是变量? 在程序运行过程中它的值是允许改变的量 一个变量对应一块小内存, 它的值保存在此内存中 什么是内存? 内存条通电后产生的存储空间(临时的) 一块内存包含2个方面的数据 内部存储的数据 地址值数据 内存空间的分类 栈空间: 全局变量和局部变量 堆空间: 对象 内存,数据, 变量三者之间的关系 内存是容器, 用来存储不同数据 变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据 问题: var a = xxx, a内存中到底保存的是什么? xxx是基本数据, 保存的就是这个数据 xxx是对象, 保存的是对象的地址值 xxx是一个变量, 保存的xxx的内存内容(可能是基本数据, 也可能是地址值) 关于引用变量赋值问题 2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据 2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象 1234567891011121314151617181920212223let obj1 = &#123; name: &apos;lqy&apos; &#125;情形一function fn1(obj) &#123; obj.name = &apos;shulu&apos;&#125;fn1(obj1)console.log(obj1.name) // shulu情形二funtion fn2(obj) &#123; obj = &#123;name: &apos;shulu&apos;&#125;&#125;fn2(obj1)console.log(obj1.name) // lqy/*解析：形参obj 在函数内部为 var obj变量执行fn( ) 传入实参obj1 即将obj1的值(这里是地址值)复制一份给obj变量*/ 问题: 在js调用函数时传递变量参数时, 是值传递还是引用传递 理解1: 都是值(基本值/地址值)传递 推荐 理解2: 可能是值传递, 也可能是引用传递(地址值) 问题: JS引擎如何管理内存? 内存生命周期 分配小内存空间, 得到它的使用权 存储数据, 可以反复进行操作 释放小内存空间 释放内存 局部变量: 函数执行完自动释放 对象: 成为垃圾对象==&gt;垃圾回收器回收 对象的理解和使用 什么是对象? 多个数据(属性)的集合 用来保存多个数据(属性)的容器 属性组成: 属性名 : 字符串(标识) 属性值 : 任意类型 属性的分类: 一般 : 属性值不是function 描述对象的状态 方法 : 属性值为function的属性 描述对象的行为 特别的对象 数组: 属性名是0,1,2,3之类的索引 函数: 可以执行的 如何操作内部属性(方法) .属性名 [‘属性名’]: 属性名有特殊字符/属性名是一个变量 问题: 什么时候必须使用[‘属性名’]的方式? 属性名包含特殊字符: - 空格 属性名不确定 函数的理解和使用 什么是函数? 用来实现特定功能的, n条语句的封装体 只有函数类型的数据是可以执行的, 其它的都不可以 为什么要用函数? 提高复用性 便于阅读交流 函数也是对象 instanceof Object===true 函数有属性: prototype 函数有方法: call()/apply() 可以添加新的属性/方法 如何调用(执行)函数? test(): 直接调用 obj.test(): 通过对象调用 new test(): new调用 test.call/apply(obj): 临时让test成为obj的方法进行调用 函数中的this是什么? 任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window 所有函数内部都有一个变量this 它的值是调用函数的当前对象 如何确定this的值? test(): window p.test(): p var p = new test(): 新创建的对象p p.call(obj): obj 1234567891011121314151617181920212223242526272829303132333435function Person(color) &#123; console.log(this) this.color = color; this.getColor = function () &#123; console.log(this) return this.color; &#125;; this.setColor = function (color) &#123; console.log(this) this.color = color; &#125;; &#125; Person(&quot;red&quot;); //this是谁? window var p = new Person(&quot;yello&quot;); //this是谁? p p.getColor(); //this是谁? p var obj = &#123;&#125;; p.setColor.call(obj, &quot;black&quot;); //this是谁? obj var test = p.setColor; test(); //this是谁? window function fun1() &#123; function fun2() &#123; console.log(this); &#125; fun2(); //this是谁? window &#125; fun1(); 匿名函数自调用: 123(function(w, obj)&#123; //实现代码&#125;)(window, obj) 专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式 作用 隐藏实现 不会污染外部(全局)命名空间 用它来编码js模块 回调函数的理解 什么函数才是回调函数? 你定义的 你没有调用 但它最终执行了(在一定条件下或某个时刻) 常用的回调函数 dom事件回调函数 定时器回调函数 ajax请求回调函数(后面讲解) 生命周期回调函数(后面讲解) 问题 js一条语句的后面是否应该加分号？ 是否加分号是编码风格问题，没有应不应该，只有喜不喜欢——尤雨溪 必须加分号的情况： 小括号开头的语句 ;(function () {…})() 方括号的开头 ;[1, 2, 3].forEach(() =&gt; {}) &emsp;&emsp;本篇笔记到此完结。 👉点这里，进入QQ交流","categories":[{"name":"js-advance","slug":"js-advance","permalink":"https://shulu520.com/categories/js-advance/"}],"tags":[{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"js-modularize","slug":"js-模块化","date":"2019-05-23T14:17:24.000Z","updated":"2019-08-18T07:26:17.492Z","comments":true,"path":"js-modularize/js-模块化/","link":"","permalink":"https://shulu520.com/js-modularize/js-模块化/","excerpt":"&emsp;&emsp;爱上一个人是一件幸福的事 👉来QQ撩我啊","text":"&emsp;&emsp;爱上一个人是一件幸福的事 👉来QQ撩我啊 JS模块化模块化介绍 模块化的理解 什么是模块? 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起 块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信 一个模块的组成 数据—&gt;内部的属性 操作数据的行为—&gt;内部的函数 模块化 编码时是按照模块一个一个编码的, 整个项目就是一个模块化的项目 模块化的进化过程全局function模式 : 编码: 全局变量/函数 问题: 污染全局命名空间, 容易引起命名冲突/数据不安全 namespace模式(命名空间) : 编码: 将数据/行为封装到对象中 解决: 命名冲突(减少了全局变量) 问题: 数据不安全(外部可以直接修改模块内部的数据) IIFE模式/增强 IIFE : 立即调用函数表达式—&gt;匿名函数自调用 编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口 引入依赖: 通过函数形参来引入依赖模块 123456789101112(function(window, module2)&#123; var data = 'atguigu.com' function foo() &#123; module2.xxx() console.log('foo()'+data) &#125; function bar() &#123; console.log('bar()'+data) &#125; window.module = &#123;foo&#125;&#125;)(window, module2) 模块化规范CommonJS Node.js : 服务器端 Browserify : 浏览器端 也称为js的打包工具 基本语法: 12345678910定义暴露模块 : exports exports.xxx = value module.exports = value引入模块 : require var module = require('模块名/模块相对路径')引入模块发生在什么时候?Node : 运行时, 动态同步引入Browserify : 在运行前对模块进行编译/转译/打包的处理(已经将依赖的模块包含进来了), 运行的是打包生成的js, 运行时不存在需要再从远程引入依赖模块 AMD 浏览器端123456789101112131415161718192021222324252627require.js基本语法 定义暴露模块: define([依赖模块名], function()&#123;return 模块对象&#125;) 引入模块: require(['模块1', '模块2', '模块3'], function(m1, m2)&#123;//使用模块对象&#125;) 配置: require.config(&#123; //基本路径 baseUrl : 'js/', //标识名称与路径的映射 paths : &#123; '模块1' : 'modules/模块1', '模块2' : 'modules/模块2', 'angular' : 'libs/angular', 'angular-messages' : 'libs/angular-messages' &#125;, //非AMD的模块 shim : &#123; 'angular' : &#123; exports : 'angular' &#125;, 'angular-messages' : &#123; exports : 'angular-messages', deps : ['angular'] &#125; &#125;&#125;) CMD : 浏览器端12345678910sea.js基本语法定义暴露模块: define(function(require, module, exports)&#123; 通过require引入依赖模块 通过module/exports来暴露模块 exports.xxx = value &#125;)使用模块seajs.use(['模块1', '模块2']) ES6 ES6内置了模块化的实现 1234567891011121314151617181920212223242526定义暴露模块 : export 暴露一个对象: export default 对象 默认暴露 暴露多个: 常规暴露 export var xxx = value1 export let yyy = value2 或 var xxx = value1 let yyy = value2 export &#123;xxx, yyy&#125; 引入使用模块 : import default模块: 争对默认暴露的模块 以及第三方库 import xxx from '模块路径/模块名' 其它模块：争对常规暴露的模块 import &#123;xxx, yyy&#125; from '模块路径/模块名' import as module1 from '模块路径/模块名'问题: 所有浏览器还不能直接识别ES6模块化的语法 解决: 使用Babel将ES6---&gt;ES5(使用了CommonJS) ----浏览器还不能直接执行 使用Browserify---&gt;打包处理----浏览器可以运行 &emsp;&emsp;未完待续…… 👉点这里，跟我聊QQ","categories":[{"name":"js-modularize","slug":"js-modularize","permalink":"https://shulu520.com/categories/js-modularize/"}],"tags":[{"name":"模块化","slug":"模块化","permalink":"https://shulu520.com/tags/模块化/"}]},{"title":"IT-proper-nouns","slug":"IT-专有名词","date":"2019-05-23T14:02:57.000Z","updated":"2019-07-17T03:38:23.052Z","comments":true,"path":"IT/IT-专有名词/","link":"","permalink":"https://shulu520.com/IT/IT-专有名词/","excerpt":"&emsp;&emsp;找到一件可以为之疯狂的事情，是一个人活着最大的意义。 👉来QQ撩我啊","text":"&emsp;&emsp;找到一件可以为之疯狂的事情，是一个人活着最大的意义。 👉来QQ撩我啊 Hack hack是基于开源的程序的基础，对其代码进行增加、删除或者修改、优化，使之在功能上符合新的需求。 api 应用程序接口(Application Programming Interface) cli 命令行界面(Command Line Interface) sdk 软件开发工具包(Software Development Kit) rc 结尾的文件 run control 运行时控制文件 thread 线程 它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 progress 进程是一个“执行中的程序”。 进程是线程的容器。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。 有以下特征 动态性：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。 并发性：任何进程都可以同其他进程一起并发执行 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位； 异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进 结构特征：进程由程序、数据和进程控制块三部分组成。 &emsp;&emsp;未完待续…… 👉点这里，跟我QQ聊天呗","categories":[{"name":"IT","slug":"IT","permalink":"https://shulu520.com/categories/IT/"}],"tags":[]},{"title":"async-fn-note","slug":"async-fn-note","date":"2019-05-20T02:00:01.000Z","updated":"2019-05-20T02:00:01.517Z","comments":true,"path":"uncategorized/async-fn-note/","link":"","permalink":"https://shulu520.com/uncategorized/async-fn-note/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 正文： &emsp;&emsp; write to me by QQ email","categories":[],"tags":[]},{"title":"arrow-js-note","slug":"arrow-js-note","date":"2019-05-19T16:11:45.000Z","updated":"2019-05-21T18:01:18.888Z","comments":true,"path":"arrowjs/arrow-js-note/","link":"","permalink":"https://shulu520.com/arrowjs/arrow-js-note/","excerpt":"&emsp;&emsp;今天是2019年，520，在这特殊的一天我面对的依然是code, but no Object, 我希望有一天能美梦成真——面向对象面向君，不负代码不负卿。","text":"&emsp;&emsp;今天是2019年，520，在这特殊的一天我面对的依然是code, but no Object, 我希望有一天能美梦成真——面向对象面向君，不负代码不负卿。 箭头函数的经典题型 有关 this 1234567891011121314151617181920212223242526272829let obj = &#123; id: 01, say: function () &#123; // 这里的this为obj setTimeout(function () &#123; // 这里是匿名函数的this默认为window console.log(&apos;arrow id:&apos;, this.id); // undifind &#125;, 100); &#125;, sayWithThis: function () &#123; // 这里将this的值当成变量存起来 let that = this; setTimeout(function () &#123; console.log(&apos;arrow id:&apos;, that.id); // 01 &#125;, 100); &#125;, sayWithArrow: function () &#123; // 这里的this为obj setTimeout(() =&gt; &#123; console.log(&apos;arrow id:&apos;, this.id); // 01 &#125;, 100); &#125;, sayWithGlobalArrow: () =&gt; &#123; // 这里的this已经为全局的this了 setTimeout(() =&gt; &#123; console.log(&apos;arrow id:&apos;, this.id); // undifind &#125;, 100); &#125;&#125;; &emsp;&emsp;未完待续…… write to me by QQ email","categories":[{"name":"arrowjs","slug":"arrowjs","permalink":"https://shulu520.com/categories/arrowjs/"}],"tags":[{"name":"arrowjs","slug":"arrowjs","permalink":"https://shulu520.com/tags/arrowjs/"}]},{"title":"git-qa-note","slug":"git-qa-note","date":"2019-05-18T04:11:06.000Z","updated":"2019-05-18T04:20:20.472Z","comments":true,"path":"git/git-qa-note/","link":"","permalink":"https://shulu520.com/git/git-qa-note/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 科学上网之后，git 报错 如下错误： 12345ssh: Could not resolve hostname github.com: Name or service not knownfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 解决方法1、找到本机的 host 文件，一般位置是进入 C:\\Windows\\System32\\drivers\\etc 2、在host文件的最后一行加上，如果之前已经设置过，可以将ip地址更改为最新的正确的ip地址 192.30.255.112 github.com git185.31.16.184 github.global.ssl.fastly.net &emsp;&emsp;遇到后继续补充…… write to me by QQ email","categories":[{"name":"git","slug":"git","permalink":"https://shulu520.com/categories/git/"}],"tags":[{"name":"git-qa","slug":"git-qa","permalink":"https://shulu520.com/tags/git-qa/"}]},{"title":"Array-note","slug":"Array-note","date":"2019-05-17T16:41:04.000Z","updated":"2019-06-23T15:46:35.088Z","comments":true,"path":"Array/Array-note/","link":"","permalink":"https://shulu520.com/Array/Array-note/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; reduce 计算数组成员的个数 123const countOccurrences = (arr,val) =&gt; arr.reduce((a,v) =&gt; (v === val ? a + 1 : a), 0)alert(countOccurrences([1,111,2,2,2,3,4], 2)); // 3 max Math.max.apply(null, arr) Math.max(…arr) &emsp;&emsp;未完待续…… write to me by QQ email","categories":[{"name":"Array","slug":"Array","permalink":"https://shulu520.com/categories/Array/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://shulu520.com/tags/Array/"}]},{"title":"hotkey-vim","slug":"hotkey-vim","date":"2019-05-15T15:34:56.000Z","updated":"2019-06-19T09:03:18.680Z","comments":true,"path":"hotkey/hotkey-vim/","link":"","permalink":"https://shulu520.com/hotkey/hotkey-vim/","excerpt":"&emsp;&emsp;You only live on this earth once.","text":"&emsp;&emsp;You only live on this earth once. vim编辑器 vi 加文件名 进入编辑器页面 按下a 键 进入编辑模式 编辑完成 (在英文输入下)按esc退出编辑模式 按:wq 回车 即可保存并退出 vim 复制/剪切/粘贴/撤销操作 按esc退出编辑模式 按v 键进入视图模式 由方向键控制选中的内容区域 复制 y键 剪贴 d键 粘贴 p键 撤销 在命令行模式下用 :u 撤销最近一次操作 快捷强大的vim 浏览器插件 vim能提升我们的浏览速度, 鼠标比键盘简单, 键盘比鼠标快! 快速向下滚动d 快速向上滚动u 滚动到页面顶部gg 滚动到页面底部G 神技! 快速搜索 (相当于浏览器顶部搜索框), 并在新标签打开 大写的O 关闭页面x 恢复页面X 主动脱离焦点esc 比如按下o搜索退出时按esc shift+/,查看所有快捷键 &emsp;&emsp;未完待续…… write to me by QQ email","categories":[{"name":"hotkey","slug":"hotkey","permalink":"https://shulu520.com/categories/hotkey/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://shulu520.com/tags/vim/"}]},{"title":"nodejs-guigu","slug":"nodejs-guigu","date":"2019-05-14T14:50:21.000Z","updated":"2019-05-27T04:57:45.581Z","comments":true,"path":"node/nodejs-guigu/","link":"","permalink":"https://shulu520.com/node/nodejs-guigu/","excerpt":"&emsp;&emsp;我期待有一天背着背包出现在你的城市。","text":"&emsp;&emsp;我期待有一天背着背包出现在你的城市。 环境变量 小娜 输入 环境变量 进入环境变量/用户变量/path 点开 里面是一条条的文件路劲 可以新建一个文件的路劲 在这里配置了 相当于 声明了一个 类似于 js 中的全局变量 为作用域链的最高层 可以将一些常用的文件或程序的路劲添加到path下 这样我们就可以在任意的位置访问他们了 进程 线程 进程 负责为程序的运行提供必备的环境 工厂的车间 线程 负责执行进程中的程序 车间工人 单线程 一个人干活 多线程 多人合作干一个活 node.js 事件驱动 非阻塞 异步I/O (性能瓶颈阶段) input写入操作 output读操作 版本 奇数为开发版 偶数为稳定版 在Node中，模块分为三类：一类是底层由C++编写的内建模块，一类是Node提供的核心模块；还有一类是用户编写的模块，称为文件模块。node.js 模块化 新建一个js文件就是一个模块 这个模块里面写的代码其实是包在一个函数里面的 即 123456789101112131415funcyion (exports, require, module, _filename, _dirname) &#123; /* 这里是我们写的代码 外面其实包了一层这个函数 默认不可见 可以通过console.log(arguments.callee) 或 console.log(arguments.callee + &quot;&quot;) 将此函数打印出来 该函数执行时传进了5个参数 所以模块里面的代码是局部变量 exports参数 用来将变量或函数暴露到外边 require参数 用来引入外部的模块 module参数 代表模块本身 exports是module的属性 _filename 当前模块的完整路劲 _dirname 当前模块所在文件夹的路劲 */&#125; module.exports 与exports的区别 module.exports == exports true exports 只能使用.的方式向外暴露 若exports = {} 这样向外暴露的话就修改了exports的引用对象 module.exports 既可以通过.的形式 也可以直接赋值 推荐写法 核心模块 由node 提供的模块 node_moudle中的 引入时直接写模块名字 不需要路劲 文件模块 由我们自己创建的模块 引入时添加./或../等路劲 包 package 包实际上就是一个压缩文件 解压以后还原为目录 规范的目录包含以下文件： -package.json 包描述文件 (必须的) 里面不能写注释 -bin 可执行二进制文件 binary 二进制 -lib js代码 library 库 图书馆 -doc 文档 document -test 单元测试 npm 即 (Node Package Manager) node包管理器 commonjs包规范的是一种理论 npm是其中一种实践 对node而言 npm帮助其完成了第三方模块的发布安和依赖 借助npm 使得node与第三方模块之间形成一个生态系统 查看版本 npm version查看相关的版本 或npm -v npm search 包名 搜索包 npm init 在某一文件夹下初始化该文件夹 帮助我们根据提示生成一个package.json的文件 在初始化后的文件夹下 安装搜索的包 并新建一个index.js 入口文件在里面就可以直接引入math模块使用了 npm install 包名 安装 包 或npm i npm remove 或 npm r 删除包 npm install 包名 杠杠save 安装包并添加到依赖中 npm install 下载当前项目所依赖的包 npm install 包名 -g 全局安装包 一般是安装一些工具 如vue-cli cnpm 也可以用 快速 node在使用下载的包时 会沿着作用域链一直往上找直到磁盘根目录找不到则报错 这就解释了某的包在删除之后依然能用的情况 Buffer （缓冲区） 结构和数组很相似 方法也类似 补充了数组方法的不足 Buffer专门存贮二进制数据的 实际上Buffer中的内存不是通过JavaScript分配的，而是在底层通过C++申请的。也就是我们可以直接通过Buffer来创建内存中的空间。 使用buffer无需引入模块 直接使用即可 Buffer.from(str) 将字符串str转为buffer二进制数据 在buffer中存贮的都是二进制数据 但在显示时都是以16进制的形式显示的 二进制 00-255 或 00-ff 计算机 一个0或一个1 称为一位(bit) 8bit = 1byte(字节) 最小单位 中文一个汉字占用三个字节 创建一个制定大小的buffer Buffer.alloc(10) 10字节大小 可通过索引来操作buffer中的元素 Buffer的大小一旦确定 不能再更该 因为存储空间是连续的 性能好 Buffer与字符串间的转换 支持的编码: ASCII、UTF-8、UTF-16LE/UCS-2、Base64、Binary、Hex 字符串转Buffer Buffer.from(str , [encoding]); Buffer转字符串 buf.toString() buf.toString([encoding] , [start] , [end]); 复制缓冲区 buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]]) 对缓冲区切片 buf.slice([start[, end]]) 拼接缓冲区 Buffer.concat(list[, totalLength]) fs (文件系统) 在Node中，与文件系统的交互是非常重要的，服务器的本质就将本地的文件发送给远程的客户端 核心模块 直接引入使用 const fs = require(‘fs’) fs 模块中所有的操作都有两种形式 同步(会阻塞 带sync) 异步(不会阻塞 带回调函数) fs模块中所有的操作都有两种形式可供选择同步和异步 同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码。异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。 打开文件 fs.open(path, flags[, mode], callback) fs.openSync(path, flags[, mode]) 关闭文件 fs.close(fd, callback) fs.closeSync(fd) fs中提供了四种不同的方式将数据写入文件 简单文件写入 同步文件写入 异步文件写入 流式文件写入 同步文件的写入： 1.打开文件 操作方式为定为写 即 var fd = fs.openSync(path, flags) 参数为字符串类型 path即文件的路劲 flags即 r表示读操作 w表示写入操作 通过返回的描述符fd对文件进行各种操作 2.写入内容数据 fs.writeSync(fd, string) fd文件的描述符 需要传入文件的描述符 string要写入的内容 3.关闭文件 考虑性能 fs.closeSync(fd) 异步文件写入 1.打开文件 123456789101112131415161718fs.open(path, flags, function (err, fd) &#123; if (!err) &#123; 2.在这里往文件写入内容 写操作 fs.write(fd, &apos;要异步写入的内容&apos;, function (err) &#123; if (!err) &#123; console.log(&apos;write success&apos;) &#125; fs.close(fd, function (err) &#123; if (!err) &#123; console.log(&apos;close success&apos;) &#125; &#125;) &#125;) console.log(fd) &#125;else&#123; console.log(err) &#125;&#125;) 返回值为 callback的参数 简单文件写入 简单同步文件 fs.write 简单异步文件 123456fs.writeFile(&apos;hello.txt&apos;, &apos;shulu520&apos;, &#123;flag: &apos;a&apos;&#125; function (err) &#123; //flag: &apos;a&apos; 追加文件内容 不会覆盖原来的 如果文件不存在则创建 flag还有好多的模式 if (!err) &#123; console.log(&apos;write success&apos;) &#125; //文件路劲可以是F:\\JSdownload\\npm-test 这种 `但是要变为`F:\\\\JSdownload\\\\npm-test或F:/JSdownload/npm-test&#125;) 同步 异步 简单文件 的写入都不适合大文件爱的写入 易导致内存溢出 性能差 流式文件写入 12345678910111213141516171819202122232425 创建流 var ws = fs.createWriteStream(path) 监听事件 once绑定一次性的事件 ws.once(&apos;open&apos;, function () &#123; console.log(&apos;stream success&apos;) &#125;) ws.once(&apos;close&apos;, function () &#123; console.log(&apos;stream close&apos;) &#125;) 写入内容 大量内容 ws.write(&apos;写入内容1&apos;) ws.write(&apos;写入内容2&apos;) ws.write(&apos;写入内容3&apos;) ws.write(&apos;写入内容4&apos;) …… 关闭流 在流开始的一方结束流 ws.end()``` + fs中提供了四种读取文件的方式 简单文件读取 同步文件读取 异步文件读取 流式文件读取+ 简单文件读取 简单异步文件读取 const fs = require(‘fs’);fs.readFile(‘shulu.jpg’, (err, data) =&gt; { if(!err) { fs.writeFile(‘桌面路劲/lqy.jpg’, data, () =&gt; { if(!err) { console.log(‘文件写入成功 ‘) } }) }})12+ 流式文件读取 适用于大文件 const fs = require(‘fs’);1.创建读取流const rs = fs.createReadStream(‘shulu.jpg’);2.监听流的开启和关闭rs.once(‘open’, () =&gt; { console.log(‘流打开成功了’)})rs.once(‘close’, () =&gt; { console.log(‘流关闭了’)})3.读取数据rs.on(‘data’, (data) =&gt; { console.log(data) //多次分批读取大数据}) pipe 流方法 12 const fs = require(‘fs’);const rs = fs.createReadStream(‘shulu.mp3’);const ws = fs.createWriteStrem(‘lqy.mp3’);rs.pipe(ws); 读取后直接流入 12345678910111213141516171819202122232425262728+ fs 模块其他操作 检查一个文件是否存在+ 列出文件 fs.readdir(path[, options], callback) fs.readdirSync(path[, options])+ 截断文件 fs.truncate(path, len, callback) fs.truncateSync(path, len)+ 建立目录 fs.mkdir(path[, mode], callback) fs.mkdirSync(path[, mode])+ 验证路径是否存在 fs.existsSync(path)+ 获取文件信息 fs.stat(path, callback) fs.statSync(path)+ 删除文件 fs.unlink(path, callback) fs.unlinkSync(path)+ 删除目录 fs.rmdir(path, callback) fs.rmdirSync(path)+ 重命名文件和目录 fs.rename(oldPath, newPath, callback) fs.renameSync(oldPath, newPath)+ 监视文件更改写入 fs.watchFile(filename[, options], listener) const fs = require(‘fs’);const isExists = fs.existsSync(‘shulu.mp3’);console.log(isExists);` &emsp;&emsp;未完待续……&emsp;&emsp;write to me","categories":[{"name":"node","slug":"node","permalink":"https://shulu520.com/categories/node/"}],"tags":[{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"git-guigu-note","slug":"git-guigu-note","date":"2019-05-12T15:21:02.000Z","updated":"2019-05-13T16:05:14.840Z","comments":true,"path":"git/git-guigu-note/","link":"","permalink":"https://shulu520.com/git/git-guigu-note/","excerpt":"&emsp;&emsp;在衰老到来之前，做一件值得做的事情。做这件事不是为了别的，而是为了证明自己是好样的。-《似水流年》","text":"&emsp;&emsp;在衰老到来之前，做一件值得做的事情。做这件事不是为了别的，而是为了证明自己是好样的。-《似水流年》 复制 选中后 Ctrl+ins 即键盘右上角的insert键粘贴 相应的位置 Shift+ins查看git 配置信息cat ~/.gitconfig状态查看 git status 查看工作区、暂存区状态文件内容查看 cat haha.txt添加操作 git add [file_name]git commit -m ‘说明信息’ [file_name]创建文件 touch haha.txt 或 vim good.txt 字母ll 列出本地库所有文件和文件总数，创建日期 时间 创建人 文件名 git add haha.txt 后 若想返回add前的状态 根据提示 git rm –cached haha.txt 即可返回，此删除只是从暂存区里面删除，工作区的文件还在git commit haha.txt 这里没带-m ‘说明信息’ 回车后会进入vim 编辑器 可以编写大量的说明信息 首先 按a键 进入插入模式，之后就可以进行编辑了。 编辑完了就可以按Esc键退出插入模式，然后输出:wq即可退出vim编辑器，回到git bash界面。 查看提交记录 git log 打印的记录风格： 分散 有作者 邮箱 日期提示，显示内容详细，内容多了，多屏显示控制方式：桥空格为向下翻页，b键为向上翻页，q 键为退出查看 git log –oneline 打印效果为一行 git reflog 打印的记录风格： 紧凑 在一行显示并有提示版本回退数字提示 版本前进后退 基于索引值操作 任意版本穿梭 推荐方法 git reset –hard alfe9cd 这里alfe9cd为某一版本的提交id值即索引值 基于符号 ^ 只能后退 返回上一个版本 git reset –hard HEAD^ 版本倒退三个 git reset –hard HEAD^^^ 基于符号 ~ 只能后退 版本倒退三个 git reset –hard HEAD~3 reset 命令的三个参数对比 –soft 仅仅在本地库移动HEAD指针 –mixed 在本地库移动HEAD指针,重置暂存区 –hard 在本地库移动HEAD指针,重置暂存区,重置工作区，三个区位置保持一致 删除文件 rm aaa.txt git status 显示为 红色 deleted: aaa.txt 提示要add该文件 git add aaa.txt git status 显示为 绿色 表示已添加到暂存区 git commit -m ‘deleted aaa.txt’ 将这次删除操作提交到本地库 删除文件并恢复 前提：删除前 文件的状态提交到了本地库 操作： git reset –hard [指针位置] 删除操作已经提交到本地库：指针位置指向包含删除文件的历史纪录 删除操作尚未提交到本地库：指针位置使用HEAD 比较文件差异 git diff [文件名] 将工作区的文件和暂存区进行比较 git diff [本地库中历史版本] [文件名] 将工作区的文件和本地历史记录比较 git diff 不带文件名 比较多个文件 分支管理 热修复 主分支的bug 更改 分一个 hot_fix 分支 分支的好处： 查看分支 git branch -v 创建分支 git branch hot_fix 切换分支 git checkout hot_fix 切换到这个分支 合并分支 第一步：切换到接受修改的分支(被合并，增加新内容)上 git checkout [接受修改的分支] 第二步：在接受修改的分支上执行命令 git merge [有新内容的分支] 解决合并分支后产生的冲突 分别在两个分支上修改内容 分别提交到本地库 比如都在haha.txt上做修改 将两个分支合并到一个分支上 出现合并冲突 vim haha.txt 查看合并后的状态 HEAD 部分表示当前分支的修改 在一行========之下为另一个分支上做的修改 解决方法： 一：删掉那些特殊符号 并手动将内容修改为满意的状态 期间可能与分支伙伴商量 保存退出 二：git add [文件名] 三：git commit -m &apos;日志说明&apos; 注意：此时commit `一定不能带 文件名` git 原理 哈希算法 明文 加密 得 密文 常见的 md5算法 git 底层 SHA-1算法 github克隆的效果 完整的把远程库克隆到本地 初始化本地库 邀请队员加入 github进入相应的项目 /settings/Collaborators/ 在Search by username 之下 添加成员的github账号名 add collaborator copy invite link 发送给队员（qq或邮箱等方式）等其他方式把邀请链接发送给队员 队员 登录github 后 Accepe invitation 队员拉取操作 pull=fetch+merge git fetch [远程库地址别名] [远程分支名] git merge [远程库地址别名/远程分支名] git pull [远程库地址别名] [远程分支名] 解决冲突 如果不是基于 GitHub 远程库的最新版所做的修改，则不能推送，必须先拉取。 拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即 跨团队协作 外团队人员fork 该项目 git 工作流分支种类 主干分支 master主要负责管理正在运行的生产环境代码。永远保持与正在运行的生产环境完全一致。 开发分支 develop主要负责管理正在开发过程中的代码。一般情况下应该是最新的代码。 bug 修理分支 hotfix主要负责管理生产环境下出现的紧急修复的代码。 从主干分支分出，修理完毕并测试上线后，并回主干分支。并回后，视情况可以删除该分支。 准生产分支（预发布分支） release较大的版本上线前，会从开发分支中分出准生产分支，进行最后阶段的集成测试。该版本上线后，会合并到主干分支。生产环境运行一段阶段较稳定后可以视情况删除。 功能分支 feature为了不影响较短周期的开发工作，一般把中长期开发模块，会从开发分支 中独立出来。 开发完成后会合并到开发分支。&emsp;&emsp;完 更多笔记看git&amp;github.pdf详细笔记","categories":[{"name":"git","slug":"git","permalink":"https://shulu520.com/categories/git/"}],"tags":[{"name":"git-note","slug":"git-note","permalink":"https://shulu520.com/tags/git-note/"}]},{"title":"http","slug":"http","date":"2019-05-06T15:32:22.000Z","updated":"2019-05-06T15:35:32.729Z","comments":true,"path":"http/http/","link":"","permalink":"https://shulu520.com/http/http/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; GET POST 的区别 前提:web浏览器环境下的RFC规范GET 用来获取信息，POST用来发送信息 可见性 安全性 数据大小 编码类型 能否收藏为书签，GET可以 刷新，后退按钮，GET无影响，POST重新提交 能否保留到浏览器历史，GET保留 &emsp;&emsp;","categories":[{"name":"http","slug":"http","permalink":"https://shulu520.com/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"https://shulu520.com/tags/http/"}]},{"title":"net-model","slug":"net-model","date":"2019-05-06T15:28:43.000Z","updated":"2019-05-06T15:30:41.121Z","comments":true,"path":"net/net-model/","link":"","permalink":"https://shulu520.com/net/net-model/","excerpt":"","text":"应用层: 程序，软件，应用层协议，http协议，DNS协议(域名解析)，FTP协议(文件传输协议)，SMTP(邮件传输协议)传输层: 对数据传输的建立和管理，传输层协议，UDP协议(有丢包的可能)，TCP(保证数据的正确性，顺序性)网络层: 好比交通网络，IP协议(IP加端口号来确定一个程序的位置)数据链路层: 两个子层，一个叫逻辑链路控制子层，另一个叫媒体访问控制子层(MAC地址)物理层: 坐公交，扫码骑车。除了五层网络模型之外还有七层网络模型，那么七层网络模型是什么呢？就是将应用层一分为三，分别为：应用层，表示层和会话层。新出来的表示层和会话层没有相应的协议。一般表示层做的是数据格式化，或者加密等操作。","categories":[{"name":"net","slug":"net","permalink":"https://shulu520.com/categories/net/"}],"tags":[]},{"title":"shanjuan","slug":"diary-shanjuan","date":"2019-05-03T06:18:17.000Z","updated":"2019-05-23T16:38:15.996Z","comments":true,"path":"diary/diary-shanjuan/","link":"","permalink":"https://shulu520.com/diary/diary-shanjuan/","excerpt":"&emsp;&emsp;juan，我的好朋友，好久不见，今偶然间，美好的回忆又浮现眼前，于是赶紧记下那些美好。","text":"&emsp;&emsp;juan，我的好朋友，好久不见，今偶然间，美好的回忆又浮现眼前，于是赶紧记下那些美好。 &emsp;&emsp;拿起雪糕想起了你。&emsp;&emsp;雪糕这玩意和辣条一样是我小时候的最爱，只是随着年岁渐长，慢慢留在记忆里了。昨晚室友叫我一起去超市，逛了一圈不知买点啥，看到有人买雪糕，心想，天气热了就买个尝尝吧。打开柜子，拿起雪糕，恍惚间，温暖的记忆又浮现在眼前。&emsp;&emsp;juan，我的高中同学，朋友，那时经常作我的同桌，人美心善，跟同学关系都挺好。当然对我也很好。常给我糖果啊各种小吃的，我用的笔啊书和本子啊经常从juan那直接拿。&emsp;&emsp;我对juan的第一印象：juan是一个可爱的小公主，而且很高洁。机缘巧合之下，我有幸认识了juan，而且常常作同桌。这让我们之间的距离又近了一点。juan是我去到十班最早认识的同学之一。&emsp;&emsp;时间久了，发生过的好多事情我就不记得了。所以我此时此刻在努力的将往事回忆，我生怕等我老了的时候，年轻时的这些美好时光要是再也回想不起来了，那样想想多遗憾啊。&emsp;&emsp;juan对我一直很好，就像对其他人一样。我们除了讨论学习，还聊小时候，聊未来。关于未来，其实都是我在表达对未来的迷惑，而juan一直在开导我。juan说我们可以永远做朋友。&emsp;&emsp;一个雪糕，那是高三时的一天中午你送我的，当时教室里是有其同学的，但是你只送给了我。在高三那个本就燥热的季节，让我清凉了一整个夏天。&emsp;&emsp;如今再拿起雪糕，眼前浮现出都是你对我的好。感谢那时的遇见，让我能有这么美好的回忆。juan，也愿你过得好，有个好对象。要是余生能再见，我想你还是那么的漂亮，那么温柔与大气。&emsp;&emsp;朋友的友谊不是三言两语就道的尽的，但都是埋藏在我的心底里的。 &emsp;&emsp;刚刚看qq空间里你发的说说–有人拿走了你的外卖，🤣🤣🤣","categories":[{"name":"diary","slug":"diary","permalink":"https://shulu520.com/categories/diary/"}],"tags":[]},{"title":"Math-random","slug":"Math-random","date":"2019-04-30T16:50:45.000Z","updated":"2019-05-02T15:02:25.641Z","comments":true,"path":"Math/Math-random/","link":"","permalink":"https://shulu520.com/Math/Math-random/","excerpt":"引言：希望你睡不着时，想起的都是那些让你开心的事 常见的问题：如何生成一个区间[min,max]内的随机整数？答案很简单，即 Math.random()*(max-min)+min 以下是一些其他的方法。","text":"引言：希望你睡不着时，想起的都是那些让你开心的事 常见的问题：如何生成一个区间[min,max]内的随机整数？答案很简单，即 Math.random()*(max-min)+min 以下是一些其他的方法。 new Date() - 0 new Date() 日期函数 默认会显示年月日等字符，new Date() - 0 会得到数字“秒” (new Date() - 0)%2239 ,得到取模数值分之一概率的随机数，即[0,2239]范围内一随机数 toString(指定进制) 方法的调用 与parseInt() 方法一样，进制区间为 [2,36]，取36得字母多一些 随便一个随机数.toString(36)得随机字符，但有数字，且长短不一 随机字符串函数，长度固定，且都是字母 从固定的字典中抽取字符构成随机字符串 12345678910// 在大小写字母之间随机生成 x 个字符function randStr(x)&#123; var s = &apos;&apos;; while(s.length &lt; x &amp;&amp; x &gt; 0)&#123; var r = Math.random(); s += String.fromCharCode(Math.floor(r*26) + (r &gt; 0.5 ? 97 : 65)) &#125;; return s;&#125;;console.log(randStr(3)); //KzE 三个随机字符 颜色随机函数1234function randomColor()&#123; var rand = &apos;#&apos;+(&apos;00000&apos;+(Math.random()*0x1000000&lt;&lt;0).toString(16)).slice(-6); return rand;&#125;; 后记 随机数相关得知识还又有很多，后面学到了再来补充笔记","categories":[{"name":"Math","slug":"Math","permalink":"https://shulu520.com/categories/Math/"}],"tags":[{"name":"random","slug":"random","permalink":"https://shulu520.com/tags/random/"}]},{"title":"git-liao-note","slug":"git-liao-note","date":"2019-04-30T16:50:45.000Z","updated":"2019-05-12T15:32:28.393Z","comments":true,"path":"git/git-liao-note/","link":"","permalink":"https://shulu520.com/git/git-liao-note/","excerpt":"&emsp;&emsp;人是不能闲的，一闲就会想得太多，一闲就会感情泛滥，所谓矫情屁事多，空虚寂寞冷，都是因为懒散寂寞闲。","text":"&emsp;&emsp;人是不能闲的，一闲就会想得太多，一闲就会感情泛滥，所谓矫情屁事多，空虚寂寞冷，都是因为懒散寂寞闲。 git 的优秀之处 它跟踪并管理的是文件的修改，而非文件。Git有不少命令中有“-”，有时候是“-”，有时候是“–”。学过linux的命令行就懂了，单个”-“ 后面跟的是单个字母的参数，如-m， 两个”–”后面跟的是多个字母的参数，如–readme.txt 在大多数情况下成立的。注意:我的博客页面上显示的效果都只有一个’-‘,若’-‘线条显示的比较细，则表示两个’-‘ 创建本地版本库cd 到目录文件夹下mkdir learn-git 新建文件夹，即版本库（repository）git init 初始化版本库,即把这个目录变成git 可以管理的仓库ctrl + l 清屏，以防代码太多看着难受ls 查看目录下的文件ls -a 查看不可见的文件touch git-test.txt 创建 txt文件 或者用vscode编辑器创建，别用windows 自带的记事本，因为记事本在编码方面有弱智的行为，键盘上的上键 返回上一步命令git add git-test.txt 添加要提交的文件，可多次添加多个文件，将文件添加到暂存区（stage即阶段的意思）git commit -m “添加描述内容，如 这是第一次使用commit提交” 可以一次提交多个文件，默认提交到master 分支时光穿梭机git status 查看仓库当前的状态git diff 查看文件的具体修改的内容 输出变化前后的内容git log 显示从最近到最远的提交日志git reset –hard HEAD^ 回退到上一个版本，HEAD表示当前版本，HEAD^即上一个版本，往上100个版本为HEAD~100git reflog 用来记录我们的每一次命令即commit 的idgit reset –hard commit_id commit_id 为某一版本提交的具体ID名词解释说明 工作区： 即我们电脑上的项目文件夹，版本库 ：即工作区里面的一个叫 .git 的隐藏目录，版本库里面有暂存区，有git 为我们创建的master 分支，以及指向master的一个指针HEAD 管理修改 每次修改，如果不用git add 到暂存区，就不会加入到commit 中git checkout – git-test.txt 让这个文件回到最近一次git commit 或 git add 时的状态，注意–是单独的即后面有空格 ，git checkout 使用版本库里面的版本替换工作区的版本 ，无论工作区是修改还是删除，都可以一键还原。 我测试时为什么不行呢cat git-test.txt 查看文件的内容 远程仓库github 上创建一个仓库就行了，最好与本地仓库同名根据提示：将本地仓库与远程仓库关联并推送到远程123…or push an existing repository from the command linegit remote add origin https://github.com/lqyasl/learn-git.git (关联)git push -u origin master (本地推送到远程) 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。一个项目库第一次推送成功后，后面 只要本地做了提交，就可以 git push origin master 不用加参数-u分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了。前面是先有本地仓库，再有远程库。如何关联远程库。现在，最好的方式是，先创建远程库，再从远程库里面克隆到本地。首先在github上创建一个 仓库 并勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。我这里创建了一个gitskills的库。git clone git@github.com:lqyasl/gitskills.git 或 git clone https://github.com/lqyasl/gitskills.git 等多种方式， 推荐使用前一种，其速度最快。cd gitskills 进入克隆的库ls 展开文件列表 可以看到已经有一叫README.md 的文件了分支管理分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 与其他svn 版本控制系统相比， git 超级快。每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点。每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上。从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变。假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并。合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。实战部分git checkout -b dev 创建dev分支，然后切换到dev分支： 这里git checkout命令加上-b参数表示创建一个分支并切换到这个分支。 checkout这里表示切换的意思。git branch 查看当前分支，git branch命令会列出所有分支，当前分支前面会标一个*号。对README.md 文件做修改，比如加一点内容。然后 git add README.md 以及 git commit -m ‘分支测试’ ，我们就可以在dev分支上正常提交现在，dev分支的工作完成，我们就可以切换回master分支 git checkout master现在，我们把dev分支的工作成果合并到master分支上 git merge dev 这里git merge命令用于合并指定分支到当前分支。注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。合并完成后，就可以放心地删除dev分支了。 git branch -d dev因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。gti branch 查看分支，可以看到只剩下一个master主分支了。创建分支与合并小结 Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 解决冲突创建新的feature1分支，继续我们的新分支开发 git checkout -b feature1修改 README.md 文件的内容在feature1分支上提交 git add README.md 以及 git commit -m ‘AND simple’切换到master分支 git checkout masterGit还会自动提示我们当前master分支比远程的master分支要超前1个提交在master分支上把readme.txt文件的最后一行改为：Creating a new branch is quick &amp; simple.提交README.md 文件现在，master分支和feature1分支各自都分别有新的提交这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看 gti merge feature1 结果显示： Automatic merge failed; fix conflicts and then commit the result.果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件修改README.md 并提交 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。最后，删除feature1分支： git branch -d feature1分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。下面我们实战一下–no-ff方式的git merge：首先，仍然创建并切换dev分支：git checkout -b dev## &emsp;&emsp;今晚到此为止，明天再写。","categories":[{"name":"git","slug":"git","permalink":"https://shulu520.com/categories/git/"}],"tags":[{"name":"git-note","slug":"git-note","permalink":"https://shulu520.com/tags/git-note/"}]},{"title":"book-fengchuan","slug":"book-fengchuan","date":"2019-04-30T16:50:45.000Z","updated":"2019-05-19T16:53:54.217Z","comments":true,"path":"book-note/book-fengchuan/","link":"","permalink":"https://shulu520.com/book-note/book-fengchuan/","excerpt":"&emsp;&emsp;深夜时，人会更加容易情绪化，所以无论多难过，都要告诉自己，没有那麽糟糕，睡一觉就好了。","text":"&emsp;&emsp;深夜时，人会更加容易情绪化，所以无论多难过，都要告诉自己，没有那麽糟糕，睡一觉就好了。 相比广告营销，口口相传更有效，分享能让我们感觉良好，因为他会让我们显得高大上。我们更愿意与人分享能提升个人形象的信息。某些产品，思想或行为，经常出现在我们眼前时，他们的影响力和传染力就会大大增加。从古至今，故事一直都是人们分享信息的重要工具。诱因，让人产生联想，看到这个，就会想到那个。打折规则，100元以上，降价多少元，以下为打几折。&emsp;&emsp;那么如何打造-个疯传的产品呢?第一，让你的产品成为一种社交货币，也就是说人们会通过分享它来赢得别人的好感和兴趣;第二，要利用诱因引发消费者的联想;第三，要带动消费者的情绪，让他们不断频繁地分享;第四，让你的产品尽可能出现在大家眼前，让人们不看都不行;第五，记得，简单实用的东西自然会受人欢迎;最后，帮你的产品量身打造一一个足够有意思的故事。&emsp;&emsp;两个可行的建议。首先，可以让你的产品带上点竞争元素。就是说利用人们的游戏心理，大家在玩游戏的时候都喜欢跟别人比赛，获得胜利之后，会得意地和别人分享自己的战绩，同时也就相当于告诉了别人某个产品。所以，如果你的产品有了游戏元素，就能鼓励消费者用你的产品进行某种互动，这样就提高了产品被分享的可能。","categories":[{"name":"book-note","slug":"book-note","permalink":"https://shulu520.com/categories/book-note/"}],"tags":[{"name":"skills","slug":"skills","permalink":"https://shulu520.com/tags/skills/"}]},{"title":"skills-search","slug":"skills-search","date":"2019-04-30T16:50:45.000Z","updated":"2019-05-27T04:49:54.955Z","comments":true,"path":"skills/skills-search/","link":"","permalink":"https://shulu520.com/skills/skills-search/","excerpt":"","text":"口语转变为关键词 关键词之间打上空格 限定在特定网站内 关键词 site:某一站点 注意：站点前不用加www或http 限定文件类型 关键词 filetype:文件格式 限定时间段 关键词 20xx..20xx 注意：中间是两个英文句号 排除某个关键词 关键词 -广告 -推广 将关键词限定在标题中 关键词 intitle:限定内容","categories":[{"name":"skills","slug":"skills","permalink":"https://shulu520.com/categories/skills/"}],"tags":[{"name":"search","slug":"search","permalink":"https://shulu520.com/tags/search/"}]},{"title":"hello","slug":"friends","date":"2019-04-23T15:03:21.000Z","updated":"2020-10-20T15:32:52.982Z","comments":true,"path":"hello/friends/","link":"","permalink":"https://shulu520.com/hello/friends/","excerpt":"","text":"&emsp;&emsp;Everything will be okay in the end. If it’s not okay, it’s not the end. &emsp;&emsp;本站”搭建”之初是为了归纳整理我个人的学习笔记，当时因为学习编程知识，做了大量的乱七八糟的笔记，造成翻阅查找笔记极其困难，后来花了半个月的时间才搭建起来这个小博客网站，整个”搭建”的过程充满挑战与惊喜，原以为可以坚持学习很久的编程之路，却在毕业之际迎来终结。一停下就是大半年之久，经过深思熟虑之后，决定博客还得继续写下去，不再继续学习写代码，而将其作为真正的在线笔记本，记录所有值得记录的内容。&emsp;&emsp;who am i, What kind of person do I want to be ? 我是谁，自己要成为什么样的人？其实，在做自己喜欢做的事情的时候，往往也逐渐让自己成为自己想要成为的那种人。&emsp;&emsp;学习编程又一年，郁闷过，快乐过，最终这条路，我想还是算了吧。付出过很多时间、金钱与精力，当然也有一些小小的收获，算是对前端开发有了一个初步的认识了。前端开发知识面广，框架层出不穷，内容日新月异，业界鱼龙混杂，一个外行人实在难以想象前端这潭水到底有多深。&emsp;&emsp;学习前端，本就源于好奇，走着走着想法就变了，总思考怎样学习前端，如何掌握这门技术，未来能够从事前端开发这个行业，一路上压力山大，知识反复学习，但总是感觉还在原地踏步，难以进阶。放眼未来，迫于无赖，镇定思痛，挥手告别。&emsp;&emsp;一切皆为瞬息，一切都会过去，而那过去了的，终将成为美丽的回忆。那些疯狂敲代码的日子，终将深藏在我的脑海。2019.10.24 夜——常州大学 12345678910111213141516171819 ) ( /+++=)) ((=+++\\ /++++++++// \\\\+++++++++\\ /++++++++++//( /\\ )\\\\++++++++++\\ /+++++++++++// \\\\^^// \\\\+++++++++++\\ _/++++++++++++// &#123;&#123;@::@&#125;&#125; \\\\++++++++++++\\_ /+++++++++++++(( &#123;\\/&#125; ))+++++++++++++\\ /+++++++++++++++\\\\ &lt;**&gt; //+++++++++++++++\\ /+++++++++++++++++\\\\ / VV \\ //+++++++++++++++++\\ /+++++++++++++++++++\\\\/******\\//+++++++++++++++++++\\|+/|++++++++++/\\++++++(***/\\***)++++++/\\++++++++++|\\+\\|/ |+/\\+/\\+/\\/ \\+/\\++\\**|**|**/++/\\+/ \\/\\+/\\+/\\+| \\|v |/ V V V V \\+\\|*|**|*|/+/ V v V V \\| v v /*|*|**|*|*\\... v (**|*|**|*|**). . __\\*|*|**|*|*/__. . (vvv(VVV)(VVV)vvv). . ............../ / 来我QQ撩我哦👇","categories":[{"name":"hello","slug":"hello","permalink":"https://shulu520.com/categories/hello/"}],"tags":[]},{"title":"h5-guigu-music","slug":"h5-guigu-music","date":"2019-04-22T14:19:33.000Z","updated":"2019-05-19T16:59:48.714Z","comments":true,"path":"H5/h5-guigu-music/","link":"","permalink":"https://shulu520.com/H5/h5-guigu-music/","excerpt":"&emsp;&emsp;想去的地方，有你才最美丽。","text":"&emsp;&emsp;想去的地方，有你才最美丽。 第一天 像素 适配 图片加载太慢，后面要用纯文字代替，记得更新 rem最终适配代码 123456;(function()&#123; var styleNode = document.createElement(&quot;style&quot;); var w = document.documentElement.clientWidth/16; styleNode.innerHTML=&quot;html&#123;font-size:&quot;+w+&quot;px!important&#125;&quot; document.head.appendChild(styleNode);&#125;)() 1物理像素的实现 用媒体查询的方法 一般用伪元素来做123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;/&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; #test:before&#123; position: absolute; bottom: 0px; content: &quot;&quot;; display: block; width: 100%; height: 1px; background: black; &#125; @media only screen and (-webkit-device-pixel-ratio:2 ) &#123; #test:before&#123; transform: scaleY(.5); &#125; &#125; @media only screen and (-webkit-device-pixel-ratio:3 ) &#123; #test:before&#123; transform: scaleY(.33333333333); &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 第二天 移动端基础事件 querySelectorAll() 匹配满足选择器的所有元素 改变dom结构后一定得再次获取 1234567891011window.onload=function()&#123; //querySelectorAll:获取静态列表 var itemNodes = document.querySelectorAll(&quot;.item&quot;); // 第一次获取 console.log(itemNodes.length) document.body.innerHTML+=&quot;&lt;div class=&apos;item&apos;&gt;&lt;/div&gt;&quot;; itemNodes = document.querySelectorAll(&quot;.item&quot;); // 改变dom结构后一定得再次获取 console.log(itemNodes) for(var i=0;i&lt;itemNodes.length;i++)&#123; itemNodes[i].style.background=&quot;pink&quot;; &#125;&#125; querySelector 获取 querySelectorAll 匹配到的第一个 触屏事件 监听用 addEventListenerpc端12345678910 touchstart mousedown touchmove mousemove 不可能单独触发 可以单独触发 touchend mouseupwindow.onload=function()&#123; var item = document.querySelector(&quot;.item&quot;); item.addEventListener(&quot;touchstart&quot;,function()&#123; console.log(&quot;touchstart&quot;) &#125;)&#125; 移动端事件默认行为 长按选中，橡皮筋效果（下拉）等 全面禁止事件默认行为 在 touchstart事件上，即手指触摸上去的时候就开始禁止 一上来就这段代码，全面禁止事件默认行为12345678910window.onload=function()&#123; document.addEventListener(&quot;touchstart&quot;,function(ev)&#123; ev=ev||event; ev.preventDefault();&#125;)// 单独按需开启 item.addEventListener(&quot;touchstart&quot;,function(ev)&#123; ev=ev||event; ev.stopPropagation();&#125;) 右键菜单的阻止与开启 与自定义右键 全局阻止右键1234567891011121314151617181920212223242526272829 document.oncontextmenu=function()&#123; return false; &#125;// 单独按需开启浏览器的右键菜单 var inner = document.querySelector(&quot;#inner&quot;); inner.oncontextmenu=function(ev)&#123; ev.stopPropagation();&#125;// 也可以自定义右键菜单window.onload=function()&#123; document.oncontextmenu=function(ev)&#123; ev = ev||event; var x = ev.clientX; var y = ev.clientY; var wrap =document.querySelector(&quot;#wrap&quot;); wrap.style.display=&quot;block&quot;; wrap.style.left = x+&quot;px&quot;; wrap.style.top = y+&quot;px&quot;; return false; &#125; // 单击消失 document.onclick=function()&#123; var wrap =document.querySelector(&quot;#wrap&quot;); wrap.style.display=&quot;none&quot;; &#125;&#125; 事件点透 pc端的事件可以在移动端触发 PC端事件有300毫秒延迟 移动端事件不会有延迟 移动端 a 标签跳转方案 并解决误触 123456789101112131415161718192021 // 阻止事件默认行为 document.addEventListener(&quot;touchstart&quot;,function(ev)&#123; ev=ev||event; ev.preventDefault(); &#125;) //移动端a标签的跳转方案 解决误触 var aNodes = document.querySelectorAll(&quot;a&quot;); for(var i=0;i&lt;aNodes.length;i++)&#123; aNodes[i].addEventListener(&quot;touchstart&quot;,function()&#123; this.isMoved=false; &#125;) aNodes[i].addEventListener(&quot;touchmove&quot;,function()&#123; this.isMoved=true; &#125;) aNodes[i].addEventListener(&quot;touchend&quot;,function()&#123; if(!this.isMoved)&#123; location.href=this.href; &#125; &#125;) &#125;&#125; event : //changedTouches: 触发当前事件的手指列表, 最常用//targetTouches: 触发当前事件时元素上的手指列表//touches: 触发当前事件时屏幕上的手指列表常见问题 及解决方法 禁止电话与邮箱,添加标签 1&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no&quot;/&gt; 按需开启 电话与邮箱 12 &lt;a href=&quot;tel:1383838438&quot;&gt;1383838438&lt;/a&gt;&lt;a href=&quot;mailto:2642816105@qq.com&quot;&gt;2642816105&lt;/a&gt; 解决连接按钮高亮问题 1234a &#123; text-decoration:none; // 去下划线 webkit-tap-highlight-color:rgba(0,0,0,0); // 去背景高亮，只需字体高亮&#125; 解决圆角过圆的问题 加属性 webkit-appearance:none 即可 fontboosting 的问题 及显示的字体与设置的大小不一致的现象，加属性 max-height:999999px;即可 无缝华屏 移动端清除浮动：父元素ul元素上加 overflow:hidden 即可 表单：表单高亮：outline:none; 表单内阴影：boder:none; 划屏相关 在谁上面划，即划屏包裹slide-wrapper 划的内容 即slide-content 元素排到一行的方法 浮动 父容器宽度不够会自动换行 另一种技巧 父容器white-space :nowrap; 子元素: display: inline-block;橡皮筋效果 减少每次move 的有效距离，最终的有效距离还是一直在增大 混合 继承 可以单独定义一系列通用的样式，在需要的时候进行调用。从而减少代码的重复 混合：简单 1234567891011121314151617181920&lt;!-- 定义混合 --&gt;.mixin()&#123; &lt;!-- 规则集 --&gt;&#125;&lt;!-- 使用混合 --&gt;#text1&#123; &lt;!-- 相当于将规则集里面的代码cv到这里 --&gt; &lt;!-- 每次使用都是将代码复制到相应位置 --&gt; &lt;!-- 使用几次就有几处相同的代码 --&gt; .mixin();&#125;#text2&#123; .mixin();&#125;#text3&#123; .mixin();&#125;&lt;!-- 多处使用相同的混合 这样写好一点-（手动写）-&gt;#text1,#text2,#text3&#123; .mixin() &#125; 继承：性能好一点 1234567891011121314151617&lt;!-- 定义继承 --&gt;.extend&#123; &lt;!-- 规则集 --&gt;&#125;&lt;!-- 使用继承 --&gt;#text1&#123; &amp;::extend(.extend);&#125;#text2&#123; &amp;::extend(.extend);&#125;#text3&#123; &amp;::extend(.extend);&#125;&lt;!-- 最终编译为 --&gt;#text1,#text2,#text3&#123; &lt;!-- 规则集 ，相当于将规则集里面的代码cv到这里--&gt;&#125;","categories":[{"name":"H5","slug":"H5","permalink":"https://shulu520.com/categories/H5/"}],"tags":[{"name":"H5-note","slug":"H5-note","permalink":"https://shulu520.com/tags/H5-note/"}]},{"title":"markdown-write","slug":"markdown","date":"2019-04-20T14:23:44.000Z","updated":"2020-09-06T06:16:01.407Z","comments":true,"path":"md/markdown/","link":"","permalink":"https://shulu520.com/md/markdown/","excerpt":"故事的开头，多是惊魂一瞥，然后一眼万年。故事的结局，多是渐行渐远，江湖不见。","text":"故事的开头，多是惊魂一瞥，然后一眼万年。故事的结局，多是渐行渐远，江湖不见。 在 xxx.md文件插入html效果 直接写html 即可 内联样式也直接写 这里输入文字，自定义字体大小 这里输入文字，自定义字体颜色这里输入文字，自定义字体背景色这是综合起来的效果 这是综合起来的效果2 首行缩进效果 其中的 &amp;emsp;&amp;emsp; 即缩进两个字最常见 全方大的空白 &amp;emsp;&emsp;&emsp;内容充实的生命就是长久的生命。我们要以行为而不是以时间来衡量生命。 ——小塞涅卡 不断行的空白格&amp;nbsp; &nbsp;以后无论我去哪我都把你带着我看账你帮我打算盘我谈生意你帮我出主意一起把吴家东院发扬光大做到陕西第一天下第一。———那年花开月正圆周莹经典台词 倾斜 单层*示例：倾斜字体 加粗 双层*示例：加粗字体 加粗倾斜 三层*示例：加粗倾斜 删除线 双层~~示例：删除线 单层引用 &gt;加内容 这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容 无序列表 用 - + * 任何一种都可以示例： 无序列表1 无序列表2 无序列表3 表格 : 表头 表头 表头 内容 内容 内容 内容 内容 内容 注：第二行分割表头和内容。-有一个就行，为了对齐，多加了几个 文字默认居左-两边加：表示文字居中-右边加：表示文字居右 代码:单行: javascript vue node ajax 代码块: 、、、.b{ background: red;}、、、 👉有事记得Q我哦","categories":[{"name":"md","slug":"md","permalink":"https://shulu520.com/categories/md/"}],"tags":[]}]}
{"meta":{"title":"梦不成","subtitle":"思念如马-自别离-未停蹄","description":"君子生非异也，善假于物也.","author":"梦不成","url":"https://shulu520.com","root":"/"},"pages":[{"title":"categories","date":"2019-04-20T01:53:24.000Z","updated":"2019-04-20T05:54:52.506Z","comments":true,"path":"categories/index.html","permalink":"https://shulu520.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-04-22T05:41:23.000Z","updated":"2019-04-25T17:02:04.110Z","comments":false,"path":"/404.html","permalink":"https://shulu520.com//404.html","excerpt":"","text":"&lt;!DOCTYPE HTML&gt; L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"model\":{\"scale\":1,\"hHeadPos\":0.5,\"vHeadPos\":0.618,\"jsonPath\":\"/live2dw/assets/shizuku.model.json\"},\"display\":{\"superSample\":2,\"width\":160,\"height\":320,\"position\":\"left\",\"hOffset\":-12,\"vOffset\":-43},\"mobile\":{\"show\":true,\"scale\":0.5},\"react\":{\"opacityDefault\":0.7,\"opacityOnHover\":0.2},\"log\":false,\"tagMode\":false});"},{"title":"","date":"2019-04-22T05:57:10.894Z","updated":"2019-04-22T05:57:10.894Z","comments":true,"path":"404/404.html","permalink":"https://shulu520.com/404/404.html","excerpt":"","text":"L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"model\":{\"scale\":1,\"hHeadPos\":0.5,\"vHeadPos\":0.618,\"jsonPath\":\"/live2dw/assets/shizuku.model.json\"},\"display\":{\"superSample\":2,\"width\":160,\"height\":320,\"position\":\"left\",\"hOffset\":-12,\"vOffset\":-43},\"mobile\":{\"show\":true,\"scale\":0.5},\"react\":{\"opacityDefault\":0.7,\"opacityOnHover\":0.2},\"log\":false,\"tagMode\":false});"},{"title":"guestbook","date":"2019-04-20T10:28:28.000Z","updated":"2019-04-20T10:30:14.977Z","comments":true,"path":"guestbook/index.html","permalink":"https://shulu520.com/guestbook/index.html","excerpt":"","text":""},{"title":"js","date":"2019-04-16T18:00:45.000Z","updated":"2019-04-16T18:00:45.870Z","comments":true,"path":"js/index.html","permalink":"https://shulu520.com/js/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-20T01:52:59.000Z","updated":"2019-04-20T05:55:51.245Z","comments":true,"path":"tags/index.html","permalink":"https://shulu520.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-04-26T10:48:46.313Z","updated":"2019-04-26T10:48:46.313Z","comments":true,"path":"about/js/index.js","permalink":"https://shulu520.com/about/js/index.js","excerpt":"","text":"(function () { var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame; window.requestAnimationFrame = requestAnimationFrame; })(); var canvas = document.getElementById(\"canvas\"), shapeCan = document.createElement(\"canvas\"), ctx = canvas.getContext(\"2d\"), sCtx = shapeCan.getContext(\"2d\"), width = window.innerWidth, height = document.body.offsetHeight, vanishPointY = height / 2, vanishPointX = width / 2, focalLength = 300, angle = 0, angleY = 0, angleX = 0, angleZ = 0, mouseX = 0, mouseY = 0; var settings = { MouseRotation: false, ClockColor: { r: 255, g: 0, b: 0 } } canvas.width = width; canvas.height = height; shapeCan.width = 200; shapeCan.height = 100; sCtx.font = '3em Arial'; /* * Controls the emitter */ function Emitter() { this.particles = []; this.shapeParts = []; this.x = 1; this.y = 1; this.z = 1; this.getShape(); this.startTime = new Date().getTime(); this.checkInterval = 200; } Emitter.prototype.update = function () { var partLen = this.particles.length; if (settings.MouseRotation) { angleX = (mouseY - vanishPointY) * 0.01; angleY = (mouseX - vanishPointX) * 0.01; } else { angleY = Math.sin(angle += 0.01); angleX = Math.sin(angle); angleZ = Math.sin(angle); } // z-sorting this.particles.sort(function (a, b) { return b.z - a.z; }); for (var i = 0; i < partLen; i++) { var particle = this.particles[i]; if (particle) { particle.update(); } } } Emitter.prototype.getShape = function () { var d = new Date(), hour = d.getHours() % 12, min = (d.getMinutes() < 10 ? \"0\" : \"\") + d.getMinutes(), sec = (d.getSeconds() < 10 ? \"0\" : \"\") + d.getSeconds(); sCtx.clearRect(0, 0, shapeCan.width, shapeCan.height); sCtx.fillText(hour + \":\" + min + \":\" + sec, 0, 30); var imageData = sCtx.getImageData(0, 0, shapeCan.width, shapeCan.height).data; for (var i = 0; i < imageData.length; i += 4) { var x = i / 4 % shapeCan.width, y = (i / 4 - x) / shapeCan.width, index = i; if (imageData[i + 3] > 0) { for (var p = 0; p < 4; p++) { if (!this.shapeParts[index + p]) { var particle = new Particle({ x: ((x * 2)) - 200, y: ((y * 2)) - 100, z: 10 }); this.shapeParts[index + p] = particle; this.particles[index + p] = particle; } } } else { for (var p = 0; p < 4; p++) { if (this.shapeParts[index + p]) { this.shapeParts[index + p].explode(); this.shapeParts[index + p] = undefined; } } } } } Emitter.prototype.render = function () { if (new Date().getTime() > this.startTime + this.checkInterval) { this.startTime = new Date().getTime(); this.getShape(); } var imgData = ctx.createImageData(width, height), data = imgData.data, partLen = this.particles.length; for (var i = 0; i < partLen; i++) { var particle = this.particles[i]; if (particle && particle.render && particle.xPos < width && particle.xPos > 0 && particle.yPos > 0 && particle.yPos < height) { for (var w = 0; w < particle.size; w++) { for (var h = 0; h < particle.size; h++) { if (particle.xPos + w < width && particle.xPos + w > 0 && particle.yPos + h > 0 && particle.yPos + h < height) { pData = (~~ (particle.xPos + w) + (~~ (particle.yPos + h) * width)) * 4; data[pData] = settings.ClockColor.r; data[pData + 1] = settings.ClockColor.g; data[pData + 2] = settings.ClockColor.b; data[pData + 3] = particle.color[3]; } } } } else if (particle && !particle.render) { this.particles[i] = undefined; delete particle; } } ctx.putImageData(imgData, 0, 0); } /* * Controls the individual particles */ function Particle(options) { options = options || {}; this.maxDist = 1000; this.x = options.x || (Math.random() * 10) - 5; this.y = options.y || (Math.random() * 10) - 5; this.z = options.z || (Math.random() * 10) - 5; this.startX = this.x; this.startY = this.y; this.startZ = this.z; this.xPos = 0; this.yPos = 0; this.angle = 0; this.vx = 0; this.vy = 0; this.vz = 0; this.color = [255, 0, 0, 255] this.render = true; this.scaler = 2; } Particle.prototype.explode = function () { this.vx = (Math.random() * 30) - 15; this.vy = (Math.random() * 30) - 15; this.vz = (Math.random() * 30) - 15; } Particle.prototype.rotate = function () { var x = this.startX * Math.cos(angleZ) - this.startY * Math.sin(angleZ), y = this.startY * Math.cos(angleZ) + this.startX * Math.sin(angleZ); this.x = x; this.y = y; x = this.startX * Math.cos(angleY) - this.startZ * Math.sin(angleY); var z = this.startZ * Math.cos(angleY) + this.startX * Math.sin(angleY); this.x = x; this.z = z; y = this.startY * Math.cos(angleX) - this.startZ * Math.sin(angleX); z = this.startZ * Math.cos(angleX) + this.startY * Math.sin(angleX); this.y = y; this.z = z; } Particle.prototype.update = function () { this.x = (this.startX += this.vx); this.y = (this.startY += this.vy); this.z = (this.startZ -= this.vz); this.rotate(); this.render = false; if (this.z > -focalLength) { var scale = focalLength / (focalLength + this.z); this.size = scale * this.scaler; this.xPos = vanishPointX + this.x * scale; this.yPos = vanishPointY + this.y * scale; var dx = this.startX - this.x, dy = this.startY - this.y, dz = this.startZ - this.z, dist = Math.sqrt(dx * dx + dy * dy + dz * dz); if (dist < this.maxDist) { this.render = true; } } } function render() { emitter.update(); emitter.render(); requestAnimationFrame(render); } var emitter = new Emitter(); render(); // var gui = new dat.GUI(); // gui.add(settings, 'MouseRotation'); // gui.addColor(settings, 'ClockColor'); document.body.addEventListener(\"mousemove\", function (e) { mouseX = e.clientX; mouseY = e.clientY; }); window.onresize = function () { height = canvas.height = document.body.offsetHeight; width = canvas.width = document.body.offsetWidth; vanishPointY = height / 2; vanishPointX = width / 2; };"},{"title":"","date":"2019-07-25T10:15:02.537Z","updated":"2019-07-25T10:15:02.537Z","comments":true,"path":"about/css/style.css","permalink":"https://shulu520.com/about/css/style.css","excerpt":"","text":"*{ margin: 0;padding: 0; } a{ text-decoration: none; } #beye{ margin-top: 10px; text-align: center; font-size: 55px } body{ width: 100%; height: 100%; overflow: hidden; border: 24px solid transparent; border-image: url(../assets/img/border.png) 80 100 repeat ; background-color: pink; } #box{ height: 180px; margin: 80px auto; line-height: 180px; text-align: center; font-size: 54px; border-radius: 20px; color: red; } canvas { position:absolute; right:0; width:100%; height: 50%; z-index: 999; } #gohome a{ text-decoration: none; color: #fff; font-weight: bold; display: block; width: 100%; height: 100%; text-align: center; } #gohome a:hover{ color:red; } #gohome{ position: absolute; bottom: 15%; left: 50%; z-index: 9999; text-align: center; margin-left:-50px; width: 80px; height: 80px; overflow: hidden; font-size: 18px; line-height: 80px; border-radius: 50%; opacity: 0.4; background-color:rgba(45, 182, 67, 0.9); -webkit-animation: rotate 3s linear infinite; -moz-animation: rotate 3s linear infinite; -o-animation: rotate 3s linear infinite; animation: rotate 3s linear infinite; } @-webkit-keyframes rotate{from{-webkit-transform: rotate(0deg)} to{-webkit-transform: rotate(360deg)} } @-moz-keyframes rotate{from{-moz-transform: rotate(0deg)} to{-moz-transform: rotate(359deg)} } @-o-keyframes rotate{from{-o-transform: rotate(0deg)} to{-o-transform: rotate(359deg)} } @keyframes rotate{from{transform: rotate(0deg)} to{transform: rotate(359deg)} }"},{"title":"","date":"2019-07-25T10:02:07.870Z","updated":"2019-07-25T10:02:07.870Z","comments":true,"path":"love/css/style.css","permalink":"https://shulu520.com/love/css/style.css","excerpt":"","text":"*{margin:0px;padding:0px;} body{ background-color: rgba(153, 205, 50, 0.358); } .heart3d { position: absolute; top: 12%; right: 0; left: 0; margin: auto; width: 100px; height: 160px; transform-origin:centercenter center; transform-style: preserve-3d; animation: spin 15s infinite linear; } #display{ position: absolute; top: 40%; left: 0; right: 0; margin: 0 10%; } .display { background-image: -webkit-linear-gradient(left,rgb(13, 13, 216),#66ffff 10%,#cc00ff 20%,#CC00CC 30%, #CCCCFF 40%, #00FFFF 50%,#CCCCFF 60%,#CC00CC 70%,#CC00FF 80%,#66FFFF 90%,rgb(4, 0, 255) 100%); -webkit-text-fill-color: transparent;/* 将字体设置成透明色 */ -webkit-background-clip: text;/* 裁剪背景图，使文字作为裁剪区域向外裁剪 */ -webkit-background-size: 200% 100%; -webkit-animation: masked-animation 5s linear infinite; } @keyframes masked-animation { 0% { background-position: 0 0; } 50% { background-position: -50% 0; } 100% { background-position: -100% 0; } } #gohome a{ text-decoration: none; color: #fff; font-weight: bold; display: block; width: 100%; height: 100%; text-align: center; } #gohome a:hover{ color:red; } #gohome{ /* position: absolute; */ position: fixed; bottom: 10%; left: 50%; text-align: center; margin-left:-50px; width: 80px; height: 80px; overflow: hidden; font-size: 18px; line-height: 80px; border-radius: 50%; opacity: 0.4; background-color:rgba(45, 182, 67, 0.2); -webkit-animation: rotate 3s linear infinite; -moz-animation: rotate 3s linear infinite; -o-animation: rotate 3s linear infinite; animation: rotate 3s linear infinite; } @-webkit-keyframes rotate{from{-webkit-transform: rotate(0deg)} to{-webkit-transform: rotate(360deg)} } @-moz-keyframes rotate{from{-moz-transform: rotate(0deg)} to{-moz-transform: rotate(359deg)} } @-o-keyframes rotate{from{-o-transform: rotate(0deg)} to{-o-transform: rotate(359deg)} } @keyframes rotate{from{transform: rotate(0deg)} to{transform: rotate(359deg)} } .heart3d [class^=\"rib\"] { position: absolute; width: 100px; height: 160px; border: solid #f22613; border-width: 1px 1px 00; border-radius: 50% 50% 0 /40% 50% 0; } .heart3d [class$=\"1\"] { transform: rotateY(10deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"2\"] { transform: rotateY(20deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"3\"] { transform: rotateY(30deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"4\"] { transform: rotateY(40deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"5\"] { transform: rotateY(50deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"6\"] { transform: rotateY(60deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"7\"] { transform: rotateY(70deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"8\"] { transform: rotateY(80deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"9\"] { transform: rotateY(90deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"10\"] { transform: rotateY(100deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"11\"] { transform: rotateY(110deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"12\"] { transform: rotateY(120deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"13\"] { transform: rotateY(130deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"14\"] { transform: rotateY(140deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"15\"] { transform: rotateY(150deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"16\"] { transform: rotateY(160deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"17\"] { transform: rotateY(170deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"18\"] { transform: rotateY(180deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"19\"] { transform: rotateY(190deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"20\"] { transform: rotateY(200deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"21\"] { transform: rotateY(210deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"22\"] { transform: rotateY(220deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"23\"] { -webkit-transform: rotateY(230deg) rotateZ(45deg) translateX(30px); transform: rotateY(230deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"24\"] { transform: rotateY(240deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"25\"] { transform: rotateY(250deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"26\"] { transform: rotateY(260deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"27\"] { transform: rotateY(270deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"28\"] { transform: rotateY(280deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"29\"] { transform: rotateY(290deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"30\"] { transform: rotateY(300deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"31\"] { transform: rotateY(310deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"32\"] { transform: rotateY(320deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"33\"] { transform: rotateY(330deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"34\"] { transform: rotateY(340deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"35\"] { transform: rotateY(350deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"36\"] { transform: rotateY(360deg) rotateZ(45deg) translateX(30px); } @keyframes spin { to { transform: rotateY(360deg) rotateX(360deg); } } .per{ width:50px;height:50px;position:absolute;top:0;left:0;right:0;bottom:0; margin:auto;transform-style:preserve-3d;perspective:800px; } .img{width:50px;height:50px;position:absolute;backface-visibility:hidden; } .img:nth-child(1){top:-50px;left:0;transform-origin:bottom; transform:translateZ(30px)rotateX(90deg);} .img:nth-child(2){top:50px;left:0;transform-origin:top; transform:translateZ(30px)rotateX(-90deg);} .img:nth-child(3){top:0px;left:-50px;transform-origin:right; transform:translateZ(30px)rotateY(-90deg);} .img:nth-child(4){top:0px;left:50px;transform-origin:left; transform:translateZ(30px)rotateY(90deg);} .img:nth-child(6){top:0px;left:0;transform:translateZ(30px);} .img:nth-child(5){top:0px;left:0;transform:translateZ(0px);} #dance span.dance-content{ float:left; position: relative; top: 10px; left: 35%; margin: 5px; } #dance span.dance-content:nth-child(1){ -webkit-animation:jump 2s linear 0s infinite alternate; } #dance span.dance-content:nth-child(2){ -webkit-animation:jump 2s linear 0.2s infinite alternate; } #dance span.dance-content:nth-child(3){ -webkit-animation:jump 2s linear 0.4s infinite alternate; } #dance span.dance-content:nth-child(4){ -webkit-animation:jump 2s linear 0.3s infinite alternate; } #dance span.dance-content:nth-child(5){ -webkit-animation:jump 2s linear 0.4s infinite alternate; } #dance span.dance-content:nth-child(6){ -webkit-animation:jump 2s linear 0.3s infinite alternate; } #dance span.dance-content:nth-child(7){ -webkit-animation:jump 2s linear 0.4s infinite alternate; } @-webkit-keyframes jump { 0%{ top:0px; color:red; } 10%{ top:-4px; color:#66ffff; } 20%{ top:-8px; color:#cc00ff; } 30%{ top:-12px; color:#CC00CC; } 50%{ top:-16px; color:#00FFFF; } 60%{ top:-12px; color:rgb(105, 108, 255); } 70%{ top:-8px; color:#CC00CC; } 80%{ top:-4px; color:#CC00FF; } 90%{ top:-2px; color:#66FFFF; } 100%{ top:0px; color:rgb(13, 13, 216); } }"},{"title":"","date":"2019-04-28T11:56:26.035Z","updated":"2011-12-29T19:48:15.000Z","comments":true,"path":"about/assets/countdown/jquery.countdown.js","permalink":"https://shulu520.com/about/assets/countdown/jquery.countdown.js","excerpt":"","text":"/** * @name jQuery Countdown Plugin * @author Martin Angelov * @version 1.0 * @url http://tutorialzine.com/2011/12/countdown-jquery/ * @license MIT License */ (function($){ // Number of seconds in every time division var days = 24*60*60, hours = 60*60, minutes = 60; // Creating the plugin $.fn.countdown = function(prop){ var options = $.extend({ callback : function(){}, timestamp : 0 },prop); var left, d, h, m, s, positions; // Initialize the plugin init(this, options); positions = this.find('.position'); (function tick(){ // Time left left = Math.floor((options.timestamp - (new Date())) / 1000); if(left < 0){ left = 0; } // Number of days left d = Math.floor(left / days); updateDuo(0, 1, d); left -= d*days; // Number of hours left h = Math.floor(left / hours); updateDuo(2, 3, h); left -= h*hours; // Number of minutes left m = Math.floor(left / minutes); updateDuo(4, 5, m); left -= m*minutes; // Number of seconds left s = left; updateDuo(6, 7, s); // Calling an optional user supplied callback options.callback(d, h, m, s); // Scheduling another call of this function in 1s setTimeout(tick, 1000); })(); // This function updates two digit positions at once function updateDuo(minor,major,value){ switchDigit(positions.eq(minor),Math.floor(value/10)%10); switchDigit(positions.eq(major),value%10); } return this; }; function init(elem, options){ elem.addClass('countdownHolder'); // Creating the markup inside the container $.each(['Days','Hours','Minutes','Seconds'],function(i){ $('').html( '\\ 0\\ \\ \\ 0\\ ' ).appendTo(elem); if(this!=\"Seconds\"){ elem.append(''); } }); } // Creates an animated transition between the two numbers function switchDigit(position,number){ var digit = position.find('.digit') if(digit.is(':animated')){ return false; } if(position.data('digit') == number){ // We are already showing this number return false; } position.data('digit', number); var replacement = $('',{ 'class':'digit', css:{ top:'-2.1em', opacity:0 }, html:number }); // The .static class is added when the animation // completes. This makes it run smoother. digit .before(replacement) .removeClass('static') .animate({top:'2.5em',opacity:0},'fast',function(){ digit.remove(); }) replacement .delay(100) .animate({top:0,opacity:1},'fast',function(){ replacement.addClass('static'); }); } })(jQuery);"},{"title":"","date":"2019-04-28T13:14:54.512Z","updated":"2019-04-28T13:14:54.512Z","comments":true,"path":"about/assets/js/script.js","permalink":"https://shulu520.com/about/assets/js/script.js","excerpt":"","text":"$(function(){ var note = $('#note'), // ts = new Date(2012, 0, 1), ts = new Date(2020,6,15); newYear = true; if((new Date()) > ts){ // The new year is here! Count towards something else. // Notice the *1000 at the end - time must be in milliseconds ts = (new Date()).getTime() + 10*24*60*60*1000; newYear = false; } $('#countdown').countdown({ timestamp : ts, callback : function(days, hours, minutes, seconds){ var message = \"\"; message += days + \" day\" + ( days==1 ? '':'s' ) + \", \"; message += hours + \" hour\" + ( hours==1 ? '':'s' ) + \", \"; message += minutes + \" minute\" + ( minutes==1 ? '':'s' ) + \" and \"; message += seconds + \" second\" + ( seconds==1 ? '':'s' ) + \" \"; if(newYear){ message += \"left until the new year!\"; } else { message += \"left to 10 days from now!\"; } note.html(message); } }); });"},{"title":"","date":"2019-04-28T11:56:26.010Z","updated":"2011-12-29T19:39:44.000Z","comments":true,"path":"about/assets/countdown/jquery.countdown.css","permalink":"https://shulu520.com/about/assets/countdown/jquery.countdown.css","excerpt":"","text":".countdownHolder{ width:450px; margin:0 auto; font: 40px/1.5 'Open Sans Condensed',sans-serif; text-align:center; letter-spacing:-3px; } .position{ display: inline-block; height: 1.6em; overflow: hidden; position: relative; width: 1.05em; } .digit{ position:absolute; display:block; width:1em; background-color:#444; border-radius:0.2em; text-align:center; color:#fff; letter-spacing:-1px; } .digit.static{ box-shadow:1px 1px 1px rgba(4, 4, 4, 0.35); background-image: linear-gradient(bottom, #3A3A3A 50%, #444444 50%); background-image: -o-linear-gradient(bottom, #3A3A3A 50%, #444444 50%); background-image: -moz-linear-gradient(bottom, #3A3A3A 50%, #444444 50%); background-image: -webkit-linear-gradient(bottom, #3A3A3A 50%, #444444 50%); background-image: -ms-linear-gradient(bottom, #3A3A3A 50%, #444444 50%); background-image: -webkit-gradient( linear, left bottom, left top, color-stop(0.5, #3A3A3A), color-stop(0.5, #444444) ); } /** * You can use these classes to hide parts * of the countdown that you don't need. */ .countDays{ /* display:none !important;*/ } .countDiv0{ /* display:none !important;*/ } .countHours{} .countDiv1{} .countMinutes{} .countDiv2{} .countSeconds{} .countDiv{ display:inline-block; width:16px; height:1.6em; position:relative; } .countDiv:before, .countDiv:after{ position:absolute; width:5px; height:5px; background-color:#444; border-radius:50%; left:50%; margin-left:-3px; top:0.5em; box-shadow:1px 1px 1px rgba(4, 4, 4, 0.5); content:''; } .countDiv:after{ top:0.9em; }"},{"title":"","date":"2019-05-02T14:08:55.625Z","updated":"2019-05-02T14:08:55.625Z","comments":true,"path":"about/assets/css/styles.css","permalink":"https://shulu520.com/about/assets/css/styles.css","excerpt":"","text":"/*------------------------- Simple reset --------------------------*/ *{ margin:0; padding:0; } /*------------------------- General Styles --------------------------*/ html{ position:relative; } body{ min-height: 600px; padding: 200px 0 0; font:14px/1.3 'Segoe UI',Arial, sans-serif; } a, a:visited { text-decoration:none; outline:none; color:#54a6de; } a:hover{ text-decoration:underline; } section, footer{ display: block; } /*---------------------------- Main Section -----------------------------*/ #note{ color: #666666; font-size: 12px; margin: 0 auto; padding: 4px; text-align: center; text-shadow: 1px 1px 0 rgba(255, 255, 255, 0.3); width: 400px; } /*---------------------------- The Footer -----------------------------*/ footer{ background-color: #111111; bottom: 0; box-shadow: 0 -1px 2px #111111; height: 45px; left: 0; position: fixed; width: 100%; z-index: 100000; } footer h2{ color: #EEEEEE; font-size: 14px; font-weight: normal; left: 50%; margin-left: -400px; padding: 13px 0 0; position: absolute; width: 540px; } footer h2 i{ font-style:normal; color:#888; } footer a.tzine,a.tzine:visited{ color: #999999; font-size: 12px; left: 50%; margin: 16px 0 0 110px; position: absolute; text-decoration: none; top: 0; } footer a i{ color:#ccc; font-style: normal; } footer a i b{ color:#c92020; font-weight: normal; }"},{"title":"","date":"2019-04-26T09:48:38.162Z","updated":"2014-06-27T06:32:24.438Z","comments":true,"path":"about/js/dat.gui.min.js","permalink":"https://shulu520.com/about/js/dat.gui.min.js","excerpt":"","text":"/** * dat-gui JavaScript Controller Library * http://code.google.com/p/dat-gui * * Copyright 2011 Data Arts Team, Google Creative Lab * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 */ var dat=dat||{};dat.gui=dat.gui||{};dat.utils=dat.utils||{};dat.controllers=dat.controllers||{};dat.dom=dat.dom||{};dat.color=dat.color||{};dat.utils.css=function(){return{load:function(e,a){var a=a||document,c=a.createElement(\"link\");c.type=\"text/css\";c.rel=\"stylesheet\";c.href=e;a.getElementsByTagName(\"head\")[0].appendChild(c)},inject:function(e,a){var a=a||document,c=document.createElement(\"style\");c.type=\"text/css\";c.innerHTML=e;a.getElementsByTagName(\"head\")[0].appendChild(c)}}}(); dat.utils.common=function(){var e=Array.prototype.forEach,a=Array.prototype.slice;return{BREAK:{},extend:function(c){this.each(a.call(arguments,1),function(a){for(var f in a)this.isUndefined(a[f])||(c[f]=a[f])},this);return c},defaults:function(c){this.each(a.call(arguments,1),function(a){for(var f in a)this.isUndefined(c[f])&&(c[f]=a[f])},this);return c},compose:function(){var c=a.call(arguments);return function(){for(var d=a.call(arguments),f=c.length-1;f>=0;f--)d=[c[f].apply(this,d)];return d[0]}}, each:function(a,d,f){if(e&&a.forEach===e)a.forEach(d,f);else if(a.length===a.length+0)for(var b=0,n=a.length;b"}],"posts":[{"title":"H5-Element","slug":"H5-Element","date":"2019-07-29T12:45:36.000Z","updated":"2019-07-29T12:54:40.132Z","comments":true,"path":"H5/H5-Element/","link":"","permalink":"https://shulu520.com/H5/H5-Element/","excerpt":"&emsp;&emsp; HTML5是Web中核心语言HTML的新规范，现在先学习H5的基础部分-H5新元素。","text":"&emsp;&emsp; HTML5是Web中核心语言HTML的新规范，现在先学习H5的基础部分-H5新元素。 先学习HTML常见的元素标签 HTML（英文Hyper Text Markup Language的缩写）中文译为“超文本标签语言”，主要是通过HTML标签对网页中的文本、图片、声音等内容进行描述。 MDN-HTML-Element html标签： 作用所有HTML中标签的一个根节点。 head标签： 作用：用于存放：title,meta,base,style,script,link 注意在head标签中我们必须要设置的标签是title title标签： 作用：让页面拥有一个属于自己的标题。 body标签： 作用：页面在的主体部分，用于存放所有的HTML标签： h系列标题标签 单词缩写:head头部即标题 为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即&lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;和&lt;h6&gt; 注意：h1 标签因为重要，尽量少用, 一般h1都是给logo使用。 p段落标签 单词缩写:paragraph段落 是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。 div span标签 div、span 是没有语义的，是我们网页布局主要的2个盒子。 div 就是division的缩写，分割，分区的意思。 span, 跨度，跨距；范围 img图像标签 单词缩写：image图像 src属性用于指定图像文件的路径和文件名，他是img标签的必需属性。 a链接标签锚点定位 单词缩写:anchor 的缩写 。基本解释 锚, 铁锚. 在HTML中创建超链接非常简单，只需用标签环绕需要被链接的对象即可. 123456789101112131415161718192021222324&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt;href：用于指定链接目标的url地址，当为标签应用href属性时，它就具有了超链接的功能。 Hypertext Reference的缩写。意思是超文本引用target：用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，_blank为在新窗口中打开方式。注意：1.外部链接 需要添加 http:// www.baidu.com2.内部链接 直接链接内部页面名称即可 比如 &lt; a href=&quot;index.html&quot;&gt; 首页 &lt;/a &gt;3.如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=&quot;#&quot;)，表示该链接暂时为一个空链接。4.不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。锚点定位:通过创建锚点链接，用户能够快速定位到目标内容。创建锚点链接分为两步：1.使用href=”#id名“链接文本创建链接文本。2.使用相应的id名标注跳转目标的位置。 注释标签 在HTML中还有一种特殊的标签——注释标签。如果需要在HTML文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。其基本语法格式如下：​ 1&lt;!-- 注释语句 --&gt; 注释内容不会显示在浏览器窗口中，但是作为HTML文档内容的一部分，也会被下载到用户的计算机上，查看源代码时就可以看到。 ul无序列表 无序列表的各个列表项之间没有顺序级别之分，是并列的。 123&lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。&lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。 ol有序列表 所有特性基本与ul 一致。但是实际工作中，较少用 ol . 自定义列表（理解） 定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。 用的还可以： 12345678910&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ...&lt;/dl&gt; Web组件元素 slot 插槽 template HTML内容模板 table表格标签 存在即是合理的。表格的现在还是较为常用的一种标签，但不是用来布局，常见为处理表格式数据。 MDN-table 123456789101112131415161718192021222324252627282930313233创建简单的表格&lt;table&gt; &lt;tr&gt; &lt;th colspan=&quot;3&quot;&gt;表头文本会加粗居中&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;table: 用于定义一个表格。tr: 用于定义表格中的一行，必须嵌套在table标签中，在 table 中包含几对 tr，就有几行表格。td：用于定义表格中的单元格，必须嵌套在tr标签中，一对 tr中包含几对td，就表示该行中有多少列（或多少个单元格）。th: 表头标签,表头一般位于表格的第一行或第一列，其文本加粗居中.注意：1. &lt;tr&gt;&lt;/tr&gt;中只能嵌套&lt;td&gt;&lt;/td&gt;2. &lt;td&gt;&lt;/td&gt;标签，他就像一个容器，可以容纳所有的元素表格结构（了解）在使用表格进行布局时，可以将表格划分为头部、主体和页脚（页脚因为有兼容性问题，此处不在赘述）&lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部。&lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主体。合并单元格跨行合并：rowspan 跨列合并：colspan表格不要纠结于外观，那是CSS 的作用。 form表单标签(掌握) 现实中的表单，类似我们去银行办理信用卡填写的单子。目的是为了收集用户信息。 在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时也需要表单。 在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。 表单控件：包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 提示信息：一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。 表单域：他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 input标签 控件(重点) 表单 &lt;input&gt;类型type,如果未指定此属性，则采用的默认类型为text. 以下为type属性的常见类型： 1234567891011121314151617181920212223242526checkbox： 复选框。使用 checked 属性指示控件是否被选择。file：此控件可以让用户选择文件。使用 accept 属性可以定义控件可以选择的文件类型。password：一个值被遮盖的单行文本字段。使用 maxlength 指定可以输入的值的最大长度 。radio：单选按钮。在同一个”单选按钮组“中，所有单选按钮的 name 属性使用同一个值。reset：用于将表单所内容设置为空的按钮。submit：用于提交表单的按钮。tel: HTML5新类型，tel类型的元素用于让用户输入和编辑电话号码。其中最明显的就是移动浏览器— 特别是在手机上 — 可能会选择提供为输入电话号码而优化的自定义键盘。使用电话号码的特定输入类型也使添加自定义验证和处理电话号码更方便。email输入邮箱格式search搜索框（体现语义化） 全局 &lt;input&gt; 属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152type 要呈现的控件类型.accept 如果该元素的 type 属性的值是file,则该属性表明了服务器端可接受的文件类型；否则它将被忽略。autocomplete HTML5新属性这个属性表示这个控件的值是否可被浏览器自动填充。autofocus HTML5这个布尔属性允许您指定的表单控件在页面加载时具有焦点（自动获得焦点）checked如果该元素的type属性的值为radio或者checkbox,则该布尔属性的存在与否表明了该控件是否是默认选择状态.disabled这个布尔属性表示此表单控件不可用。特别是在禁用的控件中，click 事件将不会被分发 。并且，禁用的控件的值在提交表单时也不会被提交。max HTML5 此项目的最大（数字或日期时间）值，且不得小于其最小值（min属性）值。min HTML5 此项目的最小（数字或日期时间）值，且不得大于其最大值（最大属性）值。minlength 元素值的长度 属性为输入的最小长度;maxlength HTML5 元素值的长度如果 type 的值是text, email, search, password, tel, 或 url，那么这个属性指明了用户最多可以输入的字符个数（按照Unicode编码方式计数）.译者注:ie10+name控件的名称，与表单数据一起提交。pattern HTML5检查控件值的正则表达式.。pattern必须匹配整个值，而不仅仅是某些子集.。使用title属性来描述帮助用户的模式.。当类型属性的值为text, search, tel, url 或 email时，此属性适用，否则将被忽略。译者注:ie10+placeholder HTML5提示用户输入框的作用。required HTML5这个属性指定用户在提交表单之前必须为该元素填充值. multiple 多文件上传，input type=filesize控件的初始大小。可以使用 size 属性来控制输入框的物理大小value控件的初始值. 此属性是可选的.list提供建议值 input 元素造型, 你可以使用各种与颜色相关的属性来设置input元素的样式。与文本输入相关的元素特有的一个不常见的特性是CSS caret-color属性，该属性允许你设置用于绘制文本输入插入符的颜色. input的demo-输入电话号码1234567891011121314151617181920212223242526272829&lt;style&gt; #telNo&#123; caret-color: red; /* 插入光标的颜色 */ &#125; #telNo:invalid+span:after &#123; position: absolute; content: &apos;✖&apos;; padding-left: 5px; color: #8b0000; &#125; #telNo:valid+span:after &#123; position: absolute; content: &apos;✓&apos;; padding-left: 5px; color: #009000; &#125;&lt;/style&gt;&lt;form &gt; &lt;fieldset&gt; //控件组 效果就是一个边框线 &lt;legend&gt;输入电话号码&lt;/legend&gt; //内容相关说明 &lt;label for=&quot;telNo&quot;&gt;Phone number: &lt;/label&gt; &lt;input id=&quot;telNo&quot; size=&quot;12&quot; autofocus name=&quot;telNo&quot; type=&quot;tel&quot; placeholder=&quot;请输入电话号码&quot; maxlength=&quot;11&quot; required list=&quot;defaultTels&quot; pattern=&quot;^(0|86|17951)?(13[0-9]|15[012356789]|166|17[3678]|18[0-9]|14[57])[0-9]&#123;8&#125;$&quot;&gt; &lt;span class=&quot;validity&quot;&gt;&lt;/span&gt; &lt;datalist id=&quot;defaultTels&quot;&gt; //选项建议列表 &lt;option value=&quot;13161122239&quot;&gt; &lt;option value=&quot;15161122239&quot;&gt; &lt;/datalist&gt; &lt;/fieldset&gt;&lt;/form&gt; label标签(理解) label 标签为 input 元素定义标注（标签）。 作用：用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点. 如何绑定元素呢？for 属性规定 label 与哪个表单元素绑定。 123&lt;label for=&quot;male&quot;&gt;Male&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; value=&quot;male&quot;&gt; textarea控件(文本域) 如果需要输入大量的信息.通过textarea控件可以轻松地创建多行文本输入框. 123&lt;textarea cols=&quot;每行中的字符数&quot; rows=&quot;显示的行数&quot;&gt; 文本内容&lt;/textarea&gt; select下拉菜单标签12345&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt;&lt;/select&gt; form表单域 在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。 123&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单名称&quot;&gt; 各种表单控件……&lt;/form&gt; 常用属性： Action 在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址。 method 用于设置表单数据的提交方式，其取值为get或post。 name 用于指定表单的名称，以区分同一个页面中的多个表单。 注意：每个表单都应该有自己表单域。 HTML5 新标签 XHTML属于XML，是HTML进行XML严格化的结果 HTML5不属于XML，比XHTML宽松，比如input属性checked直接写这样就行了,而不用写checked=”checked”。 HTML标签的语义化 所谓标签语义化，就是指标签的含义。 为什么要有语义化标签 方便代码的阅读和维护 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容 使用语义化标签会具有更好地搜索引擎优化 核心：合适的地方给一个最为合理的标签。 语义是否良好： 当我们去掉CSS之后，网页结构依然组织有序，并且有良好的可读性。 不管是谁都能看懂这块内容是什么。 遵循的原则：先确定语义的HTML ，再选合适的CSS。 HTML5样式标签 em 语义化的标签表强调，而i标签是纯样式的标签，表斜体，H5不推荐使用，一般用来做图标。 H5常用结构新标签 header：定义文档的页眉 nav：定义导航链接的部分 footer：定义文档或节的页脚 article：标签规定独立的自包含内容 section：定义文档中的节（section、区段） aside：定义其所处内容之外的内容,如广告 article 元素表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。 section 表示文档中的一个区域（或节），比如，内容中的一个专题组，一般来说会有包含一个标题（heading）。一般通过是否包含一个标题 (h1-h6 元素) 作为子节点来辨识每一个section。 audio标签 多媒体 用于在文档中表示音频内容。 autoplay 自动播放 controls 是否显不默认播放控件 loop 循环播放 更多关于audio的内容查看本博客H5-audio专栏部分。 video标签 多媒体 HTML5通过video标签来解决音频播放的问题。 autoplay 自动播放 controls 是否显示默认播放控件 loop 循环播放 width 设置播放窗口宽度 height 设置播放窗口的高度 更多关于video的内容查看本博客H5-video专栏部分。 有事您Q我👇","categories":[{"name":"H5","slug":"H5","permalink":"https://shulu520.com/categories/H5/"}],"tags":[{"name":"element","slug":"element","permalink":"https://shulu520.com/tags/element/"}]},{"title":"browser-core","slug":"browser-core","date":"2019-07-28T13:15:31.000Z","updated":"2019-07-28T14:17:27.294Z","comments":true,"path":"browser/browser-core/","link":"","permalink":"https://shulu520.com/browser/browser-core/","excerpt":"&emsp;&emsp;了解主流浏览器的核心-内核，为了应付面试，也有助于我们在不同内核的浏览器中测试网页的渲染效果。","text":"&emsp;&emsp;了解主流浏览器的核心-内核，为了应付面试，也有助于我们在不同内核的浏览器中测试网页的渲染效果。 browser主流浏览器及其内核 浏览器内核是浏览器的核心，也称“渲染引擎”，用来解释网页语法并渲染到网页上。 浏览器内核决定了浏览器该如何显示网页内容以及页面的格式信息。 不同的浏览器内核对网页的语法解释也不同，因此网页开发者需要在不同内核的浏览器中测试网页的渲染效果。 browser国际市场 1994年诞生IE浏览器； IE浏览器内核：Trident内核，也是俗称的IE内核； 1995年诞生Opera浏览器； Opera浏览器内核：最初是自己的Presto内核，后来加入谷歌大军，从Webkit又到了Blink内核； 2003年诞生Safari浏览器； Safari浏览器内核：Webkit内核； 2004年诞生Firefox浏览器； Firefox浏览器内核：Gecko内核，俗称Firefox内核； 2008年诞生Chrome浏览器； Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，2013年以后到现在是Blink内核； browser国内市场 360浏览器、 猎豹浏览器内核：IE+Chrome双内核； 搜狗、 遨游、 QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）； 百度浏览器、 世界之窗内核：IE内核； 2345浏览器内核：好像以前是IE内核，现在也是IE+Chrome双内核了； UC浏览器内核：这个众口不一，UC说是他们自己研发的U3内核，但好像还是基于Webkit和Trident，还有说是基于火狐内核。 移动端的浏览器内核 移动端的浏览器内核主要说的是系统内置浏览器的内核。 目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等。 其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit。 Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink。 Windows Phone 8 系统浏览器内核是 Trident。 browser有关说明 大家的误解，一直认为的chrome内核就是由苹果公司最先选择的算是KHTML引擎的分支-Webkit，这大概是苹果公司至今说不清道不明的伤痛吧~~chromium fork 自开源引擎 webkit，却把 WebKit 的代码梳理得可读性提高很多。 2013年4月3日，谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器内核 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实Blink引擎就是也就是Webkit的分支，就像Webkit是KHTML的分支一样。Blink引擎现在是谷歌公司与Opera Software共同研发。 win10 edge浏览器 EdgeHTML内核; 据有关消息，微软即将发布的新版 Edge 浏览器很可能同时包含谷歌的 Blink 和 自身的Trident两个浏览器内核，方便浏览器给那些为 IE 设计的网站提供向后兼容性。换句话说，就是要把未来的Windows 10默认浏览器替换成只是换了一个皮肤的Chrome。采用Chromium内核的Edge浏览器测试版已经放出了安装包。在用完之后，我最惊叹的一点，就是它能做得多么像是Chrome。这款Edge基本上可以让一个习惯使用Chrome的用户无缝切换，菜单布局，功能设置等等分毫不差。为了做到体验上的完全对接，Edge这一测试版甚至连浏览器标签页一行、后退前进等按钮和地址栏一行和书签栏一行的高度都做到了跟Chrome平齐。 还有在手机微信上内嵌的浏览器，因为它采用QQ浏览器的X5内核，同时因为跟微信深度耦合，并且要调用很多通过微信实现的系统能力，所以出现了有些网页必须专门适配微信的局面。 Web标准（重点） 通过了解以上浏览器的内核不同，我们知道他们工作原理、解析肯定不同，显示就会有差别。通过web标准的约束，尽量使同一套代码在不同的浏览器有相同的结构、表现和行为。 Web 标准的好处 让Web的发展前景更广阔 内容能被更广泛的设备访问 更容易被搜寻引擎搜索 降低网站流量费用 使网站更易于维护 提高页面浏览速度 Web 标准构成 Web标准不是某一个标准，而是由W3C和其他标准化组织制定的一系列标准的集合。 主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。 结构标准：结构用于对网页元素进行整理和分类，主要包括XML和XHTML两个部分。 样式标准：表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS。 行为标准：行为是指网页模型的定义及交互的编写，主要包括DOM和ECMAScript两个部分。 有事您Q我👇","categories":[{"name":"browser","slug":"browser","permalink":"https://shulu520.com/categories/browser/"}],"tags":[{"name":"browser","slug":"browser","permalink":"https://shulu520.com/tags/browser/"}]},{"title":"sass","slug":"css3-sass","date":"2019-07-27T14:41:58.000Z","updated":"2019-07-27T14:49:55.327Z","comments":true,"path":"sass/css3-sass/","link":"","permalink":"https://shulu520.com/sass/css3-sass/","excerpt":"&emsp;&emsp;学习使用css预处理器sass让我们更爽地敲css代码。","text":"&emsp;&emsp;学习使用css预处理器sass让我们更爽地敲css代码。 css预处理器-sass介绍 sass使用ruby语言编写，下载使用有些不方便，使用cnpm成功率高 vscode 下载EasySass运行插件。 注意：下载的是node-sass, sass的文件后缀是.scss 项目是npm init 过的 cnpm install node-sass 编写.scss后缀的文件后，自动会生成对应文件名的.css文件,以及压缩过的对应文件名的.min.css文件 css预处理器的作用 帮助我们更好的组织css代码 提高代码的复用率 提升可维护性 sass嵌套 选择器之间可以嵌套 反映层级和约束 sass变量-$ 复用常用的个别属性 123456789//定义变量$fontSize: 18px;$bgColor: red;//使用变量.child&#123; font-size: $font-size + 2px; background-color: $bgColor; &#125; sass运算 支持加减乘除多种运算。 1font-size: $font-size + 2px; sass混入-Mixin 复用css代码片段 1234567891011121314151617$color: pink;$bgColor: blue;$fontSize: 18px;//定义混入//注意：这里base是一个代码片段的名字@mixin base($color, $h, $bgc, $fontSize)&#123; color: $color; height: $h; background: $bgc; font-size: $fontSize;&#125;//使用混入.wrap&#123; @include base(yellow, 300px, $bgColor, $fontSize)&#125; sass继承-extend 复用css代码片段 生成的样式中，样式片段没有重复 @extend会增加选择器之间的联系，然后把他们堆在一起。 123456789// 一个普通的类就是一个extend.button&#123; color: yellow;&#125;// 使用extendh2&#123; @extend .button;&#125; sass中mixin的优缺点 优点：@mixin主要的优势就是它能够接受参数。 优点：还能直接给@mixin传递样式片段。 缺点：生成的代码会变得肿胀。 sass中extend的优缺点 优点：生成的样式中，样式片段没有重复。 缺点：@extend会增加选择器之间的联系，然后把他们堆在一起。被继承的选择器和继承别人的选择器可能会在样式表的不同位置，这就导致维护困难，放置顺序，或者需要差异化的一些问题。 缺点：@extend命令不够灵活。不能向它传递参数，它原本是啥样就是啥样。 sass中mixin vs extend @mixin和@extend都能帮助你模块化代码，然后更加方便地在样式表中复用一些样式片段。 从结果上看，mixin是直接把代码复制过来，而extend是将有公共样式的选择器提取出来，用分组选择器把他们放在一起。 你可能会问，到底什么时候使用@mixin，什么时候使用@extend? 总结：在大作数情况下@mixin会比@extend更好，但是它们俩都有自己的一席之地。当样式和选择器之间的关系在某些方面比较紧密的时候，使用@extend。除此之外，你可以使用@mixin在任何地方。 sass循环-loop 生成一些复杂有规律的代码片段 123456//直接使用for循环，生成各自宽度的col-1 ~ col-12的css代码片段。@for $i from 1 to 12 &#123; .col-#&#123;$i&#125;&#123; width: 1000px/12*$i; &#125;&#125; sass文件模块化@import123@import &quot;./header&quot;; .scss后缀可以省略@import &quot;./nav&quot;; @import &quot;./footer&quot; sass中css预处理器框架 Compass 提供现成的mixin, 类似js类库，封装常用功能。 有事您Q我👇","categories":[{"name":"sass","slug":"sass","permalink":"https://shulu520.com/categories/sass/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/tags/css3/"},{"name":"sass","slug":"sass","permalink":"https://shulu520.com/tags/sass/"}]},{"title":"less","slug":"css3-less","date":"2019-07-27T14:33:18.000Z","updated":"2019-07-27T14:53:24.854Z","comments":true,"path":"less/css3-less/","link":"","permalink":"https://shulu520.com/less/css3-less/","excerpt":"&emsp;&emsp;学习使用css预处理器less让我们更爽地敲css代码。","text":"&emsp;&emsp;学习使用css预处理器less让我们更爽地敲css代码。 css预处理器-less介绍 less使用nodejs编写，下载使用都方便 vscode 下载EasyLess运行插件。 项目是npm init 过的 npm i less 即可使用 编写.less后缀的文件后，自动会生成对应文件名的.css文件 css预处理器的作用 帮助我们更好的组织css代码 提高代码的复用率 提升可维护性 less嵌套 选择器之间可以嵌套 反映层级和约束 less变量-@ 复用常用的个别属性 123456789//定义变量@font-size: 18px;@bgColor: red; //使用变量.child&#123; font-size: @font-size + 2px; background-color: @bgColor; &#125; less运算 支持加减乘除多种运算。 less混入-Mixin 复用常用的css代码片段 1234567891011121314151617@color: pink;@bgColor: blue;@fontSize: 18px;//定义混入//注意：这里.base是一个类名.base(@color, @h, @bgc, @fontSize)&#123; color: @color; height: @h; background: @bgc; font-size: @fontSize;&#125;//使用混入.wrap&#123; .base(yellow, 300px, @bgColor, @fontSize)&#125; less继承-extend 复用css代码片段 生成的样式中，样式片段没有重复 &amp;:extend()会增加选择器之间的联系，然后把他们堆在一起。 123456789// 一个普通的类就是一个extend.box&#123; color: @color;&#125;// 使用extendh2&#123; &amp;:extend(.box);&#125; less中mixin和extend的优缺点 同sass中的一样，参考sass部分 less循环 生成一些复杂有规律的代码片段 less中没有循环的方法,但是我们可以在mixin中使用递归方法模拟循环。 12345678910//在mixin中使用递归方法模拟循环。.gen-col(@n) when (@n &gt; 0) &#123; .gen-col(@n - 1); .col-@&#123;n&#125; &#123; width: 1000px/12*@n; &#125;&#125;//调用循环，生成各自宽度的col-1 ~ col-12的css代码片段。.gen-col(12); less文件模块化@import123@import &quot;./header&quot;; .less后缀可以省略@import &quot;./nav&quot;; @import &quot;./footer&quot;; less中css预处理器框架 Lesshat EST(百度大牛编写) 提供现成的mixin, 类似js类库，封装常用功能。 EST的介绍使用 est 是一个基于 Less 的样式工具库，帮助您更轻松地书写 Less 代码。 est 提供了一系列方便快捷的 mixin，只在调用时才输出代码。est 不希望提供直接给 HTML 调用的类名，用「样式类」污染 HTML 代码的语义。当然您也可以根据自己的项目需求基于 est 搭建样式类库，提供类名接口来进行快速开发。 官网教程 123456789101112131415161718192021222324252627282930313233使用 Git 获取代码：git clone https://github.com/ecomfe/est.git然后在 Less 代码中引入。@import &quot;est/src/all.less&quot;;官网导航介绍：variables 全局变量设置。normalize 用来归一化不同浏览器下的页面样式。reset 进行全局样式重置。即 .global-reset()shapes 提供绘制基本形状的功能effects 提供预设视觉效果。layout 提供常见的基础布局。grid 帮助生成自定义的栅格布局。 clockhand 提供顺时针简写的功能。typography 文字排版相关功能。util 常用辅助类工具函数。compatibility 提供基础的兼容性封装。// ...your own awesome less code starts here... 有事您Q我👇","categories":[{"name":"less","slug":"less","permalink":"https://shulu520.com/categories/less/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/tags/css3/"},{"name":"less","slug":"less","permalink":"https://shulu520.com/tags/less/"}]},{"title":"css3-BFC","slug":"css3-BFC","date":"2019-07-22T14:18:55.000Z","updated":"2019-07-22T14:25:12.691Z","comments":true,"path":"css3/css3-BFC/","link":"","permalink":"https://shulu520.com/css3/css3-BFC/","excerpt":"&emsp;&emsp;BFC就是页面上的一个独立容器，容器里面的元素不会影响到外面的元素，反之亦然。学习页面布局，css-BFC的知识要重点掌握。","text":"&emsp;&emsp;BFC就是页面上的一个独立容器，容器里面的元素不会影响到外面的元素，反之亦然。学习页面布局，css-BFC的知识要重点掌握。 BFC-块级格式化上下文BFC规则、特性 Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻box的margin会发生重叠 BFC的区域不会与float box的重叠，紧贴着浮动盒子的边缘 计算BFC的高度时，浮动元素也参与计算。 BFC就是页面上的一个独立容器，容器里面的元素不会影响到外面的元素，反之亦然。 块级元素的BFC创立条件 float属性不为none position属性为absolute或fixed display属性为inline-block、table相关、flex overflow属性不为visible(以上最常用的是overflow: hidden, 副作用少) BFC的用途 清除浮动: 这时可以让父元素生成BFC，即解决子因子元素浮动而父级高度塌陷问题 解决外边距合并问题：假设有两个p元素，可以在其中一个p上包裹容器，然后触发其BFC，这样两个p就不在同一个BFC，因此就不会发生重叠 自适应两栏布局: 即左边盒子浮动，右边盒子触发BFC 有事您Q我👇","categories":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/categories/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/tags/css3/"}]},{"title":"css3-flex","slug":"css3-flex","date":"2019-07-18T13:58:53.000Z","updated":"2019-07-19T03:30:43.584Z","comments":true,"path":"css3/css3-flex/","link":"","permalink":"https://shulu520.com/css3/css3-flex/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; flex 规定了弹性元素如何伸长或缩短以适应flex容器中的可用空间。 Flexbox即 Flexible Box Module（弹性盒模型） Flexbox同一时间只能控制行或列中的一个维度。对于二维控制需要 grid网格布局。 主轴 即X轴方向(默认) 侧轴 即Y轴方向(默认) 侧轴垂直于主轴 flex 各个属性父元素-伸缩容器 display: flex; 声明使用伸缩布局 flex-direction: row(默认); 定义了主轴的方向(正方向或反方向)。 1234flex-direction: row; x轴方向flex-direction: row-reverse; -X轴方向flex-direction: column; Y轴方向flex-direction: column-reverse; -Y轴方向 justify-content 主轴上项目的对齐方式。 1234567justify-content: center; 居中排列 justify-content: start; 从行首起始位置开始排列 justify-content: end; 从行尾位置开始排列 justify-content: space-between; 均匀排列每个元素 首个元素放置于起点，末尾元素放置于终点 justify-content: space-around; 均匀排列每个元素 每个元素周围分配相同的空间 justify-content: space-evenly; 均匀排列每个元素 每个元素之间的间隔相等 align-items 侧轴上项目的对齐方式–针对单行即子元素只有一行(不换行) 1234align-items: center; align-items: start;align-items: end; align-items: stretch; 拉伸子元素的高度以适应父元素的高度(子元素不给高度的情况) align-content 侧轴上项目的对齐方式–针对多行即子元素有多行(换行) 12345678align-content: center; 将项目放置在中点 align-content: start; 最先放置项目 align-content: end; 最后放置项目 align-content: space-between; 均匀分布项目 第一项与起始点齐平，最后一项与终止点齐平 align-content: space-around; 均匀分布项目 项目在两端有一半大小的空间align-content: space-evenly; 均匀分布项目 项目周围有相等的空间 align-content: stretch; 均匀分布项目 拉伸‘自动’-大小的项目以充满容器 flex-wrap 是否允许子元素换行显示 123flex-wrap: nowrap; 默认不换行flex-wrap: wrap; 换行flex-wrap: wrap-reverse; 换行并反向显示 12345678910111213141516//demo 水平垂直对齐三条属性就搞定html,body&#123; height: 100%;&#125;body&#123; display: flex; justify-content: center; align-items: center;&#125;#app&#123; width: 300px; height: 300px; background-color: red;&#125;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; flex-flow 简写属性 弹性流 flex-direction 和 flex-wrap 属性的简写 子元素-伸缩项目 flex: 1或2等无单位的数值，表示这个子元素占几份父元素的空间，当然子元素也可以指定宽度。简写属性， 是flex-grow、 flex-shrink 和 flex-basis 的简写。 order: -1或1、2等无单位的数值，表示子元素的排列顺序，数值越小排列越靠前 justify-self: 对齐主轴方向的某个项目 align-self 对齐侧轴方向的单个项目 扩展css属性 min-width: 如500px; 盒子可伸缩最小宽度 max-width: 如1000px; 盒子可伸缩最大宽度 有事您Q我👇","categories":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/categories/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/tags/css3/"}]},{"title":"css3-animation","slug":"css3-animation","date":"2019-07-18T04:34:45.000Z","updated":"2019-07-18T09:35:11.408Z","comments":true,"path":"css3/css3-animation/","link":"","permalink":"https://shulu520.com/css3/css3-animation/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 动画定义 关键帧@keyframes1234567891011@keyframes animiationName&#123; keyframes-selector&#123; css-style; &#125;&#125;animiationName:必写项，定义动画的名称keyframes-selector：必写项，动画持续时间的百分比,两个状态点的时候，可以用from、to,多组动画状态时使用百分比。 from：0% to：100%css-style：css声明 动画使用 animation animation属性是一个简写属性形式: （可以用来描述可动画的属性） 可动画属性的列表：https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties 简写属性animation1234567891011121314animation： animation-name 动画名称 animation-duration 持续时间 animation-timing-function 速度曲线 (同过渡) animation-delay 延时执行 animation-iteration-count 执行次数 animation-direction 动画方向 animation-fill-mode 设置动画在执行之前和之后如何将样式应用于其目标。值forwards可以使其保持最终状态而不是恢复到原始状态(默认) animation-play-state 设置动画状态 running 当前动画正在运行。 paused 当前动画以被停止。 在每个动画定义中，顺序很重要：可以被解析为 的第一个值被分配给animation-duration, 第二个分配给 animation-delay。 无缝滚动 有事您Q我👇","categories":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/categories/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/tags/css3/"},{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"css3-transform","slug":"css3-transform","date":"2019-07-18T04:33:48.000Z","updated":"2019-07-18T04:40:59.724Z","comments":true,"path":"css3/css3-transform/","link":"","permalink":"https://shulu520.com/css3/css3-transform/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; transform transform 属性 , 只对 block 级元素生效！ transform 2D旋转 rotate1234transform:rotate(angle/弧度); 正值:顺时针旋转 rotate(360deg/2Π)负值:逆时针旋转 rotate(-360deg/-2Π)只能设单值。正数表示顺时针旋转，负数表示逆时针旋转 平移 translate12345678910X方向平移:transform: translateX(tx)Y方向平移:transform: translateY(ty) 二维平移：transform: translate(tx[, ty])； 如果ty没有指定，它的值默认为0。 可设单值，也可设双值。正数表示XY轴正向位移，负数为反向位移。设单值表示只X轴位移，Y轴坐标不变，例如transform: translate(100px);等价于transform: translate(100px,0);百分比：translateX(50%) 向右平移自己宽度的一半 拓展-定位的盒子居中对齐-优美写法 定位的盒子居中对齐优美写法 123456789101112131415//样式#app&#123; position: absolute; top: 50%; //父级高度的50% left: 50%; transform: translate(-50%, -50%);//自己宽高的50%，无需手动计算 width: 300px; height: 300px; background-color: deeppink;&#125;//dom结构&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 定位的盒子居中对齐传统写法 1234567891011121314151617181920212223242526272829303132写法一：/* #app&#123; position: absolute; top: 50%; left: 50%; margin-top: -150px; margin-left: -150px; width: 300px; height: 300px; background-color: deeppink;&#125; */写法二：/*#app&#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto; width: 300px; height: 300px; background-color: deeppink;&#125; */ 倾斜 skew123456789101112131415transform:skewX(45deg);X方向倾斜:transform: skewX(angle) skewX(45deg):参数值以deg为单位 代表与y轴之间的角度Y方向倾斜:transform: skewY(angle) skewY(45deg):参数值以deg为单位 代表与x轴之间的角度二维倾斜:transform: skew(ax[, ay]); 如果ay未提供，在Y轴上没有倾斜 skew(45deg,15deg):参数值以deg为单位 第一个参数代表与y轴之间的角度 第二个参数代表与x轴之间的角度 单值时表示只X轴扭曲，Y轴不变，如transform: skew(30deg);等价于 transform: skew(30deg, 0); 考虑到可读性，不推荐用单值，应该用transform: skewX(30deg);。skewY表示只Y轴扭曲，X轴不变 正值:拉正斜杠方向的两个角 负值:拉反斜杠方向的两个角 缩放 scale123456789101112131415transform:scale(2);X方向缩放:transform: scaleX(sx); Y方向缩放:transform: scaleY(sy);二维缩放 :transform: scale(sx[, sy]); (如果sy 未指定，默认认为和sx的值相同) 要缩小请设0.01～0.99之间的值，要放大请设超过1的值。例如缩小一倍可以transform: scale(.5); 放大一倍可以transform: scale(2);如果只想X轴缩放，可以用scaleX(.5)相当于scale(.5, 1)。同理只想Y轴缩放，可以用scaleY(.5)相当于scale(1, .5)正值:缩放的程度负值:不推荐使用（有旋转效果）单值时表示只X轴,Y轴上缩放粒度一样，如transform: scale(2);等价于transform: scale(2,2); 基点的变换 transform-origin transform-origin 属性让你更改一个元素变形的基点。 12345678910 一个值：必须是&lt;length&gt;，&lt;percentage&gt;，或 left, center, right, top, bottom关键字中的一个。 两个值：其中一个必须是&lt;length&gt;，&lt;percentage&gt;，或left, center, right关键字中的一个。另一个必须是&lt;length&gt;，&lt;percentage&gt;，或top, center, bottom关键字中的一个。 三个值：前两个值和只有两个值时的用法相同。第三个值必须是&lt;length&gt;。它始终代表Z轴偏移量。 transform 3D3D缩放1234transform: scaleZ(number)transform: scale3d(scaleX,scaleY,scaleZ); 如果只设置scaleZ(number)，你会发现元素并没有被扩大或压缩，scaleZ(number)需要和translateZ(length)配合使用，number乘以length得到的值，是元素沿Z轴移动的距离，从而使得感觉被扩大或压缩 3D旋转123456789CSS3中的3D旋转主要包括四个功能函数rotateX(angle) rotateY(angle) rotateZ(angle)等价于rotate(angle) rotate3d(x,y,z,angle)x, y, z分别接受一个数值(number),用来计算矢量方向(direction vector)，矢量方向是三维空间中的一条线, 从坐标系原点到x, y, z值确定的那个点，元素围绕这条线旋转angle指定的值 3D平移 translateZ 它不能是百分比 值 12345transform: translateZ(length)是3D Transformaton特有的，其他两个2D中就有translateZ 它不能是百分比 值transform: translate3d(translateX,translateY,translateZ); 景深perspective 景深是指相机对焦点前后相对清晰的成像范围。在光学中，尤其是录影或是摄影，是一个描述在空间中，可以清楚成像的距离范围。虽然透镜只能够将光聚 到某一固定的距离，远离此点则会逐渐模糊，但是在某一段特定的距离内，影像模糊的程度是肉眼无法察觉的，这段距离称之为景深。 简单的理解，景深就是我们的肉眼距离显示器的距离，景深越大，元素离我们越远，效果就不好，在我们CSS3中，perspective用于激活一个3D空间，属性值就是景深大小（默认none无景深） 应用景深的元素称为“舞台元素”，舞台元素的所有后代元素都会受影响，（如果后代元素中也添加了perspective属性，效果会叠加而不是覆盖） perspective、perspective-origin设置在父元素上，对后代元素起作用。 1234567891011transform: perspective(depth);depth的默认值是none，可以设置为一个长度值，这个长度是沿着Z轴距离坐标原点的距离。1000px被认为是个正常值若使用perspective()函数，那么他必须被放置在transform属性的首位，如果放在其他函数之后，则会被忽略perspective: depth;同perspective()函数一样，depth的默认值是none，可以设置为一个长度值，这个长度是沿着Z轴距离坐标原点的距离。他们唯一的区别是，perspective属性是被用于元素的后代元素，而不是元素本身；就是说，为某个元素设置perspective属性后，是对这个元素的子元素起作用，而不是这个元素本身。perspective-origin同perspective属性，也是设置在父元素上，对后代元素起作用。 这个属性来设置你在X, Y轴坐标确定的那个点来看这个元素，Z轴是被perspective属性设置的 1000px被认为是个正常值 若使用perspective()函数，那么他必须被放置在transform属性的首位，如果放在其他函数之后，则会被忽略 perspective属性是设置在容器被作用于后代元素，而不是容器元素本身 backface-visibility 此功能某些浏览器尚在开发中 属性 backface-visibility 指定当元素背面朝向观察者时是否可见。 visible 背面朝向用户时可见。 hidden 背面朝向用户时不可见。 transform-style 此功能某些浏览器尚在开发中 属性 transform-style 设置元素的子元素是位于 3D 空间中还是平面中。 flat 设置元素的子元素位于该元素的平面中。 preserve-3d 指示元素的子元素应位于 3D 空间中。 灭点 指的是立体图形各条边的延伸线所产生的相交点。透视点的消失点 有事您Q我👇","categories":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/categories/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/tags/css3/"},{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"css3-transition","slug":"css3-transition","date":"2019-07-17T03:24:42.000Z","updated":"2019-07-17T03:26:52.242Z","comments":true,"path":"css3/css3-transition/","link":"","permalink":"https://shulu520.com/css3/css3-transition/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 过渡 transition简写属性transition transition是一个简写属性 CSS 过渡 由简写属性 transition 定义是最好的方式，可以避免属性值列表长度不一，节省调试时间 默认值： transition-delay: 0s 属性规定了在过渡效果开始作用之前需要等待的时间。 transition-duration: 0s 属性以秒或毫秒为单位指定过渡动画所需的时间。 transition-property: all 默认值为 all，表示所有可被动画的属性都表现出过渡动画 transition-timing-function: ease 通过这个函数会建立一条加速度曲线，因此在整个transition变化过程中，变化速度可以不断改变 transition-timing-function属性值 ease：（加速然后减速）默认值，ease函数等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0). linear：（匀速），linear 函数等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0). ease-in：(加速)，ease-in 函数等同于贝塞尔曲线(0.42, 0, 1.0, 1.0). ease-out：（减速），ease-out 函数等同于贝塞尔曲线(0, 0, 0.58, 1.0). ease-in-out：（加速然后减速），ease-in-out 函数等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) cubic-bezier： 贝塞尔曲线 step-start：等同于steps(1,start) step-end：等同于steps(1,end) steps(,[,[start|end]]?) 第一个参数：必须为正整数，指定函数的步数 第二个参数：指定每一步的值发生变化的时间点（默认值end） 当属性值的列表长度不一致时 要过渡的属性的个数与对应的给出的时间列表长度不一致时，不够的时候，关于时间的会重复列表，关于transition-timing-function的时候使用的是默认值ease 超出的情况下是会被全部截掉的 检测过渡是否完成–争对属性而言的 当过渡完成时触发一个事件，在符合标准的浏览器下，这个事件是 transitionend, 在 WebKit 下是 webkitTransitionEnd 每一个拥有过渡的属性在其完成过渡时都会触发一次transitionend事件 在transition完成前设置 display: none，事件同样不会被触发 注意 在transition属性中，各个值的书写顺序是很重要的：第一个可以解析为时间的值会被赋值给transition-duration，第二个可以解析为时间的值会被赋值给transition-delay 关于时间要带单位 推荐抒写顺序 过渡时间 过渡样式 过渡形式 延迟时间 兼容性 transition 可以不用厂商前缀，不过鉴于标准刚刚稳定，对于基于 Webkit的浏览器仍然需要厂商前缀。如果想兼容旧版本的浏览器那么也需要厂商前缀（例如Firefox 15 及之前版本, Opera 12 及之前版本) 拓展-贝塞尔曲线 以物理学的角度看：贝塞尔曲线是一条位移时间曲线，其斜率表示速度。 transition: 3s all cubic-bezier(0.445, 0.05, 0.55, 0.95) 0s 有事您Q我👇","categories":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/categories/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/tags/css3/"},{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"css3-new-ui","slug":"css3-new-ui","date":"2019-07-16T14:46:52.000Z","updated":"2019-07-26T08:05:49.862Z","comments":true,"path":"css3/css3-new-ui/","link":"","permalink":"https://shulu520.com/css3/css3-new-ui/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 新增文本样式opacity 透明度，性能高 值为0~1 rgba rgba(0, 0, 0, .5) 颜色表示，a表示透明度 可以实现以前不能实现的样式—背景透明文字不透明 文字阴影 text-shadow: 1px 1px 1px pink, 1px 1px 1px orange; 参数为 x、y轴方向偏移阴影，以及模糊值，颜色 可以叠加阴影，第一个在最上面 浮雕文字 元素模糊123h1&#123; filter: blur(5px)&#125; 模糊背景 文字描边 只有webkit内核才支持：-webkit-text-stroke（准确的来说不能算是css3的东西，但需要大家知道） 123div&#123; -webkit-text-stroke: pink 5px;&#125; 文字排版 direction:控制文字的方向 一定要配合unicode-bidi:bidi-override;来使用 1234div&#123; direction: rtl; 从右向左 unicode-bidi: bidi-override;&#125; 单行文本溢出显示省略号123456// 前提是这个元素不是靠内容撑开的div&#123; white-space: nowrap; 首先不换行 overflow: hidden; 溢出隐藏 text-overflow: ellipsis; 文本显示省略号&#125; 多行文本溢出显示省略号123456789101112131415p&#123; position: relative; height: 40px; 高度为行高的整数倍，防止超出的文字露出 line-height: 20px; overflow: hidden; 溢出隐藏&#125;p:after&#123; 将::after换为:after兼容ie8 content: &quot;...&quot;; position: absolute; right: 0; bottom: 0; padding-left: 40px; background: linear-gradient(to right, transparent, #fff 55%); 添加渐变背景可避免文字只显示一半&#125; 盒模型新增样式 img、input属于行内替换元素。 替换元素就是浏览器根据元素的标签和属性，来决定元素的具体显示内容 替换元素一般有内在尺寸，所以具有width和height，可以设定。 图片居中demo用容器的伪元素给图片做一个兄弟元素(高度=容器的高度，inline-block)，并让他两个基线对齐，就实现了图片的垂直居中 123456789101112131415161718192021//样式#app&#123; width: 500px; height: 500px; border: 1px solid red; text-align: center;&#125;#app::after&#123; content: &quot;&quot;; display: inline-block; height: 100%; vertical-align: middle;&#125;img&#123; vertical-align: middle;&#125;//dom结构&lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./love.gif&quot; alt=&quot;shulu&quot;&gt;&lt;/div&gt; 盒模型阴影 box-shadow box-shadow: 5px 5px 5px 5px pink 即x偏移量 | y偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 可以做不占空间的边框。这个也挺好。 demo 一个元素生成哆啦A梦的图，即是这个元素的多个不同的阴影的叠加效果，配合border-radius，以及前后的两个伪元素。 倒影 -webkit-box-reflect 设置元素的倒影（准确的来说不能算是css3的东西，但需要大家知道） 倒影的方向 第一个值，above, below, right, left 倒影的距离 第二个值，长度单位 渐变 第三个值 123img&#123; -webkit-box-reflect: left&#125; resize 该属性允许你控制一个元素的可调整大小性。 一定要配合overflow：auto使用 both 允许用户在水平和垂直方向上调整元素的大小。 horizontal 水平方向 vertical 垂直方向 1234567#text&#123; width: 100px; height: 100px; background-color: pink; overflow: auto; resize: both;&#125; box-sizing 该属性用于更改用于计算元素宽度和高度的默认的 CSS 盒子模型。可以使用此属性来模拟不正确支持CSS盒子模型规范的浏览器的行为。 box-sizing 属性用于更改用于计算元素宽度和高度的默认的 CSS 盒子模型。可以使用此属性来模拟不正确支持CSS盒子模型规范的浏览器的行/列为。 默认值：content-box 不可继承 1234567content-box默认值，标准盒子模型。 width 与 height 只包括内容的宽和高， 不包括边框（border），内边距（padding），外边距（margin）。注意: 内边距, 边框 &amp; 外边距 都在这个盒子的外部。 比如. 如果 .box &#123;width: 350px&#125;; 而且 &#123;border: 10px solid black;&#125; 那么在浏览器中的渲染的实际宽度将是370px;尺寸计算公式： width = 内容的宽度， height = 内容的高度。 宽度和高度都不包含内容的边框（border）和内边距（padding）。 123456border-boxwidth 和 height 属性包括内容，内边距和边框，但不包括外边距。这是当文档处于 Quirks模式 时Internet Explorer使用的盒模型。这里的维度计算为： width = border + padding + 内容的 width， height = border + padding + 内容的 height。 新增UI样式圆角 border-radius 传统的圆角生成方案，必须使用多张图片作为背景图案 CSS3圆角的出现，使得我们再也不必浪费时间去制作这些图片了，而且还有其他多个优点： 12345678910111213* 减少维护的工作量。图片文件的生成、更新、编写网页代码，这些工作都不再需要了。* 提高网页性能。由于不必再发出多余的HTTP请求，网页的载入速度将变快。* 增加视觉可靠性。某些情况下（网络拥堵、服务器出错、网速过慢等等），背景图片会下载失败，导致视觉效果不佳。CSS3就不会发生这种情况. 注意 百分比值在旧版本的 Chrome 和 Safari 中不支持。(fixed in Sepember 2010)在 11.50 版本以前的 Opera 中实现有问题。Gecko 2.0 (Firefox 4) 版本前实现不标准：水平半轴和垂直半轴都相对于盒子模型的宽度。在旧版本的 iOS (iOS 5 之前) 和 Android 中 (WebKit 532 之前) 不支持。 扩展-绝对定位模拟固定定位 固定定位在ie6以及移动端的兼容性不太好，故需要模拟实现 html,body,#wrap三者的高度都为100%，即都等于文档视口的高度。 默认滚动条在document上，可以设置在一个全局的容器#wrap(高度=视口的高度，overflow: auto)身上 初始包含块：是一个与视窗等大小、等位置的矩形，滚动默认滚动条它会跟着动 body作为父级(没有定位)，绝对定位的元素是相对于这个初始包含块定位的 禁止系统滚动条后，初始包含块便不会再动了 这样绝对定位的元素也不会动了，即模拟了固定定位的效果 demo 123456789101112131415161718192021222324252627282930//样式html,body&#123; height: 100%; /* 禁止系统滚动条 */ overflow: hidden;&#125;#wrap&#123; /* 将滚动条设置到我们的容器上 */ height: 100%; overflow-y: auto;&#125;#app&#123; /* 为了撑开容器看到滚动条 */ height: 3000px;&#125;#red&#123; /* 绝对定位的元素，实现了固定定位的效果 */ position: absolute; top: 0; left: 0; width: 100px; height: 100px; background-color: red;&#125;//dom结构&lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;red&quot;&gt;&lt;/div&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/div&gt; 边框图片 border-image 属性允许在元素的边框上绘制图像。这使得绘制复杂的外观组件更加简单，使用 border-image 时，其将会替换掉 border-style 属性所设置的边框样式如实线solid。 123456border-image-source: url(./love.jpg) 图片border-image-slice: 百分比该属性会通过规范将图片明确的分割为9个区域：四个角，四边以及中心区域。图片见 MDNborder-image-width: 定义图像边框宽度。 border-image-outset: 定义边框图像可超出边框盒的大小border-image-repeat: 定义图片如何填充边框。stretch(拉伸),repeat，round（平铺） css2背景 background-color background-image background-position background-repeat 1234repeat-x repeat-y repeat no-repeat css3背景新增 background-origin设置背景渲染的起始位置 123border-boxpadding-box(默认)content-box background-clip 设置背景裁剪位置 -webkit-background-clip 按文字剪贴背景(文字有透明才行) background-size 设置背景图片大小 background 是CSS简写属性，用来集中设置各种背景属性。 线性渐变-背景图片渐变 background-image: linear-gradient(red,blue); 为了创建一个线性渐变，你需要设置一个起始点和一个方向（指定为一个角度）。你还要定义终止色。终止色就是你想让浏览器去平滑的过渡过去，并且你必须指定至少两种，当然也会可以指定更多的颜色去创建更复杂的渐变效果。 默认从上到下发生渐变 linear-gradient(red,blue); 改变渐变方向：（top bottom left right） linear-gradient(to 结束的方向,red,blue); 使用角度 linear-gradient(角度,red,blue); 颜色节点的分布（第一个不写为0%，最后一个不写为100%） linear-gradient(red 长度或者百分比,blue 长度或者百分比); 重复渐变 repeating-linear-gradient(60deg,red 0,blue 30%); 径向渐变-背景图片渐变 background-image: radial-gradient(red,blue); radial-gradient() 函数创建一个，用来展示由原点（渐变中心）辐射开的颜色渐变 默认均匀分布 radial-gradient(red,blue); 不均匀分布 radial-gradient(red 50%,blue 70%); 改变渐变的形状 radial-gradient(circle ,red,blue) circle ellipse（默认为椭圆） 渐变形状的大小 radial-gradient(closest-corner circle ,red,blue) closest-side 最近边 farthest-side 最远边 closest-corner 最近角 farthest-corner 最远角（默认值） 改变圆心 radial-gradient(closest-corner circle at 10px 10px,red,blue); 剪切元素 clip-path 该属性可以创建一个只有元素的部分区域可以显示的剪切区域。区域内的部分显示，区域外的隐藏。剪切区域是被引用内嵌的URL定义的路径或者外部svg的路径，或者作为一个形状例如circle()。 配合svg实现ios圆角 有事您Q我👇","categories":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/categories/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/tags/css3/"},{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"哲学","slug":"哲学","date":"2019-07-16T05:42:24.000Z","updated":"2019-07-16T05:54:53.370Z","comments":true,"path":"哲学/哲学/","link":"","permalink":"https://shulu520.com/哲学/哲学/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 有事您Q我👇","categories":[{"name":"哲学","slug":"哲学","permalink":"https://shulu520.com/categories/哲学/"}],"tags":[{"name":"philosophy","slug":"philosophy","permalink":"https://shulu520.com/tags/philosophy/"}]},{"title":"电影学","slug":"电影学","date":"2019-07-16T05:42:07.000Z","updated":"2019-07-16T05:49:04.657Z","comments":true,"path":"电影学/电影学/","link":"","permalink":"https://shulu520.com/电影学/电影学/","excerpt":"&emsp;&emsp;人生苦短，我只看经典电影。","text":"&emsp;&emsp;人生苦短，我只看经典电影。 有事您Q我👇","categories":[{"name":"电影学","slug":"电影学","permalink":"https://shulu520.com/categories/电影学/"}],"tags":[{"name":"movie","slug":"movie","permalink":"https://shulu520.com/tags/movie/"}]},{"title":"心理学","slug":"心理学","date":"2019-07-16T05:41:18.000Z","updated":"2019-07-16T05:50:54.744Z","comments":true,"path":"心理学/心理学/","link":"","permalink":"https://shulu520.com/心理学/心理学/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 有事您Q我👇","categories":[{"name":"心理学","slug":"心理学","permalink":"https://shulu520.com/categories/心理学/"}],"tags":[{"name":"psychology","slug":"psychology","permalink":"https://shulu520.com/tags/psychology/"}]},{"title":"生活中的经济学","slug":"经济学","date":"2019-07-16T05:28:58.000Z","updated":"2019-07-16T05:39:58.200Z","comments":true,"path":"经济学/经济学/","link":"","permalink":"https://shulu520.com/经济学/经济学/","excerpt":"&emsp;&emsp;物以稀为贵。","text":"&emsp;&emsp;物以稀为贵。 有事您Q我👇","categories":[{"name":"经济学","slug":"经济学","permalink":"https://shulu520.com/categories/经济学/"}],"tags":[{"name":"economics","slug":"economics","permalink":"https://shulu520.com/tags/economics/"}]},{"title":"css3-font","slug":"css3-font","date":"2019-07-14T07:06:41.000Z","updated":"2019-07-16T14:50:00.248Z","comments":true,"path":"css3/css3-font/","link":"","permalink":"https://shulu520.com/css3/css3-font/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 位图vs矢量图位图 位图图像（bitmap），亦称为点阵图像或栅格图像，是由称作像素（图片元素）的单个点组成的。这些点可以进行不同的排列和染色以构成图样。当放大位图时，可以看见赖以构成整个图像的无数单个方块。扩大位图尺寸的效果是增大单个像素，从而使线条和形状显得参差不齐。然而，如果从稍远的位置观看它，位图图像的颜色和形状又显得是连续的。用数码相机拍摄的照片、扫描仪扫描的图片以及计算机截屏图等都属于位图。位图的特点是可以表现色彩的变化和颜色的细微过渡，产生逼真的效果，缺点是在保存时需要记录每一个像素的位置和颜色值，占用较大的存储空间。常用的位图处理软件有Photoshop（同时也包含矢量功能） 矢量图 矢量图[vector]，也叫做向量图，简单的说，就是缩放不失真的图像格式。矢量图是通过多个对象的组合生成的，对其中的每一个对象的纪录方式，都是以数学函数来实现的，也就是说，矢量图实际上并不是象位图那样纪录画面上每一点的信息，而是纪录了元素形状及颜色的算法，当你打开一付矢量图的时候，软件对图形象对应的函数进行运算，将运算结果[图形的形状和颜色]显示给你看。无论显示画面是大还是小，画面上的对象对应的算法是不变的，所以，即使对画面进行倍数相当大的缩放，其显示效果仍然相同[不失真]。 位图与矢量图的区别 最大的区别，矢量图形与分辨率无关，可以将它缩放到任意大小和以任意分辨率在输出设备上打印出来，都不会影响清晰度，而位图是由一个一个像素点产生，当放大图像时，像素点也放大了，但每个像素点表示的颜色是单一的，所以在位图放大后就会出现咱们平时所见到的马赛克状。 位图表现的色彩比较丰富，可以表现出色彩丰富的图象，可逼真表现自然界各类实物；而矢量图形色彩不丰富，无法表现逼真的实物，矢量图常常用来表示标识、图标、Logo等简单直接的图像。 由于位图表现的色彩比较丰富，所以占用的空间会很大，颜色信息越多，占用空间越大，图像越清晰，占用空间越大；由于矢量图形表现的图像颜色比较单一，所以所占用的空间会很小。 字体图标的好处 图片不但增加了总文件的大小，还增加了很多额外的”http请求”，这都会大大降低网页的性能的。图片还有一个缺点就是不能很好的进行“缩放”，因此，有时候在“响应式设计”中需要使用图像的最好解决方案就是不去使用图片。 很容易任意地缩放； 很容易地改变颜色； 很容易地产生阴影； 可以拥有透明效果； 一般来说，有先进的浏览器支持； 可以使用CSS来装饰（可以得到CSS很好支持）； 可以快速转化形态（做出一些变化，如 :hover等）； 可以做出跟图片一样可以做的事情（改变透明度、旋转度，等）； 本身体积更小，但携带的信息并没有削减。 不用每次修改都还得重新切图替换。 自定义字体1234567891011121314//样式@font-face&#123; font-family: &apos;自定义的名字&apos;; src: url(&apos;../font/字体名称.eot&apos;); src:url(&apos;../font/字体名称.woff&apos;) format(&apos;woff&apos;), url(&apos;../font/字体名称.ttf&apos;) format(&apos;truetype&apos;), url(&apos;../font/字体名称.svg&apos;) format(&apos;svg&apos;);&#125; h1&#123; font-size:36px; color:#ccc; font-family: &quot;自定义的名字&quot;; &#125; 字体图标 字体图标就是运用了css3的自定义字体 有专门的网站可以做字体 常使用阿里巴巴字体图标库 有事您Q我👇","categories":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/categories/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/tags/css3/"},{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"css3-selectors","slug":"css3-selectors","date":"2019-07-14T03:44:38.000Z","updated":"2019-07-16T14:59:29.056Z","comments":true,"path":"css3/css3-selectors/","link":"","permalink":"https://shulu520.com/css3/css3-selectors/","excerpt":"&emsp;&emsp;走到世界尽头。那风从哪里吹来，云又将飘向哪儿，世界的尽头在何方，想知道答案，唯有往前走。","text":"&emsp;&emsp;走到世界尽头。那风从哪里吹来，云又将飘向哪儿，世界的尽头在何方，想知道答案，唯有往前走。 css的全称 Cascading Style Sheets CSS3选择器规范地址：https://www.w3.org/TR/2011/REC-css3-selectors-20110929/ CSS3选择最新选择器规范: https://www.w3.org/TR/selectors 样式表的组成 规则—&gt;选择器+声明块 —&gt;css属性+css属性值组成的键值对 浏览器读取选择器的顺序 从右往左 即从小范围开始找 属性继承：有的属性有继承性有的没有，学习选择器时要注意到这一点 继承：html元素可以从父元素那里继承一部分css属性，即使当前元素没有定义该属性。 比如：color有继承性 而border没有 基本选择器 通配符选择器 * { margin: 0; padding: 0; border: none; } 元素选择器 body { background: #eee; } 类选择器 .list { list-style: square; } ID选择器 #list { width: 500px; margin: 0 auto; } 后代选择器 .list li { margin-top: 10px; background: #abcdef; } 基本选择器扩展 子元素选择器 12#wrap &gt; .inner &#123;color: pink;&#125;也可称为直接后代选择器,此类选择器只能匹配到直接后代，不能匹配到深层次的后代元素 相邻兄弟选择器 12#wrap #first + .inner &#123;color: #f00;&#125;它只会匹配紧跟着的兄弟元素 通用兄弟选择器 12#wrap #first ~ div &#123; border: 1px solid;&#125;它会匹配所有的兄弟元素(不需要紧跟) 选择器分组 12h1,h2,h3&#123;color: pink;&#125; 此处的逗号我们称之为结合符 属性选择器存在和值属性选择器 [attr]：该选择器选择包含 attr 属性的所有元素，不论 attr 的值为何。 [attr=val]：该选择器仅选择 attr 属性被赋值为 val 的所有元素。 [attr~=val]：表示带有以 attr 命名的属性的元素，并且该属性是一个以空格作为分隔的值列表，其中至少一个值为val。 子串值属性选择器 [attr|=val] : 选择attr属性的值是val（包括val）或以val-开头的元素。 [attr^=val] : 选择attr属性的值以val开头（包括val）的元素。 [attr$=val] : 选择attr属性的值以val结尾（包括val）的元素。 [attr*=val] : 选择attr属性的值中包含字符串val的元素。 伪类与伪元素选择器 伪类：其出现是为了拿到元素的一些状态 伪元素：其出现是为了拿到css tree以外的元素 链接伪类 注意:link，:visited，:target是作用于链接元素的！ :link 表示作为超链接，并指向一个未访问的地址的所有锚 :visited 表示作为超链接，并指向一个已访问的地址的所有锚 :target 代表一个特殊的元素，它的id是URI的片段标识符 使用 :target实现最简单的选项卡 demo 123456789101112131415161718192021//样式：div&#123; width: 100px; height: 100px; color: red; background: #ccc; font-size: 33px; display: none;&#125;:target&#123; display: block;&#125;//dom结构&lt;a href=&quot;#div1&quot;&gt;div1&lt;/a&gt;&lt;a href=&quot;#div2&quot;&gt;div2&lt;/a&gt;&lt;a href=&quot;#div3&quot;&gt;div3&lt;/a&gt;&lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt;&lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt; 动态伪类 注意:hover，:active基本可以作用于所有的元素！ :hover 表示悬浮到元素上 :active 表示匹配被用户激活的元素（点击按住时） 由于a标签的:link和:visited可以覆盖了所有a标签的状态， 所以当:link，:visited，:hover，:active同时出现在a标签 身上时 :link和:visited不能放在最后！！！ 隐私与:visited选择器 只有下列的属性才能被应用到已访问链接： color background-color border-color 表单相关伪类 :enabled 匹配可编辑的表单 :disable 匹配被禁用的表单 :checked 匹配被选中的表单 :focus 匹配获焦的表单 demo单选按钮:checked 12345678910111213141516171819202122232425262728293031323334353637//样式：label&#123; position: relative; display: block; width: 100px; height: 100px; border-radius: 50%; overflow: hidden; border: 1px solid &#125;label &gt; span&#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0&#125;input:checked + span&#123; background-color: red;&#125;.float&#123; float: left;&#125;//dom结构&lt;label class=&quot;float&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;love&quot;&gt; &lt;span&gt;&lt;/span&gt;&lt;/label&gt;&lt;label class=&quot;float&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;love&quot;&gt; &lt;span&gt;&lt;/span&gt;&lt;/label&gt;&lt;label class=&quot;float&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;love&quot;&gt; &lt;span&gt;&lt;/span&gt;&lt;/label&gt; 结构性伪类 index的值从1开始计数！！！！ index可以为变量n(只能是n) index可以为even odd .wrap ele:nth-child(index) 表示匹配#wrap中第index的子元素 这个子元素必须是ele .wrap ele:nth-of-type(index) 表示匹配#wrap中第index的ele子元素 除此之外:nth-child和:nth-of-type有一个很重要的区别！！ nth-of-type以元素为中心！！！ :nth-child(index)系列 12345:nth-child(index)系列 :first-child:last-child:nth-last-child(index):only-child (相当于:first-child:last-child 或者 :nth-child(1):nth-last-child(1) :nth-of-type(index)系列 123456789:nth-of-type(index)系列:first-of-type:last-of-type:nth-last-type(index):only-of-type (相当于:first-of-type:last-of-type 或者 :nth-of-type(1):nth-last-of-type(1)``` - :not 非 :not 非面试题：常用来做前后边框div &gt; a:not(:last-of-type){ border-right: 1px solid} 12345678910111213141516171819- :empty(内容必须是空的，有空格都不行，有attr没关系)- :nth-child选择要求相对严格些- :nth-of-type选择要求相对宽松些- 在一个容器中只有一种子元素则二者没什么区别## 伪元素- ::after 常用来清除浮动- ::before- ::firstLetter- ::firstLine- ::selection 鼠标选中后的自定义样式## css声明的优先级### 选择器的特殊性- 选择器的特殊性由选择器本身的组件确定，特殊性值表述为4个部分，如 0,0,0,0- 一个选择器的具体特殊性如下确定： 通配符选择器的特殊性为0,0,0,0对于选择器中的给定的各个元素和伪元素，加0,0,0,1对于选择器中给定的各个类属性，属性选择，或伪类，加 0,0,1,0对于选择器中给定的ID属性值，加 0,1,0,0内联声明的特殊性都是1,0,0,0 结合符对选择器特殊性没有一点贡献继承没有特殊性 123456 - 特殊性 1,0,0,0 大于所有以0开头的特殊性(不进位)- 选择器的特殊性最终都会授予给其对应的声明- 如果多个规则与同一个元素匹配，而且有些声明互相冲突时，特殊性越大的越占优势- **注意：id选择器和属性选择器** div[id=”test”]（0,0,1,1） 和 #test（0,1,0,0） ` 重要声明 !important 有时某个声明比较重要，超过了所有其他声明，css2.1就称之为重要声明 并允许在这些声明的结束分号之前插入 !important 来标志 必须要准确的放置 !important 否则声明无效。 !important 总是要放在声明的最后，即分号的前面 标志为 !important的声明并没有特殊的特殊性值，不过要与非重要声明分开考虑。 实际上所有的重要声明会被浏览器分为一组，重要声明的冲突会在其内部解决 非重要声明也会被分为一组，非重要声明的冲突也会在其内部解决 如果一个重要声明与非重要声明冲突，胜出的总是重要声明 样式继承 继承没有特殊性，甚至连0特殊性都没有 0特殊性要比无特殊性来的强 也就是说通配符选择器的样式比继承来的样式特殊性高 css样式来源 css样式的来源大致有三种 创作人员 读者 用户代理 css样式权重 读者的重要声明 即用户的操作 创作人员的重要声明 即我猿 创作人员的正常声明 读者的正常声明 用户代理的声明 即浏览器 层叠样式表 找出所有相关的规则，这些规则都包含一个选择器 计算声明的优先级 先按来源排序 在按选择器的特殊性排序 最终按顺序 有事您Q我👇","categories":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/categories/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://shulu520.com/tags/css3/"},{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"axios","slug":"axios","date":"2019-07-04T09:57:25.000Z","updated":"2019-07-04T10:02:34.296Z","comments":true,"path":"axios/axios/","link":"","permalink":"https://shulu520.com/axios/axios/","excerpt":"&emsp;&emsp;每一个不曾起舞的日子，都是对生命的一种辜负。","text":"&emsp;&emsp;每一个不曾起舞的日子，都是对生命的一种辜负。 axios 基于promise用于浏览器和node.js的http客户端 特点 支持浏览器和node.js 支持promise 能拦截请求和响应 能转换请求和响应数据 能取消请求 自动转换JSON数据 浏览器端支持防止CSRF(跨站请求伪造) 1npm i axios 12345678910111213141516171819202122/* 发起一个GET请求 */// 可以参数直接拼接axios.get(&apos;/user?ID=12345&apos;) .then((result) =&gt; &#123; console.log(result) &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;)// 或者这样axios.get(&apos;/user&apos;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then((result) =&gt; &#123; console.log(result) &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;) 123456789101112/* 发起一个POST请求 */axios.post(&apos;/user&apos;, &#123; name: &apos;shulu&apos;, age: &apos;18&apos;&#125;).then((result) =&gt; &#123; console.log(result)&#125;).catch((err) =&gt; &#123; console.log(err)&#125;) 1234567/* 同时发起多个请求 */ let sendArr = [axios.get(&apos;/user/123&apos;), axios.get(&apos;/user/123/pions&apos;)]axios.all(sendArr) .then(axios.spread((resA, resB) =&gt; &#123; // 这里就可以拿到响应resA, resB&#125;)) 123456789101112131415/* 一些最最常用的请求配置项 */// 公共 URLaxios.defaults.baseURL = &apos;https://some-domain.com/api/&apos; // 定义POST请求中请求主体向服务器发送内容的格式，这里是项目中常用的格式// 这里似乎有点问题，得再看看axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;// 添加一个响应拦截器// 直接将响应的结果过滤得到我们最想要的data即响应主体数据axios.interceptors.response.use(res =&gt; res.data)// 自定义对HTTP响应状态码的处理axios.defaults.validateStatus = (status =&gt; &#123;……&#125;) 有事您Q我👇","categories":[{"name":"axios","slug":"axios","permalink":"https://shulu520.com/categories/axios/"}],"tags":[]},{"title":"tcp","slug":"tcp","date":"2019-06-25T15:37:04.000Z","updated":"2019-06-25T15:46:44.549Z","comments":true,"path":"tcp/tcp/","link":"","permalink":"https://shulu520.com/tcp/tcp/","excerpt":"&emsp;&emsp;什么时候，我们之间才会握手呢。","text":"&emsp;&emsp;什么时候，我们之间才会握手呢。 tcp 三次握手 我们来聊聊三次握手，我们看到这个问题的时候，第一个疑问是，啥叫握手？俩机器之间怎么还能握手呢？我怎么没发现我家电脑有手？ 第二个疑问是，为啥要三次？两次不行吗？我觉得握一下就行了~为啥要握三次？流氓~那么现在我们有没有清楚为什么不能是两次握手了呢？ 我们假设现在有A 和 B 两个之间要进行通信往来。 第一次握手只能让B知道A能发，第二次握手让A知道了B能收能发，但是这个时候B还不知道A能收，所以A需要发出信息，证明自己收到了B的回复~所以必须要三次才能让两台机器都知道对方能收能发。 tcp四次挥手 以一句话来说明四次挥手的根本目的，四次挥手核心就在于四个时间节点，分别是： A告诉B发完了， B告诉A知道发完了，(接收还需要一段时间的) B告诉A收完了， A告诉B知道收完了。 有事您Q我👇","categories":[{"name":"tcp","slug":"tcp","permalink":"https://shulu520.com/categories/tcp/"}],"tags":[{"name":"net","slug":"net","permalink":"https://shulu520.com/tags/net/"}]},{"title":"js-design-mode-others","slug":"js-design-mode-others","date":"2019-06-25T03:52:31.000Z","updated":"2019-06-25T12:12:40.449Z","comments":true,"path":"js-design-mode/js-design-mode-others/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-others/","excerpt":"","text":"&emsp;&emsp; &lt;!–more– 中介者模式 代码演示 // 执行者(前线士兵)class Receiver { exec() { console.log(‘前线士兵 执行命令’) }} // 命令对象(由鼓手传递 开打开打！！！)class Command { constructor(receiver) { this.receiver = receiver } cmd() { console.log(‘命令对象开始传递 “开打开打！！！”‘) this.receiver.exec() }} // 发布命令者(将军)class Invoker { constructor(command) { this.command = command } invoke() { console.log(‘发布命令: 开打开打！！！’) this.command.cmd() }}// 士兵let soldier = new Receiver()// 鼓手let drummer = new Command(soldier)// 将军let general = new Invoker(drummer)// 将军发布命令general.invoke() ` 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"js-design-mode-prototype","slug":"js-design-mode-prototype","date":"2019-06-24T09:19:51.000Z","updated":"2019-06-24T09:23:34.853Z","comments":true,"path":"js-design-mode/js-design-mode-prototype/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-prototype/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 简单示例123456789101112131415161718192021const prototype = &#123; getName() &#123; return `first-name: $&#123;this.firstName&#125;, last-name: $&#123;this.lastName&#125;` &#125;, say() &#123; console.log(&apos;love you&apos;) &#125;&#125;// 克隆自己，生成一个新的对象// Object.create()用到了原型模式的思想// 基于一个原型创建一个对象let x = Object.create(prototype)x.lastName = &apos;shulu&apos;x.firstName = &apos;lqy love&apos;x.say() //love youconsole.log(&apos;x.getName() :&apos;, x.getName())//打印为 x.getName() : first-name: lqy love, last-name: shulu 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"js-design-mode-state","slug":"js-design-mode-state","date":"2019-06-24T02:24:23.000Z","updated":"2019-06-24T05:53:45.524Z","comments":true,"path":"js-design-mode/js-design-mode-state/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-state/","excerpt":"&emsp;&emsp;莫辜负这仅有一次的人生。","text":"&emsp;&emsp;莫辜负这仅有一次的人生。 状态模式介绍 一个对象有状态变化 每次状态变化都会触发一个逻辑 不能总是用if…else来控制 交通信号灯不同颜色的变化 场景 有限状态机(finite) 有限个状态，以及在这些个状态之间的变化 开源的库 javascript-state-machine 写一个简单的Promise 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// 收藏/取消收藏例子import StateMachine from &apos;javascript-state-machine&apos;// 初始化状态机模型let fsm = new StateMachine(&#123; init: &apos;收藏&apos;, transitions: [ &#123; name: &apos;doStore&apos;, from: &apos;收藏&apos;, to: &apos;取消收藏&apos; &#125;, &#123; name: &apos;deleteStore&apos;, from: &apos;收藏&apos;, to: &apos;取消收藏&apos; &#125; ], methods: &#123; // 监听执行收藏 onDoStore() &#123; console.log(&apos;收藏成功&apos;)// 可以post请求 updateText() &#125;, // 监听取消收藏 onDeleteStore() &#123; console.log(&apos;已经取消收藏&apos;)// 可以post请求 updateText() &#125; &#125;import StateMachine from &apos;javascript-state-machine&apos;// 初始化状态机模型let fsm = new StateMachine(&#123; init: &apos;收藏&apos;, transitions: [ &#123; name: &apos;doStore&apos;, from: &apos;收藏&apos;, to: &apos;取消收藏&apos; &#125;, &#123; name: &apos;deleteStore&apos;, from: &apos;收藏&apos;, to: &apos;取消收藏&apos; &#125; ], methods: &#123; // 监听执行收藏 onDoStore() &#123; console.log(&apos;收藏成功&apos;)// 可以post请求 updateText() &#125;, // 监听取消收藏 onDeleteStore() &#123; console.log(&apos;已经取消收藏&apos;)// 可以post请求 updateText() &#125; &#125;&#125;)// 更新按钮的文案function updateText () &#123; btn.text(fsm.state)&#125;let btn = document.getElementById(&apos;btn&apos;)btn.onclick = function () &#123; if (fsm.is(&apos;收藏&apos;)) &#123; fsm.doStore() //这里的函数名与前面的name对应 &#125; else &#123; fsm.deleteStore() &#125;&#125;// 初始化文案updateText()&#125;)// 更新按钮的文案function updateText () &#123; btn.text(fsm.state)&#125;let btn = document.getElementById(&apos;btn&apos;)btn.onclick = function () &#123; if (fsm.is(&apos;收藏&apos;)) &#123; fsm.doStore() //这里的函数名与前面的name对应 &#125; else &#123; fsm.deleteStore() &#125;&#125;// 初始化文案updateText() 设计原则验证 将状态对象和主题对象分离，状态的变化逻辑单独处理 符合开放封闭原则 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"js-design-mode-iterator","slug":"js-design-mode-iterator","date":"2019-06-23T13:48:55.000Z","updated":"2019-06-23T15:37:43.560Z","comments":true,"path":"js-design-mode/js-design-mode-iterator/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-iterator/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 介绍 顺序访问一个集合 使用者无需知道内部的结构(封装) 菜鸟教程 代码实现(自己写的初级的 后面es6提供的完善的 for of)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 迭代器(遍历器)class Iterator &#123; constructor(container) &#123; this.list = container.list this.index = 0 &#125; next() &#123; if (this.hasNext()) &#123; return this.list[this.index++] &#125; return null &#125; hasNext() &#123; if (this.index &gt;= this.list.length) &#123; return false &#125; return true &#125;&#125;// 迭代器的容器class Container &#123; constructor(list) &#123; this.list = list &#125; getIterator() &#123; return new Iterator(this) &#125;&#125;let arr = [1,2,3,4,5,6]let container = new Container(arr)let iterator = container.getIterator()while (iterator.hasNext()) &#123; console.log(&apos;iterator.next() :&apos;, iterator.next());&#125;/* iterator.next() : 1 iterator.next() : 2 iterator.next() : 3 iterator.next() : 4 iterator.next() : 5 iterator.next() : 6 */ es6 Iterator 有序集合的数据如: Array Map Set String TypedArray arguments Nodelist 以上数据类型，都有[Symbol.iterator]这个属性 属性值是函数，执行函数返回一个迭代器 这个迭代器就有next方法可以顺序迭代子元素 可以运行Array.prototype[Symbol.iterator]来测试 注意 object 不是有序集合 可以用Map代替 for of12345678910111213141516171819202122232425262728293031323334353637383940414243//封装一个简单的each方法function each (data) &#123; //data是可遍历的 即data[Symbol.iterator]有值 for(let item of data) &#123; console.log(&apos;item :&apos;, item) &#125;&#125;// 测试几种可遍历的数据类型let str = &apos;love&apos;let arr = [1,2,3,4]let map = new Map()map.set(0, &quot;zero&quot;)map.set(1, &quot;one&quot;)let set = new Set([6,7,8,9])each(str)each(arr)each(map)each(set)/* item : l item : o item : v item : e item : 1 item : 2 item : 3 item : 4 item : [ 0, &apos;zero&apos; ] item : [ 1, &apos;one&apos; ] item : 6 item : 7 item : 8 item : 9*/ Map 数据结构 Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。 一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 一个 for…of 循环在每次迭代后会返回一个形式为[key，value]的数组。 一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。 Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。 你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。 Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。 Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。虽然 ES5 开始可以用 map = Obj- ect.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。 Map 在涉及频繁增删键值对的场景下会有些性能优势。 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"js-design-mode-observer","slug":"js-design-mode-observer","date":"2019-06-22T14:45:37.000Z","updated":"2019-06-22T15:21:53.677Z","comments":true,"path":"js-design-mode/js-design-mode-observer/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-observer/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 介绍 前端运用最广泛的设计模式 当一个对象被修改时，则会自动通知它的依赖对象。 注意，不一定是一对多哦，也可以一对一的。 菜鸟教程 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 主题，保存状态，状态发生变化后触发所有观察者对象class Subject &#123; constructor() &#123; this.state = 0 this.observers = [] &#125; getState() &#123; return this.state &#125; setState(state) &#123; this.state = state this.notifyAllObservers() &#125; // 通知所有的观察者 notifyAllObservers() &#123; this.observers.forEach((observer) =&gt; &#123; observer.update() &#125;) &#125; // 添加新的观察者 attach(observer) &#123; this.observers.push(observer) &#125;&#125;// 观察者class Observer &#123; constructor(name, subject) &#123; this.name = name this.subject = subject this.subject.attach(this) &#125; update() &#123; console.log(`$&#123;this.name&#125; updated, now-state:$&#123;this.subject.getState()&#125;`); &#125;&#125;// 测试let s = new Subject()let o1 = new Observer(&apos;o1&apos;, s)let o2 = new Observer(&apos;o2&apos;, s)let o3 = new Observer(&apos;o3&apos;, s)s.setState(1) s.setState(2)s.setState(3)/* //打印结果 o1 updated, now-state:1 o2 updated, now-state:1 o3 updated, now-state:1 o1 updated, now-state:2 o2 updated, now-state:2 o3 updated, now-state:2 o1 updated, now-state:3 o2 updated, now-state:3 o3 updated, now-state:3*/ 使用场景 网页事件绑定 Promise jQuery callbacks nodejs 自定义事件 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"js-design-mode-proxy","slug":"js-design-mode-proxy","date":"2019-06-21T12:36:54.000Z","updated":"2019-06-21T13:39:53.002Z","comments":true,"path":"js-design-mode/js-design-mode-proxy/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-proxy/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 代理模式简介 菜鸟教程 科学上网 明星经纪人 使用场景 网页事件代理 jQuery的 $.proxy() es6的proxy 代码实现明星经纪人 1234567891011121314151617181920212223242526272829303132333435363738394041// 明星let star = &#123; name: &apos;shulu&apos;, age: &apos;18&apos;, phone: &apos;star: 18366666666&apos;&#125;// 经纪人let agent = new Proxy(star, &#123; get(target, key) &#123; if (key === &apos;phone&apos;) &#123; // 返回经纪人(代理)的电话 return &apos;agent: 12353434343&apos; &#125; if (key === &apos;price&apos;) &#123; // 明星不报价，由经纪人报价 return &apos;agent: 1232323$&apos; &#125; return target[key] &#125;, set(target, key, val) &#123; if (key === &apos;customPrice&apos;) &#123; if (val &lt; 10000) &#123; // 最低价格 throw new Error(&apos;价格太低！&apos;) &#125;else&#123; target[key] = val return true &#125; &#125; &#125;&#125;)console.log(&apos;agent.name :&apos;, agent.name) //agent.name : shuluconsole.log(&apos;agent.age :&apos;, agent.age) //agent.age : 18console.log(&apos;agent.phone :&apos;, agent.phone) //agent.phone : agent: 12353434343console.log(&apos;agent.price :&apos;, agent.price) //agent.price : agent: 1232323$agent.customPrice = 1212 //价格太低！agent.customPrice = 100000 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"this","slug":"this","date":"2019-06-21T09:30:57.000Z","updated":"2019-06-21T09:37:32.443Z","comments":true,"path":"this/this/","link":"","permalink":"https://shulu520.com/this/this/","excerpt":"&emsp;&emsp;认识我自己。","text":"&emsp;&emsp;认识我自己。 this 当前执行代码的环境对象 mdn权威解释 全局环境 无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。 函数环境 在函数内部，this的值取决于函数被调用的方式。 如果要想把 this 的值从一个环境传到另一个，就要用 call 或者apply 方法。方法来源即Function.prototype.call Function.prototype.bind 使用 call 和 apply 函数的时候，如果传递给 this 的值不是一个对象，JavaScript 会尝试使用内部 ToObject 操作将其转换为对象。 箭头函数 它的this即它外层函数的this。 作为对象的方法 当函数作为对象里的方法被调用时，它们的 this是调用该函数的对象。 原型链中的 this 对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么this指向的是调用这个方法的对象，就像该方法在对象上一样。 getter 与 setter 中的 this 相同的概念也适用于当函数在一个 getter 或者 setter 中被调用。用作 getter 或 setter 的函数都会把 this 绑定到设置或获取属性的对象。作为构造函数 当一个函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象。作为一个DOM事件处理函数 当函数被用作事件处理函数时，它的this指向触发事件的元素。 setTimeout 关于”this”的问题 当你向 setTimeout() (或者其他定时器函数)传递一个函数时,该函数中的this指向跟你的期望可能不同。 解释 由setTimeout()调用的代码运行在与所在函数完全分离的执行环境上。这会导致，这些代码中包含的 this 关键字在非严格模式会指向 window (或全局)对象，严格模式下为 undefined，这和所期望的this的值是不一样的。 即定时器函数是一个异步宏任务，在事件循环中会被分配到对应的任务队列中去等待执行，故执行栈即执行上下文环境即this不是你以为的原来的了。 有事您Q我👇","categories":[{"name":"this","slug":"this","permalink":"https://shulu520.com/categories/this/"}],"tags":[{"name":"mdn","slug":"mdn","permalink":"https://shulu520.com/tags/mdn/"}]},{"title":"js-design-mode-decorator","slug":"js-design-mode-decorator","date":"2019-06-20T09:02:00.000Z","updated":"2019-06-20T16:27:09.287Z","comments":true,"path":"js-design-mode/js-design-mode-decorator/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-decorator/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 介绍 菜鸟教程 大牛解读es7装饰器 为对象添加功能 不改变其原有的结构和功能 代码演示 画圆 12345678910111213141516171819202122232425class Circle &#123; draw() &#123; console.log(&apos;画一个圆&apos;) &#125;&#125;class Decorator &#123; constructor(circle) &#123; this.circle = circle &#125; draw() &#123; this.circle.draw() this.setRedBorder(this.circle) &#125; setRedBorder(circle) &#123; console.log(&apos;给圆设置红色的边框&apos;) &#125;&#125;// 测试let circle = new Circle()circle.draw() //画一个圆let dec = new Decorator(circle)dec.draw() //画一个圆 给圆设置红色的边框 装饰器 ES7 中的 decorator 同样借鉴了python语法糖，不过依赖于 ES5 的 Object.defineProperty 方法 。 Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 Object.defineProperty(obj, prop, descriptor) obj：要在其上定义属性的对象。 prop：要定义或修改的属性的名称。 descriptor：将被定义或修改的属性描述符。 返回值：被传递给函数的对象。 属性描述符 对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。 数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。 存取描述符是由 getter-setter 函数对描述的属性。 描述符必须是这两种形式之一；不能同时是两者。 数据描述符和存取描述符均具有以下可选键值: configurable 可修改 布尔值 enumerable 可枚举 布尔值 value 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。 writable 可写 布尔值 get 一个给属性提供 getter 的方法 set 一个给属性提供 setter 的方法 Object.assign Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 语法 Object.assign(target, …sources)参数 target 目标对象。 sources 源对象。 返回值 目标对象。 core-decorators装饰器库的使用 安装插件 12345678910111213141516171819202122npm install --save-dev @babel/plugin-proposal-class-properties npm install --save-dev @babel/plugin-proposal-decoratorsnpm install --save-dev babel-plugin-transform-decorators-legacynpm install --save-dev core-decorators当然还有以下依赖的支持&quot;dependencies&quot;: &#123; &quot;@babel/core&quot;: &quot;^7.4.4&quot;, &quot;@babel/plugin-proposal-class-properties&quot;: &quot;^7.4.4&quot;, &quot;@babel/plugin-proposal-decorators&quot;: &quot;^7.4.4&quot;, &quot;@babel/preset-env&quot;: &quot;^7.4.4&quot;, &quot;babel-loader&quot;: &quot;^8.0.5&quot;, &quot;babel-plugin-transform-decorators-legacy&quot;: &quot;^1.3.5&quot;, &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;, &quot;core-decorators&quot;: &quot;^0.20.0&quot;&#125; .babelrc文件的配置 12345678910111213141516171819202122&#123; &quot;presets&quot;: [ [&quot;@babel/preset-env&quot;, &#123; &quot;useBuiltIns&quot;: &quot;usage&quot;,// 在每个文件中使用polyfill时，为polyfill添加特定导入。利用捆绑器只加载一次相同的polyfill。 &quot;modules&quot;: false,// 启用将ES6模块语法转换为其他模块类型，设置为false不会转换模块。 &quot;targets&quot;: &#123; //浏览器兼容 &quot;browsers&quot;: &quot;last 2 versions, not ie &lt;= 9&quot; &#125; &#125;] ], &quot;plugins&quot;: [ [ &quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;legacy&quot;: true &#125; ], [&quot;@babel/plugin-transform-runtime&quot;, &#123; &quot;helpers&quot;: false &#125;] ]&#125; 简单使用 1 123456789101112131415import &#123; readonly &#125; from &apos;core-decorators&apos;class Demo &#123; @readonly sayName() &#123; console.log(&apos;shulu&apos;) &#125;&#125;let demo = new Demo()demo.sayName() //shuludemo.sayName = function () &#123; console.log(&apos;lqy love shulu&apos;) //Uncaught TypeError: Cannot assign to read only property &apos;sayName&apos; of object &apos;#&lt;Demo&gt;&apos;&#125; 简单使用 2 123456789101112import &#123; deprecate &#125; from &apos;core-decorators&apos;class Demo &#123; @deprecate(&apos;此方法即将废除&apos; ,&#123;url: &apos;https://shulu520.com&apos;&#125;) getName() &#123; console.log(&apos;lqy&apos;) &#125;&#125;let demo = new Demo()demo.getName() //lqy DEPRECATION Demo#getName: 此方法即将废除 See https://shulu520.com for more details. 还有多种好用的方法…… 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"js-design-mode-adapter","slug":"js-design-mode-adapter","date":"2019-06-20T07:13:22.000Z","updated":"2019-06-20T08:58:06.199Z","comments":true,"path":"js-design-mode/js-design-mode-adapter/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-adapter/","excerpt":"&emsp;&emsp;江南的雨季，西北的惆怅。感君一回顾，思君朝与暮。","text":"&emsp;&emsp;江南的雨季，西北的惆怅。感君一回顾，思君朝与暮。 设计模式之适配器介绍 菜鸟教程 适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 代码演示 12345678910111213141516171819class OldStandard &#123; oldRequest() &#123; return &apos;老式标准插头&apos; &#125;&#125;class Adapter &#123; constructor() &#123; this.standard = new OldStandard() &#125; newRequest() &#123; let info = this.standard.oldRequest() return `新标准插头---&gt;适配器---&gt;$&#123;info&#125;` &#125;&#125;let adater = new Adapter()let res = adater.newRequest()console.log(&apos;res :&apos;, res) //res : 新标准插头---&gt;适配器---&gt;老式标准插头 经典案例 vue的computed计算属性 设计原则验证 将旧接口和使用者分离 开放封闭原则 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"js-design-mode-singleton","slug":"js-design-mode-singleton","date":"2019-06-20T04:07:58.000Z","updated":"2019-06-20T07:48:51.527Z","comments":true,"path":"js-design-mode/js-design-mode-singleton/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-singleton/","excerpt":"&emsp;&emsp;I love the World.","text":"&emsp;&emsp;I love the World. 单例模式介绍 菜鸟教程 系统中唯一被使用 一个类只有一个实例 私有化构造函数，外部不能new 只能内部new !!!!! instance实例是唯一被new出来的对象 代码演示123456789101112131415161718192021222324252627class SingleObject &#123; login() &#123; console.log(&apos;login&apos;) &#125; &#125;// 静态方法SingleObject.getInstance = (function() &#123; let instance return function() &#123; if (!instance) &#123; instance = new SingleObject() &#125; return instance &#125;&#125;)()let obj1 = SingleObject.getInstance()obj1.login() //loginlet obj2 = SingleObject.getInstance()obj2.login() //loginconsole.log(&apos;obj1===obj2 :&apos;, obj1===obj2) //obj1===obj2 : truelet obj3 = new SingleObject() //外部不能new,但是无法完全控制console.log(&apos;obj3===obj1 :&apos;, obj3===obj1) //obj3===obj1 : false 单例模式使用场景 jQuery 的 $ 模拟登录框 购物车 vuex react 中的store 代码实现登录框 12345678910111213141516171819202122232425262728293031323334353637383940414243class LoginForm &#123; constructor () &#123; this.state = &apos;hide&apos; &#125; show () &#123; if (this.state === &apos;show&apos;) &#123; console.log(&apos;已经显示&apos;) return &#125; this.state = &apos;show&apos; console.log(&apos;已经登录成功&apos;) &#125; hide () &#123; if (this.state === &apos;hide&apos;) &#123; console.log(&apos;已经隐藏&apos;) return &#125; this.state = &apos;hide&apos; console.log(&apos;已经隐藏成功&apos;) &#125;&#125;// 静态方法LoginForm.getInstance = (() =&gt; &#123; let instance return () =&gt; &#123; if (!instance) &#123; instance = new LoginForm() &#125; return instance &#125;&#125;)()let login1 = LoginForm.getInstance()login1.show() //已经登录成功let login2 = LoginForm.getInstance()login2.show() //已经显示login2.hide() //已经隐藏成功console.log(&apos;login1===login2 :&apos;, login1===login2)// login1===login2 : true// 这就说明login1 和login2是同一个实例 设计原则验证 符合单一职责原则，只实例化唯一的对象 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"hotkey-vscode","slug":"hotkey-vscode","date":"2019-06-19T09:04:23.000Z","updated":"2019-06-19T09:09:12.816Z","comments":true,"path":"hotkey/hotkey-vscode/","link":"","permalink":"https://shulu520.com/hotkey/hotkey-vscode/","excerpt":"&emsp;&emsp;如果你想要个和现在不同的人生，就必须去做你从未做过的事情。努力之后最坏的结果是失败，但不尝试的结果则是无止境的懊悔、怀疑和平庸。","text":"&emsp;&emsp;如果你想要个和现在不同的人生，就必须去做你从未做过的事情。努力之后最坏的结果是失败，但不尝试的结果则是无止境的懊悔、怀疑和平庸。 vscode 常用快捷键 上下移动一行： Alt+Up 或 Alt+Down 向上或向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down 同时选中所有匹配： Ctrl+Shift+L Ctrl+D 下一个匹配的也被选中 Alt + 单击 ：插入光标 Ctrl + F2 选择当前字的所有出现 ctrl shift k 删除整行 ctrl shift a 多行注释 ctrl f 当前文件内搜索相关代码，终于找到这个功能了，哈哈，右上角会有弹框，其中有前后箭头，表示搜索的代码上一次、下一次出现的位置，点击直接会跳转到相应的位置，并且侧边上有相应的位置标识。 ctrl - 整体缩小 ctrl = 整体放大 文件/首选项/设置 搜索zoom 根据配置 可以更精细的对大小进行操作 ctrl 加滚轮 col 选第一个 即console.log()的快捷键 且效果很棒 有事您Q我👇","categories":[{"name":"hotkey","slug":"hotkey","permalink":"https://shulu520.com/categories/hotkey/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://shulu520.com/tags/vscode/"}]},{"title":"js-design-mode-factory","slug":"js-design-mode-factory","date":"2019-06-19T08:43:18.000Z","updated":"2019-06-20T07:51:24.264Z","comments":true,"path":"js-design-mode/js-design-mode-factory/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-factory/","excerpt":"&emsp;&emsp;愿你做一个快乐的小仙女。","text":"&emsp;&emsp;愿你做一个快乐的小仙女。 介绍 菜鸟教程 代码实现 方法定义 12345678910111213141516// Product产品生产流水线class Product &#123; constructor (name) &#123; this.name = name &#125; getName () &#123; return `my name is $&#123;this.name&#125;` &#125;&#125;// Creator 工厂class Creator &#123; create (name) &#123; return new Product(name) &#125;&#125; 测试 123456789101112131415161718192021/* 普通调用 用户直接面对某一流水线，要产品 用户每次拿产品都得直接与产品流水线打交道*/ // 书写极其麻烦const p1 = new Product(&apos;phone&apos;)const p2 = new Product(&apos;book&apos;)console.log(&apos;p1 :&apos;, p1)console.log(&apos;p2 :&apos;, p2)/* 工厂函数 用户直接面对生产厂家，要产品 也就是说，用户无需知道其内部复杂生产过程*/// 工厂函数将生产流水线封装起来，只对外暴露接口供用户使用const creator = new Creator()//实例化一个工厂const pa = creator.create(&apos;boy&apos;)const pb = creator.create(&apos;girl&apos;)console.log(&apos;pa :&apos;, pa)console.log(&apos;pb :&apos;, pb) 工厂函数的例子 jQuery react.createElement vue异步组件 验证设计原则 构造函数和创建者分离 符合开放封闭原则 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"js-design-mode-design-philosophy","slug":"js-design-mode-design-philosophy","date":"2019-06-18T09:21:30.000Z","updated":"2019-06-19T06:19:59.568Z","comments":true,"path":"js-design-mode/js-design-mode-design-philosophy/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-design-philosophy/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; unix/linux设计哲学 小即是美 让每一个程序只做好一件事 快速建立原型 利于快速迭代 舍弃高效率而取可移植性 复用性 采用纯文本来存贮数据 可读性好 软件复用 使用shell脚本 避免强制性的用户界面 让每个程序都称为过滤器 中间件 允许用户定制环境 个性化 操作系统内核小而轻量化 使用小写字母并简写 沉默是金 没有消息是最好的消息 各部分之和大于整体 模块化 寻求90%的解决方案 不必追求完美 SOLID 五大设计原则 S 单一职责原则 每个程序之做好一件事 功能太复杂就拆分，每个部分保持独立 O 开放封闭原则 对扩展开放 对修改封闭 增加需求时 扩展新代码 而非修改已有的代码 L 李氏置换原则 子类能覆盖父类 父类能出现的地方子类就能出现 I 接口独立原则 保持接口的单一独立 避免出现胖接口 D 依赖导致原则 面向接口编程，依赖于抽象而不依赖于具体 使用方只关注接口 而不关注具体类的实现 为什么使用面向对像 面向对象 – 数据结构化 对于计算机 结构化才是简单的 编程 应该简单抽象 UML 类图 即统一建模语言 箭头表示依赖关系， 指向谁即依赖谁 泛化 即继承 空心箭头 由子类指向父类 关联 即引用 实心箭头 由引用者指向被引用者 类图 即一个表格 三行格子 第一格为类 构造函数 第二行为 属性：类型 第三行为 方法：返回值 23种设计模式总览 创建型 工厂模式 单例模式 原型模式 结构型 适配器模式 装饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 行为型 策略模式 模板方法模式 观察者模式 迭代器模式 职责链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式 面试题之弟弟打车12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Car 普通车 class Car &#123; constructor (name, number) &#123; this.name = name this.number = number &#125;&#125;// 慢车class SlowCar extends Car &#123; constructor(name, number) &#123; super(name, number) this.price = 1 &#125;&#125;// 快车class FastCar extends Car &#123; constructor(name, number) &#123; super(name, number) this.price = 2 &#125;&#125;// 旅途行程 （假定行程为5公里）class Trip &#123; constructor(car) &#123; this.car = car &#125; start () &#123; console.log(`行程开始，名称：$&#123;this.car.name&#125;,车牌号：$&#123;this.car.number&#125;`) &#125; end () &#123; console.log(`行程结束，一共$&#123;this.car.price * 5&#125;元`) &#125;&#125;//测试let car = new FastCar(&apos;兰博基尼&apos;, 18)let trip = new Trip(car)trip.start() //行程开始，名称：兰博基尼,车牌号：18trip.end() //行程结束，一共10元 面试题之停车场 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124// 车class Car &#123; constructor (num) &#123; this.num = num &#125;&#125;// 摄像头class Camera &#123; shot (car) &#123;//拍摄 return &#123; num: car.num, inTime: Date.now() &#125; &#125;&#125;// 出口显示屏class Screen &#123; show (car, inTime) &#123; console.log(`车牌号：$&#123;car.num&#125;`) console.log(`停车时间：$&#123;Date.now() - inTime&#125;`) &#125;&#125;// 停车场class Park &#123; constructor (floors) &#123; this.floors = floors || [] this.camera = new Camera() this.screen = new Screen() this.carList = &#123;&#125; // 存储摄像头拍摄的车辆信息 &#125; in (car) &#123; // 通过摄像头获取信息 const info = this.camera.shot(car) // 停到某个停车位 const i = Number.parseInt(Math.random() * 100 % 100) // 某一层 const j = Number.parseInt(Math.random() * 3) const place = this.floors[j].places[i] place.in() //车已停入某一车位 // 记录信息 info.place = place this.carList[car.num] = info &#125; out (car) &#123; // 获取车辆信息 const info = this.carList[car.num] // 将对应的停车位清空 info.place.out() // 显示时间 this.screen.show(car, info.inTime) // 删除记录 // info = null &#125; emptyNum () &#123; return this.floors.map(floor =&gt; &#123; return `第$&#123;floor.index&#125;层有$&#123;floor.emptyPlaceNum()&#125;个空位` &#125;).join(&apos;\\n&apos;) &#125;&#125;// 楼层class Floor &#123; constructor (index, places) &#123; this.index = index this.places = places || [] &#125; emptyPlaceNum () &#123; let num = 0 this.places.forEach(place =&gt; &#123; if (place.empty) &#123; num += 1 &#125; &#125;) return num &#125;&#125;// 车位class Place &#123; constructor () &#123; this.empty = true &#125; in () &#123; this.empty = false &#125; out () &#123; this.empty = true &#125;&#125;// 测试// 初始化停车场const floors = []for (let i = 0; i &lt; 3; i++) &#123; const places = [] for (let j = 0; j &lt; 100; j++) &#123; places[j] = new Place() &#125; floors[i] = new Floor(i + 1, places)&#125;const park = new Park(floors)// 初始化车辆const car1 = new Car(18)const car2 = new Car(22)const car3 = new Car(36)console.log(`$&#123;park.emptyNum()&#125;`)console.log(`第一辆车进入`)park.in(car1)console.log(`$&#123;park.emptyNum()&#125;`)console.log(`第二辆车进入`)park.in(car2)console.log(`$&#123;park.emptyNum()&#125;`)console.log(`第一辆车离开`)park.out(car1)console.log(`$&#123;park.emptyNum()&#125;`)console.log(`第二辆车离开`)park.out(car2)console.log(`$&#123;park.emptyNum()&#125;`) 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"js-design-mode-oop","slug":"js-design-mode-oop","date":"2019-06-18T02:58:30.000Z","updated":"2019-06-18T10:06:00.834Z","comments":true,"path":"js-design-mode/js-design-mode-oop/","link":"","permalink":"https://shulu520.com/js-design-mode/js-design-mode-oop/","excerpt":"&emsp;&emsp;you are my baby.","text":"&emsp;&emsp;you are my baby. webpack的配置 以支持es6的新语法 npm install webpack webpack-cli –save-dev –registry=https://registry.npm.taobao.org 在package.json中 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack --config ./webpack.dev.config.js --mode development&quot;&#125;即在命令行里面运行npm run dev 即可运行webpack 的配置文件 我们更改了配置文件的默认名字 在这里指定他的配置文件为 ./webpack.dev.config.js 即可 npm install webpack-dev-server html-webpack-plugin –save-dev –registry=https://registry.npm.taobao.org 将package.json中的webpack 改为webpack-dev-server 即为开启一个运行本地服务器 babel的es6语法插件解析 npm install –save-dev babel-loader @babel/core @babel/preset-env –registry=https://registry.npm.taobao.org npm install –save-dev @babel/polyfill @babel/plugin-transform-runtime –registry=https://registry.npm.taobao.org class 类 即模板 封装 继承 多态 123456789101112131415//创建类（构造函数）class Person &#123; constructor (name) &#123; //属性 特征 this.name = name &#125; getName () &#123; //方法 函数 return this.name &#125;&#125;//创建对象（实例）let p = new Person(&apos;shulu&apos;)alert(p.getName()) es6面向对象之继承123456789101112131415161718192021222324252627282930// 父类class Person &#123; constructor (name, age) &#123; this.name = name, this.age = age &#125; getName () &#123; return `my name is $&#123;this.name&#125;` &#125; getAge () &#123; return `my age is $&#123;this.age&#125;` &#125;&#125;// 子类 // 继承父类的属性、方法 并添加自己的属性和方法class Student extends Person &#123; constructor (name, age, number) &#123; super(name, age) this.number = number &#125; study () &#123; return `my number is $&#123;this.number&#125;, and i am studying` &#125;&#125;let s = new Student(&apos;shulu&apos;, 18, 23)alert(s.getName())alert(s.getAge())alert(s.study()) es6面向对象之封装 public 完全开放 protected 对子类开放 private 对自己开发 es6 尚不支持， 用typescript来演示trpescript网站测试代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 父类class Person &#123; name //公开的属性 age protected weight //受保护的属性，只有自己和子类可以访问，实例对象可以访问 constructor (name, age) &#123; this.name = name, this.age = age, this.weight = &apos;120&apos; &#125; getName () &#123; return `my name is $&#123;this.name&#125;` &#125; getAge () &#123; return `my age is $&#123;this.age&#125;` &#125; &#125;// 子类 // 继承父类的属性、方法 并添加自己的属性和方法class Student extends Person &#123; number //公开的属性 private boyfriend //自己的私有的属性，只有自己才可以访问，自己的实例都不能用 constructor (name, age, number) &#123; super(name, age) this.number = number this.boyfriend = &apos;lqy&apos; &#125; study () &#123; return `my 学号 is $&#123;this.number&#125;, and i am studying` &#125; getBoyfriend () &#123; return `my boyfriend is $&#123;this.boyfriend&#125;` &#125; getWeight () &#123; return `my weight is $&#123;this.weight&#125;` &#125;&#125;let s = new Student(&apos;shulu&apos;, 18, 23)alert(s.getWeight()) //可以正常访问alert(s.boyfriend()) //报错 girlfriend只能在Student 里面自己使用 es6面向对象之多态 多个子类可以继承一个父类，并扩展自己的方法 1234567891011121314151617181920212223242526272829303132333435363738// 父类class Person &#123; constructor (name) &#123; this.name = name &#125; getName () &#123; return `my name is $&#123;this.name&#125;` &#125;&#125;// 子类A class StudentA extends Person &#123; constructor (name, number) &#123; super(name) this.number = number &#125; study () &#123; return `my 学号 is $&#123;this.number&#125;, and i am studying` &#125;&#125;// 子类Bclass StudentB extends Person &#123; constructor (name, number) &#123; super(name) this.number = number &#125; study () &#123; return `my 学号 is $&#123;this.number&#125;, and i am studying` &#125;&#125;let s1 = new StudentA(&apos;shulu&apos;, 18)let s2 = new StudentB(&apos;lqy&apos;, 19)alert(s1.getName())alert(s1.study())alert(s2.getName())alert(s2.study()) 面向对像实现jQuery的例子1234567891011121314151617181920212223242526272829class jQuery &#123; constructor (selector) &#123; let dom = Array.from(document.querySelectorAll(selector)) let len = dom ? dom.length : 0 dom.forEach((item, index) =&gt; &#123; this[index] = item &#125;) this.len = len this.selector = selector || &apos;&apos; &#125; append (node) &#123; &#125; addClass (className) &#123; &#125; html (data) &#123; &#125; // 好多的方法……&#125;window.$ = function (selector) &#123; return new jQuery(selector)&#125;let $p = $(&apos;p&apos;) // p 标签选择器console.log($p)console.log($p.addClass) 有事您Q我👇","categories":[{"name":"js-design-mode","slug":"js-design-mode","permalink":"https://shulu520.com/categories/js-design-mode/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"responsive-sites","slug":"responsive-sites","date":"2019-06-16T11:23:58.000Z","updated":"2019-06-17T14:42:54.231Z","comments":true,"path":"responsive-sites/responsive-sites/","link":"","permalink":"https://shulu520.com/responsive-sites/responsive-sites/","excerpt":"&emsp;&emsp;梦终有你。","text":"&emsp;&emsp;梦终有你。 视口 布局视口 就像一本书 大小固定 如960px 是设计图纸的大小 可视视口 就像放大镜 在它上面可以移动缩放 是设备屏幕的大小 在这两种视口下，用户需要通过滑动缩放来查看整个页面的不同部分。 理想视口 为了解决以上的问题而制定的视口。是布局视口在一个设备上的最佳尺寸。即让布局视口等于可视视口。 大牛博客视口相关说明 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;/&gt; 爬虫协议robots.txt 把“robots.txt”放在你网站的根目录，并确保他能让访问者（如搜索引擎）访问到。 Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”，网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。 1234User-agent: *Disallow: /admin/Sitemap: https://shulu520.com/sitemap.xmlSitemap: https://shulu520.com/sitemap.hxml 关于humans.txthumans.txt官网 这是什么？ 这是一个TXT文件，其中包含参加该网页设计和建立的人们的信息。 为什么是一个TXT？ 这是因为TXT是一种快速和容易建立的档案格式，而且不是一种有侵扰性的格式。 很多时候业主并不希望作者在为他设计的网站签名，以为这样会降低其功能。 以我们这种方式可以从外部快速便利、经济实惠的显示证明网站作者（不是指网站的主人）。 humans.txt官网格式 12345/* TEAM *//* THANKS *//* SITE */ 项目目录的一些有用的文件 robots.txt humans.txt .editorConfig(编辑器风格配置) .gitignore LICENSE.txt(版权声明，协议是否开源) README.md(项目简介 使用方式 相关链接) CHANGLOG(说明版本更新相关) html页面重要内容 以前没有注意到的细节知识做一总结。 1234567891011121314151617181920网站内的语言为汉语，参考自淘宝网。&lt;html lang=&apos;zh-CN&apos;&gt;&lt;/html&gt;这意味着，会强制浏览器按照最新的标准去渲染。添加”chrome=1“将允许站点在使用了谷歌浏览器内嵌框架（Chrome Frame）的客户端渲染，对于没有使用的，则没有任何影响。&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;/&gt;告诉浏览器启用理想视口来展示页面。不允许用户进行缩放。&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=0&quot; /&gt;条件注释：在body标签下争对IE低版本浏览器的更新提示信息： &lt;!--[if lt IE 8]&gt; &lt;style&gt;html,body&#123;overflow:hidden;height:100%&#125;&lt;/style&gt; &lt;div&gt; &lt;p&gt;您的浏览器版本老的可笑，请到点击下面任一链接更新，以获取最佳的浏览体验。&lt;/p&gt; &lt;a href=&quot;https://www.google.cn/intl/zh-CN/chrome/browser/desktop/&quot; &quot; target=&quot;_blank&quot;&gt;谷歌 Chrome&lt;/a&gt; &lt;a href=&quot;http://www.uc.cn/ucbrowser/download/&quot; target=&quot;_blank&quot;&gt;UC 浏览器&lt;/a&gt;&quot; &lt;a href=&quot;http://browsehappy.com&quot;&gt;各大浏览器更新网站(外网) &lt;/div&gt; &lt;![endif]--&gt; logo 说明 像logo这样重要的图片最好以img标签的形式嵌入页面。 其他的不太重要的图片可以考虑background的形式引入。 样式重置 传统css样式重置resets.css 性能不佳 H5标准的样式重置 GitHub 3万多star npm install normalize.css css单位 px 1px=1像素 em 相对长度单位 em的相对参照物为 父元素的font-size值 em 具有继承的特点 当没有设值时，浏览器的默认em 1em=16px em的缺点 容易错乱 rem 相对长度单位 参照物为HTML根元素 其固定不变 计算简单 没有设值时，浏览器的默认值 1rem=16px 设置 font-size: 62.5% 那么 1rem = 10px css3 的一些样式 文本选中后的样式设置 1234::selection &#123; background-color: pink; text-shadow: none&#125; calc的使用例子 width: calc(33.33333333% - 2rem) css3 box-sizing属性 border-box，border和padding计算入width之内，其实就是怪异模式了 box-sizing: border-box box-sizing:border-box; 将正常的width height的作用范围延申至border的地方。 也就是说，对元素指定宽度和高度包括了 padding 和 border 。 正常的元素宽高给定后，增加padding border他们会往外面阔展大小。 加了这个属性后，再增加padding border 此时元素内容区会向里面缩进。 清除浮动 当元素设置float浮动后，该元素就会脱离文档流并向左/向右浮动，直到碰到父元素或者另一个浮动元素，浮动元素会造成父元素高度塌陷，所以当我们设置float后，需进行相应的清除浮动操作。 清除浮动的原理 触发BFC BFC 块级格式化上下文 一个HTML元素要创建BFC，则满足下列的任意一个或多个条件即可： 1.float的值不是none。2.position的值不是static或者relative。3.display的值是inline-block、table-cell、flex、table-caption或者inline-flex4.overflow的值不是visible BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列 清除浮动方式一 使用额外的标签clear:both 原理：在浮动元素下面添加一个空标签，在这个标签中设置clear：both； 优点：简单，浏览器兼容性好； 缺点：增加页面的标签，造成页面混乱； 方式二 使用overflow属性 原理：父元素定义overflow:hidden，此时，浏览器会自动检查浮动区域的高度； 优点：简单，无需增加新的标签； 缺点：不能和position配合使用，因为超出的尺寸的会被隐藏 方式三 使用伪元素:after清除浮动 原理：原理同方法一有点类似，在元素最后定义一个空的内容，然后让该空的内容来清除浮动； 优点：无需额外的标签，浏览器兼容性好，是目前用的最多的一种清除浮动的方法之一； 缺点：代码稍微复杂点，初学者可能不太能理解其原理； 方式四 推荐 老外大师推荐 12345.clearfix:before,.clearfix:after&#123; content: &apos; &apos;; display: table;&#125; line-height 注意事项 在使用rem 的单位设置时会有点问题 建议使用px的单位 diaplay: inline-block 注意事项 将元素设置为inline-block即行内块元素 多个inline-block元素会排列为一行 对外显示为行内元素 对内为块级元素的特性 带来的问题： 各个元素间会出现一条小缝隙 即是元素间的空白字符 两个标签之间看不见的东西 解决方法： 将元素排列为一行 或去掉元素后面的闭合标签 将闭合标签放到下一个标签的开头部分 还有好多种方法 雪碧图的使用 CSS雪碧 即CSS Sprite，也有人叫它CSS精灵，是一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分 CSS雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。该图片使用CSS background和background-position属性渲染。 省略号的设置12345.box&#123; text-overflow: ellipsis; overflow: hidden; white-space: nowrap;&#125; 有事您Q我👇","categories":[{"name":"responsive-sites","slug":"responsive-sites","permalink":"https://shulu520.com/categories/responsive-sites/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"express","slug":"express","date":"2019-06-12T01:34:23.000Z","updated":"2019-06-12T01:37:23.416Z","comments":true,"path":"express/express/","link":"","permalink":"https://shulu520.com/express/express/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 有事您Q我👇","categories":[{"name":"express","slug":"express","permalink":"https://shulu520.com/categories/express/"}],"tags":[{"name":"zhuf","slug":"zhuf","permalink":"https://shulu520.com/tags/zhuf/"}]},{"title":"cookie-js","slug":"cookie-js","date":"2019-06-11T15:13:25.000Z","updated":"2019-06-11T15:24:47.123Z","comments":true,"path":"cookie/cookie-js/","link":"","permalink":"https://shulu520.com/cookie/cookie-js/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 转载 原文链接运用JS设置cookie、读取cookie、删除cookieJavaScript是运行在客户端的脚本，因此一般是不能够设置Session的，因为Session是运行在服务器端的。 而cookie是运行在客户端的，所以可以用JS来设置cookie. 假设有这样一种情况，在某个用例流程中，由A页面跳至B页面，若在A页面中采用JS用变量temp保存了某一变量的值，在B页面的时候，同样需要使用JS来引用temp的变量值，对于JS中的全局变量或者静态变量的生命周期是有限的，当发生页面跳转或者页面关闭的时候，这些变量的值会重新载入，即没有达到保存的效果。解决这个问题的最好的方案是采用cookie来保存该变量的值，那么如何来设置和读取cookie呢？ 首先需要稍微了解一下cookie的结构，简单地说：cookie是以键值对的形式保存的，即key=value的格式。各个cookie之间一般是以“;”分隔。 JS设置cookie: 假设在A页面中要保存变量username的值(“jack”)到cookie中,key值为name，则相应的JS代码为： document.cookie=”name=”+username; JS读取cookie: 假设cookie中存储的内容为：name=jack;password=123 则在B页面中获取变量username的值的JS代码如下： var username=document.cookie.split(“;”)[0].split(“=”)[1]; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//JS操作cookies方法! //写cookies function setCookie(name, value) &#123; var Days = 30; var exp = new Date(); exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 1000); document.cookie = name + &quot;=&quot; + escape(value) + &quot;;expires=&quot; + exp.toGMTString();&#125;//读取cookiesfunction getCookie(name) &#123; var arr, reg = new RegExp(&quot;(^| )&quot; + name + &quot;=([^;]*)(;|$)&quot;); if ((arr = document.cookie.match(reg))) return unescape(arr[2]); else return null;&#125;//删除cookiesfunction delCookie(name) &#123; var exp = new Date(); exp.setTime(exp.getTime() - 1); var cval = getCookie(name); if (cval != null) document.cookie = name + &quot;=&quot; + cval + &quot;;expires=&quot; + exp.toGMTString();&#125;//使用示例setCookie(&quot;name&quot;, &quot;hayden&quot;);alert(getCookie(&quot;name&quot;));//如果需要设定自定义过期时间//那么把上面的setCookie 函数换成下面两个函数就ok;//程序代码function setCookie(name, value, time) &#123; var strsec = getsec(time); var exp = new Date(); exp.setTime(exp.getTime() + strsec * 1); document.cookie = name + &quot;=&quot; + escape(value) + &quot;;expires=&quot; + exp.toGMTString();&#125;function getsec(str) &#123; alert(str); var str1 = str.substring(1, str.length) * 1; var str2 = str.substring(0, 1); if (str2 == &quot;s&quot;) &#123; return str1 * 1000; &#125; else if (str2 == &quot;h&quot;) &#123; return str1 * 60 * 60 * 1000; &#125; else if (str2 == &quot;d&quot;) &#123; return str1 * 24 * 60 * 60 * 1000; &#125;&#125;//这是有设定过期时间的使用示例：//s20是代表20秒//h是指小时，如12小时则是：h12//d是天数，30天则：d30setCookie(&quot;name&quot;, &quot;hayden&quot;, &quot;s20&quot;); 转载 原文链接 有事您Q我👇","categories":[{"name":"cookie","slug":"cookie","permalink":"https://shulu520.com/categories/cookie/"}],"tags":[]},{"title":"localStorage","slug":"localStorage","date":"2019-06-11T11:52:59.000Z","updated":"2019-06-11T15:33:48.321Z","comments":true,"path":"localStorage/localStorage/","link":"","permalink":"https://shulu520.com/localStorage/localStorage/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 本地存贮 把一些信息存储到客户端本地 存储到浏览器指定的地方 实现多页面之间的信息共享 本地存贮种类 (xxx.manifest) 本地缓存 H5中的api localStorage H5中的api 小数据的存储 常用 indexDB / webSQL 本地数据库存储 CacheStroge / ApplicationCache cookie 常用 本地存贮使用场景 页面之间的信息通信 性能优化 本地存储信息的局限性 按照域来管理信息 如访问我的网站 则存储到shulu520.com这个域中 不能跨浏览器共享 不能跨域共享 session cookie 的关联 session 服务器端存储 cookie 客户端存储 在服务器端创建session之后，服务器和当前客户端之间会建立一个唯一的标识(sessionID/sid),当前信息存储在对应的sid之下。 当服务器端把一些成功或失败的结果返回给客户端的时候，在响应头信息中会增加set-cookie(客户端cookie)这样的字段，把connect.sid存储到客户端的cookie中。即在客户端本地种下cookie. 当客户端再向服务器发送任何请求的时候，都会把cookie信息带上，传递给服务器. 服务器端根据sid值进行校验。 localStroge vs cookie cookie 兼容所有浏览器 存储大小限制 一个域下能存储4kb左右数据 有过期时间(可以设置) 杀毒软件或浏览器的垃圾清理都可能会把cookie信息强制清除掉 在隐私或无痕浏览模式下，是不会记录cookie的 cookie不是严格的本地存储，因为要和服务器之间来回传输 localStroge 不兼容ie8 及以下 存储大小限制 一个域下能存储5Mb左右数据 本地永久存储(不手动删除的情况下) 杀毒软件或浏览器的垃圾清理暂时不会清理localStroge的信息(新版本google会清理localStroge的) 在隐私或无痕浏览模式下，是会记录localStroge的 localStroge和服务器之间无半毛钱的关系 cookie的设置 document.cookie = ‘’转载 原文链接 localStroge的使用 常用 localStroge.setItem(key, value) 设置 其中value必须是字符串 localStroge.getItem(key) 获取 localStroge.removeItem(key) 删除 localStroge.clear() 清除当前域下的所有的localStroge信息 有事您Q我👇","categories":[{"name":"localStorage","slug":"localStorage","permalink":"https://shulu520.com/categories/localStorage/"}],"tags":[{"name":"zhuf","slug":"zhuf","permalink":"https://shulu520.com/tags/zhuf/"}]},{"title":"Promise-zhuf","slug":"Promise-zhuf","date":"2019-06-10T13:26:00.000Z","updated":"2019-06-11T15:35:14.048Z","comments":true,"path":"Promise/Promise-zhuf/","link":"","permalink":"https://shulu520.com/Promise/Promise-zhuf/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; js执行顺序优先级 scncfunction –&gt; micro task –&gt; macro task 同步代码 scncfunction 微任务 micro task 宏任务 macro task 微任务 micro task Process.nextTick 把当前任务放到主栈的最后执行 Promise(async await) 宏任务 macro task 回调函数 ajax 事件绑定 node 中的 fs 三种定时器 setImmediate (nodejs独有) setTimeout setInterval 123setImmediate (() =&gt; &#123; console.log(&apos;shulu&apos;)&#125;) Promise 三种状态 进行中 成功 失败 Promise.all([promise1, promise2, promise3]).then(() =&gt; {……}).catch(){……} 即promise1,2,3都成功则执行then的成功方法，有一个失败则走catch方法。 es6 class 类 class 的本质是 function。 在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。 它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法 constructor 方法是类的默认方法，创建类的实例化对象时被调用 class 的实例化必须通过 new 关键字。 123456789101112class Promise &#123; //constructor 创建类的实例化对象时被调用 constructor () &#123; &#125; //这里写原型上的方法 then() catch()&#125; 手写Promise实现 有事您Q我👇","categories":[{"name":"Promise","slug":"Promise","permalink":"https://shulu520.com/categories/Promise/"}],"tags":[{"name":"zhuf","slug":"zhuf","permalink":"https://shulu520.com/tags/zhuf/"}]},{"title":"git-linux","slug":"git-linux","date":"2019-06-09T03:23:05.000Z","updated":"2019-06-10T06:07:03.393Z","comments":true,"path":"git/git-linux/","link":"","permalink":"https://shulu520.com/git/git-linux/","excerpt":"&emsp;&emsp;终有一天，我会出现在你的眼前。","text":"&emsp;&emsp;终有一天，我会出现在你的眼前。 个人本地操作篇 显示目录或文件 ls -s / ls -a -s 文件列表 -a 包括隐藏文件 cd cd / cd ../ 可以直接拖动文件进入目录 创建文件夹 mkdir + shulu 创建空文件 touch + lqy 编辑文件 方式一 vim/vi + lqy A或I 键进入插入模式 编辑完成后 Esc 然后:wq 即可保存退出 方式二 向指定的文件输入内容 echo xxx &gt; shulu.txt shulu.txt若不存在则创建 每次编辑都会覆盖之前的内容 查看文件中的内容 cat lqy 删除文件或文件夹 一旦删除 不可恢复 rm + name -rf -r 递归删除 -f 强制删除 -rf 以上二者都有 git status 查看当前文件处于哪一个区域 红色：在工作区 绿色：在暂存区 看不见：已经提交到历史区，三区保持一致了 暂存区删除文件操作 只要新add一下新的内容 即可覆盖前面暂存区不好的代码 根据提示： (use “git reset HEAD …” to unstage) 即git reset HEAD &lt;要删除的file&gt; 或git rm –cached &lt;要删除的file&gt; 代码回滚 一 暂存区回滚 一步回滚操作 将暂存区文件撤回来覆盖工作区新写的不好的代码 git checkout &lt;要撤回的file&gt; (注意 . 表示所有的文件) 暂存区的文件依然在，只是将其拿出来覆盖新写的不好的代码 工作区和暂存区 状态保持一致了 两步回滚操作 git reset HEAD &lt;要删除的file&gt; 把当前暂存区的内容删掉，此时暂存区的内容为上一次add的内容 git checkout 将上一次add的内容拿回来覆盖工作区的不好的代码 代码回滚 二 历史版本回滚 git log 版本信息 若出现了 提交的信息最后有一个end 按Q键即可退出 git reset –hard &lt;版本id&gt; 三区保持一致了 .gitignore文件 添加不用git管理的文件 ctrl + L 清屏 团队协作篇 创建远程仓库 最好创建一个README.md文件 这样远程就会有一个master的分支 有利于后续的操作 创建本地仓库初始化本地仓库连接远程仓库这操作不常用 mkdir repository git init git remote add origin git@github.com:lqyasl/git-zhuf.git git clone 常用 一步操作等于以上三步操作 git clone git@github.com:lqyasl/git-zhuf.git 不同开发者之间的配合 假设有a b 两个开发者不冲突的情况 a b 两人提交修改的是不同的文件 提交之前最好git pull origin master 拉取远程仓库的内容 然后再git push origin master 推送到远程产生冲突的情况 两人同时对相同的文件都做了不一样的修改 解决冲突 若直接弹出vim的内容 正常退出即可 即 输入a 然后按Esc 再按 :wq 若显示MERGEING 则删掉那些特殊符号 ，修改好后退出 无分支开发模式 即只有一个master 分支分支开发模式 新开一个分支即可 git checkout -b deva 即可创建一个deva分支 并且切换到这个分支上 新创建分支的特点：本地master内容会自动同步到deva分支上 在deva分支上完事后 git add . git commit -m ‘……’ git stash 保存当前的工作进度。会分别对暂存区和工作区的状态进行保存 关于这一步操作后面有说明 git checkout master git merge deva git pull origin master git push origin master git stash &amp; git stash pop git stash 保存当前的工作进度。会分别对暂存区和工作区的状态进行保存. git stash pop 恢复工作现场。 软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。 当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交。 并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？ 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来(先git add . 到暂存区 然后 git stash 藏起来)，等以后回来恢复现场后继续工作。 总结： 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除bug分支； 当手头工作没有完成时，先把工作现场git stash一下，然后去bug分支修复bug，修复后，再回到之前的分支git stash pop，将工作现场恢复。 有事您Q我👇","categories":[{"name":"git","slug":"git","permalink":"https://shulu520.com/categories/git/"}],"tags":[{"name":"zhuf","slug":"zhuf","permalink":"https://shulu520.com/tags/zhuf/"}]},{"title":"webpack-mooc","slug":"webpack-mooc","date":"2019-06-01T15:54:12.000Z","updated":"2019-06-07T03:00:27.318Z","comments":true,"path":"webpack/webpack-mooc/","link":"","permalink":"https://shulu520.com/webpack/webpack-mooc/","excerpt":"&emsp;&emsp;只要有想见的人，就不是孤身一人。","text":"&emsp;&emsp;只要有想见的人，就不是孤身一人。 开始 node 安装 webpack 安装 初始化文件夹 npm init 打包符合node规范的项目 或 npm init -y 生成默认初始化的文件夹 全局安装webpack 不推荐 因为各个项目依赖的webpack版本可能不一样 npm uninstall webpack webpack-cli -g 卸载webpack npm install webpack webpack-cli -D 推荐在项目中独立安装 npm info webpack 打印输出webpack的信息 可以查看你想要的版本是否存在 安装你所需要的版本就行了 npm i webpack@版本号 webpack-cli -D webpack 默认的打包配置文件为webpack.config.js 开始配置 webpack.config.js初步配置 新建webpack.config.js文件 新建src目录 放我们的源代码 webpack.config.js配置如下： 123456789101112//nodejs引入path模块 为commonjs规范const path = require(&apos;path&apos;)module.exports = &#123; mode: development, // 指定运行环境 entry: &apos;./src/index.js&apos;, // 入口文件 output: &#123; // 出口文件 //被编译到你指定的输出路径的文件夹中 path: path.resolve(_dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; //指定打包生成的文件名字 &#125;&#125; package.json 配置scripts命令 简化命打包令为 npm run bundle 12345&#123; &quot;scripts&quot;: &#123; &quot;bundle&quot;: &quot;webpack&quot; //npm run bundle 执行webpack命令 &#125;,&#125; 不同安装的webpack打包形式 未配置scriptsnpx webpack 要打包的文件 配置scripts后npm run bundle 即可 配置打包图片 loader 所谓 loader 只是一个导出为函数的 JavaScript 模块。让 webpack 能够去处理那些非 JavaScript 文件 (webpack 自身只理解 JavaScript) loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块， 然后你就可以利用 webpack 的打包能力，对它们进行处理。 12345678910111213141516171819202122232425const path = require(&apos;path&apos;)module.exports = &#123; mode: &apos;development&apos;, entry: &#123; main: &apos;./src/index.js&apos; &#125;, module: &#123; rules: [&#123; test: /\\.(jpg|png|gif)$/,//用于标识出应该被对应的 loader 进行转换的某个或某些文件。 use: &#123;//表示进行转换时，应该使用哪个 loader。 loader: &apos;url-loader&apos;, // loader: &apos;file-loader&apos;, options: &#123; //配置项 name: &apos;[name].[ext]&apos;,//以原来的名字和后缀打包生成文件名 outputPath: &apos;images/&apos;,//打包生成的文件放到dist/images/ limit: 2048 //当图片的大小在2kb以下时直接打包成base64的图片嵌入js文件中 &#125; &#125; &#125;] &#125;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;&#125; 样式loader css-loader 处理各个css文件间的关系 style-loader 将增加一个style标签并插入css文件然后挂载到head标签中 处理sass文件 npm install sass-loader node-sass -D loader 的执行顺序 从下到上 从右到左 处理less文件 首先npm install less –save-dev 再npm i -D less-loader 123456789101112module: &#123; rules: [&#123; test: /\\.scss$/, use: [&#123; loader: &quot;style-loader&quot; // 将 JS 字符串生成为 style 节点 &#125;, &#123; loader: &quot;css-loader&quot; // 将 CSS 转化成 CommonJS 模块 &#125;, &#123; loader: &quot;sass-loader&quot; // 将 Sass 编译成 CSS &#125;] &#125;]&#125; 自动添加前缀loader 使用Can I Use中的值为CSS规则添加供应商前缀。 Autoprefixer将使用基于当前浏览器流行度和属性支持的数据为您应用前缀。 npm i -D postcss-loader npm i -D autoprefixer 123456//配置新建postcss.config.jsmodule.exports = &#123; plugins: [ require(&apos;autoprefixer&apos;) ]&#125; 123456789//然后配置webpack.config.js&#123; test: /\\.css$/, use: [ &apos;style-loader&apos;, &#123; loader: &apos;css-loader&apos;, options: &#123; importLoaders: 1 &#125; &#125;, &apos;postcss-loader&apos; ]&#125; css-loader 常用的配置 当less(sass)等文件中再引入其他的less(sass)文件时，默认是不会打包引入的文件的， 配置opations 中 importLoaders: 2 后，则会通过’less-loader’, ‘postcss-loader’ 这两个loader的打包 { loader: ‘css-loader’, options: { importLoaders: 2, modules: true //模块化 }},‘less-loader’,‘postcss-loader’ css 打包的模块化 模块中需要哪个样式文件 引入即可import style from ‘./avator.less’ 使用:如 img.classList.add(style.avator) 在avator.less样式中自己写的叫avator的classname 123options: &#123; modules: true //开启css模块化&#125; 字体的引入iconfont file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录。 这就是说，我们可以将它们用于任何类型的文件，包括字体。 src/font一般需要 中如下几种正则中的字体文件 iconfont.css文件，在需要字体的地方引入样式即可 src: url(‘./font/iconfont.eot?t=155948’) url(‘./font/iconfont.ttf?t=155948’) 其中./font为自己加的路劲 其中有个base64格式的路劲不用变 1234test: /\\.(woff|woff2|eot|ttf|svg)$/,use: [ &apos;file-loader&apos;] plugin 插件的使用 html-webpack-plugin插件的使用 npm install –save-dev html-webpack-plugin HtmlWebpackPlugin 插件的作用： 会在打包结束后自动生成一个html文件，并把打包生成的js文件自动引入html文件 plugin的作用：在webpack运行到某个时刻的时候，帮我门做一些在事情 就像vue中的生命周期钩子函数 12345678//webpack.config.js中plugins: [ new HtmlWebpackPlugin(&#123; title: &quot;my html template&quot;, //自定义title 默认为webpack app filename: &quot;myindex.html&quot;, //自定义文件名 默认为index.html template: &quot;src/index.html&quot; //以此为模板创建html &#125;)] clean-webpack-plugin 清除旧的打包的文件 1var &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;) 123plugins: [ new CleanWebpackPlugin(),//打包前删除前面旧的dist文件] entry1234entry: &#123; main: &apos;./src/index.js&apos;, sub: &apos;./src/index.js&apos; //再打包生成一个js文件&#125;, output12345output: &#123; publicPath: &apos;https://cdn.abc.com&apos;,//公共前缀路劲如cdn filename: &apos;[name].js&apos;, //以entry的key值作为打包生成的文件名 path: path.resolve(__dirname, &apos;dist&apos;)&#125;, SourceMap 再打包生成main.js文件之后如果代码里出现错误，它会将main.js中错误出现的地方与源码之间做一映射，告诉我们源码中错误出现在哪里，以便我们快速定位bug出处 错误代码使用chrome调试工具直接显示在index.js?b635这个文件打开即可看到源码里面错误出现的位置 123devtool: &apos;cheap-module-eval-source-map&apos;,//development模式推荐使用devtool: &apos;cheap-module-source-map&apos;,//production模式推荐使用 使用WebpackDevServer提升开发效率 npm install webpack-dev-server -D 在webpack.config.js 12345678910111213devServer: &#123; contentBase: &apos;./dist&apos;,//开启一个服务器运行dist里面的内容 open: true ,//自动在浏览器里打开 /* //vue中就是配置的这样的代理 proxy: &#123; &apos;/api&apos;: &apos;http://localhost:3000&apos;//当用户访问api这个地址时proxy将其转到localhost:3000这个地址 &#125;, */ port: 8888//必要时可以自定义端口&#125;, 在 package.json 123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server&quot; //npm run start 开启服务器 自动刷新 目前最常用的 打包生成的dist文件直接放到内存里运行 速度更快&#125;, HotModuleReplacementPlugin 热模块更新1234567891011121314var webpack = require(&apos;webpack&apos;)//配置devServer: &#123; contentBase: &apos;./dist&apos;, open: true, hot: true, //代码更新时只会更新最新变化的部分 不会全部刷新一遍 hotOnly: true&#125;, //配置plugins: [ new webpack.HotModuleReplacementPlugin()] 使用 Babel 处理 ES6 语法1npm install --save-dev babel-loader babel-core babel-preset-env 123456&#123; test: /\\.js$/, include: &apos;../src&apos; , // 指定匹配文件的范围 exclude: /node_modules/, loader: &apos;babel-loader&apos;&#125; Tree Shaking 概念详解 把一个模块里面的没有用到的方法摇晃掉 去掉 不打包 如果对一些文件不使用此功能 则配置 package.json 添加 配置 “sideEffects”: [‘不使用此功能的文件’] .babelrc文件配置如下 123456789101112&#123; &quot;presets&quot;: [ [ &quot;env&quot; ,&#123; &quot;targets&quot;: &#123; &quot;chrome&quot;: &quot;67&quot;, &#125;, &quot;useBuiltIns&quot;: &quot;usage&quot; &#125; ] ]&#125; Develoment 和 Production 模式的区分打包 新建webpack.dev.js 开发环境 新建webpack.common.js 公共代码 新建webpack.prod.js 生产环境 详见简书配置 Webpack 和 Code Splitting 代码分割 将外来库的方法与业务逻辑代码分开打包 SplitChunksPlugin 配置参数详解 weback.common.js 1234567891011121314151617181920212223242526optimization: &#123;//优化 splitChunks: &#123; chunks: &apos;all&apos;,//同步异步代码都分割 minSize: 30000,//30kb 分割的最小限度配合cacheGroups //maxSize: 50000,//不常用 minChunks: 1,//当一个模块至少被使用了多少次的时候才代码分割 maxAsyncRequests: 5,//假设有多个库要进行分割，但这里只做分割5个 maxInitialRequests: 3,//不用修改 默认就行了 automaticNameDelimiter: &apos;~&apos;,//组和文件之间的连接符 name: true, cacheGroups: &#123;//缓存组 vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/,//在node_modules里面匹配 priority: -10,//优先级和default的优先级作比较， // 若这里的高那么就将符合上面要求的文件打包放到vender组 //filename: &apos;vender.js&apos; &#125;, default: &#123; // minChunks: 2, priority: -20, reuseExistingChunk: true ,//入一个文件已经在之前的步骤中打包过了，那这里就不用再打包了 filename: &apos;common.js&apos; &#125; &#125; &#125;&#125;, Lazy Loading 和 chunk 是什么 懒加载 即当时机成熟的时候再加载代码 promise 必须要有catch() 捕获错误 chunk表示一个文件，默认情况下webpack的输入是一个入口entry文件，输出output也是一个文件，这个文件就是一个chunk，chunkId就是产出时给每个文件一个唯一标识id，chunkhash就是文件内容的md5值，name就是在entry中指定的key值。 123//安装插件npm install --save-dev @babel/plugin-syntax-dynamic-import 12345678910111213141516//src/index.jsasync function getComponent () &#123; const &#123; default: _ &#125; = await import(&apos;lodash&apos;)//异步按需引入lodash函数库 var dom = document.createElement(&apos;div&apos;) dom.innerHTML = _.join([&apos;hello&apos;, &apos;shulu&apos;, &apos;lqy&apos;, &apos;love&apos;, &apos;you&apos;], &apos;^_^&apos;) return dom&#125;document.addEventListener(&apos;click&apos;, () =&gt; &#123; getComponent().then((dom) =&gt; &#123; document.body.appendChild(dom) &#125;).catch((err) =&gt; &#123; console.log(err) &#125;)&#125;) 123456789101112131415//.babelrc&#123; &quot;presets&quot;: [ [ &quot;env&quot; ,&#123; &quot;targets&quot;: &#123; &quot;chrome&quot;: &quot;67&quot;, &#125;, &quot;useBuiltIns&quot;: &quot;usage&quot; &#125; ] ], &quot;plugins&quot;: [&quot;@babel/plugin-syntax-dynamic-import&quot;,]//配置插件&#125; 123456//事实上webpack.common.js的配置如下即可optimization: &#123; splitChunks: &#123; chunks: &apos;all&apos;//同步异步代码都分割 &#125;&#125;, css 模块的分割打包 目前不支持模块热跟新 故在生产环境使用好一些 将webpack.common.js中的css配置文件分别拿到webpack.dev.js 和webpack.prod.js 12345678extract-text-webpack-plugin还不能支持webpack4.0.0以上的版本。 解决办法： npm install -–save-dev extract-text-webpack-plugin@next 会下载到+ extract-text-webpack-plugin@4.0.0-beta.0 然后打包就正常了//npm install --save-dev extract-text-webpack-pluginnpm install --save-dev extract-text-webpack-plugin@next 1234567891011121314151617181920212223242526//webpack.prod.jsconst ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;)//配置module: &#123; rules: [ &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: [&apos;css-loader&apos;, &apos;postcss-loader&apos;] &#125;) &#125;, &#123; test: /\\.less$/, use: ExtractTextPlugin.extract(&#123; fallback: &apos;style-loader&apos;, //如果需要，可以在 sass-loader 之前将 resolve-url-loader 链接进来 use: [&apos;css-loader&apos;, &apos;less-loader&apos;, &apos;postcss-loader&apos;] &#125;) &#125; ]&#125;,plugins: [ new ExtractTextPlugin(&quot;styles.css&quot;),] 12345//package.json 对css文件不使用tree shaking&quot;sideEffects&quot;: [ &quot;*.css&quot;], 12345678//webpack.common.jsoptimization: &#123; usedExports: true, //模块中只引入使用了的方法(函数) splitChunks: &#123; chunks: &apos;all&apos; &#125;&#125;, 将打包后的css压缩代码 1npm i -S optimize-css-assets-webpack-plugin 1234567//webpack.prod.jsconst OptimizeCSSAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;)optimization: &#123; minimizer: [new OptimizeCSSAssetsPlugin(&#123;&#125;)],&#125;, webpack Library库webpack PWA 的打包TypeScript 的打包配置WebpackDevServer 请求转发 devServer.proxy的配置 开发环境development 12345678910111213141516devServer: &#123; proxy: &#123;//代理 &quot;/api&quot;: &#123; //将所有对/api的请求转发到http://shulu520.com/test.json target: &quot;http://shulu520.com/test.json&quot;, //在开发中当后端/api还没有做好时，将路劲变为love.json, 做好后，将这里配置注释掉即可，就不用改源码了 pathRewrite: &#123;&quot;^/api&quot; : &quot;love.json&quot;&#125;, //默认不支持https的 配置后即可支持 secure: false //如果希望代理多个特定路径到同一个目标，可以这样使用 context: [&quot;/auth&quot;, &quot;/api&quot;], &#125;&#125; webpack 打包优化 跟上技术的迭代 工具的更新 在尽可能少的模块上应用loader 约束loader的应用范围 123456&#123; test: /\\.js$/, include: path.resolve(__diename, &apos;./src&apos;) exclude: /node_modules/, loader: &apos;babel-loader&apos;&#125; 尽可能少的使用plugin 并确保可靠 官网的推荐 resolve 配置项 参数的合理配置 123456//webpack.common.jsresole: &#123; alias: &#123;// 别名 简化长路劲 Child: path.resolve(__dirname, &apos;./src/a/b/c/Child&apos;) &#125;&#125; 自己编写 Loader 实现代码的装饰 loader 是转译模块源代码的转换规则。 loader 被编写为，接受源代码作为参数的函数， 并返回这些转换过的新版本代码. 手写 pluginbundler 源码编写 (模块分析) 有事您Q我👇","categories":[{"name":"webpack","slug":"webpack","permalink":"https://shulu520.com/categories/webpack/"}],"tags":[{"name":"mooc","slug":"mooc","permalink":"https://shulu520.com/tags/mooc/"}]},{"title":"js-advance-four","slug":"js-advance-four","date":"2019-05-31T02:57:20.000Z","updated":"2019-06-08T07:04:54.130Z","comments":true,"path":"js-advance/js-advance-four/","link":"","permalink":"https://shulu520.com/js-advance/js-advance-four/","excerpt":"&emsp;&emsp;这世界为何有那么可爱的人儿，儿童节快乐哦","text":"&emsp;&emsp;这世界为何有那么可爱的人儿，儿童节快乐哦 线程与进程 进程: 程序的一次执行, 它占有一片独有的内存空间 可以通过windows任务管理器查看进程 线程: 是进程内的一个独立执行单元 是程序执行的一个完整流程 是CPU的最小的调度单元 关系 一个进程至少有一个线程(主) 程序是在某个进程中的某个线程执行的 应用程序必须运行在某个进程的某个线程上 一个进程中至少有一个运行的线程: 主线程, 进程启动后自动创建 一个进程内的数据可以供其中的多个线程直接共享 多个进程之间的数据是不能直接共享的 线程池(thread pool): 保存多个线程对象的容器, 实现线程对象的反复利用 何为多进程与多线程? 多进程运行: 一应用程序可以同时启动多个实例运行 多线程: 在一个进程内, 同时有多个线程运行 比较单线程与多线程? 多线程优点：能有效提升CPU的利用率缺点：创建多线程开销 线程间切换开销 死锁与状态同步问题 单线程优点：顺序编程简单易懂缺点：效率低 JS是单线程还是多线程? js是单线程运行的 但使用H5中的 Web Workers可以多线程运行 浏览器运行是单进程还是多进程? 有的是单进程 firefox 老版IE 有的是多进程 chrome 新版IE 如何查看浏览器是否是多进程运行的呢? 任务管理器 —&gt; 进程 浏览器内核 支撑浏览器运行的最核心的程序 不同的浏览器可能不一样 Chrome, Safari : webkit firefox : Gecko IE: Trident 360,搜狗等国内浏览器: Trident + webkit 浏览器内核模块组成 主线程 js引擎模块 : 负责js程序的编译与运行 html,css文档解析模块 : 负责页面文本的解析 DOM/CSS模块 : 负责dom/css在内存中的相关处理 布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象) 分线程 定时器模块 : 负责定时器的管理 DOM事件模块 : 负责事件的管理 网络请求模块 : 负责Ajax请求 js线程 js是单线程执行的(回调函数也是在主线程) H5提出了实现多线程的方案: Web Workers 只能是主线程更新界面 定时器问题: 定时器并不真正完全定时 如果在主线程执行了一个长时间的操作, 可能导致延时才处理 事件处理机制(图) 代码分类 初始化执行代码: 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码 回调执行代码: 处理回调逻辑 js引擎执行代码的基本流程: 初始化代码===&gt;回调代码 模型的2个重要组成部分: 事件管理模块 回调队列 模型的运转流程 执行初始化代码, 将事件回调函数交给对应模块管理 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行 H5 Web Workers 可以让js在分线程执行 Worker 计算斐波那契数列的例子 12345678910//在主线程 创建一个Worker实例对象 var worker = new Worker(&apos;worker.js&apos;) // 其中worker.js为worker文件路劲 // 绑定接收消息的监听 worker.onmessage = function (event) &#123; //通信的数据都在event.data里面 alert(event.data) &#125; // 向分线程发送消息 worker.postMessage(number) 123456789101112// 在分线程 斐波那契数列function fibonacci(n) &#123; //递归调用 return n&lt;=2 ? 1 : fibonacci(n-1) + fibonacci(n-2) &#125;this.onmessage = function (event) &#123; var number = event.data console.log(&apos;分线程接收到主线程发送的数据: &apos;+number) var result = fibonacci(number)//计算斐波那契数列 postMessage(result)&#125; / 分线程中this不再是window 而是另一个全局对象 其有onmessage,postMessage等方法 故在这里可以直接调用 而不可以直接调用window的方法 如alert() // alert is not defind document 方法 等 可以更新页面的方法都不可以调用 只有主线程才可以跟新界面 / 问题: worker内代码不能操作DOM更新UI 不是每个浏览器都支持这个新特性 不能跨域加载JS 慢一点 数据传输过程 来我QQ撩我哦👇","categories":[{"name":"js-advance","slug":"js-advance","permalink":"https://shulu520.com/categories/js-advance/"}],"tags":[{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"js-advance-three","slug":"js-advance-three","date":"2019-05-30T10:42:14.000Z","updated":"2019-05-30T15:43:30.456Z","comments":true,"path":"js-advance/js-advance-three/","link":"","permalink":"https://shulu520.com/js-advance/js-advance-three/","excerpt":"&emsp;&emsp;想起你，内心充满欢喜O(∩_∩)O","text":"&emsp;&emsp;想起你，内心充满欢喜O(∩_∩)O 对象的创建模式 Object构造函数模式 套路: 先创建空Object对象, 再动态添加属性/方法 适用场景: 起始时不确定对象内部数据 问题: 语句太多 123var obj = new Object()obj.name = &apos;Tom&apos;obj.setName = function(name)&#123;this.name=name&#125; 对象字面量模式 套路: 使用{}创建对象, 同时指定属性/方法 适用场景: 起始时对象内部数据是确定的 问题: 如果创建多个对象, 有重复代码 1234var obj = &#123; name : &apos;Tom&apos;, setName : function(name)&#123;this.name = name&#125;&#125; 工厂函数模式 套路: 通过工厂函数动态创建对象并返回 适用场景: 需要创建多个对象 问题: 对象没有一个具体的类型, 都是Object类型 即通过instanceof判断得到的都是Object类型 类型不够具体 人和🐶均为同一类型 用的不多 只是比较经典 返回一个对象的函数===&gt;工厂函数 联系真实工厂 12345678910function createPerson(name, age) &#123; var obj = &#123; name: name, age: age, setName: function (name) &#123; this.name = name &#125; &#125; return obj&#125; 构造函数模式 套路: 自定义构造函数, 通过new创建实例对象 适用场景: 需要创建多个类型确定的对象 问题: 每个对象都有相同的数据, 浪费内存 123456function Person(name, age) &#123; this.name = name; this.age = age; this.setName = function(name)&#123;this.name=name;&#125;;&#125;new Person(&apos;tom&apos;, 12); 组合模式 (构造函数+原型) 套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上 适用场景: 需要创建多个类型确定的对象 123456function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.setName = function(name)&#123;this.name=name;&#125;;new Person(&apos;tom&apos;, 12); 继承模式 原型链继承 : 得到方法 12345678function Parent() &#123;&#125;Parent.prototype.test = function()&#123;&#125;;function Child() &#123;&#125;Child.prototype = new Parent(); //子类型的原型指向父类型实例Child.prototype.constructor = Child //修正constructor属性重新指向子构造函数var child = new Child(); //有test() 借用构造函数 : 得到属性(假继承) 1234567function Parent(xxx)&#123;this.xxx = xxx&#125;Parent.prototype.test = function()&#123;&#125;;function Child(xxx,yyy)&#123; Parent.call(this, xxx);//借用构造函数 this.Parent(xxx)&#125;var child = new Child(&apos;a&apos;, &apos;b&apos;); //child.xxx为&apos;a&apos;, 但child没有test() 组合继承 (原型链继承+构造函数) 利用原型链实现对父类型对象的方法继承 利用call()借用父类型构建函数初始化相同属性 12345678910function Parent(xxx)&#123;this.xxx = xxx&#125;Parent.prototype.test = function()&#123;&#125;function Child(xxx,yyy)&#123; Parent.call(this, xxx)//借用构造函数 this.Parent(xxx)&#125;Child.prototype = new Parent() //得到test()Child.prototype.constructor = Child //修正constructor属性var child = new Child(); //child.xxx为&apos;a&apos;, 也有test() new一个对象背后做了些什么? 创建一个空对象 给对象设置proto, 值为构造函数对象的prototype属性值 this.proto = Fn.prototype 执行构造函数体(给对象添加属性/方法) 来我QQ撩我哦👇","categories":[{"name":"js-advance","slug":"js-advance","permalink":"https://shulu520.com/categories/js-advance/"}],"tags":[{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"hotkey-listary","slug":"hotkey-listary","date":"2019-05-28T15:21:39.000Z","updated":"2019-05-28T15:39:24.343Z","comments":true,"path":"hotkey/hotkey-listary/","link":"","permalink":"https://shulu520.com/hotkey/hotkey-listary/","excerpt":"&emsp;&emsp;人生如逆旅，我亦是行人。","text":"&emsp;&emsp;人生如逆旅，我亦是行人。 listary 最常用的快捷键 alt A 打开listary 双击 ctrl 打开listary bing 必应搜索 bd 百度一下 百度网盘 zh 知乎搜索 ctrl N 向下切换选中的目录 ctrl P 向上切换选中的目录 双击桌面 打开listary选项 在任意文件夹/目录下双击 打开listary选项 可以选命令打开cmd &emsp;&emsp;未完待续…… 来我QQ撩我哦👇","categories":[{"name":"hotkey","slug":"hotkey","permalink":"https://shulu520.com/categories/hotkey/"}],"tags":[{"name":"listary","slug":"listary","permalink":"https://shulu520.com/tags/listary/"}]},{"title":"hotkey-windows","slug":"hotkey-windows","date":"2019-05-27T04:24:05.000Z","updated":"2019-05-27T04:46:38.907Z","comments":true,"path":"hotkey/hotkey-windows/","link":"","permalink":"https://shulu520.com/hotkey/hotkey-windows/","excerpt":"&emsp;&emsp; 👉Q我吧","text":"&emsp;&emsp; 👉Q我吧 windows 最常用快捷键 ctrl w 关闭当前网页 f2键 ：选中后按f2键即可重命名文件，另一种方法，点一下文件名，稍等，再点一下，即可重命名 f4: 重复上步操作 f5: 刷新桌面 刷新网页 f11: 全屏显示网页 shift : 省略号 shift + 数字6 （表示六个点） …… 书名号 shift + &lt;&gt; (小于大于） 分隔号 单独按 数字1 前面的键 《简 · 爱》 Alt + 单击拖动 为矩形选择 AlT + f4 关闭当前程序 删除 选中后 按delete 永久删除 选中后 shift +delete 截屏 PrtSc 截全屏 Alt +PrtSc 截当前窗口 ctrl alt delete 任务管理器 windows 打开开始菜单 ctrl shift n 新建文件夹 window e 打开文件资源管理器 alt tab 切换窗口 window d 回到桌面 &emsp;&emsp;学到了再来补充😝 👉点这里，进入QQ交流","categories":[{"name":"hotkey","slug":"hotkey","permalink":"https://shulu520.com/categories/hotkey/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://shulu520.com/tags/windows/"}]},{"title":"js-advance-two","slug":"js-advance-two","date":"2019-05-25T15:06:08.000Z","updated":"2019-05-30T15:49:15.430Z","comments":true,"path":"js-advance/js-advance-two/","link":"","permalink":"https://shulu520.com/js-advance/js-advance-two/","excerpt":"","text":"&emsp;&emsp;又是元气满满的一天😝,文章链接失效，又好了。有惊无险 来我QQ撩我哦👇 原型与原型链 所有函数都有一个特别的属性: prototype : 显式原型属性 所有实例对象都有一个特别的属性: proto : 隐式原型属性 当然所有函数也都有一个特别的属性： proto : 隐式原型属性 且所有函数的 隐式原型 都一样 都等于Function的显式原型 函数的显式原型指向的对象默认是空Object实例对象(但Object不满足) 123console.log(Fn.prototype instanceof Object) // trueconsole.log(Object.prototype instanceof Object) // falseconsole.log(Function.prototype instanceof Object) // true 所有函数都是Function的实例(包含Function自身) 1console.log(Function.__proto__===Function.prototype) Object的原型对象是原型链尽头 1console.log(Object.prototype.__proto__) // null 1234567891011121314151617// 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)console.log(Date.prototype, typeof Date.prototype)function Fun () &#123;//alt + shift +r(重命名rename)&#125;console.log(Fun.prototype) // 默认指向一个Object空对象(没有我们的属性)// 原型对象中有一个属性constructor, 它指向函数对象console.log(Date.prototype.constructor===Date)console.log(Fun.prototype.constructor===Fun)//给原型对象添加属性(一般是方法) ===&gt;实例对象可以访问Fun.prototype.test = function () &#123; console.log(&apos;test()&apos;)&#125;var fun = new Fun()fun.test() 显式原型与隐式原型的关系 函数的prototype: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象 实例对象的proto: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值 原型对象即为当前实例对象的父对象 原型链 所有的实例对象都有proto属性, 它指向的就是原型对象 这样通过proto属性就形成了一个链的结构—-&gt;原型链 当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找 当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作,如果当前对象中没有此属性, 直接添加此属性并设置其值 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上 面试题1 1234567891011121314function A () &#123; ...&#125;A.prototype.n = 1var b = new A()A.prototype = &#123; n: 2, m: 3&#125;var c = new A()console.log(b.n, b.m, c.n, c.m) // 1 undifind 2 3 面试题2 12345678910111213141516function F ()&#123;&#125; Object.prototype.a = function()&#123; console.log(&apos;a()&apos;)&#125;Function.prototype.b = function()&#123; console.log(&apos;b()&apos;)&#125;var f = new F()f.a()f.b() // 找不到,可以看原型链图进行分析F.a()F.b() instanceof是如何判断的? 表达式: A instanceof B 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false Function是通过new自己产生的实例 123456789101112131415161718/*案例1 */function Foo() &#123; &#125;var f1 = new Foo()console.log(f1 instanceof Foo) // trueconsole.log(f1 instanceof Object) // true/*案例2 */console.log(Object instanceof Function) // trueconsole.log(Object instanceof Object) // trueconsole.log(Function instanceof Function) // trueconsole.log(Function instanceof Object) // truefunction Foo() &#123;&#125;console.log(Object instanceof Foo) // false 执行上下文与执行上下文栈 变量提升与函数提升 变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined) 函数提升: 在函数定义语句之前, 就执行该函数 先执行变量提升, 再执行函数提升 123function a() &#123;&#125;var aconsole.log(typeof a) // &apos;function&apos; 123456789101112var c = 1function c(c) &#123; console.log(c) var c = 3&#125;c(2) // 报错 c is not a function过程解析： var c fun c c = 1 c(2) 理解 执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性 执行上下文栈: 用来管理产生的多个执行上下文 分类: 全局: window 函数: 对程序员来说是透明的 生命周期 全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡 函数 : 调用函数时产生, 函数执行完时死亡 包含哪些属性: 全局 : 用var定义的全局变量 ==&gt;undefined 使用function声明的函数 ===&gt;function this ===&gt;window 函数 用var定义的局部变量 ==&gt;undefined 使用function声明的函数 ===&gt;function this ===&gt; 调用函数的对象, 如果没有指定就是window 形参变量 ===&gt;对应实参值 arguments ===&gt;实参列表的伪数组 执行上下文 创建和初始化的过程 全局执行上下文: 在全局代码执行前最先创建一个全局执行上下文(window) 收集一些全局变量, 并初始化 var定义的全局变量==&gt;undefined, 添加为window的属性 function声明的全局函数==&gt;赋值(fun), 添加为window的方法 this==&gt;赋值(window) 开始执行全局代码 函数执行上下文: 在调用函数时, 在执行函数体之前，先创建一个函数执行上下文对象(虚拟的, 存在于栈中) 收集一些局部变量, 并初始化 形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性 arguments==&gt;赋值(实参列表), 添加为执行上下文的属性 var定义的局部变量==&gt;undefined, 添加为执行上下文的属性 function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法 this==&gt;赋值(调用函数的对象) 开始执行函数体代码 执行上下文栈 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象 在全局执行上下文(window)确定后, 将其添加到栈中(压栈) 在函数执行上下文创建后, 将其添加到栈中(压栈) 在当前函数执行完后,将栈顶的对象移除(出栈) 当所有的代码执行完后, 栈中只剩下window 12345678910var a = 10var bar = function (x) &#123; var b = 5 foo(x + b)&#125;var foo = function (y) &#123; var c = 5 console.log(a + c + y)&#125;bar(10) 产生执行上下文的个数 = (N)函数调用次数 + 1 面试题 整个过程中产生了几个执行上下文? 5 依次输出什么? gb: undefined fb: 1 fb: 2 fb: 3 fe: 3 fe: 2 fe: 1 ge: 1 123456789101112console.log(&apos;gb: &apos;+ i)var i = 1foo(1)function foo(i) &#123; if (i == 4) &#123; return &#125; console.log(&apos;fb:&apos; + i) foo(i + 1) // 递归调用: 在函数内部调用自己 console.log(&apos;fe:&apos; + i)&#125;console.log(&apos;ge: &apos; + i) 作用域与作用域链 理解: 作用域: 一块代码区域, 在编码时就确定了, 不会再变化 作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量 产生作用域的个数 = (N)定义函数的个数 + 1 分类: 全局 函数 js没有块作用域(在ES6之前) 作用 作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突 作用域链: 查找变量 区别作用域与执行上下文 作用域: 静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了 执行上下文: 动态的, 执行代码时动态创建, 当执行结束消失 联系: 执行上下文环境是在对应的作用域中的 面试题 12345678910111213141516var x = 10; function fn() &#123; console.log(x); &#125; function show(f) &#123; var x = 20; f(); &#125; show(fn); // 10 /* 解析：作用域在函数创建的时候就确定了，一旦确定就不会变化了 */ 1234567891011121314151617var fn = function () &#123; console.log(fn) &#125; fn() // fn函数体 var obj = &#123; fn2: function () &#123; console.log(fn2) &#125; &#125; obj.fn2() // fn2 is not defind /* 解析： 首先在fn2函数作用域里面找fn2 没有 然后再全局作用域找 也没有 故报错 若为this.fn2 则可以 */ 作用域链和原型链的用处 作用域链用来找变量 原型链用来找方法 在全局直接找一个不存在的方法 a is not defined 而通过window.a 则为undifind 闭包 如何产生闭包? 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包 闭包到底是什么? 使用chrome调试查看 会调试的程序员至少不是初级程序员 理解一: 闭包是嵌套的内部函数(绝大部分人) 初步认识 理解二: 包含被引用变量(函数)的对象(极少数人) 高级认识 注意: 闭包存在于嵌套的内部函数中 产生闭包的条件 函数嵌套 内部函数引用了外部函数的数据(变量/函数) 产生闭包的个数 等于外部函数调用的次数 12345678910//三个button按钮for (var i = 0,length=btns.length; i &lt; length; i++) &#123; (function (j) &#123; var btn = btns[j] btn.onclick = function () &#123; alert(&apos;第&apos;+(j+1)+&apos;个&apos;) &#125; &#125;)(i) &#125;// 共产生三个闭包 因为外部函数共调用了三次，每一闭包内部都保存了各自的变量 常见的闭包 将函数作为另一个函数的返回值 将函数作为实参传递给另一个函数调用 闭包生命周期 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用) 死亡: 在嵌套的内部函数成为垃圾对象时 12345678910111213function fn1() &#123; //此时闭包就已经产生了(函数提升, 内部函数对象已经创建了) var a = 2 function fn2 () &#123; a++ console.log(a) &#125; return fn2&#125;var f = fn1() //f来接收fn2f() // 3f() // 4f = null //闭包死亡(包含闭包的函数对象成为垃圾对象) 作用: 延长局部变量的生命周期 让函数外部能操作内部的局部变量 写一个闭包程序 1234567891011function fn1() &#123; var a = 2 function fn2() &#123; a++ console.log(a) &#125; return fn2&#125;var f = fn1()f()f() 闭包应用: 模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为 循环遍历加监听 JS框架(jQuery)大量使用了闭包 缺点: 变量占用内存的时间可能会过长 可能导致内存泄露 解决: 及时释放 : f = null; //让内部函数对象成为垃圾对象 面试题1 123456789101112131415161718192021222324//代码片段一var name = &quot;The Window&quot;;var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); // the window//代码片段二var name2 = &quot;The Window&quot;;var object2 = &#123; name2 : &quot;My Object&quot;, getNameFunc : function()&#123; var that = this; return function()&#123; return that.name2; &#125;; &#125;&#125;;alert(object2.getNameFunc()()); // my object 内存溢出与内存泄露 内存溢出 一种程序运行出现的错误 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误 内存泄露 占用的内存没有及时释放 内存泄露积累多了就容易导致内存溢出 常见的内存泄露: 意外的全局变量 没有及时清理的计时器或回调函数 闭包 &gt;👉点这里，进入QQ交流","categories":[{"name":"js-advance","slug":"js-advance","permalink":"https://shulu520.com/categories/js-advance/"}],"tags":[{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"js-advance-one","slug":"js-advance-one","date":"2019-05-24T06:13:53.000Z","updated":"2019-05-27T04:54:45.525Z","comments":true,"path":"js-advance/js-advance-one/","link":"","permalink":"https://shulu520.com/js-advance/js-advance-one/","excerpt":"能够让你后悔的从来不是你做过的事而是你想做却没有去做的事👉Q我吧","text":"能够让你后悔的从来不是你做过的事而是你想做却没有去做的事👉Q我吧 数据类型的分类和判断 基本(值)类型 Number —– 任意数值 ——– typeof String —– 任意字符串 —— typeof Boolean —- true/false —– typeof undefined — undefined —– typeof/=== null ——– null ———- === 对象(引用)类型 Object —– 任意对象 —– typeof/instanceof Array —— 一种特别的对象(数值下标)—– instanceof Function —- 一种特别的对象(可以执行，内部数据是有序的) —– typeof 判断 typeof ——– 返回数据类型的字符串表达 不能判断 null和object ， object和array instanceof —- 判断对象的具体类型 a instanceof b 即a是否是b构造函数的一个实例 === ———— 可以判断 undefined 和 null 名词解释 实例 实例对象 类型 类型对象 即构造函数 undefined与null的区别? undefined代表定义未赋值 nulll定义并赋值了, 只是值为null 什么时候给变量赋值为null呢? 初始赋值, 表明将要赋值为对象 结束前, 让对象成为垃圾对象(被垃圾回收器回收) 严格区别变量类型与数据类型? 数据的类型 基本类型 对象类型 变量的类型(变量内存值的类型) 基本类型: 保存就是基本类型的数据 引用类型: 保存的是地址值 数据,变量, 内存的理解 什么是数据? 在内存中可读的, 可传递的保存了特定信息的’东东’ 一切皆数据, 函数也是数据 在内存中的所有操作的目标: 数据 什么是变量? 在程序运行过程中它的值是允许改变的量 一个变量对应一块小内存, 它的值保存在此内存中 什么是内存? 内存条通电后产生的存储空间(临时的) 一块内存包含2个方面的数据 内部存储的数据 地址值数据 内存空间的分类 栈空间: 全局变量和局部变量 堆空间: 对象 内存,数据, 变量三者之间的关系 内存是容器, 用来存储不同数据 变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据 问题: var a = xxx, a内存中到底保存的是什么? xxx是基本数据, 保存的就是这个数据 xxx是对象, 保存的是对象的地址值 xxx是一个变量, 保存的xxx的内存内容(可能是基本数据, 也可能是地址值) 关于引用变量赋值问题 2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据 2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象 1234567891011121314151617181920212223let obj1 = &#123; name: &apos;lqy&apos; &#125;情形一function fn1(obj) &#123; obj.name = &apos;shulu&apos;&#125;fn1(obj1)console.log(obj1.name) // shulu情形二funtion fn2(obj) &#123; obj = &#123;name: &apos;shulu&apos;&#125;&#125;fn2(obj1)console.log(obj1.name) // lqy/*解析：形参obj 在函数内部为 var obj变量执行fn( ) 传入实参obj1 即将obj1的值(这里是地址值)复制一份给obj变量*/ 问题: 在js调用函数时传递变量参数时, 是值传递还是引用传递 理解1: 都是值(基本值/地址值)传递 推荐 理解2: 可能是值传递, 也可能是引用传递(地址值) 问题: JS引擎如何管理内存? 内存生命周期 分配小内存空间, 得到它的使用权 存储数据, 可以反复进行操作 释放小内存空间 释放内存 局部变量: 函数执行完自动释放 对象: 成为垃圾对象==&gt;垃圾回收器回收 对象的理解和使用 什么是对象? 多个数据(属性)的集合 用来保存多个数据(属性)的容器 属性组成: 属性名 : 字符串(标识) 属性值 : 任意类型 属性的分类: 一般 : 属性值不是function 描述对象的状态 方法 : 属性值为function的属性 描述对象的行为 特别的对象 数组: 属性名是0,1,2,3之类的索引 函数: 可以执行的 如何操作内部属性(方法) .属性名 [‘属性名’]: 属性名有特殊字符/属性名是一个变量 问题: 什么时候必须使用[‘属性名’]的方式? 属性名包含特殊字符: - 空格 属性名不确定 函数的理解和使用 什么是函数? 用来实现特定功能的, n条语句的封装体 只有函数类型的数据是可以执行的, 其它的都不可以 为什么要用函数? 提高复用性 便于阅读交流 函数也是对象 instanceof Object===true 函数有属性: prototype 函数有方法: call()/apply() 可以添加新的属性/方法 如何调用(执行)函数? test(): 直接调用 obj.test(): 通过对象调用 new test(): new调用 test.call/apply(obj): 临时让test成为obj的方法进行调用 函数中的this是什么? 任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window 所有函数内部都有一个变量this 它的值是调用函数的当前对象 如何确定this的值? test(): window p.test(): p var p = new test(): 新创建的对象p p.call(obj): obj 1234567891011121314151617181920212223242526272829303132333435function Person(color) &#123; console.log(this) this.color = color; this.getColor = function () &#123; console.log(this) return this.color; &#125;; this.setColor = function (color) &#123; console.log(this) this.color = color; &#125;; &#125; Person(&quot;red&quot;); //this是谁? window var p = new Person(&quot;yello&quot;); //this是谁? p p.getColor(); //this是谁? p var obj = &#123;&#125;; p.setColor.call(obj, &quot;black&quot;); //this是谁? obj var test = p.setColor; test(); //this是谁? window function fun1() &#123; function fun2() &#123; console.log(this); &#125; fun2(); //this是谁? window &#125; fun1(); 匿名函数自调用: 123(function(w, obj)&#123; //实现代码&#125;)(window, obj) 专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式 作用 隐藏实现 不会污染外部(全局)命名空间 用它来编码js模块 回调函数的理解 什么函数才是回调函数? 你定义的 你没有调用 但它最终执行了(在一定条件下或某个时刻) 常用的回调函数 dom事件回调函数 定时器回调函数 ajax请求回调函数(后面讲解) 生命周期回调函数(后面讲解) 问题 js一条语句的后面是否应该加分号？ 是否加分号是编码风格问题，没有应不应该，只有喜不喜欢——尤雨溪 必须加分号的情况： 小括号开头的语句 ;(function () {…})() 方括号的开头 ;[1, 2, 3].forEach(() =&gt; {}) &emsp;&emsp;本篇笔记到此完结。 👉点这里，进入QQ交流","categories":[{"name":"js-advance","slug":"js-advance","permalink":"https://shulu520.com/categories/js-advance/"}],"tags":[{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"js-modularize","slug":"js-modularize","date":"2019-05-23T14:17:24.000Z","updated":"2019-06-01T15:57:35.557Z","comments":true,"path":"js-modularize/js-modularize/","link":"","permalink":"https://shulu520.com/js-modularize/js-modularize/","excerpt":"&emsp;&emsp; 👉来QQ撩我啊","text":"&emsp;&emsp; 👉来QQ撩我啊 modularize 一阶段 所有的代码都写在一个文件下 即暴露在全局环境下 污染环境 二阶段 将某些api 放到一个对象之中 使用时通过obj.xxx来调用 不安全 因为在别处同样可以通过obj.xxx来将其修改掉 三阶段 匿名函数自执行(闭包) 安全 JQuery 就是这么做的 引入js文件太多 请求过多 依赖模糊 12345678910111213(function( window )&#123; function foo () &#123; ... &#125; ... // 将foo方法挂载到window上的xxx属性对象上 // 调用时xxx.foo()即可 window.xxx = &#123; foo &#125; // 或将foo方法挂载到window上的xxx属性对象上，作为一个函数 // 调用时直接foo()执行即可 window.xxx = foo &#125;)( window ) 模块化规范commonJs 一个js文件就是一个模块 向外暴露1 module.exports = value value可以是任意值 向外暴露2 exports.xxx = value value可以是任意值 引入模块 require(‘包名’) 自己写的文件要相对路劲 AMD define CMD 阿里大牛结合commonjs和AMD写的 卖给老外了 ES6 webpack 模块打包工具 分别暴露 即常规暴露相当于一个模块中有许多个变量export xxx = …export yyy = …export zzz = … 引入时要解构赋值 指名道姓拿到相应的变量import { xxx, yyy, zzz } from ‘路劲’ 统一暴露 默认暴露export default {…} 引入时 import xxx from ‘路劲’ &emsp;&emsp;未完待续…… 👉点这里，跟我聊QQ","categories":[{"name":"js-modularize","slug":"js-modularize","permalink":"https://shulu520.com/categories/js-modularize/"}],"tags":[{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"IT-proper-nouns","slug":"IT-proper-nouns","date":"2019-05-23T14:02:57.000Z","updated":"2019-07-17T03:38:23.052Z","comments":true,"path":"IT/IT-proper-nouns/","link":"","permalink":"https://shulu520.com/IT/IT-proper-nouns/","excerpt":"&emsp;&emsp;找到一件可以为之疯狂的事情，是一个人活着最大的意义。 👉来QQ撩我啊","text":"&emsp;&emsp;找到一件可以为之疯狂的事情，是一个人活着最大的意义。 👉来QQ撩我啊 Hack hack是基于开源的程序的基础，对其代码进行增加、删除或者修改、优化，使之在功能上符合新的需求。 api 应用程序接口(Application Programming Interface) cli 命令行界面(Command Line Interface) sdk 软件开发工具包(Software Development Kit) rc 结尾的文件 run control 运行时控制文件 thread 线程 它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 progress 进程是一个“执行中的程序”。 进程是线程的容器。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。 有以下特征 动态性：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。 并发性：任何进程都可以同其他进程一起并发执行 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位； 异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进 结构特征：进程由程序、数据和进程控制块三部分组成。 &emsp;&emsp;未完待续…… 👉点这里，跟我QQ聊天呗","categories":[{"name":"IT","slug":"IT","permalink":"https://shulu520.com/categories/IT/"}],"tags":[]},{"title":"node-koa2","slug":"node-koa2","date":"2019-05-21T17:54:24.000Z","updated":"2019-05-21T18:02:24.876Z","comments":true,"path":"node/node-koa2/","link":"","permalink":"https://shulu520.com/node/node-koa2/","excerpt":"&emsp;&emsp;hello my world","text":"&emsp;&emsp;hello my world 开始 github创建仓库 本地git clone 仓库 项目目录下 初始化 npm initnpm start 启动快捷方法 在package.json 中添加配置 12&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node server/index.js&quot;, 添加 .gitignore 文件 1234567891011121314# dependenciesnode_modules# logsnpm-debug.log# System.DS_Store#Generatedist# Buildbulid pug 模板引擎npm i pug -S &emsp;&emsp;未完待续…… write to me by QQ email","categories":[{"name":"node","slug":"node","permalink":"https://shulu520.com/categories/node/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://shulu520.com/tags/nodejs/"},{"name":"koa2","slug":"koa2","permalink":"https://shulu520.com/tags/koa2/"}]},{"title":"async-fn-note","slug":"async-fn-note","date":"2019-05-20T02:00:01.000Z","updated":"2019-05-20T02:00:01.517Z","comments":true,"path":"uncategorized/async-fn-note/","link":"","permalink":"https://shulu520.com/uncategorized/async-fn-note/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 正文： &emsp;&emsp; write to me by QQ email","categories":[],"tags":[]},{"title":"arrow-js-note","slug":"arrow-js-note","date":"2019-05-19T16:11:45.000Z","updated":"2019-05-21T18:01:18.888Z","comments":true,"path":"arrowjs/arrow-js-note/","link":"","permalink":"https://shulu520.com/arrowjs/arrow-js-note/","excerpt":"&emsp;&emsp;今天是2019年，520，在这特殊的一天我面对的依然是code, but no Object, 我希望有一天能美梦成真——面向对象面向君，不负代码不负卿。","text":"&emsp;&emsp;今天是2019年，520，在这特殊的一天我面对的依然是code, but no Object, 我希望有一天能美梦成真——面向对象面向君，不负代码不负卿。 箭头函数的经典题型 有关 this 1234567891011121314151617181920212223242526272829let obj = &#123; id: 01, say: function () &#123; // 这里的this为obj setTimeout(function () &#123; // 这里是匿名函数的this默认为window console.log(&apos;arrow id:&apos;, this.id); // undifind &#125;, 100); &#125;, sayWithThis: function () &#123; // 这里将this的值当成变量存起来 let that = this; setTimeout(function () &#123; console.log(&apos;arrow id:&apos;, that.id); // 01 &#125;, 100); &#125;, sayWithArrow: function () &#123; // 这里的this为obj setTimeout(() =&gt; &#123; console.log(&apos;arrow id:&apos;, this.id); // 01 &#125;, 100); &#125;, sayWithGlobalArrow: () =&gt; &#123; // 这里的this已经为全局的this了 setTimeout(() =&gt; &#123; console.log(&apos;arrow id:&apos;, this.id); // undifind &#125;, 100); &#125;&#125;; &emsp;&emsp;未完待续…… write to me by QQ email","categories":[{"name":"arrowjs","slug":"arrowjs","permalink":"https://shulu520.com/categories/arrowjs/"}],"tags":[{"name":"arrowjs","slug":"arrowjs","permalink":"https://shulu520.com/tags/arrowjs/"}]},{"title":"git-qa-note","slug":"git-qa-note","date":"2019-05-18T04:11:06.000Z","updated":"2019-05-18T04:20:20.472Z","comments":true,"path":"git/git-qa-note/","link":"","permalink":"https://shulu520.com/git/git-qa-note/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 科学上网之后，git 报错 如下错误： 12345ssh: Could not resolve hostname github.com: Name or service not knownfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 解决方法1、找到本机的 host 文件，一般位置是进入 C:\\Windows\\System32\\drivers\\etc 2、在host文件的最后一行加上，如果之前已经设置过，可以将ip地址更改为最新的正确的ip地址 192.30.255.112 github.com git185.31.16.184 github.global.ssl.fastly.net &emsp;&emsp;遇到后继续补充…… write to me by QQ email","categories":[{"name":"git","slug":"git","permalink":"https://shulu520.com/categories/git/"}],"tags":[{"name":"git-qa","slug":"git-qa","permalink":"https://shulu520.com/tags/git-qa/"}]},{"title":"Array-note","slug":"Array-note","date":"2019-05-17T16:41:04.000Z","updated":"2019-06-23T15:46:35.088Z","comments":true,"path":"Array/Array-note/","link":"","permalink":"https://shulu520.com/Array/Array-note/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; reduce 计算数组成员的个数 123const countOccurrences = (arr,val) =&gt; arr.reduce((a,v) =&gt; (v === val ? a + 1 : a), 0)alert(countOccurrences([1,111,2,2,2,3,4], 2)); // 3 max Math.max.apply(null, arr) Math.max(…arr) &emsp;&emsp;未完待续…… write to me by QQ email","categories":[{"name":"Array","slug":"Array","permalink":"https://shulu520.com/categories/Array/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://shulu520.com/tags/Array/"}]},{"title":"node-blue-note","slug":"node-blue-note-md","date":"2019-05-16T13:44:45.000Z","updated":"2019-05-18T05:42:53.876Z","comments":true,"path":"node/node-blue-note-md/","link":"","permalink":"https://shulu520.com/node/node-blue-note-md/","excerpt":"&emsp;&emsp;我本来要忘记你了，可我又做梦了。","text":"&emsp;&emsp;我本来要忘记你了，可我又做梦了。 node http 模块 GET方式 123456789const http = require(&apos;http); //创建一个服务器var server = http.createServer((req, res) =&gt; &#123; /* 给这个地址随便提交一个表单 http://localhost:8080/aaa 其中 req.url = &apos;/aaa?user=shulu&amp;pass=123&apos; 运用字符串的切割数组的拼接就可以拿到用户名与密码 */&#125;).listen(8080); queryString 模块 GET方式争对这种数据 xxx=…&amp;yyy=…&amp;zzz=… 123const querystring = require(&apos;queryString&apos;);var json = querystring.parse(&apos;user=shulu&amp;pass=123&amp;age=18&apos;);console.log(json) // &#123;&quot;user&quot;: &quot;shulu&quot;, &quot;pass&quot;: &quot;123&quot;, &quot;age&quot;: &quot;18&quot;&#125; url 模块 GET方式争对这种数据 整个url部分 参数为true效果更好 1234567const http = require(&apos;http);const _url = require(&apos;url&apos;);var server = http.createServer((req, res) =&gt; &#123; var obj = _url.parse(req.url, true); var url = obj.pathname; const GET = obj.query;&#125;).listen(8080); http 模块 POST方式 12345678910111213const http = require(&apos;http&apos;);const querystring = require(&apos;querystring&apos;);var server = http.createServer((req, res) =&gt;&#123; //请求数据一样在req中 var str = &apos;&apos;; //data数据大 分多次到达 req.on(&apos;data&apos;, (data) =&gt; &#123; //data事件 str += data; &#125;); req.on(&apos;end&apos;, () =&gt; &#123; var POST = querystring.parse(str) &#125;);&#125;).listen(8888); express 框架 express保留了原生的功能，增加了一些自己的功能 基本使用 123456789const express = require(&apos;express&apos;);var server = express();server.use(&apos;/a.html&apos;, function (req, res) &#123; //res.send() 方法参数可以是json等 //res.write() 参数只能是字符串或buffer res.send(&apos;aaaa&apos;); res.end();&#125;);server.listen(8080); 三种接收处理请求的方法 123server.get()server.post()server.use() express-static 插件 处理静态文件的 1234567const express = require(&apos;express&apos;);const expresStatic = require(&apos;express-static&apos;);var server = express();server.listen(8888);server.use(expresStatic(&apos;./www&apos;)); 中间件 body-parser 解析POST数据 1234server.use(bodyParser.urlencode(&#123; extend: false, //扩展模式 limit: 1024*1024 //限制1M&#125;)); multer 解析post文件 multipart/form-data 格式的表单数据 链式操作 next 1234567server.use(&apos;/&apos;, function (req, res, next) &#123; console.log(&apos;aaa&apos;); next();&#125;);server.use(&apos;/&apos;, function (req, res, next) &#123; console.log(&apos;bbb&apos;);&#125;); 模板引擎 ejspath 模块12345678const path = require(&apos;path&apos;);var str = &apos;c:\\\\user\\\\www\\\\a.html&apos;;var obj = path.parse(str);console.log(obj);//base: 文件名部分 如a.html//ext: 扩展名 如.html//dir: 文件路劲 如c:\\\\user\\\\www &emsp;&emsp;未完待续…… write to me by QQ email","categories":[{"name":"node","slug":"node","permalink":"https://shulu520.com/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://shulu520.com/tags/node/"},{"name":"blue","slug":"blue","permalink":"https://shulu520.com/tags/blue/"}]},{"title":"hotkey-vim","slug":"hotkey-vim","date":"2019-05-15T15:34:56.000Z","updated":"2019-06-19T09:03:18.680Z","comments":true,"path":"hotkey/hotkey-vim/","link":"","permalink":"https://shulu520.com/hotkey/hotkey-vim/","excerpt":"&emsp;&emsp;You only live on this earth once.","text":"&emsp;&emsp;You only live on this earth once. vim编辑器 vi 加文件名 进入编辑器页面 按下a 键 进入编辑模式 编辑完成 (在英文输入下)按esc退出编辑模式 按:wq 回车 即可保存并退出 vim 复制/剪切/粘贴/撤销操作 按esc退出编辑模式 按v 键进入视图模式 由方向键控制选中的内容区域 复制 y键 剪贴 d键 粘贴 p键 撤销 在命令行模式下用 :u 撤销最近一次操作 快捷强大的vim 浏览器插件 vim能提升我们的浏览速度, 鼠标比键盘简单, 键盘比鼠标快! 快速向下滚动d 快速向上滚动u 滚动到页面顶部gg 滚动到页面底部G 神技! 快速搜索 (相当于浏览器顶部搜索框), 并在新标签打开 大写的O 关闭页面x 恢复页面X 主动脱离焦点esc 比如按下o搜索退出时按esc shift+/,查看所有快捷键 &emsp;&emsp;未完待续…… write to me by QQ email","categories":[{"name":"hotkey","slug":"hotkey","permalink":"https://shulu520.com/categories/hotkey/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://shulu520.com/tags/vim/"}]},{"title":"nodejs-guigu","slug":"nodejs-guigu","date":"2019-05-14T14:50:21.000Z","updated":"2019-05-27T04:57:45.581Z","comments":true,"path":"node/nodejs-guigu/","link":"","permalink":"https://shulu520.com/node/nodejs-guigu/","excerpt":"&emsp;&emsp;我期待有一天背着背包出现在你的城市。","text":"&emsp;&emsp;我期待有一天背着背包出现在你的城市。 环境变量 小娜 输入 环境变量 进入环境变量/用户变量/path 点开 里面是一条条的文件路劲 可以新建一个文件的路劲 在这里配置了 相当于 声明了一个 类似于 js 中的全局变量 为作用域链的最高层 可以将一些常用的文件或程序的路劲添加到path下 这样我们就可以在任意的位置访问他们了 进程 线程 进程 负责为程序的运行提供必备的环境 工厂的车间 线程 负责执行进程中的程序 车间工人 单线程 一个人干活 多线程 多人合作干一个活 node.js 事件驱动 非阻塞 异步I/O (性能瓶颈阶段) input写入操作 output读操作 版本 奇数为开发版 偶数为稳定版 在Node中，模块分为三类：一类是底层由C++编写的内建模块，一类是Node提供的核心模块；还有一类是用户编写的模块，称为文件模块。node.js 模块化 新建一个js文件就是一个模块 这个模块里面写的代码其实是包在一个函数里面的 即 123456789101112131415funcyion (exports, require, module, _filename, _dirname) &#123; /* 这里是我们写的代码 外面其实包了一层这个函数 默认不可见 可以通过console.log(arguments.callee) 或 console.log(arguments.callee + &quot;&quot;) 将此函数打印出来 该函数执行时传进了5个参数 所以模块里面的代码是局部变量 exports参数 用来将变量或函数暴露到外边 require参数 用来引入外部的模块 module参数 代表模块本身 exports是module的属性 _filename 当前模块的完整路劲 _dirname 当前模块所在文件夹的路劲 */&#125; module.exports 与exports的区别 module.exports == exports true exports 只能使用.的方式向外暴露 若exports = {} 这样向外暴露的话就修改了exports的引用对象 module.exports 既可以通过.的形式 也可以直接赋值 推荐写法 核心模块 由node 提供的模块 node_moudle中的 引入时直接写模块名字 不需要路劲 文件模块 由我们自己创建的模块 引入时添加./或../等路劲 包 package 包实际上就是一个压缩文件 解压以后还原为目录 规范的目录包含以下文件： -package.json 包描述文件 (必须的) 里面不能写注释 -bin 可执行二进制文件 binary 二进制 -lib js代码 library 库 图书馆 -doc 文档 document -test 单元测试 npm 即 (Node Package Manager) node包管理器 commonjs包规范的是一种理论 npm是其中一种实践 对node而言 npm帮助其完成了第三方模块的发布安和依赖 借助npm 使得node与第三方模块之间形成一个生态系统 查看版本 npm version查看相关的版本 或npm -v npm search 包名 搜索包 npm init 在某一文件夹下初始化该文件夹 帮助我们根据提示生成一个package.json的文件 在初始化后的文件夹下 安装搜索的包 并新建一个index.js 入口文件在里面就可以直接引入math模块使用了 npm install 包名 安装 包 或npm i npm remove 或 npm r 删除包 npm install 包名 杠杠save 安装包并添加到依赖中 npm install 下载当前项目所依赖的包 npm install 包名 -g 全局安装包 一般是安装一些工具 如vue-cli cnpm 也可以用 快速 node在使用下载的包时 会沿着作用域链一直往上找直到磁盘根目录找不到则报错 这就解释了某的包在删除之后依然能用的情况 Buffer （缓冲区） 结构和数组很相似 方法也类似 补充了数组方法的不足 Buffer专门存贮二进制数据的 实际上Buffer中的内存不是通过JavaScript分配的，而是在底层通过C++申请的。也就是我们可以直接通过Buffer来创建内存中的空间。 使用buffer无需引入模块 直接使用即可 Buffer.from(str) 将字符串str转为buffer二进制数据 在buffer中存贮的都是二进制数据 但在显示时都是以16进制的形式显示的 二进制 00-255 或 00-ff 计算机 一个0或一个1 称为一位(bit) 8bit = 1byte(字节) 最小单位 中文一个汉字占用三个字节 创建一个制定大小的buffer Buffer.alloc(10) 10字节大小 可通过索引来操作buffer中的元素 Buffer的大小一旦确定 不能再更该 因为存储空间是连续的 性能好 Buffer与字符串间的转换 支持的编码: ASCII、UTF-8、UTF-16LE/UCS-2、Base64、Binary、Hex 字符串转Buffer Buffer.from(str , [encoding]); Buffer转字符串 buf.toString() buf.toString([encoding] , [start] , [end]); 复制缓冲区 buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]]) 对缓冲区切片 buf.slice([start[, end]]) 拼接缓冲区 Buffer.concat(list[, totalLength]) fs (文件系统) 在Node中，与文件系统的交互是非常重要的，服务器的本质就将本地的文件发送给远程的客户端 核心模块 直接引入使用 const fs = require(‘fs’) fs 模块中所有的操作都有两种形式 同步(会阻塞 带sync) 异步(不会阻塞 带回调函数) fs模块中所有的操作都有两种形式可供选择同步和异步 同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码。异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。 打开文件 fs.open(path, flags[, mode], callback) fs.openSync(path, flags[, mode]) 关闭文件 fs.close(fd, callback) fs.closeSync(fd) fs中提供了四种不同的方式将数据写入文件 简单文件写入 同步文件写入 异步文件写入 流式文件写入 同步文件的写入： 1.打开文件 操作方式为定为写 即 var fd = fs.openSync(path, flags) 参数为字符串类型 path即文件的路劲 flags即 r表示读操作 w表示写入操作 通过返回的描述符fd对文件进行各种操作 2.写入内容数据 fs.writeSync(fd, string) fd文件的描述符 需要传入文件的描述符 string要写入的内容 3.关闭文件 考虑性能 fs.closeSync(fd) 异步文件写入 1.打开文件 123456789101112131415161718fs.open(path, flags, function (err, fd) &#123; if (!err) &#123; 2.在这里往文件写入内容 写操作 fs.write(fd, &apos;要异步写入的内容&apos;, function (err) &#123; if (!err) &#123; console.log(&apos;write success&apos;) &#125; fs.close(fd, function (err) &#123; if (!err) &#123; console.log(&apos;close success&apos;) &#125; &#125;) &#125;) console.log(fd) &#125;else&#123; console.log(err) &#125;&#125;) 返回值为 callback的参数 简单文件写入 简单同步文件 fs.write 简单异步文件 123456fs.writeFile(&apos;hello.txt&apos;, &apos;shulu520&apos;, &#123;flag: &apos;a&apos;&#125; function (err) &#123; //flag: &apos;a&apos; 追加文件内容 不会覆盖原来的 如果文件不存在则创建 flag还有好多的模式 if (!err) &#123; console.log(&apos;write success&apos;) &#125; //文件路劲可以是F:\\JSdownload\\npm-test 这种 `但是要变为`F:\\\\JSdownload\\\\npm-test或F:/JSdownload/npm-test&#125;) 同步 异步 简单文件 的写入都不适合大文件爱的写入 易导致内存溢出 性能差 流式文件写入 12345678910111213141516171819202122232425 创建流 var ws = fs.createWriteStream(path) 监听事件 once绑定一次性的事件 ws.once(&apos;open&apos;, function () &#123; console.log(&apos;stream success&apos;) &#125;) ws.once(&apos;close&apos;, function () &#123; console.log(&apos;stream close&apos;) &#125;) 写入内容 大量内容 ws.write(&apos;写入内容1&apos;) ws.write(&apos;写入内容2&apos;) ws.write(&apos;写入内容3&apos;) ws.write(&apos;写入内容4&apos;) …… 关闭流 在流开始的一方结束流 ws.end()``` + fs中提供了四种读取文件的方式 简单文件读取 同步文件读取 异步文件读取 流式文件读取+ 简单文件读取 简单异步文件读取 const fs = require(‘fs’);fs.readFile(‘shulu.jpg’, (err, data) =&gt; { if(!err) { fs.writeFile(‘桌面路劲/lqy.jpg’, data, () =&gt; { if(!err) { console.log(‘文件写入成功 ‘) } }) }})12+ 流式文件读取 适用于大文件 const fs = require(‘fs’);1.创建读取流const rs = fs.createReadStream(‘shulu.jpg’);2.监听流的开启和关闭rs.once(‘open’, () =&gt; { console.log(‘流打开成功了’)})rs.once(‘close’, () =&gt; { console.log(‘流关闭了’)})3.读取数据rs.on(‘data’, (data) =&gt; { console.log(data) //多次分批读取大数据}) pipe 流方法 12 const fs = require(‘fs’);const rs = fs.createReadStream(‘shulu.mp3’);const ws = fs.createWriteStrem(‘lqy.mp3’);rs.pipe(ws); 读取后直接流入 12345678910111213141516171819202122232425262728+ fs 模块其他操作 检查一个文件是否存在+ 列出文件 fs.readdir(path[, options], callback) fs.readdirSync(path[, options])+ 截断文件 fs.truncate(path, len, callback) fs.truncateSync(path, len)+ 建立目录 fs.mkdir(path[, mode], callback) fs.mkdirSync(path[, mode])+ 验证路径是否存在 fs.existsSync(path)+ 获取文件信息 fs.stat(path, callback) fs.statSync(path)+ 删除文件 fs.unlink(path, callback) fs.unlinkSync(path)+ 删除目录 fs.rmdir(path, callback) fs.rmdirSync(path)+ 重命名文件和目录 fs.rename(oldPath, newPath, callback) fs.renameSync(oldPath, newPath)+ 监视文件更改写入 fs.watchFile(filename[, options], listener) const fs = require(‘fs’);const isExists = fs.existsSync(‘shulu.mp3’);console.log(isExists);` &emsp;&emsp;未完待续……&emsp;&emsp;write to me","categories":[{"name":"node","slug":"node","permalink":"https://shulu520.com/categories/node/"}],"tags":[{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"es6-zhuf-01.md","slug":"es6-zhuf-01","date":"2019-05-13T15:46:29.000Z","updated":"2019-05-18T16:25:00.765Z","comments":true,"path":"es6/es6-zhuf-01/","link":"","permalink":"https://shulu520.com/es6/es6-zhuf-01/","excerpt":"&emsp;&emsp;想要的东西，会以最快的速度来到你的身边。","text":"&emsp;&emsp;想要的东西，会以最快的速度来到你的身边。 var 与 let 和 const 的区别新的方法解决了老方法遗留的问题 var 在同一作用域内可以对同一变量重复声明 不能定义常量(控制不了，因为可以修改，写了等于没写) 不支持块级作用域 let 在同一作用域内不能对同一变量重复声明 变量不会提升 变量定义之前使用会报错 有块级作用域 {这里面为块级作用域} 以前js只有两种作用域 一个是全局 一个是函数级 作用域经典问题： for 循环里面套 定时器 当时的解决方法 给定时器包一层自执行的匿名函数并将循环变量传进去 本质上是作用域问题 现在用let声明变量就可以了 const 在同一作用域内不能对同一变量重复声明 专门声明常量 常量声明后不可修改 但若此常量是一个引用类型的话(例如一个对象) 引用对象的属性还是可以改的 例如：定义 const USER = {name: ‘shulu’} 更改为 USER.name = ‘lqy’ 可以的 解构 分解一个对象的解构 解构的时候 等号的两边解构相似 右边必须是一个真实的值 数组的省略赋值 let arr = [1, 2, 3]; let [,,x] = arr 则只拿到x=3的值 模板字符串 以前是字符串拼串 现在是这个符号 可以折行 换行 模板语言的原理 正则实现 面试 带参数的模板字符串 字符串的新方法 返回布尔值 str.startWith(‘http’) str.endsWith(‘.com’) str.includes(‘shulu’) 以前 str.indexOf(‘shulu’) == -1 做判断 str.repeat(10) 重复10次 展开运算符 … 对象合并： Object.assign(obj3, obj2, obj1); 将对象1，2合并为3 obj3 = {…obj1, …obj2} 更简洁 对象的深拷贝 1let obj2 = JSON.parse(JSON.stringify(obj1)) 递归实现对象深拷贝 12345678910111213141516171819202122232425262728//对象深拷贝function deepClone(origin,target)&#123; //target是否存在如果不存在创建空对象 let tar = target || &#123;&#125;, //判断是否为引用数据类型 toStr = Object.prototype.toString, arrType=&apos;[object Array]&apos;; for(let key in origin)&#123; //剥离原型链的数据 if(origin.hasOwnProperty(key))&#123; //判断是否为引用数据类型 对象或数组 if(typeof(origin[key]) === &apos;object&apos; &amp;&amp; origin[key] !== null)&#123; if(toStr.call(origin[key]) === arrType )&#123; tar[key] = []; &#125;else&#123; tar[key] = &#123;&#125;; &#125; deepClone(origin[key],tar[key]); &#125;else&#123; tar[key] = origin[key]; &#125; &#125; &#125; return tar;&#125; 箭头函数箭头函数this 继承自父级，自己本身没有this &emsp;&emsp;未完待续……","categories":[{"name":"es6","slug":"es6","permalink":"https://shulu520.com/categories/es6/"}],"tags":[{"name":"zhuf","slug":"zhuf","permalink":"https://shulu520.com/tags/zhuf/"},{"name":"es6","slug":"es6","permalink":"https://shulu520.com/tags/es6/"}]},{"title":"git-guigu-note","slug":"git-guigu-note","date":"2019-05-12T15:21:02.000Z","updated":"2019-05-13T16:05:14.840Z","comments":true,"path":"git/git-guigu-note/","link":"","permalink":"https://shulu520.com/git/git-guigu-note/","excerpt":"&emsp;&emsp;在衰老到来之前，做一件值得做的事情。做这件事不是为了别的，而是为了证明自己是好样的。-《似水流年》","text":"&emsp;&emsp;在衰老到来之前，做一件值得做的事情。做这件事不是为了别的，而是为了证明自己是好样的。-《似水流年》 复制 选中后 Ctrl+ins 即键盘右上角的insert键粘贴 相应的位置 Shift+ins查看git 配置信息cat ~/.gitconfig状态查看 git status 查看工作区、暂存区状态文件内容查看 cat haha.txt添加操作 git add [file_name]git commit -m ‘说明信息’ [file_name]创建文件 touch haha.txt 或 vim good.txt 字母ll 列出本地库所有文件和文件总数，创建日期 时间 创建人 文件名 git add haha.txt 后 若想返回add前的状态 根据提示 git rm –cached haha.txt 即可返回，此删除只是从暂存区里面删除，工作区的文件还在git commit haha.txt 这里没带-m ‘说明信息’ 回车后会进入vim 编辑器 可以编写大量的说明信息 首先 按a键 进入插入模式，之后就可以进行编辑了。 编辑完了就可以按Esc键退出插入模式，然后输出:wq即可退出vim编辑器，回到git bash界面。 查看提交记录 git log 打印的记录风格： 分散 有作者 邮箱 日期提示，显示内容详细，内容多了，多屏显示控制方式：桥空格为向下翻页，b键为向上翻页，q 键为退出查看 git log –oneline 打印效果为一行 git reflog 打印的记录风格： 紧凑 在一行显示并有提示版本回退数字提示 版本前进后退 基于索引值操作 任意版本穿梭 推荐方法 git reset –hard alfe9cd 这里alfe9cd为某一版本的提交id值即索引值 基于符号 ^ 只能后退 返回上一个版本 git reset –hard HEAD^ 版本倒退三个 git reset –hard HEAD^^^ 基于符号 ~ 只能后退 版本倒退三个 git reset –hard HEAD~3 reset 命令的三个参数对比 –soft 仅仅在本地库移动HEAD指针 –mixed 在本地库移动HEAD指针,重置暂存区 –hard 在本地库移动HEAD指针,重置暂存区,重置工作区，三个区位置保持一致 删除文件 rm aaa.txt git status 显示为 红色 deleted: aaa.txt 提示要add该文件 git add aaa.txt git status 显示为 绿色 表示已添加到暂存区 git commit -m ‘deleted aaa.txt’ 将这次删除操作提交到本地库 删除文件并恢复 前提：删除前 文件的状态提交到了本地库 操作： git reset –hard [指针位置] 删除操作已经提交到本地库：指针位置指向包含删除文件的历史纪录 删除操作尚未提交到本地库：指针位置使用HEAD 比较文件差异 git diff [文件名] 将工作区的文件和暂存区进行比较 git diff [本地库中历史版本] [文件名] 将工作区的文件和本地历史记录比较 git diff 不带文件名 比较多个文件 分支管理 热修复 主分支的bug 更改 分一个 hot_fix 分支 分支的好处： 查看分支 git branch -v 创建分支 git branch hot_fix 切换分支 git checkout hot_fix 切换到这个分支 合并分支 第一步：切换到接受修改的分支(被合并，增加新内容)上 git checkout [接受修改的分支] 第二步：在接受修改的分支上执行命令 git merge [有新内容的分支] 解决合并分支后产生的冲突 分别在两个分支上修改内容 分别提交到本地库 比如都在haha.txt上做修改 将两个分支合并到一个分支上 出现合并冲突 vim haha.txt 查看合并后的状态 HEAD 部分表示当前分支的修改 在一行========之下为另一个分支上做的修改 解决方法： 一：删掉那些特殊符号 并手动将内容修改为满意的状态 期间可能与分支伙伴商量 保存退出 二：git add [文件名] 三：git commit -m &apos;日志说明&apos; 注意：此时commit `一定不能带 文件名` git 原理 哈希算法 明文 加密 得 密文 常见的 md5算法 git 底层 SHA-1算法 github克隆的效果 完整的把远程库克隆到本地 初始化本地库 邀请队员加入 github进入相应的项目 /settings/Collaborators/ 在Search by username 之下 添加成员的github账号名 add collaborator copy invite link 发送给队员（qq或邮箱等方式）等其他方式把邀请链接发送给队员 队员 登录github 后 Accepe invitation 队员拉取操作 pull=fetch+merge git fetch [远程库地址别名] [远程分支名] git merge [远程库地址别名/远程分支名] git pull [远程库地址别名] [远程分支名] 解决冲突 如果不是基于 GitHub 远程库的最新版所做的修改，则不能推送，必须先拉取。 拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即 跨团队协作 外团队人员fork 该项目 git 工作流分支种类 主干分支 master主要负责管理正在运行的生产环境代码。永远保持与正在运行的生产环境完全一致。 开发分支 develop主要负责管理正在开发过程中的代码。一般情况下应该是最新的代码。 bug 修理分支 hotfix主要负责管理生产环境下出现的紧急修复的代码。 从主干分支分出，修理完毕并测试上线后，并回主干分支。并回后，视情况可以删除该分支。 准生产分支（预发布分支） release较大的版本上线前，会从开发分支中分出准生产分支，进行最后阶段的集成测试。该版本上线后，会合并到主干分支。生产环境运行一段阶段较稳定后可以视情况删除。 功能分支 feature为了不影响较短周期的开发工作，一般把中长期开发模块，会从开发分支 中独立出来。 开发完成后会合并到开发分支。&emsp;&emsp;完 更多笔记看git&amp;github.pdf详细笔记","categories":[{"name":"git","slug":"git","permalink":"https://shulu520.com/categories/git/"}],"tags":[{"name":"git-note","slug":"git-note","permalink":"https://shulu520.com/tags/git-note/"}]},{"title":"vue-tour","slug":"vue-tour","date":"2019-05-10T16:09:17.000Z","updated":"2019-05-12T15:31:01.615Z","comments":true,"path":"vue/vue-tour/","link":"","permalink":"https://shulu520.com/vue/vue-tour/","excerpt":"&emsp;&emsp;I love three things in this world. Sun, Moon, and You. Sun for morning, Moon for night, and You forever.浮世三千，吾爱有三，日、月与卿。日为朝，月为暮，卿为朝朝暮暮。","text":"&emsp;&emsp;I love three things in this world. Sun, Moon, and You. Sun for morning, Moon for night, and You forever.浮世三千，吾爱有三，日、月与卿。日为朝，月为暮，卿为朝朝暮暮。 A Vue.js project-去哪儿旅行，vue学习练手小项目。 Build Setup1234567891011# install dependenciesnpm install# serve with hot reload at localhost:8080npm run dev# build for production with minificationnpm run build# build for production and view the bundle analyzer reportnpm run build --report css 省略号…123overflow hiddenwhite-space nowraptext-overflow ellipsis 项目初始化 如果这个项目是从github 上克隆来的 初始化时直接 vue init webpack 注意这里不用再加初始化的项目名称 修改 标签 路劲优化，简化 ,在webpack 中配置 build/webpack.base.conf.js 的alias 下面是vue-cli 配置好的 1234alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;),&#125; import HelloWorld from ‘@/components/HelloWorld’ 其中的 @ 表示src目录 在css 样式中 import ‘~@/assets/styles/varibles.styl’ 其中的 ~@ 表示src目录 移动端快速点击 npm i fastclick –save 解决300毫秒延迟 在main.js 中 import fastClick from ‘fastclick’ fastClick.attach(document.body) css代码编辑工具 stylus npm i stylus –save npm i stylus-loader –save 阿里图标 进入网站后 /图标管理/我的项目/新建项目1px 使用的是硅谷外卖 stylus/mixins.styl 使用 @import ‘~@/assets/styles/border.styl’ 某一个样式下 bottom-border-1px(#ccc) 自己传一个色值 github 创建新分支index-swiper本地 git pull 将分支拉到本地切换到这个分支 git checkout index-swiper轮播图 npm i vue-awesome-swiper@2.6.7 –save 官网具体配置 轮播图 index-swiper 开发完成后 git add . git commit -m ‘swiper finished’ git push git checkout master git merge index-swiper 将index-swiper 分支的文件 合并到master主分支 git push 在浏览器中自动打开 config/index.js 修改里面的配置，把autoOpenBrowser:false改为autoOpenBrowser:true即可 布局 高度 height 0padding-bottom 33.9% 用padding-bottom 的值撑开高度 即高宽比 Git出现|MERGING解决 使用git上传或者下拉中出现MERGING，这是合并冲突了 输入命令可以正常跳转：git reset –hard head ajax npm install axios –save config/index.js中配置 12345678proxyTable: &#123; &apos;/api&apos;: &#123; target: &apos;http://localhost:8081&apos;, pathRewrite: &#123; &apos;^/api&apos;: &apos;/static/mock&apos; &#125; &#125; &#125;, vue 文件中 12axios.get(&apos;/api/index.json&apos;) .then(this.getHomeInfoSucc) 解决 swiper 初次显示时为最后一张图的情况 是因为刚开始时是一个空数组 给swiper 加 v-if = “list.length” 即list 传过来有值的时候在加载。 页面滚动 npm install better-scroll –save ref 属性使用注意 如果 ref 的值 是 v-for 循环产生的 使用时 this.$refs[‘A’][0] 即第零相 才是真正的dom 使用函数截流 提示网站性能 在 touchmove 事件中 使用 settimeout 即将一些触发特别快又频繁的代码放到 定时器里面 减少执行次数 vuex 状态管理 npm install vuex –save 安装 src/新建store/index.js 12345678910import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; city: &apos;北京&apos; &#125;&#125;) main.js 12345678910import store from &apos;./store&apos;new Vue(&#123; el: &apos;#app&apos;, router, store, 添加选项store components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;&#125;) 城市选择后 直接跳转到 首页 显示相应的城市 在事件处理 方法里面 12this.$store.dispatch(&apos;changeCity&apos;, city)this.$router.push(&apos;/&apos;) localStorage 的使用 需要在外层加 tyr catch 以防 某谢用户 避了本地存储功能 或浏览器使用隐身模式 12345678910111213141516171819202122232425let defaultCity = &apos;常州&apos;try &#123; if (localStorage.city) &#123; defaultCity = localStorage.city &#125;&#125;catch (e) &#123;&#125;export default new Vuex.Store(&#123; state: &#123; city: defaultCity || &apos;常州&apos; &#125;, actions: &#123; changeCity (ctx,city) &#123; ctx.commit(&apos;changeCity&apos;, city) &#125; &#125;, mutations: &#123; changeCity (state, city) &#123; state.city = city try &#123; localStorage.city = city &#125;catch (e) &#123;&#125; &#125; &#125;&#125;) mapState 的使用 定义import { mapState } from &#39;vuex&#39; 12345678910computed: &#123; ...mapState([&apos;city&apos;]) &#125; 也可以是computed: &#123; ...mapState(&#123; currentCity: &apos;city&apos; &#125;) &#125;, 使用 或 keep-alike 的使用123&lt;keep-alive&gt; &lt;router-view/&gt;&lt;/keep-alive&gt; 相应的组件 数据 加载一次后会保存到内存中 下次调用 直接取 提升性能 vue 实例 选项中多了一个生命 周期钩子函数 activated, 其在页面重新显示，有变动的时候触发 12345activated () &#123; if (this.lastCity !== this.city) &#123; this.getHomeInfo() &#125; &#125; 及时解除全局事件 让其只在当前组件中触发 deactivated 在页面隐藏，页面被替换为新的页面 时触发 123456activated () &#123; window.addEventListener(&apos;scroll&apos;, this.handleScroll) &#125;, deactivated () &#123; window.removeEventListener(&apos;scroll&apos;,this.handleScroll) &#125; 递归组件的使用 在自己组件内部 通过name 选项 的名字 作为递归组件的标签名使用&lt;detail-list :list=&quot;item.children&quot;&gt;&lt;/detail-list&gt; 缓存相关 App.vue 中 Detail 组件不缓存 123&lt;keep-alive exclude=&quot;Detail&quot;&gt; &lt;router-view/&gt;&lt;/keep-alive&gt; 解决不同页面位置的相互影响问题 router/index.js 中加入scrollBehavior选项 123456789101112export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, name: &apos;Home&apos;, component: Home &#125; ], scrollBehavior (to, from, savedPosition) &#123; return &#123;x: 0, y: 0&#125; &#125;&#125;) 解决某些手机浏览器 不支持 promise 的情况 npm install babel-polyfill –save main.js 中 import &#39;babel-polyfill&#39; 项目优化 按需加载js 组件 此方法 只在打包生成的app.js文件特别大（1M左右）的时候使用，小的话，不宜，因为这样会增加http 请求 router/index.js 将import Home from &#39;@/pages/home/Home.vue&#39;引入组件的方式去掉，配置路由为 12345&#123; path: &apos;/&apos;, name: &apos;Home&apos;, component: ( ) =&gt; import(&apos;@/pages/home/Home.vue&apos;) &#125;, 项目上线 npm run build 生成dist 文件夹 将dist 给后端运行 &emsp;&emsp; 项目正在开发完毕。","categories":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/categories/vue/"}],"tags":[{"name":"vue-project","slug":"vue-project","permalink":"https://shulu520.com/tags/vue-project/"}]},{"title":"http","slug":"http","date":"2019-05-06T15:32:22.000Z","updated":"2019-05-06T15:35:32.729Z","comments":true,"path":"http/http/","link":"","permalink":"https://shulu520.com/http/http/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; GET POST 的区别 前提:web浏览器环境下的RFC规范GET 用来获取信息，POST用来发送信息 可见性 安全性 数据大小 编码类型 能否收藏为书签，GET可以 刷新，后退按钮，GET无影响，POST重新提交 能否保留到浏览器历史，GET保留 &emsp;&emsp;","categories":[{"name":"http","slug":"http","permalink":"https://shulu520.com/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"https://shulu520.com/tags/http/"}]},{"title":"net-model","slug":"net-model","date":"2019-05-06T15:28:43.000Z","updated":"2019-05-06T15:30:41.121Z","comments":true,"path":"net/net-model/","link":"","permalink":"https://shulu520.com/net/net-model/","excerpt":"","text":"应用层: 程序，软件，应用层协议，http协议，DNS协议(域名解析)，FTP协议(文件传输协议)，SMTP(邮件传输协议)传输层: 对数据传输的建立和管理，传输层协议，UDP协议(有丢包的可能)，TCP(保证数据的正确性，顺序性)网络层: 好比交通网络，IP协议(IP加端口号来确定一个程序的位置)数据链路层: 两个子层，一个叫逻辑链路控制子层，另一个叫媒体访问控制子层(MAC地址)物理层: 坐公交，扫码骑车。除了五层网络模型之外还有七层网络模型，那么七层网络模型是什么呢？就是将应用层一分为三，分别为：应用层，表示层和会话层。新出来的表示层和会话层没有相应的协议。一般表示层做的是数据格式化，或者加密等操作。","categories":[{"name":"net","slug":"net","permalink":"https://shulu520.com/categories/net/"}],"tags":[]},{"title":"safe-xss","slug":"safe-xss","date":"2019-05-06T15:23:35.000Z","updated":"2019-05-27T04:52:25.111Z","comments":true,"path":"safe/safe-xss/","link":"","permalink":"https://shulu520.com/safe/safe-xss/","excerpt":"&emsp;&emsp;让一个人变强大的最好方式是拥有一个想去保护的人。","text":"&emsp;&emsp;让一个人变强大的最好方式是拥有一个想去保护的人。 XSS攻击究竟是如何一步一步的获取了别人的隐私呢？下面我们就来一步一步的来进行解析。1. 攻击者，上传一片文章或者博客，这边文章中带有一段JS代码，这段代码内容很简单，读取本地Cookie，发送给某个url。2. XX微博的服务器没有对用户上传的内容进行审查，就将内容存储起来。3. 当正常用户访问XX微博的时候，服务器将有问题的文章推送给了这个正常用户。（因为服务器并没有检查哪篇文章有问题，所以它会认为这是一篇正常的文章，以正常的方式推送给用户。）4. 当正常的用户点开这篇文章的时候，攻击者编写的脚本就会在正常的用户的电脑上执行。（因为攻击者的脚本就是在文章的内容中加入一段script代码，浏览器会将script标签中的内容当作js代码来看待，然后执行这段代码）5. 这段带有攻击性的代码可以读取用户本地的cookie内容，并将内容发送给攻击者事先准备好的url。（因为正常用户在本地打开，所以不存在跨域的问题）6. 攻击者收到了发送过来的cookie之后，就可以将cookie内容写入自己的浏览器里，然后就能登录这个正常用户的XX微博了。（因为现在很多网站都做了免登录功能，这个功能主要是依赖于种在浏览器里的cookie，这个cookie中会带有用户的部分信息，当用户在每次进入网站的时候，由于这些cookie的存在，就可以免登录了。我们这个例子中，XSS攻击就是获取到了用户的Cookie，从而在我们的本地来将这份cookie写入到我们的浏览器里，就能登录这个正常用户的帐号了~）我们会发现XSS攻击最大的问题在于，服务器端在用户上传文章内容的时候，没有进行内容审查。其实，我们只要将一些危险的符号进行HTML编码就可以了，比如将‘&lt;’替换为”&lt;”，将‘&gt;’替换为”&gt;”，这样攻击者就无法通过script标签的方式来进行攻击了~","categories":[{"name":"safe","slug":"safe","permalink":"https://shulu520.com/categories/safe/"}],"tags":[{"name":"xss","slug":"xss","permalink":"https://shulu520.com/tags/xss/"}]},{"title":"shanjuan","slug":"diary-shanjuan","date":"2019-05-03T06:18:17.000Z","updated":"2019-05-23T16:38:15.996Z","comments":true,"path":"diary/diary-shanjuan/","link":"","permalink":"https://shulu520.com/diary/diary-shanjuan/","excerpt":"&emsp;&emsp;juan，我的好朋友，好久不见，今偶然间，美好的回忆又浮现眼前，于是赶紧记下那些美好。","text":"&emsp;&emsp;juan，我的好朋友，好久不见，今偶然间，美好的回忆又浮现眼前，于是赶紧记下那些美好。 &emsp;&emsp;拿起雪糕想起了你。&emsp;&emsp;雪糕这玩意和辣条一样是我小时候的最爱，只是随着年岁渐长，慢慢留在记忆里了。昨晚室友叫我一起去超市，逛了一圈不知买点啥，看到有人买雪糕，心想，天气热了就买个尝尝吧。打开柜子，拿起雪糕，恍惚间，温暖的记忆又浮现在眼前。&emsp;&emsp;juan，我的高中同学，朋友，那时经常作我的同桌，人美心善，跟同学关系都挺好。当然对我也很好。常给我糖果啊各种小吃的，我用的笔啊书和本子啊经常从juan那直接拿。&emsp;&emsp;我对juan的第一印象：juan是一个可爱的小公主，而且很高洁。机缘巧合之下，我有幸认识了juan，而且常常作同桌。这让我们之间的距离又近了一点。juan是我去到十班最早认识的同学之一。&emsp;&emsp;时间久了，发生过的好多事情我就不记得了。所以我此时此刻在努力的将往事回忆，我生怕等我老了的时候，年轻时的这些美好时光要是再也回想不起来了，那样想想多遗憾啊。&emsp;&emsp;juan对我一直很好，就像对其他人一样。我们除了讨论学习，还聊小时候，聊未来。关于未来，其实都是我在表达对未来的迷惑，而juan一直在开导我。juan说我们可以永远做朋友。&emsp;&emsp;一个雪糕，那是高三时的一天中午你送我的，当时教室里是有其同学的，但是你只送给了我。在高三那个本就燥热的季节，让我清凉了一整个夏天。&emsp;&emsp;如今再拿起雪糕，眼前浮现出都是你对我的好。感谢那时的遇见，让我能有这么美好的回忆。juan，也愿你过得好，有个好对象。要是余生能再见，我想你还是那么的漂亮，那么温柔与大气。&emsp;&emsp;朋友的友谊不是三言两语就道的尽的，但都是埋藏在我的心底里的。 &emsp;&emsp;刚刚看qq空间里你发的说说–有人拿走了你的外卖，🤣🤣🤣","categories":[{"name":"diary","slug":"diary","permalink":"https://shulu520.com/categories/diary/"}],"tags":[]},{"title":"skills-search","slug":"skills-search","date":"2019-04-30T16:50:45.000Z","updated":"2019-05-27T04:49:54.955Z","comments":true,"path":"skills/skills-search/","link":"","permalink":"https://shulu520.com/skills/skills-search/","excerpt":"","text":"口语转变为关键词 关键词之间打上空格 限定在特定网站内 关键词 site:某一站点 注意：站点前不用加www或http 限定文件类型 关键词 filetype:文件格式 限定时间段 关键词 20xx..20xx 注意：中间是两个英文句号 排除某个关键词 关键词 -广告 -推广 将关键词限定在标题中 关键词 intitle:限定内容","categories":[{"name":"skills","slug":"skills","permalink":"https://shulu520.com/categories/skills/"}],"tags":[{"name":"search","slug":"search","permalink":"https://shulu520.com/tags/search/"}]},{"title":"git-liao-note","slug":"git-liao-note","date":"2019-04-30T16:50:45.000Z","updated":"2019-05-12T15:32:28.393Z","comments":true,"path":"git/git-liao-note/","link":"","permalink":"https://shulu520.com/git/git-liao-note/","excerpt":"&emsp;&emsp;人是不能闲的，一闲就会想得太多，一闲就会感情泛滥，所谓矫情屁事多，空虚寂寞冷，都是因为懒散寂寞闲。","text":"&emsp;&emsp;人是不能闲的，一闲就会想得太多，一闲就会感情泛滥，所谓矫情屁事多，空虚寂寞冷，都是因为懒散寂寞闲。 git 的优秀之处 它跟踪并管理的是文件的修改，而非文件。Git有不少命令中有“-”，有时候是“-”，有时候是“–”。学过linux的命令行就懂了，单个”-“ 后面跟的是单个字母的参数，如-m， 两个”–”后面跟的是多个字母的参数，如–readme.txt 在大多数情况下成立的。注意:我的博客页面上显示的效果都只有一个’-‘,若’-‘线条显示的比较细，则表示两个’-‘ 创建本地版本库cd 到目录文件夹下mkdir learn-git 新建文件夹，即版本库（repository）git init 初始化版本库,即把这个目录变成git 可以管理的仓库ctrl + l 清屏，以防代码太多看着难受ls 查看目录下的文件ls -a 查看不可见的文件touch git-test.txt 创建 txt文件 或者用vscode编辑器创建，别用windows 自带的记事本，因为记事本在编码方面有弱智的行为，键盘上的上键 返回上一步命令git add git-test.txt 添加要提交的文件，可多次添加多个文件，将文件添加到暂存区（stage即阶段的意思）git commit -m “添加描述内容，如 这是第一次使用commit提交” 可以一次提交多个文件，默认提交到master 分支时光穿梭机git status 查看仓库当前的状态git diff 查看文件的具体修改的内容 输出变化前后的内容git log 显示从最近到最远的提交日志git reset –hard HEAD^ 回退到上一个版本，HEAD表示当前版本，HEAD^即上一个版本，往上100个版本为HEAD~100git reflog 用来记录我们的每一次命令即commit 的idgit reset –hard commit_id commit_id 为某一版本提交的具体ID名词解释说明 工作区： 即我们电脑上的项目文件夹，版本库 ：即工作区里面的一个叫 .git 的隐藏目录，版本库里面有暂存区，有git 为我们创建的master 分支，以及指向master的一个指针HEAD 管理修改 每次修改，如果不用git add 到暂存区，就不会加入到commit 中git checkout – git-test.txt 让这个文件回到最近一次git commit 或 git add 时的状态，注意–是单独的即后面有空格 ，git checkout 使用版本库里面的版本替换工作区的版本 ，无论工作区是修改还是删除，都可以一键还原。 我测试时为什么不行呢cat git-test.txt 查看文件的内容 远程仓库github 上创建一个仓库就行了，最好与本地仓库同名根据提示：将本地仓库与远程仓库关联并推送到远程123…or push an existing repository from the command linegit remote add origin https://github.com/lqyasl/learn-git.git (关联)git push -u origin master (本地推送到远程) 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。一个项目库第一次推送成功后，后面 只要本地做了提交，就可以 git push origin master 不用加参数-u分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了。前面是先有本地仓库，再有远程库。如何关联远程库。现在，最好的方式是，先创建远程库，再从远程库里面克隆到本地。首先在github上创建一个 仓库 并勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。我这里创建了一个gitskills的库。git clone git@github.com:lqyasl/gitskills.git 或 git clone https://github.com/lqyasl/gitskills.git 等多种方式， 推荐使用前一种，其速度最快。cd gitskills 进入克隆的库ls 展开文件列表 可以看到已经有一叫README.md 的文件了分支管理分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 与其他svn 版本控制系统相比， git 超级快。每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点。每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上。从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变。假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并。合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。实战部分git checkout -b dev 创建dev分支，然后切换到dev分支： 这里git checkout命令加上-b参数表示创建一个分支并切换到这个分支。 checkout这里表示切换的意思。git branch 查看当前分支，git branch命令会列出所有分支，当前分支前面会标一个*号。对README.md 文件做修改，比如加一点内容。然后 git add README.md 以及 git commit -m ‘分支测试’ ，我们就可以在dev分支上正常提交现在，dev分支的工作完成，我们就可以切换回master分支 git checkout master现在，我们把dev分支的工作成果合并到master分支上 git merge dev 这里git merge命令用于合并指定分支到当前分支。注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。合并完成后，就可以放心地删除dev分支了。 git branch -d dev因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。gti branch 查看分支，可以看到只剩下一个master主分支了。创建分支与合并小结 Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 解决冲突创建新的feature1分支，继续我们的新分支开发 git checkout -b feature1修改 README.md 文件的内容在feature1分支上提交 git add README.md 以及 git commit -m ‘AND simple’切换到master分支 git checkout masterGit还会自动提示我们当前master分支比远程的master分支要超前1个提交在master分支上把readme.txt文件的最后一行改为：Creating a new branch is quick &amp; simple.提交README.md 文件现在，master分支和feature1分支各自都分别有新的提交这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看 gti merge feature1 结果显示： Automatic merge failed; fix conflicts and then commit the result.果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件修改README.md 并提交 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。最后，删除feature1分支： git branch -d feature1分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。下面我们实战一下–no-ff方式的git merge：首先，仍然创建并切换dev分支：git checkout -b dev## &emsp;&emsp;今晚到此为止，明天再写。","categories":[{"name":"git","slug":"git","permalink":"https://shulu520.com/categories/git/"}],"tags":[{"name":"git-note","slug":"git-note","permalink":"https://shulu520.com/tags/git-note/"}]},{"title":"book-fengchuan","slug":"book-fengchuan","date":"2019-04-30T16:50:45.000Z","updated":"2019-05-19T16:53:54.217Z","comments":true,"path":"book-note/book-fengchuan/","link":"","permalink":"https://shulu520.com/book-note/book-fengchuan/","excerpt":"&emsp;&emsp;深夜时，人会更加容易情绪化，所以无论多难过，都要告诉自己，没有那麽糟糕，睡一觉就好了。","text":"&emsp;&emsp;深夜时，人会更加容易情绪化，所以无论多难过，都要告诉自己，没有那麽糟糕，睡一觉就好了。 相比广告营销，口口相传更有效，分享能让我们感觉良好，因为他会让我们显得高大上。我们更愿意与人分享能提升个人形象的信息。某些产品，思想或行为，经常出现在我们眼前时，他们的影响力和传染力就会大大增加。从古至今，故事一直都是人们分享信息的重要工具。诱因，让人产生联想，看到这个，就会想到那个。打折规则，100元以上，降价多少元，以下为打几折。&emsp;&emsp;那么如何打造-个疯传的产品呢?第一，让你的产品成为一种社交货币，也就是说人们会通过分享它来赢得别人的好感和兴趣;第二，要利用诱因引发消费者的联想;第三，要带动消费者的情绪，让他们不断频繁地分享;第四，让你的产品尽可能出现在大家眼前，让人们不看都不行;第五，记得，简单实用的东西自然会受人欢迎;最后，帮你的产品量身打造一一个足够有意思的故事。&emsp;&emsp;两个可行的建议。首先，可以让你的产品带上点竞争元素。就是说利用人们的游戏心理，大家在玩游戏的时候都喜欢跟别人比赛，获得胜利之后，会得意地和别人分享自己的战绩，同时也就相当于告诉了别人某个产品。所以，如果你的产品有了游戏元素，就能鼓励消费者用你的产品进行某种互动，这样就提高了产品被分享的可能。","categories":[{"name":"book-note","slug":"book-note","permalink":"https://shulu520.com/categories/book-note/"}],"tags":[{"name":"skills","slug":"skills","permalink":"https://shulu520.com/tags/skills/"}]},{"title":"Math-random","slug":"Math-random","date":"2019-04-30T16:50:45.000Z","updated":"2019-05-02T15:02:25.641Z","comments":true,"path":"Math/Math-random/","link":"","permalink":"https://shulu520.com/Math/Math-random/","excerpt":"引言：希望你睡不着时，想起的都是那些让你开心的事 常见的问题：如何生成一个区间[min,max]内的随机整数？答案很简单，即 Math.random()*(max-min)+min 以下是一些其他的方法。","text":"引言：希望你睡不着时，想起的都是那些让你开心的事 常见的问题：如何生成一个区间[min,max]内的随机整数？答案很简单，即 Math.random()*(max-min)+min 以下是一些其他的方法。 new Date() - 0 new Date() 日期函数 默认会显示年月日等字符，new Date() - 0 会得到数字“秒” (new Date() - 0)%2239 ,得到取模数值分之一概率的随机数，即[0,2239]范围内一随机数 toString(指定进制) 方法的调用 与parseInt() 方法一样，进制区间为 [2,36]，取36得字母多一些 随便一个随机数.toString(36)得随机字符，但有数字，且长短不一 随机字符串函数，长度固定，且都是字母 从固定的字典中抽取字符构成随机字符串 12345678910// 在大小写字母之间随机生成 x 个字符function randStr(x)&#123; var s = &apos;&apos;; while(s.length &lt; x &amp;&amp; x &gt; 0)&#123; var r = Math.random(); s += String.fromCharCode(Math.floor(r*26) + (r &gt; 0.5 ? 97 : 65)) &#125;; return s;&#125;;console.log(randStr(3)); //KzE 三个随机字符 颜色随机函数1234function randomColor()&#123; var rand = &apos;#&apos;+(&apos;00000&apos;+(Math.random()*0x1000000&lt;&lt;0).toString(16)).slice(-6); return rand;&#125;; 后记 随机数相关得知识还又有很多，后面学到了再来补充笔记","categories":[{"name":"Math","slug":"Math","permalink":"https://shulu520.com/categories/Math/"}],"tags":[{"name":"random","slug":"random","permalink":"https://shulu520.com/tags/random/"}]},{"title":"vue-source-guigu","slug":"vue-source-guigu","date":"2019-04-30T10:49:43.000Z","updated":"2019-05-27T04:53:19.309Z","comments":true,"path":"vue/vue-source-guigu/","link":"","permalink":"https://shulu520.com/vue/vue-source-guigu/","excerpt":"&emsp;&emsp;read the fucking source code.","text":"&emsp;&emsp;read the fucking source code. vue 源码分析知识点分析 vue 作为一个 MVVM 框架的基本实现原理准备知识 1 [].slice.call(lis): 将伪数组转换为真数组 slice 方法有浅拷贝的用法，表示截取一部分，不传参数的话就是拷贝原数组 这样更好 Array.prototype.slice.call(lis) 2 node.nodeType: 得到节点类型 节点类型：常用的 document // 文档 Element //元素节点 节点类型 nodeType === 1; Attr //属性 Text //文本 documentFragment // 文档碎片 3 Object.defineProperty(obj, propName, {}): 给对象添加/修改属性(指定描述符) vue 数据代理的核心语法，不支持ie8，面试题 属性描述符： 数据描述符： configurable: true/false 是否可以重新 define enumerable: true/false 是否可以枚举(for..in / keys()) value: 指定初始值 writable: true/false value 是否可以修改 访问描述符：vue的计算属性就是利用get set 方法 get: 回调函数, 根据其他相关的属性动态计算得到当前属性值，根据相关的属性更新（得到）当前的属性 set: 回调函数, 监视当前属性值的变化，更新相关的属性值 ，根据当前的属性更新相关的属性 Object.keys(obj): 得到对象自身可枚举的属性名的数组 obj.hasOwnProperty(prop): 判断 prop 是否是 obj 自身的属性 DocumentFragment: 文档碎片(高效批量更新多个节点) 传言啊 这个 childNodes是正统属性 亲生的 而这个children是野孩子 这个野孩子比较随意 所以用它返回来的就只有DOM元素了 其他的文字啥的 都不返回 而 childNodes比较讲究 事无巨细 都要返回来 但是我还是觉得野孩子乖 所以也获得了几乎所有浏览器的支持 如果你想要DOM节点 直接用野孩子就可以了 12345&lt;ul id=&quot;list&quot;&gt; &lt;li&gt;test1&lt;/li&gt; &lt;li&gt;test2&lt;/li&gt; &lt;li&gt;test3&lt;/li&gt;&lt;/ul&gt; 12345678910111213141516let list = document.getElementById(&quot;list&quot;); // 1. 创建文档碎片 let fragment = document.createDocumentFragment(); // 2. 取出ul中 所有 子节点保存到fragment中 //Array.prototype.slice.call(list.children).forEach(element =&gt; &#123; fragment.appendChild(element); &#125;); // 3.修改fragment中的每一个子元素的内容 Array.prototype.slice.call(fragment.children).forEach(element =&gt; &#123; element.textContent = &apos;舒璐&apos;; &#125;); // 4.将文档碎片插入到list中 list.appendChild(fragment); 数据代理的实现基本实现流程 通过 Object.defineProperty()给 vm 添加与 data 对象的属性对应的属性描述符 所有添加的属性都包含 getter/setter getter/setter 内部去操作 data 中对应的属性数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152相当于Vue的构造函数function MVVM(options) &#123; // 将选项对象保存到vm this.$options = options; // 将data对象保存到vm和datq变量中 var data = this._data = this.$options.data; //将vm保存在me变量中 var me = this; // 遍历data中所有属性 Object.keys(data).forEach(function (key) &#123; // 属性名: name // 对指定属性实现代理 me._proxy(key); &#125;); // 对data进行监视 observe(data, this); // 创建一个用来编译模板的compile对象 this.$compile = new Compile(options.el || document.body, this)&#125;MVVM.prototype = &#123; $watch: function (key, cb, options) &#123; new Watcher(this, key, cb); &#125;, // 对指定属性实现代理 _proxy: function (key) &#123; // 保存vm var me = this; // 给vm添加指定属性名的属性(使用属性描述) Object.defineProperty(me, key, &#123; configurable: false, // 不能再重新定义 enumerable: true, // 可以枚举 // 当通过vm.name读取属性值时自动调用 get: function proxyGetter() &#123; // 读取data中对应属性值返回(实现代理读操作) return me._data[key]; &#125;, // 当通过vm.name = &apos;xxx&apos;时自动调用 set: function proxySetter(newVal) &#123; // 将最新的值保存到data中对应的属性上(实现代理写操作) me._data[key] = newVal; &#125; &#125;); &#125;&#125;; 其中最关键的部分为 1234567891011121314Object.defineProperty(me, key, &#123; configurable: false, // 不能再重新定义 enumerable: true, // 可以枚举 // 当通过vm.name读取属性值时自动调用 get: function proxyGetter() &#123; // 读取data中对应属性值返回(实现代理读操作) return me._data[key]; &#125;, // 当通过vm.name = &apos;xxx&apos;时自动调用 set: function proxySetter(newVal) &#123; // 将最新的值保存到data中对应的属性上(实现代理写操作) me._data[key] = newVal; &#125; &#125;); 模板解析 嵌套调用: a里面调用b,b里面调用c 递归: a 里面调用 a ,a继续调用a即特殊的嵌套调用 模板解析的基本流程 1)将 el 的所有子节点取出, 添加到一个新建的文档 fragment 对象中 2)对 fragment 中的所有层次子节点递归进行编译解析处理 对大括号表达式文本节点进行解析 对元素节点的指令属性进行解析 事件指令解析 一般指令解析 3) 将解析后的 fragment 添加到 el 中显示 模板解析(1): 大括号表达式解析&lt;p&gt;&lt;/p&gt; 根据正则对象得到匹配出的表达式字符串: 子匹配/RegExp.$1 name 从 data 中取出表达式对应的属性值 将属性值设置为文本节点的 textContent 模板解析(2): 事件指令解析从指令名中取出事件名 根据指令的值(表达式)从 methods 中得到对应的事件处理函数对象 给当前元素节点绑定指定事件名和回调函数的 dom 事件监听 指令解析完后, 移除此指令属性 模板解析(3): 一般指令解析得到指令名和指令值(表达式) text/html/class msg/myClass 从 data 中根据表达式得到对应的值 根据指令名确定需要操作元素节点的什么属性 v-text—textContent 属性 v-html—innerHTML 属性 v-class–className 属性 4) 将得到的表达式的值设置到对应的属性上 5) 移除元素的指令属性 call apply bind JavaScript 的一大特点是， 函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念 apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里 bind()最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的this值。 常见的错误就像，将方法从对象中拿出来，然后调用，并且希望this指向原来的对象。 如果不做特殊处理，一般会丢失原来的对象。用bind方法可以 数据绑定 简单地说，就是数据更新，界面改变。 一旦更新了 data 中的某个属性数据, 所有界面上直接使用或间接使用了此属性的节点+更新 数据劫持 数据劫持是 vue 中用来实现数据绑定的一种技术 基本思想: 通过 defineProperty()来监视 data 中所有属性(任意层次)数据的变化, 一旦变化就去更新界面 初始化显示：页面（表达式/指令）能从data中读取数据显示（编译/解析） 更新显示：更新data中的属性数据，.&gt;&gt;&gt; 页面更新 图中黑线表示初始化，红线表示更新时触发 双向数据绑定 双向数据绑定是建立在单向数据绑定(model==&gt;View)的基础之上的 双向数据绑定的实现流程: 在解析 v-model 指令时, 给当前元素添加 input 监听(input事件会在value属性值发生改变时触发，通过js改变value属性值不会触发此事件。只有IE8以上或者谷歌火狐等标准浏览器支持。) 当 input 的 value 发生改变时, 将最新的值赋值给当前表达式所对应的 data 属性 vuex 是vue 的一个插件 简单来说: 对 vue 应用中多个组件的共享状态进行集中式的管理(读/写) 状态自管理应用 state: 驱动应用的数据源（data） view: 以声明方式将 state 映射到视图(模板界面) actions:（在vue中是函数） 响应在 view 上的用户输入导致的状态变化 (包含 n 个*更新状态的方法*) ![](vuenote/2.jpg) 多组件共享状态的问题 多个视图依赖于同一状态 来自不同视图的行为需要变更同一状态 以前的解决办 将数据以及操作数据的行为都定义在父组件 将数据以及操作数据的行为传递给需要的各个子组件(有可能需要多级传递) vuex 就是用来解决这个问题的 vuex 核心概念和 API state vuex 管理的状态对象,它应该是唯一的 mutations 包含多个直接更新 state 的方法(回调函数)的对象 谁来触发: action 中的 commit(&apos;mutation 名称&apos;) 只能包含同步的代码, 不能写异步代码 const mutations = { yyy (state, {data1}) { // 更新 state 的某个属性 } } vuex 人生管理哲学，哈哈State:想一想，你现在心里在意哪些事？ Mutation目标导向: 写下目标，直接改变State Action阶段性执行： 写下行动 ，执行一个个Matation、异步函数、和其它阶段性执行。 Getters: 写下其它指标，根据现有的state得到其他的指标 mapState和mapGetters必须在computed中访问，因为它们返回的是对象，所以需要用拓展符…进行展开。 mapActions则是将Action挂载到methods上，也需要用拓展符…进行展开。 组件中的mapActions([“increment”])与actions 中 increment 函数名一样actions 中 commit(“INCREMENT”)与mutations 中 INCREMENT函数名一样大写的函数名只是为了区分各个函数 可以定义一个mutation-type.js 后记","categories":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/categories/vue/"}],"tags":[{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"hello-friends","slug":"friends","date":"2019-04-23T15:03:21.000Z","updated":"2019-06-24T02:28:49.439Z","comments":true,"path":"hello/friends/","link":"","permalink":"https://shulu520.com/hello/friends/","excerpt":"","text":"&emsp;&emsp;Welcome to my blog,终于等到你，还好我没放弃(^_^)这里有我的学习心得,编程感悟,心情故事等,是我个人在互联网上的一个小窝。来了就好好逛逛，这里既是我的学习园地，也是我的精神家园。 &emsp;&emsp;欢迎来我QQ交流，也欢迎匿名来撩，无需登录哦，点击右下角，进我的聊天室开撩呗。 &emsp;&emsp;Everything will be okay in the end. If it’s not okay, it’s not the end. who am i, What kind of person do I want to be我是谁，自己要成为什么样的人？其实，在做自己喜欢做的事情的时候，往往也逐渐让自己成为自己想要成为的那种人。在学习、工作、生活中，接触各种各样的人，他们是什么样的人？有什么特殊的经历？在阅读的过程中，甚至能接触古今中外的人物，他们是如何度过自己的一生的？每个时代，每个人做的事情也许不一样，都是选择人生道路时经历的心境却是相似的，而那些成功的人生，离不开他们所处的“时势”，更为重要的是他们对于机会的觉察和行动的品质。这些不管时代如何变迁，都是大致相同的。听到的，接触的人多了，也许自己的人生方向也就越来越清晰了，在实际行动中，通过尝试，也许就会发现一条自己要走的路。 12345678910111213141516171819 ) ( /+++=)) ((=+++\\ /++++++++// \\\\+++++++++\\ /++++++++++//( /\\ )\\\\++++++++++\\ /+++++++++++// \\\\^^// \\\\+++++++++++\\ _/++++++++++++// &#123;&#123;@::@&#125;&#125; \\\\++++++++++++\\_ /+++++++++++++(( &#123;\\/&#125; ))+++++++++++++\\ /+++++++++++++++\\\\ &lt;**&gt; //+++++++++++++++\\ /+++++++++++++++++\\\\ / VV \\ //+++++++++++++++++\\ /+++++++++++++++++++\\\\/******\\//+++++++++++++++++++\\|+/|++++++++++/\\++++++(***/\\***)++++++/\\++++++++++|\\+\\|/ |+/\\+/\\+/\\/ \\+/\\++\\**|**|**/++/\\+/ \\/\\+/\\+/\\+| \\|v |/ V V V V \\+\\|*|**|*|/+/ V v V V \\| v v /*|*|**|*|*\\... v (**|*|**|*|**). . __\\*|*|**|*|*/__. . (vvv(VVV)(VVV)vvv). . ............../ / 注感谢原作者的神代码注释，网上流传很多，不知具体出处，愿我等小白借大佬神兽保佑永无bug。^_^ . 来我QQ撩我哦👇","categories":[{"name":"hello","slug":"hello","permalink":"https://shulu520.com/categories/hello/"}],"tags":[]},{"title":"h5-guigu-music","slug":"h5-guigu-music","date":"2019-04-22T14:19:33.000Z","updated":"2019-05-19T16:59:48.714Z","comments":true,"path":"H5/h5-guigu-music/","link":"","permalink":"https://shulu520.com/H5/h5-guigu-music/","excerpt":"&emsp;&emsp;想去的地方，有你才最美丽。","text":"&emsp;&emsp;想去的地方，有你才最美丽。 第一天 像素 适配 图片加载太慢，后面要用纯文字代替，记得更新 rem最终适配代码 123456;(function()&#123; var styleNode = document.createElement(&quot;style&quot;); var w = document.documentElement.clientWidth/16; styleNode.innerHTML=&quot;html&#123;font-size:&quot;+w+&quot;px!important&#125;&quot; document.head.appendChild(styleNode);&#125;)() 1物理像素的实现 用媒体查询的方法 一般用伪元素来做123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;/&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; #test:before&#123; position: absolute; bottom: 0px; content: &quot;&quot;; display: block; width: 100%; height: 1px; background: black; &#125; @media only screen and (-webkit-device-pixel-ratio:2 ) &#123; #test:before&#123; transform: scaleY(.5); &#125; &#125; @media only screen and (-webkit-device-pixel-ratio:3 ) &#123; #test:before&#123; transform: scaleY(.33333333333); &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 第二天 移动端基础事件 querySelectorAll() 匹配满足选择器的所有元素 改变dom结构后一定得再次获取 1234567891011window.onload=function()&#123; //querySelectorAll:获取静态列表 var itemNodes = document.querySelectorAll(&quot;.item&quot;); // 第一次获取 console.log(itemNodes.length) document.body.innerHTML+=&quot;&lt;div class=&apos;item&apos;&gt;&lt;/div&gt;&quot;; itemNodes = document.querySelectorAll(&quot;.item&quot;); // 改变dom结构后一定得再次获取 console.log(itemNodes) for(var i=0;i&lt;itemNodes.length;i++)&#123; itemNodes[i].style.background=&quot;pink&quot;; &#125;&#125; querySelector 获取 querySelectorAll 匹配到的第一个 触屏事件 监听用 addEventListenerpc端12345678910 touchstart mousedown touchmove mousemove 不可能单独触发 可以单独触发 touchend mouseupwindow.onload=function()&#123; var item = document.querySelector(&quot;.item&quot;); item.addEventListener(&quot;touchstart&quot;,function()&#123; console.log(&quot;touchstart&quot;) &#125;)&#125; 移动端事件默认行为 长按选中，橡皮筋效果（下拉）等 全面禁止事件默认行为 在 touchstart事件上，即手指触摸上去的时候就开始禁止 一上来就这段代码，全面禁止事件默认行为12345678910window.onload=function()&#123; document.addEventListener(&quot;touchstart&quot;,function(ev)&#123; ev=ev||event; ev.preventDefault();&#125;)// 单独按需开启 item.addEventListener(&quot;touchstart&quot;,function(ev)&#123; ev=ev||event; ev.stopPropagation();&#125;) 右键菜单的阻止与开启 与自定义右键 全局阻止右键1234567891011121314151617181920212223242526272829 document.oncontextmenu=function()&#123; return false; &#125;// 单独按需开启浏览器的右键菜单 var inner = document.querySelector(&quot;#inner&quot;); inner.oncontextmenu=function(ev)&#123; ev.stopPropagation();&#125;// 也可以自定义右键菜单window.onload=function()&#123; document.oncontextmenu=function(ev)&#123; ev = ev||event; var x = ev.clientX; var y = ev.clientY; var wrap =document.querySelector(&quot;#wrap&quot;); wrap.style.display=&quot;block&quot;; wrap.style.left = x+&quot;px&quot;; wrap.style.top = y+&quot;px&quot;; return false; &#125; // 单击消失 document.onclick=function()&#123; var wrap =document.querySelector(&quot;#wrap&quot;); wrap.style.display=&quot;none&quot;; &#125;&#125; 事件点透 pc端的事件可以在移动端触发 PC端事件有300毫秒延迟 移动端事件不会有延迟 移动端 a 标签跳转方案 并解决误触 123456789101112131415161718192021 // 阻止事件默认行为 document.addEventListener(&quot;touchstart&quot;,function(ev)&#123; ev=ev||event; ev.preventDefault(); &#125;) //移动端a标签的跳转方案 解决误触 var aNodes = document.querySelectorAll(&quot;a&quot;); for(var i=0;i&lt;aNodes.length;i++)&#123; aNodes[i].addEventListener(&quot;touchstart&quot;,function()&#123; this.isMoved=false; &#125;) aNodes[i].addEventListener(&quot;touchmove&quot;,function()&#123; this.isMoved=true; &#125;) aNodes[i].addEventListener(&quot;touchend&quot;,function()&#123; if(!this.isMoved)&#123; location.href=this.href; &#125; &#125;) &#125;&#125; event : //changedTouches: 触发当前事件的手指列表, 最常用//targetTouches: 触发当前事件时元素上的手指列表//touches: 触发当前事件时屏幕上的手指列表常见问题 及解决方法 禁止电话与邮箱,添加标签 1&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no&quot;/&gt; 按需开启 电话与邮箱 12 &lt;a href=&quot;tel:1383838438&quot;&gt;1383838438&lt;/a&gt;&lt;a href=&quot;mailto:2642816105@qq.com&quot;&gt;2642816105&lt;/a&gt; 解决连接按钮高亮问题 1234a &#123; text-decoration:none; // 去下划线 webkit-tap-highlight-color:rgba(0,0,0,0); // 去背景高亮，只需字体高亮&#125; 解决圆角过圆的问题 加属性 webkit-appearance:none 即可 fontboosting 的问题 及显示的字体与设置的大小不一致的现象，加属性 max-height:999999px;即可 无缝华屏 移动端清除浮动：父元素ul元素上加 overflow:hidden 即可 表单：表单高亮：outline:none; 表单内阴影：boder:none; 划屏相关 在谁上面划，即划屏包裹slide-wrapper 划的内容 即slide-content 元素排到一行的方法 浮动 父容器宽度不够会自动换行 另一种技巧 父容器white-space :nowrap; 子元素: display: inline-block;橡皮筋效果 减少每次move 的有效距离，最终的有效距离还是一直在增大 混合 继承 可以单独定义一系列通用的样式，在需要的时候进行调用。从而减少代码的重复 混合：简单 1234567891011121314151617181920&lt;!-- 定义混合 --&gt;.mixin()&#123; &lt;!-- 规则集 --&gt;&#125;&lt;!-- 使用混合 --&gt;#text1&#123; &lt;!-- 相当于将规则集里面的代码cv到这里 --&gt; &lt;!-- 每次使用都是将代码复制到相应位置 --&gt; &lt;!-- 使用几次就有几处相同的代码 --&gt; .mixin();&#125;#text2&#123; .mixin();&#125;#text3&#123; .mixin();&#125;&lt;!-- 多处使用相同的混合 这样写好一点-（手动写）-&gt;#text1,#text2,#text3&#123; .mixin() &#125; 继承：性能好一点 1234567891011121314151617&lt;!-- 定义继承 --&gt;.extend&#123; &lt;!-- 规则集 --&gt;&#125;&lt;!-- 使用继承 --&gt;#text1&#123; &amp;::extend(.extend);&#125;#text2&#123; &amp;::extend(.extend);&#125;#text3&#123; &amp;::extend(.extend);&#125;&lt;!-- 最终编译为 --&gt;#text1,#text2,#text3&#123; &lt;!-- 规则集 ，相当于将规则集里面的代码cv到这里--&gt;&#125;","categories":[{"name":"H5","slug":"H5","permalink":"https://shulu520.com/categories/H5/"}],"tags":[{"name":"H5-note","slug":"H5-note","permalink":"https://shulu520.com/tags/H5-note/"}]},{"title":"markdown-write","slug":"markdown","date":"2019-04-20T14:23:44.000Z","updated":"2019-05-27T05:19:40.953Z","comments":true,"path":"md/markdown/","link":"","permalink":"https://shulu520.com/md/markdown/","excerpt":"故事的开头，多是惊魂一瞥，然后一眼万年。故事的结局，多是渐行渐远，江湖不见。","text":"故事的开头，多是惊魂一瞥，然后一眼万年。故事的结局，多是渐行渐远，江湖不见。 在 xxx.md文件插入html效果 直接写html 即可 内联样式也直接写 这里输入文字，自定义字体大小 这里输入文字，自定义字体颜色这里输入文字，自定义字体背景色这是综合起来的效果 这是综合起来的效果2 首行缩进效果 其中的 &amp;emsp;&amp;emsp; 即缩进两个字最常见 全方大的空白 &amp;emsp;&emsp;&emsp;内容充实的生命就是长久的生命。我们要以行为而不是以时间来衡量生命。 ——小塞涅卡 不断行的空白格&amp;nbsp; &nbsp;以后无论我去哪我都把你带着我看账你帮我打算盘我谈生意你帮我出主意一起把吴家东院发扬光大做到陕西第一天下第一。———那年花开月正圆周莹经典台词 倾斜 单层*示例：倾斜字体 加粗 双层*示例：加粗字体 加粗倾斜 三层*示例：加粗倾斜 删除线 双层~~示例：删除线 单层引用 &gt;加内容 这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容 无序列表 用 - + * 任何一种都可以示例： 无序列表1 无序列表2 无序列表3 表格 : 表头 表头 表头 内容 内容 内容 内容 内容 内容 注：第二行分割表头和内容。-有一个就行，为了对齐，多加了几个 文字默认居左-两边加：表示文字居中-右边加：表示文字居右 代码:单行: javascript vue node ajax 代码块: 、、、.b{ background: red;}、、、 👉有事记得Q我哦","categories":[{"name":"md","slug":"md","permalink":"https://shulu520.com/categories/md/"}],"tags":[]},{"title":"vue-guigug","slug":"vue-guigu","date":"2019-04-17T12:00:21.954Z","updated":"2019-05-27T04:13:10.324Z","comments":true,"path":"vue/vue-guigu/","link":"","permalink":"https://shulu520.com/vue/vue-guigu/","excerpt":"&emsp;&emsp;人生即在于体验，而体验源于去尝试，去折腾，去改变，去塑新。 &emsp;&emsp;要知道：过一个平凡无趣的人生实在太容易了，你可以不读书，不冒险，不运动，不写作，不外出，不折腾…… &emsp;&emsp;但是，人生最后悔的事情就是：我本可以。生活也好，职场也罢，亦同此理；编程则更如其是","text":"&emsp;&emsp;人生即在于体验，而体验源于去尝试，去折腾，去改变，去塑新。 &emsp;&emsp;要知道：过一个平凡无趣的人生实在太容易了，你可以不读书，不冒险，不运动，不写作，不外出，不折腾…… &emsp;&emsp;但是，人生最后悔的事情就是：我本可以。生活也好，职场也罢，亦同此理；编程则更如其是 Vue 的特点 遵循 MVVM 模式 即MVVM 模式的一种实现 编码简洁, 体积小, 运行效率高, 适合移动/PC 端开发 它本身只关注 UI, 可以轻松引入 vue 插件（依赖vue）或其它第三库(不依赖vue)开发项目 MVVM 的理解 M 即 model 模型, 数据对象（data） V 即 view 视图，模板页面 VM 即 viewModel 视图模型 是vue的实例 dom监听 数据绑定 组件 即 局部功能界面 ，是提供某一完整功能的模块模板的理解：动态的html页面，包含了一些js语法代码vue 扩展组件 vue-cli: vue 脚手架 axios: ajax 请求 vue-router: 路由 vuex: 状态管 vue-lazyload: 图片懒加载 vue-scroller: 页面滑动相关 mint-ui: 基于 vue 的 UI 组件库(移动端) element-ui: 基于 vue 的 UI 组件库(PC 端) 编程方式 命令式 如 jquery 声明式 如 vue 数组的扩展-array.some()和array.every()区别 some():方法用于检测数组中的元素是否有满足指定条件的，若满足返回true，否则返回false； every():方法用于检测数组中所有元素是否都符合指定条件，若符合返回true，否则返回false； 挂载元素app new Vue({ el :’#app’ }); new vue({}).$moute(‘#app’) 用于单元测试 vue 指令 v-bind 即 : 强制 动态 数据绑定（属性） v-on 即 @ 绑定事件监听 v-html 内部innerHTML XSS攻击 内容必须是可信赖的 vue 计算属性 computed 什么时候执行 ： 初始化显示，/ 相关的data 数据属性发生变化时触发 各个方法的返回值作为相关的属性值 get 回调函数，当需要读取当前属性值的时候回调，计算并返回当前属性的值 set 回调函数，监视当前属性值的变化，当属性值变化时回调，更新相关的属性数据 计算属性，存在缓存，多次读取，只调用一次getter计算，性能好, 全选时可用计算属性 vue 的方法 methods 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。 然而，不同的是计算属性是基于它们的依赖进行缓存的。只在相关依赖发生改变时它们才会重新求值 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数 如果你不希望有缓存，请用方法来替代 vue 的watch 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器 当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的 绑定 style class :class=”xxx” xxx是字符串或对象 :style=”xxx” xxx是对象 对象更新,数组更新 完全跟新 即重新写这个对象 补充更新 vm.$set(要跟新的对象名,补充的属性名,属性值) 数组更新 vm.$set(要跟新的数组名,更新的下标,具体值) 数组更新检测 变异方法（vue重写原生的方法）即以下这些方法已不再是原生的方法 push pop shift unshift splice sort reverse 使用它们会触发视图更新 注意事项： 利用索引直接设置一个项时/修改数组的长度时 vue不能检测到数组变化 常用事件修饰符 阻止事件冒泡 如@click.stop=”XXX” 传统方法 e.stopPropagation 取消事件默认行为 如 @click.prevent=”xxx” 传统方法 e.preventDefault @click.once=”xxx” 点击事件将只会触发一次 常用按键修饰符 抬起某键时，执行操作 如按回车 @keyup.enter=”xxx” 鼠标修饰符 left right middle 系统修饰键 可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 ctrl alt shift meta 表单数据的自动收集 使用 v-model vue实例的 生命周期（钩子函数） 大致有三个阶段 初始化阶段 beforeCreate created beforeMount mounted 只执行一次 更新阶段 beforeUpdate updated 执行N次 销毁阶段 beforeDestory destoryed 常用的有1：`mounted` （挂载方法） 发送*Ajax* 请求,获取真实dom ，执行定时器等异步任务 2：`beforeDestory` 收尾工作，如清除定时器，解绑操作等 vue 过渡&amp;动画 过渡 ：transition 显示时的效果：xxx-enter-active{…} 隐藏时的效果 ：xxx-leave-active{…} 其中xxx表示 transition元素的name 属性值 动画 ：animation 过滤 vue.filter(‘自定义函数名’，() =&gt; {…}) 指令 ref 为某个元素指定一个唯一的标识，vue对象通过$refs属性访问这个元素对象 v-cloak 防止闪现表达式 与css属性选择器配合 [v-cloak] {display:none} 自定义指令 全局指令： vue.directive(‘指令名’，function(el,binding){…}) 参数el指属性所在的标签对象 binding包含指令相关的数据对象 局部指令： 在vue实例选项中配置directives:{‘指令名’，(el,binding) =&gt; {…},others} vue 自定义插件 plugin Vue 插件是一个包含 install 方法的对象 1234567891011121314151617181920 自定义 Vue 插件 包在匿名函数自执行里面(function () &#123; const MyPlugin = &#123;&#125;; MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或属性 Vue.myGlobalMethod = function () &#123; alert(&apos;Vue 函数对象方法执行&apos;) &#125;; // 2. 添加全局资源 Vue.directive(&apos;my-directive&apos;, function (el, binding) &#123; el.innerHTML = &quot;MyPlugin my-directive &quot; + binding.value &#125;); // 3. 添加实例方法 Vue.prototype.$myMethod = function () &#123; alert(&apos;vue 实例对象方法执行&apos;) &#125;; &#125; window.MyPlugin = MyPlugin;&#125;)() 页面使用插件 1234567891011121314151617181920212223&lt;div id=&quot;demo&quot;&gt;&lt;!--使用自定义指令--&gt;&lt;p v-my-directive=&quot;msg&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;vue-myPlugin.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;//声明使用自定义插件Vue.use(MyPlugin)var vm = new Vue(&#123;el: &apos;#demo&apos;,data: &#123;msg: &apos;atguigu&apos;&#125;&#125;)//调用自定义的静态方法Vue.myGlobalMethod()//调用自定义的对象方法vm.$myMethod()&lt;/script&gt; vue 组件 全局组件 局部组件 vue 组件间通信 父传向子 props 在组件内声明所有的 props 方式一: 只指定名称props: [‘name’, ‘age’, ‘setName’] 方式二: 指定名称和类型props: { name: String, age: Number, setNmae: Function} 方式三: 指定名称/类型/必要性/默认值props: { name: {type: String, required: true, default:xxx},}问题: a. 如果需要向非子后代传递数据必须多层逐层传递 b. 兄弟组件间也不能直接 props 通信, 必须借助父组件才可以 属性校验 123456789101112 要校验的 props : &#123; msg :&#123; type :Number, validator (value)&#123; //validator 属性校验器，可以自定义属性校验 return value &gt; 3; &#125; &#125; arr :&#123; type :Array, default :() =&gt; ([1,2,3]) // 属性校验中，如果是`数组/对象` 需要将默认值返回 &#125;&#125; 子传向父 通过自定义事件 绑定事件监听 // 方式一: 通过 v-on 绑定 @delete_todo=”deleteTodo” // 方式二: 通过$on() this.$refs.xxx.$on(‘delete_todo’, function (todo) { this.deleteTodo(todo) }) 触发事件 // 触发事件(只能在父组件中接收) this.$emit(eventName, data) 问题: 隔代组件或兄弟组件间通信此种方式不合适 vue 自定义事件 我的理解 子组件中 @click=”add” methods 里面 是具体的add方法干的事情 add里面最终 通过this.$emit(“add”,this.msg)通知父级我触发了此事件 并传值给父组件 父组件中 监听@add=”addCounter”methods里面定义addCounter要干啥事，用一个形参接收子组件传来的值 消息订阅与发布(PubSubJS 库) 订阅消息 —-&gt;事件监听 PubSub.subscribe(‘msg’, function(msg, data){}) 发布消息 —–&gt;触发事件 PubSub.publish(‘msg’, data) 优点: 此方式可实现任意关系组件间通信(数据) slot(插槽，占位的) 此方式用于父组件向子组件传递标签数据4.2 复用性 使用 父组件中 使用子组件，slot属性 ：xxx 对应的标签结构 子组件中 定义插槽，slot元素 name属性：不确定的标签结构 1 插槽对应的方法属性等定义在父组件中， 模块导出为函数还是对象的依据要看模块向外暴露一个功能还是多个功能 一个功能即函数 多个功能则对象 ，因为对象可以包含多个方法 ajax 插件相关知识 下载插件 引入插件 声明使用插件 即 Vue.use(名字) 方式一：vue-resource 内部会给vm对象和组件对象添加一个属性：$http $http 有两个方法 get() ,post() 方式二：axios vue.2.X 下载 npm install axios –save // 直接引入模块使用，不用声明 在哪里使用在哪里引入 123456789import axios from &apos;axios&apos; // 发送 ajax 请求axios.get(url).then(response =&gt; &#123; console.log(response.data) // 得到返回结果数据&#125;).catch(error =&gt; &#123; console.log(error.message)&#125;) 数组方法之map方法的特点：数组里面的对象变，但数组对象的个数不变组件名称 路由相关 开发中分为路由组件和非路由组件 路由组件 名称为 views 或 pages 非路由组件 名称为 components 路由器模块命名为router建立index.js文件 路由器模块: src/router/index.js 引入vue import Vue from ‘vue’ 引入VueRouter import VueRouter from ‘vue-router’ 注册使用VueRouter Vue.use(VueRouter) 导出一个VueRouter实例 1234567891011 export default new VueRouter(&#123; routes 数组， routes: [ // 路由配置 k即（path） 和value即（component） &#123; path: &apos;/&apos;, redirect: &apos;/about&apos; &#125;, &#123; path: &apos;/about&apos;, component: About &#125;, ]&#125;) 注册路由器: main.js 1234567 import Vue from &apos;vue&apos; import router from &apos;./router&apos; // 创建 vue 配置路由器new Vue(&#123; el: &apos;#app&apos;, router, render: h =&gt; h(app)&#125;) 使用路由组件标签 12345&lt;!--路由链接--&gt;&lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;&lt;router-link to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;&lt;!--用于渲染当前路由组件--&gt;&lt;router-view&gt;&lt;/router-view&gt; 子路由 children path可以写全或 直接写当前的路由名字（简化写法） 缓存路由组件对象 默认情况下, 被切换的路由组件对象会死亡释放, 再次回来时是重新创建的 如果可以缓存路由组件对象, 可以提高用户体验 123&lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 向路由组件传递数据 方式 1: 路由路径携带参数(param/query) 配置路由 12345children: [&#123; path: &apos;mdetail/:id&apos;, component: MessageDetail&#125;] 路由路径 1&lt;router-link :to=&quot;&apos;/home/message/mdetail/&apos;+m.id&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt; 路由组件中读取请求参数 1this.$route.params.id 方式 2: 属性携带数据 1&lt;router-view :msg=&quot;msg&quot;&gt;&lt;/router-view&gt; 编程式路由导航 即用js 的方法实现而非 标签方式 相关 API 栈的结构 this.$router.push(path): 相当于点击路由链接(可以返回到当前路由界面) this.$router.replace(path): 用新路由替换当前路由(不可以返回到当前路由界面) this.$router.back(): 请求(返回)上一个记录路由 this.$router.go(-1): 请求(返回)上一个记录路由 this.$router.go(1): 请求下一个记录路由 栈 队列 例子 ： 喝醉酒后站着从上面出来即为栈 call 方法调用 让一个函数成为指定对象的方法进行调用 slice.call(lis) 即让slice函数成为lis的方法进行调用","categories":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/categories/vue/"}],"tags":[{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"less-note","slug":"less","date":"2019-04-17T12:00:21.909Z","updated":"2019-04-26T06:53:41.006Z","comments":true,"path":"less/less/","link":"","permalink":"https://shulu520.com/less/less/","excerpt":"君子生非异也，善假于物也.","text":"君子生非异也，善假于物也. less 即css预处理器 vscode 编辑器 下载插件 easy less 声明编码集 @charset “utf-8”声明变量 声明变量(原始值类型) @bb:#ff0000; 使用变量 color:@bb; 声明变量（路劲类型） @img:”../images”; 使用变量 background-image:url(“@{img}/1.jpg”) 声明变量(属性类型) @ww:width; 使用变量 @{ww}:100px; 混合方式 带默认参数 定义 .border-r(@radius:5px){ border-radiis:@radius; } 使用 .box{ .border-r; 传参即.border-r(10px); } 接收多个参数 定义 .box-s(@x, @y, @blur, @color){ box-shadow:@arguments; } 使用 .box{ .box-s(3px,4px,5px,red) } color 函数 了解就行 运算 各种可以计算的都可以计算 包括颜色值 支持运算符 + - * / 即加减乘除命名空间 它用于将mixins分组在通用名称下。 使用命名空间可以避免名称冲突，并从外部封装mixin组12345678910111213141516171819202122定义：#bgcolor()&#123; // 加 () 默认不输出 background: #ffffff; .a&#123; color: #888888; &amp;:hover&#123; color: green; &#125; .b&#123; background: red; &#125; &#125;&#125;使用：.bgcolor1&#123; background: yellow; #bgcolor&gt;.a; // &gt;符号表示选中混合中的每一个样式&#125;.bgcolor2&#123; // #bgcolor&gt;.a&gt;.b; #bgcolor .a .b; // 省略写法：将&gt;换成空格即可&#125; 避免编译 我们能在编译后的css文件中看到 它 编译计算之前的样子 最终的编译计算由浏览器来完成 css3中有这样一个函数calc() less里面 123.box&#123; width:~&apos;calc(300px - 10px)&apos;&#125; 编译完的 css 123.box&#123; width:calc(300px - 10px)&#125; !important css 样式中 用来提升优先级（最高） less 中 一样 常用来调试代码 比如 某一段样式不起作用，不知道是继承还是覆盖等造成的 给他加上 !important 还不起作用的话 就说明代码书写有误","categories":[{"name":"less","slug":"less","permalink":"https://shulu520.com/categories/less/"}],"tags":[]}]}
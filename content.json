{"meta":{"title":"heloword","subtitle":null,"description":"js vue node h5 css3 es6","author":"Liu","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"vuenote","date":"2019-04-16T12:17:32.686Z","updated":"2019-04-16T12:23:35.359Z","comments":true,"path":"2019/04/16/vuenote/","link":"","permalink":"http://yoursite.com/2019/04/16/vuenote/","excerpt":"","text":"人生即在于体验，而体验源于去尝试，去折腾，去改变，去塑新。要知道：“过一个平凡无趣的人生实在太容易了，你可以不读书，不冒险，不运动，不写作，不外出，不折腾……但是，人生最后悔的事情就是：我本可以”。生活也好，职场也罢，亦同此理；编程则更如其是。Vue 的特点 1) 遵循 MVVM 模式 即MVVM 模式的一种实现2) 编码简洁, 体积小, 运行效率高, 适合移动/PC 端开发3) 它本身只关注 UI, 可以轻松引入 vue 插件（依赖vue）或其它第三库(不依赖vue)开发项目 MVVM 的理解 M 即 model 模型, 数据对象（data） V 即 view 视图，模板页面 VM 即 viewModel 视图模型 是vue的实例 dom监听 数据绑定 组件 即 局部功能界面 ，是提供某一完整功能的模块模板的理解：动态的html页面，包含了一些js语法代码vue 扩展组件1.) vue-cli: vue 脚手架2.) vue-resource(axios): ajax 请求3.) vue-router: 路由4.) vuex: 状态管理5.) vue-lazyload: 图片懒加载6.) vue-scroller: 页面滑动相关7.) mint-ui: 基于 vue 的 UI 组件库(移动端)8.) element-ui: 基于 vue 的 UI 组件库(PC 端) 编程方式 命令式 如 jquery 声明式 如 vue数组的扩展-array.some()和array.every()区别1.some():方法用于检测数组中的元素是否有满足指定条件的，若满足返回true，否则返回false；2.every():方法用于检测数组中所有元素是否都符合指定条件，若符合返回true，否则返回false；挂载元素app1.new Vue({ el :’#app’ });2.new vue({}).$moute(‘#app’) 用于单元测试vue 指令 v-bind 即 : 强制 动态 数据绑定（属性） v-on 即 @ 绑定事件监听 v-html 内部innerHTML XSS攻击 内容必须是可信赖的 vue 计算属性 computed 什么时候执行 ： 初始化显示，/ 相关的data 数据属性发生变化时触发 各个方法的返回值作为相关的属性值 get 回调函数，当需要读取当前属性值的时候回调，计算并返回当前属性的值 set 回调函数，监视当前属性值的变化，当属性值变化时回调，更新相关的属性数据 计算属性，存在缓存，多次读取，只调用一次getter计算，性能好, 全选时可用计算属性 vue 的方法 methods 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。 然而，不同的是计算属性是基于它们的依赖进行缓存的。只在相关依赖发生改变时它们才会重新求值 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数 如果你不希望有缓存，请用方法来替代 vue 的watch 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器 当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的 绑定 style class :class=”xxx” xxx是字符串或对象 :style=”xxx” xxx是对象 对象更新 完全跟新 即重新写这个对象 补充更新 vm.$set(要跟新的对象名,补充的属性名,属性值) 数组更新检测 变异方法（vue重写原生的方法）即以下这些方法已不再是原生的方法1.1 push pop shift unshift splice sort reverse 使用它们会触发视图更新1.2 注意事项： 利用索引直接设置一个项时/修改数组的长度时 vue不能检测到数组变化 常用事件修饰符 阻止事件冒泡 如@click.stop=”XXX” 传统方法 e.stopPropagation 取消事件默认行为 如 @click.prevent=”xxx” 传统方法 e.preventDefault @click.once=”xxx” 点击事件将只会触发一次 常用按键修饰符 抬起某键时，执行操作 如按回车 @keyup.enter=”xxx” 鼠标修饰符 left right middle 系统修饰键 可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 ctrl alt shift meta 表单数据的自动收集 使用 v-model vue实例的 生命周期（钩子函数） 大致有三个阶段 初始化阶段 beforeCreate created beforeMount mounted 只执行一次 更新阶段 beforeUpdate updated 执行N次 销毁阶段 beforeDestory destoryed 常用的有1：mounted （挂载方法） 发送Ajax 请求,获取真实dom ，执行定时器等异步任务2： `beforeDestory` 收尾工作，如清除定时器，解绑操作等 vue 过渡&amp;动画 过渡 ：transition1.0. 显示时的效果：xxx-enter-active{…}1.1. 隐藏时的效果 ：xxx-leave-active{…}1.2. 其中xxx表示 transition元素的name 属性值 动画 ：animation2.0 过滤 vue.filter(‘自定义函数名’，() =&gt; {…})指令 ref 为某个元素指定一个唯一的标识，vue对象通过$refs属性访问这个元素对象 v-cloak 防止闪现表达式 与css属性选择器配合 [v-cloak] {display:none} 自定义指令1.全局指令1.1 vue.directive(‘指令名’，function(el,binding){…})1.2 参数el指属性所在的标签对象 binding包含指令相关的数据对象 局部指令2.1 在vue实例选项中配置directives:{‘指令名’，(el,binding) =&gt; {…},others} vue 自定义插件 plugin Vue 插件是一个包含 install 方法的对象 1234567891011121314151617181920212223/*** 自定义 Vue 插件 包在匿名函数自执行里面*/(function () &#123; const MyPlugin = &#123;&#125;; MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或属性 Vue.myGlobalMethod = function () &#123; alert(&apos;Vue 函数对象方法执行&apos;) &#125;; // 2. 添加全局资源 Vue.directive(&apos;my-directive&apos;, function (el, binding) &#123; el.innerHTML = &quot;MyPlugin my-directive &quot; + binding.value &#125;); // 3. 添加实例方法 Vue.prototype.$myMethod = function () &#123; alert(&apos;vue 实例对象方法执行&apos;) &#125;; &#125; window.MyPlugin = MyPlugin;&#125;)() 2.页面使用插件1234567891011121314151617181920212223&lt;div id=&quot;demo&quot;&gt;&lt;!--使用自定义指令--&gt;&lt;p v-my-directive=&quot;msg&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;vue-myPlugin.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;//声明使用自定义插件Vue.use(MyPlugin)var vm = new Vue(&#123;el: &apos;#demo&apos;,data: &#123;msg: &apos;atguigu&apos;&#125;&#125;)//调用自定义的静态方法Vue.myGlobalMethod()//调用自定义的对象方法vm.$myMethod()&lt;/script&gt; vue 组件 全局组件 局部组件vue 组件间通信 父传向子 props 1) 在组件内声明所有的 props 2) 方式一: 只指定名称 props: [‘name’, ‘age’, ‘setName’] 3) 方式二: 指定名称和类型 props: {name: String, age: Number, setNmae: Function } 4) 方式三: 指定名称/类型/必要性/默认值 props: {name: {type: String, required: true, default:xxx}, }问题: a. 如果需要向非子后代传递数据必须多层逐层传递 b. 兄弟组件间也不能直接 props 通信, 必须借助父组件才可以1.1 属性校验1234567891011121.1.1 要校验的 props : &#123; msg :&#123; type :Number, validator (value)&#123; //validator 属性校验器，可以自定义属性校验 return value &gt; 3; &#125; &#125; arr :&#123; type :Array, default :() =&gt; ([1,2,3]) // 属性校验中，如果是`数组/对象` 需要将默认值返回 &#125;&#125; 子传向父 通过自定义事件2.1. 绑定事件监听 // 方式一: 通过 v-on 绑定 @delete_todo=”deleteTodo” // 方式二: 通过$on() this.$refs.xxx.$on(‘delete_todo’, function (todo) { this.deleteTodo(todo) })2.2. 触发事件 // 触发事件(只能在父组件中接收) this.$emit(eventName, data) 问题: 隔代组件或兄弟组件间通信此种方式不合适 vue 自定义事件 我的理解 子组件中 @click=”add” methods 里面 是具体的add方法干的事情 add里面最终 通过this.$emit(&quot;add&quot;,this.msg)通知父级我触发了此事件 并传值给父组件 父组件中 监听@add=”addCounter” methods里面定义addCounter要干啥事，用一个形参接收子组件传来的值 消息订阅与发布(PubSubJS 库)3.1 订阅消息 —-&gt;事件监听 PubSub.subscribe(‘msg’, function(msg, data){})3.2. 发布消息 —–&gt;触发事件 PubSub.publish(‘msg’, data) 优点: 此方式可实现任意关系组件间通信(数据) slot(插槽，占位的)4.1 此方式用于父组件向子组件传递标签数据 4.2 复用性4.3 使用4.3.1 父组件中：xxx 对应的标签结构4.3.2 子组件中：不确定的标签结构 14.4.3 插槽对应的方法属性等定义在父组件中，子组件只是使用罢了 模块导出为函数还是对象的依据要看模块向外暴露一个功能还是多个功能 一个功能即函数 多个功能则对象 ，因为对象可以包含多个方法 ajax 插件相关知识 下载插件 引入插件 声明使用插件 即 Vue.use(名字)4.方式一：vue-resource 内部会给vm对象和组件对象添加一个属性：$http $http 有两个方法 get() ,post() 6.方式二：axios vue.2.X6.1 下载 npm install axios –save // 直接引入模块使用，不用声明 在哪里使用在哪里引入12345678import axios from &apos;axios&apos; // 发送 ajax 请求axios.get(url).then(response =&gt; &#123;console.log(response.data) // 得到返回结果数据&#125;).catch(error =&gt; &#123;console.log(error.message)&#125;) 数组方法之map方法的特点：数组里面的对象变，但数组对象的个数不变vue路由 vue-router 官方提供的用来实现 SPA 的 vue 插件 下载下载: npm install vue-router –save 相关 API 说明2.1 组件名称 路由相关 开发中分为路由组件和非路由组件 路由组件 名称为 views 或 pages 非路由组件 名称为 components 4.路由器模块命名为router建立index.js文件4.1 路由器模块: src/router/index.js5.1 引入vue import Vue from ‘vue’5.2 引入VueRouter import VueRouter from ‘vue-router’5.3 注册使用VueRouter Vue.use(VueRouter)5.导出一个VueRouter实例 1234567891011121314 export default new VueRouter(&#123; routes 数组， routes: [ // 路由配置 k即（path） 和value即（component） &#123; path: &apos;/&apos;, redirect: &apos;/about&apos; &#125;, &#123; path: &apos;/about&apos;, component: About &#125;, &#123; path: &apos;/home&apos;, component: Home &#125; ]&#125;) 注册路由器: main.js1234567 import Vue from &apos;vue&apos; import router from &apos;./router&apos; // 创建 vue 配置路由器new Vue(&#123; el: &apos;#app&apos;, router, render: h =&gt; h(app)&#125;) 7.使用路由组件标签12345&lt;!--路由链接--&gt;&lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;&lt;router-link to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;&lt;!--用于渲染当前路由组件--&gt;&lt;router-view&gt;&lt;/router-view&gt; 子路由 children path可以写全或 直接写当前的路由名字（简化写法） 缓存路由组件对象 默认情况下, 被切换的路由组件对象会死亡释放, 再次回来时是重新创建的 如果可以缓存路由组件对象, 可以提高用户体验 编码实现123&lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 向路由组件传递数据 方式 1: 路由路径携带参数(param/query) 1) 配置路由 12345children: [&#123; path: &apos;mdetail/:id&apos;, component: MessageDetail&#125;] 2) 路由路径 1&lt;router-link :to=&quot;&apos;/home/message/mdetail/&apos;+m.id&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt; 3) 路由组件中读取请求参数 1this.$route.params.id 5.4.3. 方式 2: 12```&lt;router-view :msg=&quot;msg&quot;&gt;&lt;/router-view&gt; 编程式路由导航 即用js 的方法实现而非 标签方式 相关 API 栈的结构 this.$router.push(path): 相当于点击路由链接(可以返回到当前路由界面) this.$router.replace(path): 用新路由替换当前路由(不可以返回到当前路由界面) this.$router.back(): 请求(返回)上一个记录路由 this.$router.go(-1): 请求(返回)上一个记录路由 this.$router.go(1): 请求下一个记录路由 栈 队列 例子 ： 喝醉酒后站着从上面出来即为栈 ， call 方法调用 让一个函数成为指定对象的方法进行调用 slice.call(lis) 即让slice函数成为lis的方法进行调用 vue 源码分析知识点分析 vue 作为一个 MVVM 框架的基本实现原理##. 准备知识 1) [].slice.call(lis): 将伪数组转换为真数组 slice 方法有浅拷贝的用法，表示截取一部分，不传参数的话就是拷贝原数组 这样更好 Array.prototype.slice.call(lis) 2) node.nodeType: 得到节点类型 节点类型：常用的 document // 文档 Element //元素节点 节点类型 nodeType === 1; Attr //属性 Text //文本 documentFragment // 文档碎片 3)Object.defineProperty(obj, propName, {}): 给对象添加/修改属性(指定描述符) vue 数据代理的核心语法，不支持ie8，面试题 属性描述符： （1）数据描述符： configurable: true/false 是否可以重新 define enumerable: true/false 是否可以枚举(for..in / keys()) value: 指定初始值 writable: true/false value 是否可以修改 （2）访问描述符：vue的计算属性就是利用get set 方法 get: 回调函数, 根据其他相关的属性动态计算得到当前属性值，根据相关的属性更新（得到）当前的属性 set: 回调函数, 监视当前属性值的变化，更新相关的属性值 ，根据当前的属性更新相关的属性 4) Object.keys(obj): 得到对象自身可枚举的属性名的数组 5) obj.hasOwnProperty(prop): 判断 prop 是否是 obj 自身的属性 6) DocumentFragment: 文档碎片(高效批量更新多个节点) 传言啊 这个 childNodes是正统属性 亲生的 而这个children是野孩子 这个野孩子比较随意 所以用它返回来的就只有DOM元素了 其他的文字啥的 都不返回 而 childNodes比较讲究 事无巨细 都要返回来 但是我还是觉得野孩子乖 所以也获得了几乎所有浏览器的支持 如果你想要DOM节点 直接用野孩子就可以了 例子 id1234 &lt;li&gt;test1&lt;/li&gt; &lt;li&gt;test2&lt;/li&gt; &lt;li&gt;test3&lt;/li&gt;&lt;/ul&gt; 12345678910111213let list = document.getElementById(&quot;list&quot;); // 1. 创建文档碎片 let fragment = document.createDocumentFragment(); // 2. 取出ul中 所有 子节点保存到fragment中 //Array.prototype.slice.call(list.children).forEach(element =&gt; &#123; fragment.appendChild(element); &#125;); // 3.修改fragment中的每一个子元素的内容 Array.prototype.slice.call(fragment.children).forEach(element =&gt; &#123; element.textContent = &apos;舒璐&apos;; &#125;); // 4.将文档碎片插入到list中 list.appendChild(fragment); 数据代理的实现基本实现流程 通过 Object.defineProperty()给 vm 添加与 data 对象的属性对应的属性描述符 所有添加的属性都包含 getter/setter getter/setter 内部去操作 data 中对应的属性数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849相当于Vue的构造函数function MVVM(options) &#123; // 将选项对象保存到vm this.$options = options; // 将data对象保存到vm和datq变量中 var data = this._data = this.$options.data; //将vm保存在me变量中 var me = this; // 遍历data中所有属性 Object.keys(data).forEach(function (key) &#123; // 属性名: name // 对指定属性实现代理 me._proxy(key); &#125;); // 对data进行监视 observe(data, this); // 创建一个用来编译模板的compile对象 this.$compile = new Compile(options.el || document.body, this)&#125;MVVM.prototype = &#123; $watch: function (key, cb, options) &#123; new Watcher(this, key, cb); &#125;, // 对指定属性实现代理 _proxy: function (key) &#123; // 保存vm var me = this; // 给vm添加指定属性名的属性(使用属性描述) Object.defineProperty(me, key, &#123; configurable: false, // 不能再重新定义 enumerable: true, // 可以枚举 // 当通过vm.name读取属性值时自动调用 get: function proxyGetter() &#123; // 读取data中对应属性值返回(实现代理读操作) return me._data[key]; &#125;, // 当通过vm.name = &apos;xxx&apos;时自动调用 set: function proxySetter(newVal) &#123; // 将最新的值保存到data中对应的属性上(实现代理写操作) me._data[key] = newVal; &#125; &#125;); &#125;&#125;; 其中最关键的部分为 Object.defineProperty(me, key, { configurable: false, // 不能再重新定义 enumerable: true, // 可以枚举 // 当通过vm.name读取属性值时自动调用 get: function proxyGetter() {// 读取data中对应属性值返回(实现代理读操作) return me._data[key]; }, // 当通过vm.name = ‘xxx’时自动调用 set: function proxySetter(newVal) {// 将最新的值保存到data中对应的属性上(实现代理写操作) me._data[key] = newVal; }}); 模板解析 嵌套调用: a里面调用b,b里面调用c 递归: a 里面调用 a ,a继续调用a即特殊的嵌套调用 模板解析的基本流程 1)将 el 的所有子节点取出, 添加到一个新建的文档 fragment 对象中 2)对 fragment 中的所有层次子节点递归进行编译解析处理 对大括号表达式文本节点进行解析 对元素节点的指令属性进行解析 事件指令解析 一般指令解析 3) 将解析后的 fragment 添加到 el 中显示 模板解析(1): 大括号表达式解析&lt;p&gt;&lt;/p&gt; 1) 根据正则对象得到匹配出的表达式字符串: 子匹配/RegExp.$1 name 2) 从 data 中取出表达式对应的属性值 3) 将属性值设置为文本节点的 textContent 模板解析(2): 事件指令解析 1) 从指令名中取出事件名 2) 根据指令的值(表达式)从 methods 中得到对应的事件处理函数对象 3) 给当前元素节点绑定指定事件名和回调函数的 dom 事件监听 4) 指令解析完后, 移除此指令属性 模板解析(3): 一般指令解析 1) 得到指令名和指令值(表达式) text/html/class msg/myClass 2) 从 data 中根据表达式得到对应的值 3) 根据指令名确定需要操作元素节点的什么属性 v-text—textContent 属性 v-html—innerHTML 属性 v-class–className 属性 4) 将得到的表达式的值设置到对应的属性上 5) 移除元素的指令属性 call apply bind JavaScript 的一大特点是， 函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念 apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里 bind()最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的this值。 常见的错误就像，将方法从对象中拿出来，然后调用，并且希望this指向原来的对象。 如果不做特殊处理，一般会丢失原来的对象。用bind方法可以 数据绑定 简单地说，就是数据更新，界面改变。 一旦更新了 data 中的某个属性数据, 所有界面上直接使用或间接使用了此属性的节点都会 更新 数据劫持 1) 数据劫持是 vue 中用来实现数据绑定的一种技术 2) 基本思想: 通过 defineProperty()来监视 data 中所有属性(任意层次)数据的变化, 一旦变化就去更新界面 初始化显示：页面（表达式/指令）能从data中读取数据显示（编译/解析）更新显示：更新data中的属性数据，.&gt;&gt;&gt; 页面更新图中黑线表示初始化，红线表示更新时触发 双向数据绑定 双向数据绑定是建立在单向数据绑定(model==&gt;View)的基础之上的 双向数据绑定的实现流程: a. 在解析 v-model 指令时, 给当前元素添加 input 监听(input事件会在value属性值发生改变时触发，通过js改变value属性值不会触发此事件。只有IE8以上或者谷歌火狐等标准浏览器支持。) b. 当 input 的 value 发生改变时, 将最新的值赋值给当前表达式所对应的 data 属性 vuex 是vue 的一个插件 简单来说: 对 vue 应用中多个组件的共享状态进行集中式的管理(读/写) 状态自管理应用 1) state: 驱动应用的数据源（data） 2) view: 以声明方式将 state 映射到视图(模板界面) 3) actions:（在vue中是函数） 响应在 view 上的用户输入导致的状态变化 (包含 n 个*更新状态的方法*) ![](vuenote_files/2.jpg) 多组件共享状态的问题 1) 多个视图依赖于同一状态 2) 来自不同视图的行为需要变更同一状态 3) 以前的解决办法: a. 将数据以及操作数据的行为都定义在父组件 b. 将数据以及操作数据的行为传递给需要的各个子组件(有可能需要多级传递) 4) vuex 就是用来解决这个问题的 vuex 核心概念和 API 1. state 1) vuex 管理的状态对象 2) 它应该是唯一的 2. mutations 1) 包含多个直接更新 state 的方法(回调函数)的对象 2) 谁来触发: action 中的 commit(&apos;mutation 名称&apos;) 3) 只能包含同步的代码, 不能写异步代码 const mutations = { yyy (state, {data1}) { // 更新 state 的某个属性 } } vuex 人生管理哲学，哈哈State:想一想，你现在心里在意哪些事？ Mutation目标导向: 写下目标，直接改变State Action阶段性执行： 写下行动 ，执行一个个Matation、异步函数、和其它阶段性执行。 Getters: 写下其它指标，根据现有的state得到其他的指标 mapState和mapGetters必须在computed中访问，因为它们返回的是对象，所以需要用拓展符…进行展开。 mapActions则是将Action挂载到methods上，也需要用拓展符…进行展开。 组件中的mapActions([“increment”])与actions 中 increment 函数名一样actions 中 commit(“INCREMENT”)与mutations 中 INCREMENT函数名一样大写的函数名只是为了区分各个函数 可以定义一个mutation-type.js","categories":[],"tags":[]},{"title":"哈哈，棒棒哒","slug":"haha","date":"2019-04-16T06:11:29.151Z","updated":"2019-04-16T06:16:23.650Z","comments":true,"path":"2019/04/16/haha/","link":"","permalink":"http://yoursite.com/2019/04/16/haha/","excerpt":"","text":"试了好几次，终于可以了 这是二级标题这是三级标题三级标题的内容","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-04-16T05:42:35.807Z","updated":"2019-04-16T05:42:35.808Z","comments":true,"path":"2019/04/16/hello-world/","link":"","permalink":"http://yoursite.com/2019/04/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}
{"meta":{"title":"梦不成","subtitle":"思念如马-自别离-未停蹄","description":"君子生非异也，善假于物也.","author":"梦不成","url":"https://shulu520.com","root":"/"},"pages":[{"title":"","date":"2019-04-22T05:57:10.894Z","updated":"2019-04-22T05:57:10.894Z","comments":true,"path":"404/404.html","permalink":"https://shulu520.com/404/404.html","excerpt":"","text":"L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"model\":{\"scale\":1,\"hHeadPos\":0.5,\"vHeadPos\":0.618,\"jsonPath\":\"/live2dw/assets/shizuku.model.json\"},\"display\":{\"superSample\":2,\"width\":160,\"height\":320,\"position\":\"left\",\"hOffset\":-12,\"vOffset\":-43},\"mobile\":{\"show\":true,\"scale\":0.5},\"react\":{\"opacityDefault\":0.7,\"opacityOnHover\":0.2},\"log\":false,\"tagMode\":false});"},{"title":"","date":"2019-04-22T05:41:23.000Z","updated":"2019-04-25T17:02:04.110Z","comments":false,"path":"/404.html","permalink":"https://shulu520.com//404.html","excerpt":"","text":"&lt;!DOCTYPE HTML&gt; L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"model\":{\"scale\":1,\"hHeadPos\":0.5,\"vHeadPos\":0.618,\"jsonPath\":\"/live2dw/assets/shizuku.model.json\"},\"display\":{\"superSample\":2,\"width\":160,\"height\":320,\"position\":\"left\",\"hOffset\":-12,\"vOffset\":-43},\"mobile\":{\"show\":true,\"scale\":0.5},\"react\":{\"opacityDefault\":0.7,\"opacityOnHover\":0.2},\"log\":false,\"tagMode\":false});"},{"title":"guestbook","date":"2019-04-20T10:28:28.000Z","updated":"2019-04-20T10:30:14.977Z","comments":true,"path":"guestbook/index.html","permalink":"https://shulu520.com/guestbook/index.html","excerpt":"","text":""},{"title":"js","date":"2019-04-16T18:00:45.000Z","updated":"2019-04-16T18:00:45.870Z","comments":true,"path":"js/index.html","permalink":"https://shulu520.com/js/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-04-20T01:53:24.000Z","updated":"2019-04-20T05:54:52.506Z","comments":true,"path":"categories/index.html","permalink":"https://shulu520.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-20T01:52:59.000Z","updated":"2019-04-20T05:55:51.245Z","comments":true,"path":"tags/index.html","permalink":"https://shulu520.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-05-10T17:06:30.320Z","updated":"2019-05-10T17:06:30.320Z","comments":true,"path":"about/css/style.css","permalink":"https://shulu520.com/about/css/style.css","excerpt":"","text":"*{ margin: 0;padding: 0; } a{ text-decoration: none; } #beye{ margin-top: 10px; text-align: center; font-size: 55px } body{ width: 100%; height: 100%; overflow: hidden; background-color: pink; } #box{ height: 180px; margin: 80px auto; line-height: 180px; text-align: center; font-size: 54px; border-radius: 20px; color: red; } canvas { position:absolute; right:0; width:100%; height: 50%; z-index: 999; } #gohome a{ text-decoration: none; color: #fff; font-weight: bold; display: block; width: 100%; height: 100%; text-align: center; } #gohome a:hover{ color:red; } #gohome{ position: absolute; bottom: 15%; left: 50%; z-index: 9999; text-align: center; margin-left:-50px; width: 80px; height: 80px; overflow: hidden; font-size: 18px; line-height: 80px; border-radius: 50%; opacity: 0.4; background-color:rgba(45, 182, 67, 0.9); -webkit-animation: rotate 3s linear infinite; -moz-animation: rotate 3s linear infinite; -o-animation: rotate 3s linear infinite; animation: rotate 3s linear infinite; } @-webkit-keyframes rotate{from{-webkit-transform: rotate(0deg)} to{-webkit-transform: rotate(360deg)} } @-moz-keyframes rotate{from{-moz-transform: rotate(0deg)} to{-moz-transform: rotate(359deg)} } @-o-keyframes rotate{from{-o-transform: rotate(0deg)} to{-o-transform: rotate(359deg)} } @keyframes rotate{from{transform: rotate(0deg)} to{transform: rotate(359deg)} }"},{"title":"","date":"2019-04-26T10:48:46.313Z","updated":"2019-04-26T10:48:46.313Z","comments":true,"path":"about/js/index.js","permalink":"https://shulu520.com/about/js/index.js","excerpt":"","text":"(function () { var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame; window.requestAnimationFrame = requestAnimationFrame; })(); var canvas = document.getElementById(\"canvas\"), shapeCan = document.createElement(\"canvas\"), ctx = canvas.getContext(\"2d\"), sCtx = shapeCan.getContext(\"2d\"), width = window.innerWidth, height = document.body.offsetHeight, vanishPointY = height / 2, vanishPointX = width / 2, focalLength = 300, angle = 0, angleY = 0, angleX = 0, angleZ = 0, mouseX = 0, mouseY = 0; var settings = { MouseRotation: false, ClockColor: { r: 255, g: 0, b: 0 } } canvas.width = width; canvas.height = height; shapeCan.width = 200; shapeCan.height = 100; sCtx.font = '3em Arial'; /* * Controls the emitter */ function Emitter() { this.particles = []; this.shapeParts = []; this.x = 1; this.y = 1; this.z = 1; this.getShape(); this.startTime = new Date().getTime(); this.checkInterval = 200; } Emitter.prototype.update = function () { var partLen = this.particles.length; if (settings.MouseRotation) { angleX = (mouseY - vanishPointY) * 0.01; angleY = (mouseX - vanishPointX) * 0.01; } else { angleY = Math.sin(angle += 0.01); angleX = Math.sin(angle); angleZ = Math.sin(angle); } // z-sorting this.particles.sort(function (a, b) { return b.z - a.z; }); for (var i = 0; i < partLen; i++) { var particle = this.particles[i]; if (particle) { particle.update(); } } } Emitter.prototype.getShape = function () { var d = new Date(), hour = d.getHours() % 12, min = (d.getMinutes() < 10 ? \"0\" : \"\") + d.getMinutes(), sec = (d.getSeconds() < 10 ? \"0\" : \"\") + d.getSeconds(); sCtx.clearRect(0, 0, shapeCan.width, shapeCan.height); sCtx.fillText(hour + \":\" + min + \":\" + sec, 0, 30); var imageData = sCtx.getImageData(0, 0, shapeCan.width, shapeCan.height).data; for (var i = 0; i < imageData.length; i += 4) { var x = i / 4 % shapeCan.width, y = (i / 4 - x) / shapeCan.width, index = i; if (imageData[i + 3] > 0) { for (var p = 0; p < 4; p++) { if (!this.shapeParts[index + p]) { var particle = new Particle({ x: ((x * 2)) - 200, y: ((y * 2)) - 100, z: 10 }); this.shapeParts[index + p] = particle; this.particles[index + p] = particle; } } } else { for (var p = 0; p < 4; p++) { if (this.shapeParts[index + p]) { this.shapeParts[index + p].explode(); this.shapeParts[index + p] = undefined; } } } } } Emitter.prototype.render = function () { if (new Date().getTime() > this.startTime + this.checkInterval) { this.startTime = new Date().getTime(); this.getShape(); } var imgData = ctx.createImageData(width, height), data = imgData.data, partLen = this.particles.length; for (var i = 0; i < partLen; i++) { var particle = this.particles[i]; if (particle && particle.render && particle.xPos < width && particle.xPos > 0 && particle.yPos > 0 && particle.yPos < height) { for (var w = 0; w < particle.size; w++) { for (var h = 0; h < particle.size; h++) { if (particle.xPos + w < width && particle.xPos + w > 0 && particle.yPos + h > 0 && particle.yPos + h < height) { pData = (~~ (particle.xPos + w) + (~~ (particle.yPos + h) * width)) * 4; data[pData] = settings.ClockColor.r; data[pData + 1] = settings.ClockColor.g; data[pData + 2] = settings.ClockColor.b; data[pData + 3] = particle.color[3]; } } } } else if (particle && !particle.render) { this.particles[i] = undefined; delete particle; } } ctx.putImageData(imgData, 0, 0); } /* * Controls the individual particles */ function Particle(options) { options = options || {}; this.maxDist = 1000; this.x = options.x || (Math.random() * 10) - 5; this.y = options.y || (Math.random() * 10) - 5; this.z = options.z || (Math.random() * 10) - 5; this.startX = this.x; this.startY = this.y; this.startZ = this.z; this.xPos = 0; this.yPos = 0; this.angle = 0; this.vx = 0; this.vy = 0; this.vz = 0; this.color = [255, 0, 0, 255] this.render = true; this.scaler = 2; } Particle.prototype.explode = function () { this.vx = (Math.random() * 30) - 15; this.vy = (Math.random() * 30) - 15; this.vz = (Math.random() * 30) - 15; } Particle.prototype.rotate = function () { var x = this.startX * Math.cos(angleZ) - this.startY * Math.sin(angleZ), y = this.startY * Math.cos(angleZ) + this.startX * Math.sin(angleZ); this.x = x; this.y = y; x = this.startX * Math.cos(angleY) - this.startZ * Math.sin(angleY); var z = this.startZ * Math.cos(angleY) + this.startX * Math.sin(angleY); this.x = x; this.z = z; y = this.startY * Math.cos(angleX) - this.startZ * Math.sin(angleX); z = this.startZ * Math.cos(angleX) + this.startY * Math.sin(angleX); this.y = y; this.z = z; } Particle.prototype.update = function () { this.x = (this.startX += this.vx); this.y = (this.startY += this.vy); this.z = (this.startZ -= this.vz); this.rotate(); this.render = false; if (this.z > -focalLength) { var scale = focalLength / (focalLength + this.z); this.size = scale * this.scaler; this.xPos = vanishPointX + this.x * scale; this.yPos = vanishPointY + this.y * scale; var dx = this.startX - this.x, dy = this.startY - this.y, dz = this.startZ - this.z, dist = Math.sqrt(dx * dx + dy * dy + dz * dz); if (dist < this.maxDist) { this.render = true; } } } function render() { emitter.update(); emitter.render(); requestAnimationFrame(render); } var emitter = new Emitter(); render(); // var gui = new dat.GUI(); // gui.add(settings, 'MouseRotation'); // gui.addColor(settings, 'ClockColor'); document.body.addEventListener(\"mousemove\", function (e) { mouseX = e.clientX; mouseY = e.clientY; }); window.onresize = function () { height = canvas.height = document.body.offsetHeight; width = canvas.width = document.body.offsetWidth; vanishPointY = height / 2; vanishPointX = width / 2; };"},{"title":"","date":"2019-05-14T09:00:02.381Z","updated":"2019-05-14T09:00:02.381Z","comments":true,"path":"love/css/style.css","permalink":"https://shulu520.com/love/css/style.css","excerpt":"","text":"*{margin:0px;padding:0px;} body{background:rgb(224, 160, 205);} .heart3d { position: absolute; top: 12%; right: 0; left: 0; margin: auto; width: 100px; height: 160px; transform-origin:centercenter center; transform-style: preserve-3d; animation: spin 15s infinite linear; } #display{ position: absolute; top: 40%; left: 0; right: 0; margin: 0 10%; } .display { background-image: -webkit-linear-gradient(left,rgb(13, 13, 216),#66ffff 10%,#cc00ff 20%,#CC00CC 30%, #CCCCFF 40%, #00FFFF 50%,#CCCCFF 60%,#CC00CC 70%,#CC00FF 80%,#66FFFF 90%,rgb(4, 0, 255) 100%); -webkit-text-fill-color: transparent;/* 将字体设置成透明色 */ -webkit-background-clip: text;/* 裁剪背景图，使文字作为裁剪区域向外裁剪 */ -webkit-background-size: 200% 100%; -webkit-animation: masked-animation 5s linear infinite; } @keyframes masked-animation { 0% { background-position: 0 0; } 50% { background-position: -50% 0; } 100% { background-position: -100% 0; } } #gohome a{ text-decoration: none; color: #fff; font-weight: bold; display: block; width: 100%; height: 100%; text-align: center; } #gohome a:hover{ color:red; } #gohome{ position: absolute; bottom: 10%; left: 50%; text-align: center; margin-left:-50px; width: 80px; height: 80px; overflow: hidden; font-size: 18px; line-height: 80px; border-radius: 50%; opacity: 0.4; background-color:rgba(45, 182, 67, 0.2); -webkit-animation: rotate 3s linear infinite; -moz-animation: rotate 3s linear infinite; -o-animation: rotate 3s linear infinite; animation: rotate 3s linear infinite; } @-webkit-keyframes rotate{from{-webkit-transform: rotate(0deg)} to{-webkit-transform: rotate(360deg)} } @-moz-keyframes rotate{from{-moz-transform: rotate(0deg)} to{-moz-transform: rotate(359deg)} } @-o-keyframes rotate{from{-o-transform: rotate(0deg)} to{-o-transform: rotate(359deg)} } @keyframes rotate{from{transform: rotate(0deg)} to{transform: rotate(359deg)} } .heart3d [class^=\"rib\"] { position: absolute; width: 100px; height: 160px; border: solid #f22613; border-width: 1px 1px 00; border-radius: 50% 50% 0 /40% 50% 0; } .heart3d [class$=\"1\"] { transform: rotateY(10deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"2\"] { transform: rotateY(20deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"3\"] { transform: rotateY(30deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"4\"] { transform: rotateY(40deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"5\"] { transform: rotateY(50deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"6\"] { transform: rotateY(60deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"7\"] { transform: rotateY(70deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"8\"] { transform: rotateY(80deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"9\"] { transform: rotateY(90deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"10\"] { transform: rotateY(100deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"11\"] { transform: rotateY(110deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"12\"] { transform: rotateY(120deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"13\"] { transform: rotateY(130deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"14\"] { transform: rotateY(140deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"15\"] { transform: rotateY(150deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"16\"] { transform: rotateY(160deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"17\"] { transform: rotateY(170deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"18\"] { transform: rotateY(180deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"19\"] { transform: rotateY(190deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"20\"] { transform: rotateY(200deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"21\"] { transform: rotateY(210deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"22\"] { transform: rotateY(220deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"23\"] { -webkit-transform: rotateY(230deg) rotateZ(45deg) translateX(30px); transform: rotateY(230deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"24\"] { transform: rotateY(240deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"25\"] { transform: rotateY(250deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"26\"] { transform: rotateY(260deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"27\"] { transform: rotateY(270deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"28\"] { transform: rotateY(280deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"29\"] { transform: rotateY(290deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"30\"] { transform: rotateY(300deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"31\"] { transform: rotateY(310deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"32\"] { transform: rotateY(320deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"33\"] { transform: rotateY(330deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"34\"] { transform: rotateY(340deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"35\"] { transform: rotateY(350deg) rotateZ(45deg) translateX(30px); } .heart3d [class$=\"36\"] { transform: rotateY(360deg) rotateZ(45deg) translateX(30px); } @keyframes spin { to { transform: rotateY(360deg) rotateX(360deg); } } .per{ width:50px;height:50px;position:absolute;top:0;left:0;right:0;bottom:0; margin:auto;transform-style:preserve-3d;perspective:800px; } .img{width:50px;height:50px;position:absolute;backface-visibility:hidden; } .img:nth-child(1){top:-50px;left:0;transform-origin:bottom; transform:translateZ(30px)rotateX(90deg);} .img:nth-child(2){top:50px;left:0;transform-origin:top; transform:translateZ(30px)rotateX(-90deg);} .img:nth-child(3){top:0px;left:-50px;transform-origin:right; transform:translateZ(30px)rotateY(-90deg);} .img:nth-child(4){top:0px;left:50px;transform-origin:left; transform:translateZ(30px)rotateY(90deg);} .img:nth-child(6){top:0px;left:0;transform:translateZ(30px);} .img:nth-child(5){top:0px;left:0;transform:translateZ(0px);} #dance span.dance-content{ float:left; position: relative; top: 10px; left: 35%; margin: 5px; } #dance span.dance-content:nth-child(1){ -webkit-animation:jump 2s linear 0s infinite alternate; } #dance span.dance-content:nth-child(2){ -webkit-animation:jump 2s linear 0.2s infinite alternate; } #dance span.dance-content:nth-child(3){ -webkit-animation:jump 2s linear 0.4s infinite alternate; } #dance span.dance-content:nth-child(4){ -webkit-animation:jump 2s linear 0.3s infinite alternate; } #dance span.dance-content:nth-child(5){ -webkit-animation:jump 2s linear 0.4s infinite alternate; } #dance span.dance-content:nth-child(6){ -webkit-animation:jump 2s linear 0.3s infinite alternate; } #dance span.dance-content:nth-child(7){ -webkit-animation:jump 2s linear 0.4s infinite alternate; } @-webkit-keyframes jump { 0%{ top:0px; color:red; } 10%{ top:-4px; color:#66ffff; } 20%{ top:-8px; color:#cc00ff; } 30%{ top:-12px; color:#CC00CC; } 50%{ top:-16px; color:#00FFFF; } 60%{ top:-12px; color:rgb(105, 108, 255); } 70%{ top:-8px; color:#CC00CC; } 80%{ top:-4px; color:#CC00FF; } 90%{ top:-2px; color:#66FFFF; } 100%{ top:0px; color:rgb(13, 13, 216); } }"},{"title":"","date":"2019-04-28T11:56:26.010Z","updated":"2011-12-29T19:39:44.000Z","comments":true,"path":"about/assets/countdown/jquery.countdown.css","permalink":"https://shulu520.com/about/assets/countdown/jquery.countdown.css","excerpt":"","text":".countdownHolder{ width:450px; margin:0 auto; font: 40px/1.5 'Open Sans Condensed',sans-serif; text-align:center; letter-spacing:-3px; } .position{ display: inline-block; height: 1.6em; overflow: hidden; position: relative; width: 1.05em; } .digit{ position:absolute; display:block; width:1em; background-color:#444; border-radius:0.2em; text-align:center; color:#fff; letter-spacing:-1px; } .digit.static{ box-shadow:1px 1px 1px rgba(4, 4, 4, 0.35); background-image: linear-gradient(bottom, #3A3A3A 50%, #444444 50%); background-image: -o-linear-gradient(bottom, #3A3A3A 50%, #444444 50%); background-image: -moz-linear-gradient(bottom, #3A3A3A 50%, #444444 50%); background-image: -webkit-linear-gradient(bottom, #3A3A3A 50%, #444444 50%); background-image: -ms-linear-gradient(bottom, #3A3A3A 50%, #444444 50%); background-image: -webkit-gradient( linear, left bottom, left top, color-stop(0.5, #3A3A3A), color-stop(0.5, #444444) ); } /** * You can use these classes to hide parts * of the countdown that you don't need. */ .countDays{ /* display:none !important;*/ } .countDiv0{ /* display:none !important;*/ } .countHours{} .countDiv1{} .countMinutes{} .countDiv2{} .countSeconds{} .countDiv{ display:inline-block; width:16px; height:1.6em; position:relative; } .countDiv:before, .countDiv:after{ position:absolute; width:5px; height:5px; background-color:#444; border-radius:50%; left:50%; margin-left:-3px; top:0.5em; box-shadow:1px 1px 1px rgba(4, 4, 4, 0.5); content:''; } .countDiv:after{ top:0.9em; }"},{"title":"","date":"2019-05-02T14:08:55.625Z","updated":"2019-05-02T14:08:55.625Z","comments":true,"path":"about/assets/css/styles.css","permalink":"https://shulu520.com/about/assets/css/styles.css","excerpt":"","text":"/*------------------------- Simple reset --------------------------*/ *{ margin:0; padding:0; } /*------------------------- General Styles --------------------------*/ html{ position:relative; } body{ min-height: 600px; padding: 200px 0 0; font:14px/1.3 'Segoe UI',Arial, sans-serif; } a, a:visited { text-decoration:none; outline:none; color:#54a6de; } a:hover{ text-decoration:underline; } section, footer{ display: block; } /*---------------------------- Main Section -----------------------------*/ #note{ color: #666666; font-size: 12px; margin: 0 auto; padding: 4px; text-align: center; text-shadow: 1px 1px 0 rgba(255, 255, 255, 0.3); width: 400px; } /*---------------------------- The Footer -----------------------------*/ footer{ background-color: #111111; bottom: 0; box-shadow: 0 -1px 2px #111111; height: 45px; left: 0; position: fixed; width: 100%; z-index: 100000; } footer h2{ color: #EEEEEE; font-size: 14px; font-weight: normal; left: 50%; margin-left: -400px; padding: 13px 0 0; position: absolute; width: 540px; } footer h2 i{ font-style:normal; color:#888; } footer a.tzine,a.tzine:visited{ color: #999999; font-size: 12px; left: 50%; margin: 16px 0 0 110px; position: absolute; text-decoration: none; top: 0; } footer a i{ color:#ccc; font-style: normal; } footer a i b{ color:#c92020; font-weight: normal; }"},{"title":"","date":"2019-04-28T11:56:26.035Z","updated":"2011-12-29T19:48:15.000Z","comments":true,"path":"about/assets/countdown/jquery.countdown.js","permalink":"https://shulu520.com/about/assets/countdown/jquery.countdown.js","excerpt":"","text":"/** * @name jQuery Countdown Plugin * @author Martin Angelov * @version 1.0 * @url http://tutorialzine.com/2011/12/countdown-jquery/ * @license MIT License */ (function($){ // Number of seconds in every time division var days = 24*60*60, hours = 60*60, minutes = 60; // Creating the plugin $.fn.countdown = function(prop){ var options = $.extend({ callback : function(){}, timestamp : 0 },prop); var left, d, h, m, s, positions; // Initialize the plugin init(this, options); positions = this.find('.position'); (function tick(){ // Time left left = Math.floor((options.timestamp - (new Date())) / 1000); if(left < 0){ left = 0; } // Number of days left d = Math.floor(left / days); updateDuo(0, 1, d); left -= d*days; // Number of hours left h = Math.floor(left / hours); updateDuo(2, 3, h); left -= h*hours; // Number of minutes left m = Math.floor(left / minutes); updateDuo(4, 5, m); left -= m*minutes; // Number of seconds left s = left; updateDuo(6, 7, s); // Calling an optional user supplied callback options.callback(d, h, m, s); // Scheduling another call of this function in 1s setTimeout(tick, 1000); })(); // This function updates two digit positions at once function updateDuo(minor,major,value){ switchDigit(positions.eq(minor),Math.floor(value/10)%10); switchDigit(positions.eq(major),value%10); } return this; }; function init(elem, options){ elem.addClass('countdownHolder'); // Creating the markup inside the container $.each(['Days','Hours','Minutes','Seconds'],function(i){ $('').html( '\\ 0\\ \\ \\ 0\\ ' ).appendTo(elem); if(this!=\"Seconds\"){ elem.append(''); } }); } // Creates an animated transition between the two numbers function switchDigit(position,number){ var digit = position.find('.digit') if(digit.is(':animated')){ return false; } if(position.data('digit') == number){ // We are already showing this number return false; } position.data('digit', number); var replacement = $('',{ 'class':'digit', css:{ top:'-2.1em', opacity:0 }, html:number }); // The .static class is added when the animation // completes. This makes it run smoother. digit .before(replacement) .removeClass('static') .animate({top:'2.5em',opacity:0},'fast',function(){ digit.remove(); }) replacement .delay(100) .animate({top:0,opacity:1},'fast',function(){ replacement.addClass('static'); }); } })(jQuery);"},{"title":"","date":"2019-04-28T13:14:54.512Z","updated":"2019-04-28T13:14:54.512Z","comments":true,"path":"about/assets/js/script.js","permalink":"https://shulu520.com/about/assets/js/script.js","excerpt":"","text":"$(function(){ var note = $('#note'), // ts = new Date(2012, 0, 1), ts = new Date(2020,6,15); newYear = true; if((new Date()) > ts){ // The new year is here! Count towards something else. // Notice the *1000 at the end - time must be in milliseconds ts = (new Date()).getTime() + 10*24*60*60*1000; newYear = false; } $('#countdown').countdown({ timestamp : ts, callback : function(days, hours, minutes, seconds){ var message = \"\"; message += days + \" day\" + ( days==1 ? '':'s' ) + \", \"; message += hours + \" hour\" + ( hours==1 ? '':'s' ) + \", \"; message += minutes + \" minute\" + ( minutes==1 ? '':'s' ) + \" and \"; message += seconds + \" second\" + ( seconds==1 ? '':'s' ) + \" \"; if(newYear){ message += \"left until the new year!\"; } else { message += \"left to 10 days from now!\"; } note.html(message); } }); });"},{"title":"","date":"2019-04-26T09:48:38.162Z","updated":"2014-06-27T06:32:24.438Z","comments":true,"path":"about/js/dat.gui.min.js","permalink":"https://shulu520.com/about/js/dat.gui.min.js","excerpt":"","text":"/** * dat-gui JavaScript Controller Library * http://code.google.com/p/dat-gui * * Copyright 2011 Data Arts Team, Google Creative Lab * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 */ var dat=dat||{};dat.gui=dat.gui||{};dat.utils=dat.utils||{};dat.controllers=dat.controllers||{};dat.dom=dat.dom||{};dat.color=dat.color||{};dat.utils.css=function(){return{load:function(e,a){var a=a||document,c=a.createElement(\"link\");c.type=\"text/css\";c.rel=\"stylesheet\";c.href=e;a.getElementsByTagName(\"head\")[0].appendChild(c)},inject:function(e,a){var a=a||document,c=document.createElement(\"style\");c.type=\"text/css\";c.innerHTML=e;a.getElementsByTagName(\"head\")[0].appendChild(c)}}}(); dat.utils.common=function(){var e=Array.prototype.forEach,a=Array.prototype.slice;return{BREAK:{},extend:function(c){this.each(a.call(arguments,1),function(a){for(var f in a)this.isUndefined(a[f])||(c[f]=a[f])},this);return c},defaults:function(c){this.each(a.call(arguments,1),function(a){for(var f in a)this.isUndefined(c[f])&&(c[f]=a[f])},this);return c},compose:function(){var c=a.call(arguments);return function(){for(var d=a.call(arguments),f=c.length-1;f>=0;f--)d=[c[f].apply(this,d)];return d[0]}}, each:function(a,d,f){if(e&&a.forEach===e)a.forEach(d,f);else if(a.length===a.length+0)for(var b=0,n=a.length;b"}],"posts":[{"title":"hotkey-listary","slug":"hotkey-listary","date":"2019-05-28T15:21:39.000Z","updated":"2019-05-28T15:39:24.343Z","comments":true,"path":"hotkey/hotkey-listary/","link":"","permalink":"https://shulu520.com/hotkey/hotkey-listary/","excerpt":"&emsp;&emsp;人生如逆旅，我亦是行人。","text":"&emsp;&emsp;人生如逆旅，我亦是行人。 listary 最常用的快捷键 alt A 打开listary 双击 ctrl 打开listary bing 必应搜索 bd 百度一下 百度网盘 zh 知乎搜索 ctrl N 向下切换选中的目录 ctrl P 向上切换选中的目录 双击桌面 打开listary选项 在任意文件夹/目录下双击 打开listary选项 可以选命令打开cmd &emsp;&emsp;未完待续…… 来我QQ撩我哦👇","categories":[{"name":"hotkey","slug":"hotkey","permalink":"https://shulu520.com/categories/hotkey/"}],"tags":[{"name":"listary","slug":"listary","permalink":"https://shulu520.com/tags/listary/"}]},{"title":"hotkey-windows","slug":"hotkey-windows","date":"2019-05-27T04:24:05.000Z","updated":"2019-05-27T04:46:38.907Z","comments":true,"path":"hotkey/hotkey-windows/","link":"","permalink":"https://shulu520.com/hotkey/hotkey-windows/","excerpt":"&emsp;&emsp; 👉Q我吧","text":"&emsp;&emsp; 👉Q我吧 windows 最常用快捷键 ctrl w 关闭当前网页 f2键 ：选中后按f2键即可重命名文件，另一种方法，点一下文件名，稍等，再点一下，即可重命名 f4: 重复上步操作 f5: 刷新桌面 刷新网页 f11: 全屏显示网页 shift : 省略号 shift + 数字6 （表示六个点） …… 书名号 shift + &lt;&gt; (小于大于） 分隔号 单独按 数字1 前面的键 《简 · 爱》 Alt + 单击拖动 为矩形选择 AlT + f4 关闭当前程序 删除 选中后 按delete 永久删除 选中后 shift +delete 截屏 PrtSc 截全屏 Alt +PrtSc 截当前窗口 ctrl alt delete 任务管理器 windows 打开开始菜单 ctrl shift n 新建文件夹 window e 打开文件资源管理器 alt tab 切换窗口 window d 回到桌面 &emsp;&emsp;学到了再来补充😝 👉点这里，进入QQ交流","categories":[{"name":"hotkey","slug":"hotkey","permalink":"https://shulu520.com/categories/hotkey/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://shulu520.com/tags/windows/"}]},{"title":"js-advance-two","slug":"js-advance-two","date":"2019-05-25T15:06:08.000Z","updated":"2019-05-29T15:27:34.295Z","comments":true,"path":"js-advance/js-advance-two/","link":"","permalink":"https://shulu520.com/js-advance/js-advance-two/","excerpt":"","text":"&emsp;&emsp;又是元气满满的一天😝,文章链接失效，又好了。有惊无险 来我QQ撩我哦👇 原型与原型链 所有函数都有一个特别的属性: prototype : 显式原型属性 所有实例对象都有一个特别的属性: proto : 隐式原型属性 当然所有函数也都有一个特别的属性： proto : 隐式原型属性 且所有函数的 隐式原型 都一样 都等于Function的显式原型 函数的显式原型指向的对象默认是空Object实例对象(但Object不满足) 123console.log(Fn.prototype instanceof Object) // trueconsole.log(Object.prototype instanceof Object) // falseconsole.log(Function.prototype instanceof Object) // true 所有函数都是Function的实例(包含Function自身) 1console.log(Function.__proto__===Function.prototype) Object的原型对象是原型链尽头 1console.log(Object.prototype.__proto__) // null 1234567891011121314151617// 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)console.log(Date.prototype, typeof Date.prototype)function Fun () &#123;//alt + shift +r(重命名rename)&#125;console.log(Fun.prototype) // 默认指向一个Object空对象(没有我们的属性)// 原型对象中有一个属性constructor, 它指向函数对象console.log(Date.prototype.constructor===Date)console.log(Fun.prototype.constructor===Fun)//给原型对象添加属性(一般是方法) ===&gt;实例对象可以访问Fun.prototype.test = function () &#123; console.log(&apos;test()&apos;)&#125;var fun = new Fun()fun.test() 显式原型与隐式原型的关系 函数的prototype: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象 实例对象的proto: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值 原型对象即为当前实例对象的父对象 原型链 所有的实例对象都有proto属性, 它指向的就是原型对象 这样通过proto属性就形成了一个链的结构—-&gt;原型链 当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找 当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作,如果当前对象中没有此属性, 直接添加此属性并设置其值 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上 面试题1 1234567891011121314function A () &#123; ...&#125;A.prototype.n = 1var b = new A()A.prototype = &#123; n: 2, m: 3&#125;var c = new A()console.log(b.n, b.m, c.n, c.m) // 1 undifind 2 3 面试题2 12345678910111213141516function F ()&#123;&#125; Object.prototype.a = function()&#123; console.log(&apos;a()&apos;)&#125;Function.prototype.b = function()&#123; console.log(&apos;b()&apos;)&#125;var f = new F()f.a()f.b() // 找不到,可以看原型链图进行分析F.a()F.b() instanceof是如何判断的? 表达式: A instanceof B 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false Function是通过new自己产生的实例 123456789101112131415161718/*案例1 */function Foo() &#123; &#125;var f1 = new Foo()console.log(f1 instanceof Foo) // trueconsole.log(f1 instanceof Object) // true/*案例2 */console.log(Object instanceof Function) // trueconsole.log(Object instanceof Object) // trueconsole.log(Function instanceof Function) // trueconsole.log(Function instanceof Object) // truefunction Foo() &#123;&#125;console.log(Object instanceof Foo) // false 执行上下文与执行上下文栈 变量提升与函数提升 变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined) 函数提升: 在函数定义语句之前, 就执行该函数 先执行变量提升, 再执行函数提升 123function a() &#123;&#125;var aconsole.log(typeof a) // &apos;function&apos; 123456789101112var c = 1function c(c) &#123; console.log(c) var c = 3&#125;c(2) // 报错 c is not a function过程解析： var c fun c c = 1 c(2) 理解 执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性 执行上下文栈: 用来管理产生的多个执行上下文 分类: 全局: window 函数: 对程序员来说是透明的 生命周期 全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡 函数 : 调用函数时产生, 函数执行完时死亡 包含哪些属性: 全局 : 用var定义的全局变量 ==&gt;undefined 使用function声明的函数 ===&gt;function this ===&gt;window 函数 用var定义的局部变量 ==&gt;undefined 使用function声明的函数 ===&gt;function this ===&gt; 调用函数的对象, 如果没有指定就是window 形参变量 ===&gt;对应实参值 arguments ===&gt;实参列表的伪数组 执行上下文 创建和初始化的过程 全局执行上下文: 在全局代码执行前最先创建一个全局执行上下文(window) 收集一些全局变量, 并初始化 var定义的全局变量==&gt;undefined, 添加为window的属性 function声明的全局函数==&gt;赋值(fun), 添加为window的方法 this==&gt;赋值(window) 开始执行全局代码 函数执行上下文: 在调用函数时, 在执行函数体之前，先创建一个函数执行上下文对象(虚拟的, 存在于栈中) 收集一些局部变量, 并初始化 形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性 arguments==&gt;赋值(实参列表), 添加为执行上下文的属性 var定义的局部变量==&gt;undefined, 添加为执行上下文的属性 function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法 this==&gt;赋值(调用函数的对象) 开始执行函数体代码 执行上下文栈 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象 在全局执行上下文(window)确定后, 将其添加到栈中(压栈) 在函数执行上下文创建后, 将其添加到栈中(压栈) 在当前函数执行完后,将栈顶的对象移除(出栈) 当所有的代码执行完后, 栈中只剩下window 12345678910var a = 10var bar = function (x) &#123; var b = 5 foo(x + b)&#125;var foo = function (y) &#123; var c = 5 console.log(a + c + y)&#125;bar(10) 产生执行上下文的个数 = (N)函数调用次数 + 1 面试题 整个过程中产生了几个执行上下文? 5 依次输出什么?gb: undefinedfb: 1fb: 2fb: 3fe: 3fe: 2fe: 1ge: 1 123456789101112console.log(&apos;gb: &apos;+ i)var i = 1foo(1)function foo(i) &#123; if (i == 4) &#123; return &#125; console.log(&apos;fb:&apos; + i) foo(i + 1) // 递归调用: 在函数内部调用自己 console.log(&apos;fe:&apos; + i)&#125;console.log(&apos;ge: &apos; + i) 作用域与作用域链 理解: 作用域: 一块代码区域, 在编码时就确定了, 不会再变化 作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量 产生作用域的个数 = (N)定义函数的个数 + 1 分类: 全局 函数 js没有块作用域(在ES6之前) 作用 作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突 作用域链: 查找变量 区别作用域与执行上下文 作用域: 静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了 执行上下文: 动态的, 执行代码时动态创建, 当执行结束消失 联系: 执行上下文环境是在对应的作用域中的 面试题 12345678910111213141516var x = 10; function fn() &#123; console.log(x); &#125; function show(f) &#123; var x = 20; f(); &#125; show(fn); // 10 /* 解析：作用域在函数创建的时候就确定了，一旦确定就不会变化了 */ 1234567891011121314151617var fn = function () &#123; console.log(fn) &#125; fn() // fn函数体 var obj = &#123; fn2: function () &#123; console.log(fn2) &#125; &#125; obj.fn2() // fn2 is not defind /* 解析： 首先在fn2函数作用域里面找fn2 没有 然后再全局作用域找 也没有 故报错 若为this.fn2 则可以 */ 闭包 如何产生闭包? 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包 闭包到底是什么? 使用chrome调试查看 理解一: 闭包是嵌套的内部函数(绝大部分人) 理解二: 包含被引用变量(函数)的对象(极少数人) 注意: 闭包存在于嵌套的内部函数中 产生闭包的条件? 函数嵌套 内部函数引用了外部函数的数据(变量/函数) 常见的闭包 将函数作为另一个函数的返回值 将函数作为实参传递给另一个函数调用 闭包生命周期 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用) 死亡: 在嵌套的内部函数成为垃圾对象时 12345678910111213function fn1() &#123; //此时闭包就已经产生了(函数提升, 内部函数对象已经创建了) var a = 2 function fn2 () &#123; a++ console.log(a) &#125; return fn2&#125;var f = fn1()f() // 3f() // 4f = null //闭包死亡(包含闭包的函数对象成为垃圾对象) 作用: 延长局部变量的生命周期 让函数外部能操作内部的局部变量 写一个闭包程序 1234567891011function fn1() &#123; var a = 2 function fn2() &#123; a++ console.log(a) &#125; return fn2&#125;var f = fn1()f()f() 闭包应用: 模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为 循环遍历加监听 JS框架(jQuery)大量使用了闭包 缺点: 变量占用内存的时间可能会过长 可能导致内存泄露 解决: 及时释放 : f = null; //让内部函数对象成为垃圾对象 内存溢出与内存泄露 内存溢出 一种程序运行出现的错误 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误 内存泄露 占用的内存没有及时释放 内存泄露积累多了就容易导致内存溢出 常见的内存泄露: 意外的全局变量 没有及时清理的计时器或回调函数 闭包 👉点这里，进入QQ交流","categories":[{"name":"js-advance","slug":"js-advance","permalink":"https://shulu520.com/categories/js-advance/"}],"tags":[{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"js-advance-one","slug":"js-advance-one","date":"2019-05-24T06:13:53.000Z","updated":"2019-05-27T04:54:45.525Z","comments":true,"path":"js-advance/js-advance-one/","link":"","permalink":"https://shulu520.com/js-advance/js-advance-one/","excerpt":"能够让你后悔的从来不是你做过的事而是你想做却没有去做的事👉Q我吧","text":"能够让你后悔的从来不是你做过的事而是你想做却没有去做的事👉Q我吧 数据类型的分类和判断 基本(值)类型 Number —– 任意数值 ——– typeof String —– 任意字符串 —— typeof Boolean —- true/false —– typeof undefined — undefined —– typeof/=== null ——– null ———- === 对象(引用)类型 Object —– 任意对象 —– typeof/instanceof Array —— 一种特别的对象(数值下标)—– instanceof Function —- 一种特别的对象(可以执行，内部数据是有序的) —– typeof 判断 typeof ——– 返回数据类型的字符串表达 不能判断 null和object ， object和array instanceof —- 判断对象的具体类型 a instanceof b 即a是否是b构造函数的一个实例 === ———— 可以判断 undefined 和 null 名词解释 实例 实例对象 类型 类型对象 即构造函数 undefined与null的区别? undefined代表定义未赋值 nulll定义并赋值了, 只是值为null 什么时候给变量赋值为null呢? 初始赋值, 表明将要赋值为对象 结束前, 让对象成为垃圾对象(被垃圾回收器回收) 严格区别变量类型与数据类型? 数据的类型 基本类型 对象类型 变量的类型(变量内存值的类型) 基本类型: 保存就是基本类型的数据 引用类型: 保存的是地址值 数据,变量, 内存的理解 什么是数据? 在内存中可读的, 可传递的保存了特定信息的’东东’ 一切皆数据, 函数也是数据 在内存中的所有操作的目标: 数据 什么是变量? 在程序运行过程中它的值是允许改变的量 一个变量对应一块小内存, 它的值保存在此内存中 什么是内存? 内存条通电后产生的存储空间(临时的) 一块内存包含2个方面的数据 内部存储的数据 地址值数据 内存空间的分类 栈空间: 全局变量和局部变量 堆空间: 对象 内存,数据, 变量三者之间的关系 内存是容器, 用来存储不同数据 变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据 问题: var a = xxx, a内存中到底保存的是什么? xxx是基本数据, 保存的就是这个数据 xxx是对象, 保存的是对象的地址值 xxx是一个变量, 保存的xxx的内存内容(可能是基本数据, 也可能是地址值) 关于引用变量赋值问题 2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据 2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象 1234567891011121314151617181920212223let obj1 = &#123; name: &apos;lqy&apos; &#125;情形一function fn1(obj) &#123; obj.name = &apos;shulu&apos;&#125;fn1(obj1)console.log(obj1.name) // shulu情形二funtion fn2(obj) &#123; obj = &#123;name: &apos;shulu&apos;&#125;&#125;fn2(obj1)console.log(obj1.name) // lqy/*解析：形参obj 在函数内部为 var obj变量执行fn( ) 传入实参obj1 即将obj1的值(这里是地址值)复制一份给obj变量*/ 问题: 在js调用函数时传递变量参数时, 是值传递还是引用传递 理解1: 都是值(基本值/地址值)传递 推荐 理解2: 可能是值传递, 也可能是引用传递(地址值) 问题: JS引擎如何管理内存? 内存生命周期 分配小内存空间, 得到它的使用权 存储数据, 可以反复进行操作 释放小内存空间 释放内存 局部变量: 函数执行完自动释放 对象: 成为垃圾对象==&gt;垃圾回收器回收 对象的理解和使用 什么是对象? 多个数据(属性)的集合 用来保存多个数据(属性)的容器 属性组成: 属性名 : 字符串(标识) 属性值 : 任意类型 属性的分类: 一般 : 属性值不是function 描述对象的状态 方法 : 属性值为function的属性 描述对象的行为 特别的对象 数组: 属性名是0,1,2,3之类的索引 函数: 可以执行的 如何操作内部属性(方法) .属性名 [‘属性名’]: 属性名有特殊字符/属性名是一个变量 问题: 什么时候必须使用[‘属性名’]的方式? 属性名包含特殊字符: - 空格 属性名不确定 函数的理解和使用 什么是函数? 用来实现特定功能的, n条语句的封装体 只有函数类型的数据是可以执行的, 其它的都不可以 为什么要用函数? 提高复用性 便于阅读交流 函数也是对象 instanceof Object===true 函数有属性: prototype 函数有方法: call()/apply() 可以添加新的属性/方法 如何调用(执行)函数? test(): 直接调用 obj.test(): 通过对象调用 new test(): new调用 test.call/apply(obj): 临时让test成为obj的方法进行调用 函数中的this是什么? 任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window 所有函数内部都有一个变量this 它的值是调用函数的当前对象 如何确定this的值? test(): window p.test(): p var p = new test(): 新创建的对象p p.call(obj): obj 1234567891011121314151617181920212223242526272829303132333435function Person(color) &#123; console.log(this) this.color = color; this.getColor = function () &#123; console.log(this) return this.color; &#125;; this.setColor = function (color) &#123; console.log(this) this.color = color; &#125;; &#125; Person(&quot;red&quot;); //this是谁? window var p = new Person(&quot;yello&quot;); //this是谁? p p.getColor(); //this是谁? p var obj = &#123;&#125;; p.setColor.call(obj, &quot;black&quot;); //this是谁? obj var test = p.setColor; test(); //this是谁? window function fun1() &#123; function fun2() &#123; console.log(this); &#125; fun2(); //this是谁? window &#125; fun1(); 匿名函数自调用: 123(function(w, obj)&#123; //实现代码&#125;)(window, obj) 专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式 作用 隐藏实现 不会污染外部(全局)命名空间 用它来编码js模块 回调函数的理解 什么函数才是回调函数? 你定义的 你没有调用 但它最终执行了(在一定条件下或某个时刻) 常用的回调函数 dom事件回调函数 定时器回调函数 ajax请求回调函数(后面讲解) 生命周期回调函数(后面讲解) 问题 js一条语句的后面是否应该加分号？ 是否加分号是编码风格问题，没有应不应该，只有喜不喜欢——尤雨溪 必须加分号的情况： 小括号开头的语句 ;(function () {…})() 方括号的开头 ;[1, 2, 3].forEach(() =&gt; {}) &emsp;&emsp;本篇笔记到此完结。 👉点这里，进入QQ交流","categories":[{"name":"js-advance","slug":"js-advance","permalink":"https://shulu520.com/categories/js-advance/"}],"tags":[{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"js-modularize","slug":"js-modularize","date":"2019-05-23T14:17:24.000Z","updated":"2019-05-27T04:56:34.163Z","comments":true,"path":"js-modularize/js-modularize/","link":"","permalink":"https://shulu520.com/js-modularize/js-modularize/","excerpt":"&emsp;&emsp; 👉来QQ撩我啊","text":"&emsp;&emsp; 👉来QQ撩我啊 modularize 一阶段 所有的代码都写在一个文件下 即暴露在全局环境下 污染环境 二阶段 将某些api 放到一个对象之中 使用时通过obj.xxx来调用 不安全 因为在别处同样可以通过obj.xxx来将其修改掉 三阶段 匿名函数自执行(闭包) 安全 JQuery 就是这么做的 引入js文件太多 请求过多 依赖模糊 12345678910111213(function( window )&#123; function foo () &#123; ... &#125; ... // 将foo方法挂载到window上的xxx属性对象上 // 调用时xxx.foo()即可 window.xxx = &#123; foo &#125; // 或将foo方法挂载到window上的xxx属性对象上，作为一个函数 // 调用时直接foo()执行即可 window.xxx = foo &#125;)( window ) 模块化规范commonJs 一个js文件就是一个模块 向外暴露1 module.exports = value value可以是任意值 向外暴露2 exports.xxx = value value可以是任意值 引入模块 require(‘包名’) 自己写的文件要相对路劲 AMD define CMD 阿里大牛结合commonjs和AMD写的 卖给老外了 ES6 安装编译转化工具 npm i babel-cli browserify -g npm babel-preset-es2015 –save-dev 创建.babelrc 文件 并配置 123&#123; &quot;preset&quot;: [&quot;es2015&quot;]&#125; 分别暴露 即常规暴露相当于一个模块中有许多个变量export xxx = …export yyy = …export zzz = … 引入时要解构赋值 指名道姓拿到相应的变量import { xxx, yyy, zzz } from ‘路劲’ 统一暴露 默认暴露export default {…} 引入时 import xxx from ‘路劲’ &emsp;&emsp;未完待续…… 👉点这里，跟我聊QQ","categories":[{"name":"js-modularize","slug":"js-modularize","permalink":"https://shulu520.com/categories/js-modularize/"}],"tags":[{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"IT-proper-nouns","slug":"IT-proper-nouns","date":"2019-05-23T14:02:57.000Z","updated":"2019-05-27T04:55:24.962Z","comments":true,"path":"IT/IT-proper-nouns/","link":"","permalink":"https://shulu520.com/IT/IT-proper-nouns/","excerpt":"&emsp;&emsp; 👉来QQ撩我啊","text":"&emsp;&emsp; 👉来QQ撩我啊 api 应用程序接口(Application Programming Interface) cli 命令行界面(Command Line Interface) sdk 软件开发工具包(Software Development Kit) rc 结尾的文件 run control 运行时控制文件 &emsp;&emsp;未完待续…… 👉点这里，跟我QQ聊天呗","categories":[{"name":"IT","slug":"IT","permalink":"https://shulu520.com/categories/IT/"}],"tags":[]},{"title":"node-koa2","slug":"node-koa2","date":"2019-05-21T17:54:24.000Z","updated":"2019-05-21T18:02:24.876Z","comments":true,"path":"node/node-koa2/","link":"","permalink":"https://shulu520.com/node/node-koa2/","excerpt":"&emsp;&emsp;hello my world","text":"&emsp;&emsp;hello my world 开始 github创建仓库 本地git clone 仓库 项目目录下 初始化 npm initnpm start 启动快捷方法 在package.json 中添加配置 12&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node server/index.js&quot;, 添加 .gitignore 文件 1234567891011121314# dependenciesnode_modules# logsnpm-debug.log# System.DS_Store#Generatedist# Buildbulid pug 模板引擎npm i pug -S &emsp;&emsp;未完待续…… write to me by QQ email","categories":[{"name":"node","slug":"node","permalink":"https://shulu520.com/categories/node/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://shulu520.com/tags/nodejs/"},{"name":"koa2","slug":"koa2","permalink":"https://shulu520.com/tags/koa2/"}]},{"title":"async-fn-note","slug":"async-fn-note","date":"2019-05-20T02:00:01.000Z","updated":"2019-05-20T02:00:01.517Z","comments":true,"path":"uncategorized/async-fn-note/","link":"","permalink":"https://shulu520.com/uncategorized/async-fn-note/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 正文： &emsp;&emsp; write to me by QQ email","categories":[],"tags":[]},{"title":"arrow-js-note","slug":"arrow-js-note","date":"2019-05-19T16:11:45.000Z","updated":"2019-05-21T18:01:18.888Z","comments":true,"path":"arrowjs/arrow-js-note/","link":"","permalink":"https://shulu520.com/arrowjs/arrow-js-note/","excerpt":"&emsp;&emsp;今天是2019年，520，在这特殊的一天我面对的依然是code, but no Object, 我希望有一天能美梦成真——面向对象面向君，不负代码不负卿。","text":"&emsp;&emsp;今天是2019年，520，在这特殊的一天我面对的依然是code, but no Object, 我希望有一天能美梦成真——面向对象面向君，不负代码不负卿。 箭头函数的经典题型 有关 this 1234567891011121314151617181920212223242526272829let obj = &#123; id: 01, say: function () &#123; // 这里的this为obj setTimeout(function () &#123; // 这里是匿名函数的this默认为window console.log(&apos;arrow id:&apos;, this.id); // undifind &#125;, 100); &#125;, sayWithThis: function () &#123; // 这里将this的值当成变量存起来 let that = this; setTimeout(function () &#123; console.log(&apos;arrow id:&apos;, that.id); // 01 &#125;, 100); &#125;, sayWithArrow: function () &#123; // 这里的this为obj setTimeout(() =&gt; &#123; console.log(&apos;arrow id:&apos;, this.id); // 01 &#125;, 100); &#125;, sayWithGlobalArrow: () =&gt; &#123; // 这里的this已经为全局的this了 setTimeout(() =&gt; &#123; console.log(&apos;arrow id:&apos;, this.id); // undifind &#125;, 100); &#125;&#125;; &emsp;&emsp;未完待续…… write to me by QQ email","categories":[{"name":"arrowjs","slug":"arrowjs","permalink":"https://shulu520.com/categories/arrowjs/"}],"tags":[{"name":"arrowjs","slug":"arrowjs","permalink":"https://shulu520.com/tags/arrowjs/"}]},{"title":"git-qa-note","slug":"git-qa-note","date":"2019-05-18T04:11:06.000Z","updated":"2019-05-18T04:20:20.472Z","comments":true,"path":"git/git-qa-note/","link":"","permalink":"https://shulu520.com/git/git-qa-note/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; 科学上网之后，git 报错 如下错误： 12345ssh: Could not resolve hostname github.com: Name or service not knownfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 解决方法1、找到本机的 host 文件，一般位置是进入 C:\\Windows\\System32\\drivers\\etc 2、在host文件的最后一行加上，如果之前已经设置过，可以将ip地址更改为最新的正确的ip地址 192.30.255.112 github.com git185.31.16.184 github.global.ssl.fastly.net &emsp;&emsp;遇到后继续补充…… write to me by QQ email","categories":[{"name":"git","slug":"git","permalink":"https://shulu520.com/categories/git/"}],"tags":[{"name":"git-qa","slug":"git-qa","permalink":"https://shulu520.com/tags/git-qa/"}]},{"title":"Array-note","slug":"Array-note","date":"2019-05-17T16:41:04.000Z","updated":"2019-05-27T15:01:59.010Z","comments":true,"path":"Array/Array-note/","link":"","permalink":"https://shulu520.com/Array/Array-note/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; reduce 计算数组成员的个数 123const countOccurrences = (arr,val) =&gt; arr.reduce((a,v) =&gt; (v === val ? a + 1 : a), 0)alert(countOccurrences([1,111,2,2,2,3,4], 2)); // 3 max Math.max.apply(null, arr) Math.max(…arr) &emsp;&emsp;未完待续…… write to me by QQ email","categories":[{"name":"Array","slug":"Array","permalink":"https://shulu520.com/categories/Array/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://shulu520.com/tags/Array/"}]},{"title":"node-blue-note","slug":"node-blue-note-md","date":"2019-05-16T13:44:45.000Z","updated":"2019-05-18T05:42:53.876Z","comments":true,"path":"node/node-blue-note-md/","link":"","permalink":"https://shulu520.com/node/node-blue-note-md/","excerpt":"&emsp;&emsp;我本来要忘记你了，可我又做梦了。","text":"&emsp;&emsp;我本来要忘记你了，可我又做梦了。 node http 模块 GET方式 123456789const http = require(&apos;http); //创建一个服务器var server = http.createServer((req, res) =&gt; &#123; /* 给这个地址随便提交一个表单 http://localhost:8080/aaa 其中 req.url = &apos;/aaa?user=shulu&amp;pass=123&apos; 运用字符串的切割数组的拼接就可以拿到用户名与密码 */&#125;).listen(8080); queryString 模块 GET方式争对这种数据 xxx=…&amp;yyy=…&amp;zzz=… 123const querystring = require(&apos;queryString&apos;);var json = querystring.parse(&apos;user=shulu&amp;pass=123&amp;age=18&apos;);console.log(json) // &#123;&quot;user&quot;: &quot;shulu&quot;, &quot;pass&quot;: &quot;123&quot;, &quot;age&quot;: &quot;18&quot;&#125; url 模块 GET方式争对这种数据 整个url部分 参数为true效果更好 1234567const http = require(&apos;http);const _url = require(&apos;url&apos;);var server = http.createServer((req, res) =&gt; &#123; var obj = _url.parse(req.url, true); var url = obj.pathname; const GET = obj.query;&#125;).listen(8080); http 模块 POST方式 12345678910111213const http = require(&apos;http&apos;);const querystring = require(&apos;querystring&apos;);var server = http.createServer((req, res) =&gt;&#123; //请求数据一样在req中 var str = &apos;&apos;; //data数据大 分多次到达 req.on(&apos;data&apos;, (data) =&gt; &#123; //data事件 str += data; &#125;); req.on(&apos;end&apos;, () =&gt; &#123; var POST = querystring.parse(str) &#125;);&#125;).listen(8888); express 框架 express保留了原生的功能，增加了一些自己的功能 基本使用 123456789const express = require(&apos;express&apos;);var server = express();server.use(&apos;/a.html&apos;, function (req, res) &#123; //res.send() 方法参数可以是json等 //res.write() 参数只能是字符串或buffer res.send(&apos;aaaa&apos;); res.end();&#125;);server.listen(8080); 三种接收处理请求的方法 123server.get()server.post()server.use() express-static 插件 处理静态文件的 1234567const express = require(&apos;express&apos;);const expresStatic = require(&apos;express-static&apos;);var server = express();server.listen(8888);server.use(expresStatic(&apos;./www&apos;)); 中间件 body-parser 解析POST数据 1234server.use(bodyParser.urlencode(&#123; extend: false, //扩展模式 limit: 1024*1024 //限制1M&#125;)); multer 解析post文件 multipart/form-data 格式的表单数据 链式操作 next 1234567server.use(&apos;/&apos;, function (req, res, next) &#123; console.log(&apos;aaa&apos;); next();&#125;);server.use(&apos;/&apos;, function (req, res, next) &#123; console.log(&apos;bbb&apos;);&#125;); 模板引擎 ejspath 模块12345678const path = require(&apos;path&apos;);var str = &apos;c:\\\\user\\\\www\\\\a.html&apos;;var obj = path.parse(str);console.log(obj);//base: 文件名部分 如a.html//ext: 扩展名 如.html//dir: 文件路劲 如c:\\\\user\\\\www &emsp;&emsp;未完待续…… write to me by QQ email","categories":[{"name":"node","slug":"node","permalink":"https://shulu520.com/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://shulu520.com/tags/node/"},{"name":"blue","slug":"blue","permalink":"https://shulu520.com/tags/blue/"}]},{"title":"hotkey-vim","slug":"hotkey-vim","date":"2019-05-15T15:34:56.000Z","updated":"2019-05-27T16:35:33.727Z","comments":true,"path":"hotkey/hotkey-vim/","link":"","permalink":"https://shulu520.com/hotkey/hotkey-vim/","excerpt":"&emsp;&emsp;You only live on this earth once.","text":"&emsp;&emsp;You only live on this earth once. 快捷强大的vim vimium能提升我们的浏览速度, 鼠标比键盘简单, 键盘比鼠标快! 快速向下滚动d 快速向上滚动u 滚动到页面顶部gg 滚动到页面底部G 神技! 快速搜索 (相当于浏览器顶部搜索框), 并在新标签打开 大写的O 关闭页面x 恢复页面X 主动脱离焦点esc 比如按下o搜索退出时按esc shift+/,查看所有快捷键 &emsp;&emsp;如果你想要个和现在不同的人生，就必须去做你从未做过的事情。努力之后最坏的结果是失败，但不尝试的结果则是无止境的懊悔、怀疑和平庸。 vscode 常用快捷键 上下移动一行： Alt+Up 或 Alt+Down 向上或向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down 同时选中所有匹配： Ctrl+Shift+L Ctrl+D 下一个匹配的也被选中 Alt + 单击 ：插入光标 Ctrl + F2 选择当前字的所有出现 ctrl shift k 删除整行 ctrl shift a 多行注释 ctrl f 当前文件内搜索相关代码，终于找到这个功能了，哈哈，右上角会有弹框，其中有前后箭头，表示搜索的代码上一次、下一次出现的位置，点击直接会跳转到相应的位置，并且侧边上有相应的位置标识。 ctrl - 整体缩小 ctrl = 整体放大 文件/首选项/设置 搜索zoom 根据配置 可以更精细的对大小进行操作 ctrl 加滚轮 &emsp;&emsp;未完待续…… write to me by QQ email","categories":[{"name":"hotkey","slug":"hotkey","permalink":"https://shulu520.com/categories/hotkey/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://shulu520.com/tags/vim/"}]},{"title":"nodejs-guigu","slug":"nodejs-guigu","date":"2019-05-14T14:50:21.000Z","updated":"2019-05-27T04:57:45.581Z","comments":true,"path":"node/nodejs-guigu/","link":"","permalink":"https://shulu520.com/node/nodejs-guigu/","excerpt":"&emsp;&emsp;我期待有一天背着背包出现在你的城市。","text":"&emsp;&emsp;我期待有一天背着背包出现在你的城市。 环境变量 小娜 输入 环境变量 进入环境变量/用户变量/path 点开 里面是一条条的文件路劲 可以新建一个文件的路劲 在这里配置了 相当于 声明了一个 类似于 js 中的全局变量 为作用域链的最高层 可以将一些常用的文件或程序的路劲添加到path下 这样我们就可以在任意的位置访问他们了 进程 线程 进程 负责为程序的运行提供必备的环境 工厂的车间 线程 负责执行进程中的程序 车间工人 单线程 一个人干活 多线程 多人合作干一个活 node.js 事件驱动 非阻塞 异步I/O (性能瓶颈阶段) input写入操作 output读操作 版本 奇数为开发版 偶数为稳定版 在Node中，模块分为三类：一类是底层由C++编写的内建模块，一类是Node提供的核心模块；还有一类是用户编写的模块，称为文件模块。node.js 模块化 新建一个js文件就是一个模块 这个模块里面写的代码其实是包在一个函数里面的 即 123456789101112131415funcyion (exports, require, module, _filename, _dirname) &#123; /* 这里是我们写的代码 外面其实包了一层这个函数 默认不可见 可以通过console.log(arguments.callee) 或 console.log(arguments.callee + &quot;&quot;) 将此函数打印出来 该函数执行时传进了5个参数 所以模块里面的代码是局部变量 exports参数 用来将变量或函数暴露到外边 require参数 用来引入外部的模块 module参数 代表模块本身 exports是module的属性 _filename 当前模块的完整路劲 _dirname 当前模块所在文件夹的路劲 */&#125; module.exports 与exports的区别 module.exports == exports true exports 只能使用.的方式向外暴露 若exports = {} 这样向外暴露的话就修改了exports的引用对象 module.exports 既可以通过.的形式 也可以直接赋值 推荐写法 核心模块 由node 提供的模块 node_moudle中的 引入时直接写模块名字 不需要路劲 文件模块 由我们自己创建的模块 引入时添加./或../等路劲 包 package 包实际上就是一个压缩文件 解压以后还原为目录 规范的目录包含以下文件： -package.json 包描述文件 (必须的) 里面不能写注释 -bin 可执行二进制文件 binary 二进制 -lib js代码 library 库 图书馆 -doc 文档 document -test 单元测试 npm 即 (Node Package Manager) node包管理器 commonjs包规范的是一种理论 npm是其中一种实践 对node而言 npm帮助其完成了第三方模块的发布安和依赖 借助npm 使得node与第三方模块之间形成一个生态系统 查看版本 npm version查看相关的版本 或npm -v npm search 包名 搜索包 npm init 在某一文件夹下初始化该文件夹 帮助我们根据提示生成一个package.json的文件 在初始化后的文件夹下 安装搜索的包 并新建一个index.js 入口文件在里面就可以直接引入math模块使用了 npm install 包名 安装 包 或npm i npm remove 或 npm r 删除包 npm install 包名 杠杠save 安装包并添加到依赖中 npm install 下载当前项目所依赖的包 npm install 包名 -g 全局安装包 一般是安装一些工具 如vue-cli cnpm 也可以用 快速 node在使用下载的包时 会沿着作用域链一直往上找直到磁盘根目录找不到则报错 这就解释了某的包在删除之后依然能用的情况 Buffer （缓冲区） 结构和数组很相似 方法也类似 补充了数组方法的不足 Buffer专门存贮二进制数据的 实际上Buffer中的内存不是通过JavaScript分配的，而是在底层通过C++申请的。也就是我们可以直接通过Buffer来创建内存中的空间。 使用buffer无需引入模块 直接使用即可 Buffer.from(str) 将字符串str转为buffer二进制数据 在buffer中存贮的都是二进制数据 但在显示时都是以16进制的形式显示的 二进制 00-255 或 00-ff 计算机 一个0或一个1 称为一位(bit) 8bit = 1byte(字节) 最小单位 中文一个汉字占用三个字节 创建一个制定大小的buffer Buffer.alloc(10) 10字节大小 可通过索引来操作buffer中的元素 Buffer的大小一旦确定 不能再更该 因为存储空间是连续的 性能好 Buffer与字符串间的转换 支持的编码: ASCII、UTF-8、UTF-16LE/UCS-2、Base64、Binary、Hex 字符串转Buffer Buffer.from(str , [encoding]); Buffer转字符串 buf.toString() buf.toString([encoding] , [start] , [end]); 复制缓冲区 buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]]) 对缓冲区切片 buf.slice([start[, end]]) 拼接缓冲区 Buffer.concat(list[, totalLength]) fs (文件系统) 在Node中，与文件系统的交互是非常重要的，服务器的本质就将本地的文件发送给远程的客户端 核心模块 直接引入使用 const fs = require(‘fs’) fs 模块中所有的操作都有两种形式 同步(会阻塞 带sync) 异步(不会阻塞 带回调函数) fs模块中所有的操作都有两种形式可供选择同步和异步 同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码。异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。 打开文件 fs.open(path, flags[, mode], callback) fs.openSync(path, flags[, mode]) 关闭文件 fs.close(fd, callback) fs.closeSync(fd) fs中提供了四种不同的方式将数据写入文件 简单文件写入 同步文件写入 异步文件写入 流式文件写入 同步文件的写入： 1.打开文件 操作方式为定为写 即 var fd = fs.openSync(path, flags) 参数为字符串类型 path即文件的路劲 flags即 r表示读操作 w表示写入操作 通过返回的描述符fd对文件进行各种操作 2.写入内容数据 fs.writeSync(fd, string) fd文件的描述符 需要传入文件的描述符 string要写入的内容 3.关闭文件 考虑性能 fs.closeSync(fd) 异步文件写入 1.打开文件 123456789101112131415161718fs.open(path, flags, function (err, fd) &#123; if (!err) &#123; 2.在这里往文件写入内容 写操作 fs.write(fd, &apos;要异步写入的内容&apos;, function (err) &#123; if (!err) &#123; console.log(&apos;write success&apos;) &#125; fs.close(fd, function (err) &#123; if (!err) &#123; console.log(&apos;close success&apos;) &#125; &#125;) &#125;) console.log(fd) &#125;else&#123; console.log(err) &#125;&#125;) 返回值为 callback的参数 简单文件写入 简单同步文件 fs.write 简单异步文件 123456fs.writeFile(&apos;hello.txt&apos;, &apos;shulu520&apos;, &#123;flag: &apos;a&apos;&#125; function (err) &#123; //flag: &apos;a&apos; 追加文件内容 不会覆盖原来的 如果文件不存在则创建 flag还有好多的模式 if (!err) &#123; console.log(&apos;write success&apos;) &#125; //文件路劲可以是F:\\JSdownload\\npm-test 这种 `但是要变为`F:\\\\JSdownload\\\\npm-test或F:/JSdownload/npm-test&#125;) 同步 异步 简单文件 的写入都不适合大文件爱的写入 易导致内存溢出 性能差 流式文件写入 12345678910111213141516171819202122232425 创建流 var ws = fs.createWriteStream(path) 监听事件 once绑定一次性的事件 ws.once(&apos;open&apos;, function () &#123; console.log(&apos;stream success&apos;) &#125;) ws.once(&apos;close&apos;, function () &#123; console.log(&apos;stream close&apos;) &#125;) 写入内容 大量内容 ws.write(&apos;写入内容1&apos;) ws.write(&apos;写入内容2&apos;) ws.write(&apos;写入内容3&apos;) ws.write(&apos;写入内容4&apos;) …… 关闭流 在流开始的一方结束流 ws.end()``` + fs中提供了四种读取文件的方式 简单文件读取 同步文件读取 异步文件读取 流式文件读取+ 简单文件读取 简单异步文件读取 const fs = require(‘fs’);fs.readFile(‘shulu.jpg’, (err, data) =&gt; { if(!err) { fs.writeFile(‘桌面路劲/lqy.jpg’, data, () =&gt; { if(!err) { console.log(‘文件写入成功 ‘) } }) }})12+ 流式文件读取 适用于大文件 const fs = require(‘fs’);1.创建读取流const rs = fs.createReadStream(‘shulu.jpg’);2.监听流的开启和关闭rs.once(‘open’, () =&gt; { console.log(‘流打开成功了’)})rs.once(‘close’, () =&gt; { console.log(‘流关闭了’)})3.读取数据rs.on(‘data’, (data) =&gt; { console.log(data) //多次分批读取大数据}) pipe 流方法 12 const fs = require(‘fs’);const rs = fs.createReadStream(‘shulu.mp3’);const ws = fs.createWriteStrem(‘lqy.mp3’);rs.pipe(ws); 读取后直接流入 12345678910111213141516171819202122232425262728+ fs 模块其他操作 检查一个文件是否存在+ 列出文件 fs.readdir(path[, options], callback) fs.readdirSync(path[, options])+ 截断文件 fs.truncate(path, len, callback) fs.truncateSync(path, len)+ 建立目录 fs.mkdir(path[, mode], callback) fs.mkdirSync(path[, mode])+ 验证路径是否存在 fs.existsSync(path)+ 获取文件信息 fs.stat(path, callback) fs.statSync(path)+ 删除文件 fs.unlink(path, callback) fs.unlinkSync(path)+ 删除目录 fs.rmdir(path, callback) fs.rmdirSync(path)+ 重命名文件和目录 fs.rename(oldPath, newPath, callback) fs.renameSync(oldPath, newPath)+ 监视文件更改写入 fs.watchFile(filename[, options], listener) const fs = require(‘fs’);const isExists = fs.existsSync(‘shulu.mp3’);console.log(isExists);` &emsp;&emsp;未完待续……&emsp;&emsp;write to me","categories":[{"name":"node","slug":"node","permalink":"https://shulu520.com/categories/node/"}],"tags":[{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"es6-zhuf-01.md","slug":"es6-zhuf-01","date":"2019-05-13T15:46:29.000Z","updated":"2019-05-18T16:25:00.765Z","comments":true,"path":"es6/es6-zhuf-01/","link":"","permalink":"https://shulu520.com/es6/es6-zhuf-01/","excerpt":"&emsp;&emsp;想要的东西，会以最快的速度来到你的身边。","text":"&emsp;&emsp;想要的东西，会以最快的速度来到你的身边。 var 与 let 和 const 的区别新的方法解决了老方法遗留的问题 var 在同一作用域内可以对同一变量重复声明 不能定义常量(控制不了，因为可以修改，写了等于没写) 不支持块级作用域 let 在同一作用域内不能对同一变量重复声明 变量不会提升 变量定义之前使用会报错 有块级作用域 {这里面为块级作用域} 以前js只有两种作用域 一个是全局 一个是函数级 作用域经典问题： for 循环里面套 定时器 当时的解决方法 给定时器包一层自执行的匿名函数并将循环变量传进去 本质上是作用域问题 现在用let声明变量就可以了 const 在同一作用域内不能对同一变量重复声明 专门声明常量 常量声明后不可修改 但若此常量是一个引用类型的话(例如一个对象) 引用对象的属性还是可以改的 例如：定义 const USER = {name: ‘shulu’} 更改为 USER.name = ‘lqy’ 可以的 解构 分解一个对象的解构 解构的时候 等号的两边解构相似 右边必须是一个真实的值 数组的省略赋值 let arr = [1, 2, 3]; let [,,x] = arr 则只拿到x=3的值 模板字符串 以前是字符串拼串 现在是这个符号 可以折行 换行 模板语言的原理 正则实现 面试 带参数的模板字符串 字符串的新方法 返回布尔值 str.startWith(‘http’) str.endsWith(‘.com’) str.includes(‘shulu’) 以前 str.indexOf(‘shulu’) == -1 做判断 str.repeat(10) 重复10次 展开运算符 … 对象合并： Object.assign(obj3, obj2, obj1); 将对象1，2合并为3 obj3 = {…obj1, …obj2} 更简洁 对象的深拷贝 1let obj2 = JSON.parse(JSON.stringify(obj1)) 递归实现对象深拷贝 12345678910111213141516171819202122232425262728//对象深拷贝function deepClone(origin,target)&#123; //target是否存在如果不存在创建空对象 let tar = target || &#123;&#125;, //判断是否为引用数据类型 toStr = Object.prototype.toString, arrType=&apos;[object Array]&apos;; for(let key in origin)&#123; //剥离原型链的数据 if(origin.hasOwnProperty(key))&#123; //判断是否为引用数据类型 对象或数组 if(typeof(origin[key]) === &apos;object&apos; &amp;&amp; origin[key] !== null)&#123; if(toStr.call(origin[key]) === arrType )&#123; tar[key] = []; &#125;else&#123; tar[key] = &#123;&#125;; &#125; deepClone(origin[key],tar[key]); &#125;else&#123; tar[key] = origin[key]; &#125; &#125; &#125; return tar;&#125; 箭头函数箭头函数this 继承自父级，自己本身没有this &emsp;&emsp;未完待续……","categories":[{"name":"es6","slug":"es6","permalink":"https://shulu520.com/categories/es6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://shulu520.com/tags/es6/"},{"name":"zhuf","slug":"zhuf","permalink":"https://shulu520.com/tags/zhuf/"}]},{"title":"git-guigu-note","slug":"git-guigu-note","date":"2019-05-12T15:21:02.000Z","updated":"2019-05-13T16:05:14.840Z","comments":true,"path":"git/git-guigu-note/","link":"","permalink":"https://shulu520.com/git/git-guigu-note/","excerpt":"&emsp;&emsp;在衰老到来之前，做一件值得做的事情。做这件事不是为了别的，而是为了证明自己是好样的。-《似水流年》","text":"&emsp;&emsp;在衰老到来之前，做一件值得做的事情。做这件事不是为了别的，而是为了证明自己是好样的。-《似水流年》 复制 选中后 Ctrl+ins 即键盘右上角的insert键粘贴 相应的位置 Shift+ins查看git 配置信息cat ~/.gitconfig状态查看 git status 查看工作区、暂存区状态文件内容查看 cat haha.txt添加操作 git add [file_name]git commit -m ‘说明信息’ [file_name]创建文件 touch haha.txt 或 vim good.txt 字母ll 列出本地库所有文件和文件总数，创建日期 时间 创建人 文件名 git add haha.txt 后 若想返回add前的状态 根据提示 git rm –cached haha.txt 即可返回，此删除只是从暂存区里面删除，工作区的文件还在git commit haha.txt 这里没带-m ‘说明信息’ 回车后会进入vim 编辑器 可以编写大量的说明信息 首先 按a键 进入插入模式，之后就可以进行编辑了。 编辑完了就可以按Esc键退出插入模式，然后输出:wq即可退出vim编辑器，回到git bash界面。 查看提交记录 git log 打印的记录风格： 分散 有作者 邮箱 日期提示，显示内容详细，内容多了，多屏显示控制方式：桥空格为向下翻页，b键为向上翻页，q 键为退出查看 git log –oneline 打印效果为一行 git reflog 打印的记录风格： 紧凑 在一行显示并有提示版本回退数字提示 版本前进后退 基于索引值操作 任意版本穿梭 推荐方法 git reset –hard alfe9cd 这里alfe9cd为某一版本的提交id值即索引值 基于符号 ^ 只能后退 返回上一个版本 git reset –hard HEAD^ 版本倒退三个 git reset –hard HEAD^^^ 基于符号 ~ 只能后退 版本倒退三个 git reset –hard HEAD~3 reset 命令的三个参数对比 –soft 仅仅在本地库移动HEAD指针 –mixed 在本地库移动HEAD指针,重置暂存区 –hard 在本地库移动HEAD指针,重置暂存区,重置工作区，三个区位置保持一致 删除文件 rm aaa.txt git status 显示为 红色 deleted: aaa.txt 提示要add该文件 git add aaa.txt git status 显示为 绿色 表示已添加到暂存区 git commit -m ‘deleted aaa.txt’ 将这次删除操作提交到本地库 删除文件并恢复 前提：删除前 文件的状态提交到了本地库 操作： git reset –hard [指针位置] 删除操作已经提交到本地库：指针位置指向包含删除文件的历史纪录 删除操作尚未提交到本地库：指针位置使用HEAD 比较文件差异 git diff [文件名] 将工作区的文件和暂存区进行比较 git diff [本地库中历史版本] [文件名] 将工作区的文件和本地历史记录比较 git diff 不带文件名 比较多个文件 分支管理 热修复 主分支的bug 更改 分一个 hot_fix 分支 分支的好处： 查看分支 git branch -v 创建分支 git branch hot_fix 切换分支 git checkout hot_fix 切换到这个分支 合并分支 第一步：切换到接受修改的分支(被合并，增加新内容)上 git checkout [接受修改的分支] 第二步：在接受修改的分支上执行命令 git merge [有新内容的分支] 解决合并分支后产生的冲突 分别在两个分支上修改内容 分别提交到本地库 比如都在haha.txt上做修改 将两个分支合并到一个分支上 出现合并冲突 vim haha.txt 查看合并后的状态 HEAD 部分表示当前分支的修改 在一行========之下为另一个分支上做的修改 解决方法： 一：删掉那些特殊符号 并手动将内容修改为满意的状态 期间可能与分支伙伴商量 保存退出 二：git add [文件名] 三：git commit -m &apos;日志说明&apos; 注意：此时commit `一定不能带 文件名` git 原理 哈希算法 明文 加密 得 密文 常见的 md5算法 git 底层 SHA-1算法 github克隆的效果 完整的把远程库克隆到本地 初始化本地库 邀请队员加入 github进入相应的项目 /settings/Collaborators/ 在Search by username 之下 添加成员的github账号名 add collaborator copy invite link 发送给队员（qq或邮箱等方式）等其他方式把邀请链接发送给队员 队员 登录github 后 Accepe invitation 队员拉取操作 pull=fetch+merge git fetch [远程库地址别名] [远程分支名] git merge [远程库地址别名/远程分支名] git pull [远程库地址别名] [远程分支名] 解决冲突 如果不是基于 GitHub 远程库的最新版所做的修改，则不能推送，必须先拉取。 拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即 跨团队协作 外团队人员fork 该项目 git 工作流分支种类 主干分支 master主要负责管理正在运行的生产环境代码。永远保持与正在运行的生产环境完全一致。 开发分支 develop主要负责管理正在开发过程中的代码。一般情况下应该是最新的代码。 bug 修理分支 hotfix主要负责管理生产环境下出现的紧急修复的代码。 从主干分支分出，修理完毕并测试上线后，并回主干分支。并回后，视情况可以删除该分支。 准生产分支（预发布分支） release较大的版本上线前，会从开发分支中分出准生产分支，进行最后阶段的集成测试。该版本上线后，会合并到主干分支。生产环境运行一段阶段较稳定后可以视情况删除。 功能分支 feature为了不影响较短周期的开发工作，一般把中长期开发模块，会从开发分支 中独立出来。 开发完成后会合并到开发分支。&emsp;&emsp;完 更多笔记看git&amp;github.pdf详细笔记","categories":[{"name":"git","slug":"git","permalink":"https://shulu520.com/categories/git/"}],"tags":[{"name":"git-note","slug":"git-note","permalink":"https://shulu520.com/tags/git-note/"}]},{"title":"vue-tour","slug":"vue-tour","date":"2019-05-10T16:09:17.000Z","updated":"2019-05-12T15:31:01.615Z","comments":true,"path":"vue/vue-tour/","link":"","permalink":"https://shulu520.com/vue/vue-tour/","excerpt":"&emsp;&emsp;I love three things in this world. Sun, Moon, and You. Sun for morning, Moon for night, and You forever.浮世三千，吾爱有三，日、月与卿。日为朝，月为暮，卿为朝朝暮暮。","text":"&emsp;&emsp;I love three things in this world. Sun, Moon, and You. Sun for morning, Moon for night, and You forever.浮世三千，吾爱有三，日、月与卿。日为朝，月为暮，卿为朝朝暮暮。 A Vue.js project-去哪儿旅行，vue学习练手小项目。 Build Setup1234567891011# install dependenciesnpm install# serve with hot reload at localhost:8080npm run dev# build for production with minificationnpm run build# build for production and view the bundle analyzer reportnpm run build --report css 省略号…123overflow hiddenwhite-space nowraptext-overflow ellipsis 项目初始化 如果这个项目是从github 上克隆来的 初始化时直接 vue init webpack 注意这里不用再加初始化的项目名称 修改 标签 路劲优化，简化 ,在webpack 中配置 build/webpack.base.conf.js 的alias 下面是vue-cli 配置好的 1234alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;),&#125; import HelloWorld from ‘@/components/HelloWorld’ 其中的 @ 表示src目录 在css 样式中 import ‘~@/assets/styles/varibles.styl’ 其中的 ~@ 表示src目录 移动端快速点击 npm i fastclick –save 解决300毫秒延迟 在main.js 中 import fastClick from ‘fastclick’ fastClick.attach(document.body) css代码编辑工具 stylus npm i stylus –save npm i stylus-loader –save 阿里图标 进入网站后 /图标管理/我的项目/新建项目1px 使用的是硅谷外卖 stylus/mixins.styl 使用 @import ‘~@/assets/styles/border.styl’ 某一个样式下 bottom-border-1px(#ccc) 自己传一个色值 github 创建新分支index-swiper本地 git pull 将分支拉到本地切换到这个分支 git checkout index-swiper轮播图 npm i vue-awesome-swiper@2.6.7 –save 官网具体配置 轮播图 index-swiper 开发完成后 git add . git commit -m ‘swiper finished’ git push git checkout master git merge index-swiper 将index-swiper 分支的文件 合并到master主分支 git push 在浏览器中自动打开 config/index.js 修改里面的配置，把autoOpenBrowser:false改为autoOpenBrowser:true即可 布局 高度 height 0padding-bottom 33.9% 用padding-bottom 的值撑开高度 即高宽比 Git出现|MERGING解决 使用git上传或者下拉中出现MERGING，这是合并冲突了 输入命令可以正常跳转：git reset –hard head ajax npm install axios –save config/index.js中配置 12345678proxyTable: &#123; &apos;/api&apos;: &#123; target: &apos;http://localhost:8081&apos;, pathRewrite: &#123; &apos;^/api&apos;: &apos;/static/mock&apos; &#125; &#125; &#125;, vue 文件中 12axios.get(&apos;/api/index.json&apos;) .then(this.getHomeInfoSucc) 解决 swiper 初次显示时为最后一张图的情况 是因为刚开始时是一个空数组 给swiper 加 v-if = “list.length” 即list 传过来有值的时候在加载。 页面滚动 npm install better-scroll –save ref 属性使用注意 如果 ref 的值 是 v-for 循环产生的 使用时 this.$refs[‘A’][0] 即第零相 才是真正的dom 使用函数截流 提示网站性能 在 touchmove 事件中 使用 settimeout 即将一些触发特别快又频繁的代码放到 定时器里面 减少执行次数 vuex 状态管理 npm install vuex –save 安装 src/新建store/index.js 12345678910import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; city: &apos;北京&apos; &#125;&#125;) main.js 12345678910import store from &apos;./store&apos;new Vue(&#123; el: &apos;#app&apos;, router, store, 添加选项store components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;&#125;) 城市选择后 直接跳转到 首页 显示相应的城市 在事件处理 方法里面 12this.$store.dispatch(&apos;changeCity&apos;, city)this.$router.push(&apos;/&apos;) localStorage 的使用 需要在外层加 tyr catch 以防 某谢用户 避了本地存储功能 或浏览器使用隐身模式 12345678910111213141516171819202122232425let defaultCity = &apos;常州&apos;try &#123; if (localStorage.city) &#123; defaultCity = localStorage.city &#125;&#125;catch (e) &#123;&#125;export default new Vuex.Store(&#123; state: &#123; city: defaultCity || &apos;常州&apos; &#125;, actions: &#123; changeCity (ctx,city) &#123; ctx.commit(&apos;changeCity&apos;, city) &#125; &#125;, mutations: &#123; changeCity (state, city) &#123; state.city = city try &#123; localStorage.city = city &#125;catch (e) &#123;&#125; &#125; &#125;&#125;) mapState 的使用 定义import { mapState } from &#39;vuex&#39; 12345678910computed: &#123; ...mapState([&apos;city&apos;]) &#125; 也可以是computed: &#123; ...mapState(&#123; currentCity: &apos;city&apos; &#125;) &#125;, 使用 或 keep-alike 的使用123&lt;keep-alive&gt; &lt;router-view/&gt;&lt;/keep-alive&gt; 相应的组件 数据 加载一次后会保存到内存中 下次调用 直接取 提升性能 vue 实例 选项中多了一个生命 周期钩子函数 activated, 其在页面重新显示，有变动的时候触发 12345activated () &#123; if (this.lastCity !== this.city) &#123; this.getHomeInfo() &#125; &#125; 及时解除全局事件 让其只在当前组件中触发 deactivated 在页面隐藏，页面被替换为新的页面 时触发 123456activated () &#123; window.addEventListener(&apos;scroll&apos;, this.handleScroll) &#125;, deactivated () &#123; window.removeEventListener(&apos;scroll&apos;,this.handleScroll) &#125; 递归组件的使用 在自己组件内部 通过name 选项 的名字 作为递归组件的标签名使用&lt;detail-list :list=&quot;item.children&quot;&gt;&lt;/detail-list&gt; 缓存相关 App.vue 中 Detail 组件不缓存 123&lt;keep-alive exclude=&quot;Detail&quot;&gt; &lt;router-view/&gt;&lt;/keep-alive&gt; 解决不同页面位置的相互影响问题 router/index.js 中加入scrollBehavior选项 123456789101112export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, name: &apos;Home&apos;, component: Home &#125; ], scrollBehavior (to, from, savedPosition) &#123; return &#123;x: 0, y: 0&#125; &#125;&#125;) 解决某些手机浏览器 不支持 promise 的情况 npm install babel-polyfill –save main.js 中 import &#39;babel-polyfill&#39; 项目优化 按需加载js 组件 此方法 只在打包生成的app.js文件特别大（1M左右）的时候使用，小的话，不宜，因为这样会增加http 请求 router/index.js 将import Home from &#39;@/pages/home/Home.vue&#39;引入组件的方式去掉，配置路由为 12345&#123; path: &apos;/&apos;, name: &apos;Home&apos;, component: ( ) =&gt; import(&apos;@/pages/home/Home.vue&apos;) &#125;, 项目上线 npm run build 生成dist 文件夹 将dist 给后端运行 &emsp;&emsp; 项目正在开发完毕。","categories":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/categories/vue/"}],"tags":[{"name":"vue-project","slug":"vue-project","permalink":"https://shulu520.com/tags/vue-project/"}]},{"title":"http","slug":"http","date":"2019-05-06T15:32:22.000Z","updated":"2019-05-06T15:35:32.729Z","comments":true,"path":"http/http/","link":"","permalink":"https://shulu520.com/http/http/","excerpt":"&emsp;&emsp;","text":"&emsp;&emsp; GET POST 的区别 前提:web浏览器环境下的RFC规范GET 用来获取信息，POST用来发送信息 可见性 安全性 数据大小 编码类型 能否收藏为书签，GET可以 刷新，后退按钮，GET无影响，POST重新提交 能否保留到浏览器历史，GET保留 &emsp;&emsp;","categories":[{"name":"http","slug":"http","permalink":"https://shulu520.com/categories/http/"}],"tags":[{"name":"http","slug":"http","permalink":"https://shulu520.com/tags/http/"}]},{"title":"net-model","slug":"net-model","date":"2019-05-06T15:28:43.000Z","updated":"2019-05-06T15:30:41.121Z","comments":true,"path":"net/net-model/","link":"","permalink":"https://shulu520.com/net/net-model/","excerpt":"","text":"应用层: 程序，软件，应用层协议，http协议，DNS协议(域名解析)，FTP协议(文件传输协议)，SMTP(邮件传输协议)传输层: 对数据传输的建立和管理，传输层协议，UDP协议(有丢包的可能)，TCP(保证数据的正确性，顺序性)网络层: 好比交通网络，IP协议(IP加端口号来确定一个程序的位置)数据链路层: 两个子层，一个叫逻辑链路控制子层，另一个叫媒体访问控制子层(MAC地址)物理层: 坐公交，扫码骑车。除了五层网络模型之外还有七层网络模型，那么七层网络模型是什么呢？就是将应用层一分为三，分别为：应用层，表示层和会话层。新出来的表示层和会话层没有相应的协议。一般表示层做的是数据格式化，或者加密等操作。","categories":[{"name":"net","slug":"net","permalink":"https://shulu520.com/categories/net/"}],"tags":[]},{"title":"safe-xss","slug":"safe-xss","date":"2019-05-06T15:23:35.000Z","updated":"2019-05-27T04:52:25.111Z","comments":true,"path":"safe/safe-xss/","link":"","permalink":"https://shulu520.com/safe/safe-xss/","excerpt":"&emsp;&emsp;让一个人变强大的最好方式是拥有一个想去保护的人。","text":"&emsp;&emsp;让一个人变强大的最好方式是拥有一个想去保护的人。 XSS攻击究竟是如何一步一步的获取了别人的隐私呢？下面我们就来一步一步的来进行解析。1. 攻击者，上传一片文章或者博客，这边文章中带有一段JS代码，这段代码内容很简单，读取本地Cookie，发送给某个url。2. XX微博的服务器没有对用户上传的内容进行审查，就将内容存储起来。3. 当正常用户访问XX微博的时候，服务器将有问题的文章推送给了这个正常用户。（因为服务器并没有检查哪篇文章有问题，所以它会认为这是一篇正常的文章，以正常的方式推送给用户。）4. 当正常的用户点开这篇文章的时候，攻击者编写的脚本就会在正常的用户的电脑上执行。（因为攻击者的脚本就是在文章的内容中加入一段script代码，浏览器会将script标签中的内容当作js代码来看待，然后执行这段代码）5. 这段带有攻击性的代码可以读取用户本地的cookie内容，并将内容发送给攻击者事先准备好的url。（因为正常用户在本地打开，所以不存在跨域的问题）6. 攻击者收到了发送过来的cookie之后，就可以将cookie内容写入自己的浏览器里，然后就能登录这个正常用户的XX微博了。（因为现在很多网站都做了免登录功能，这个功能主要是依赖于种在浏览器里的cookie，这个cookie中会带有用户的部分信息，当用户在每次进入网站的时候，由于这些cookie的存在，就可以免登录了。我们这个例子中，XSS攻击就是获取到了用户的Cookie，从而在我们的本地来将这份cookie写入到我们的浏览器里，就能登录这个正常用户的帐号了~）我们会发现XSS攻击最大的问题在于，服务器端在用户上传文章内容的时候，没有进行内容审查。其实，我们只要将一些危险的符号进行HTML编码就可以了，比如将‘&lt;’替换为”&lt;”，将‘&gt;’替换为”&gt;”，这样攻击者就无法通过script标签的方式来进行攻击了~","categories":[{"name":"safe","slug":"safe","permalink":"https://shulu520.com/categories/safe/"}],"tags":[{"name":"xss","slug":"xss","permalink":"https://shulu520.com/tags/xss/"}]},{"title":"shanjuan","slug":"diary-shanjuan","date":"2019-05-03T06:18:17.000Z","updated":"2019-05-23T16:38:15.996Z","comments":true,"path":"diary/diary-shanjuan/","link":"","permalink":"https://shulu520.com/diary/diary-shanjuan/","excerpt":"&emsp;&emsp;juan，我的好朋友，好久不见，今偶然间，美好的回忆又浮现眼前，于是赶紧记下那些美好。","text":"&emsp;&emsp;juan，我的好朋友，好久不见，今偶然间，美好的回忆又浮现眼前，于是赶紧记下那些美好。 &emsp;&emsp;拿起雪糕想起了你。&emsp;&emsp;雪糕这玩意和辣条一样是我小时候的最爱，只是随着年岁渐长，慢慢留在记忆里了。昨晚室友叫我一起去超市，逛了一圈不知买点啥，看到有人买雪糕，心想，天气热了就买个尝尝吧。打开柜子，拿起雪糕，恍惚间，温暖的记忆又浮现在眼前。&emsp;&emsp;juan，我的高中同学，朋友，那时经常作我的同桌，人美心善，跟同学关系都挺好。当然对我也很好。常给我糖果啊各种小吃的，我用的笔啊书和本子啊经常从juan那直接拿。&emsp;&emsp;我对juan的第一印象：juan是一个可爱的小公主，而且很高洁。机缘巧合之下，我有幸认识了juan，而且常常作同桌。这让我们之间的距离又近了一点。juan是我去到十班最早认识的同学之一。&emsp;&emsp;时间久了，发生过的好多事情我就不记得了。所以我此时此刻在努力的将往事回忆，我生怕等我老了的时候，年轻时的这些美好时光要是再也回想不起来了，那样想想多遗憾啊。&emsp;&emsp;juan对我一直很好，就像对其他人一样。我们除了讨论学习，还聊小时候，聊未来。关于未来，其实都是我在表达对未来的迷惑，而juan一直在开导我。juan说我们可以永远做朋友。&emsp;&emsp;一个雪糕，那是高三时的一天中午你送我的，当时教室里是有其同学的，但是你只送给了我。在高三那个本就燥热的季节，让我清凉了一整个夏天。&emsp;&emsp;如今再拿起雪糕，眼前浮现出都是你对我的好。感谢那时的遇见，让我能有这么美好的回忆。juan，也愿你过得好，有个好对象。要是余生能再见，我想你还是那么的漂亮，那么温柔与大气。&emsp;&emsp;朋友的友谊不是三言两语就道的尽的，但都是埋藏在我的心底里的。 &emsp;&emsp;刚刚看qq空间里你发的说说–有人拿走了你的外卖，🤣🤣🤣","categories":[{"name":"diary","slug":"diary","permalink":"https://shulu520.com/categories/diary/"}],"tags":[]},{"title":"git-liao-note","slug":"git-liao-note","date":"2019-04-30T16:50:45.000Z","updated":"2019-05-12T15:32:28.393Z","comments":true,"path":"git/git-liao-note/","link":"","permalink":"https://shulu520.com/git/git-liao-note/","excerpt":"&emsp;&emsp;人是不能闲的，一闲就会想得太多，一闲就会感情泛滥，所谓矫情屁事多，空虚寂寞冷，都是因为懒散寂寞闲。","text":"&emsp;&emsp;人是不能闲的，一闲就会想得太多，一闲就会感情泛滥，所谓矫情屁事多，空虚寂寞冷，都是因为懒散寂寞闲。 git 的优秀之处 它跟踪并管理的是文件的修改，而非文件。Git有不少命令中有“-”，有时候是“-”，有时候是“–”。学过linux的命令行就懂了，单个”-“ 后面跟的是单个字母的参数，如-m， 两个”–”后面跟的是多个字母的参数，如–readme.txt 在大多数情况下成立的。注意:我的博客页面上显示的效果都只有一个’-‘,若’-‘线条显示的比较细，则表示两个’-‘ 创建本地版本库cd 到目录文件夹下mkdir learn-git 新建文件夹，即版本库（repository）git init 初始化版本库,即把这个目录变成git 可以管理的仓库ctrl + l 清屏，以防代码太多看着难受ls 查看目录下的文件ls -a 查看不可见的文件touch git-test.txt 创建 txt文件 或者用vscode编辑器创建，别用windows 自带的记事本，因为记事本在编码方面有弱智的行为，键盘上的上键 返回上一步命令git add git-test.txt 添加要提交的文件，可多次添加多个文件，将文件添加到暂存区（stage即阶段的意思）git commit -m “添加描述内容，如 这是第一次使用commit提交” 可以一次提交多个文件，默认提交到master 分支时光穿梭机git status 查看仓库当前的状态git diff 查看文件的具体修改的内容 输出变化前后的内容git log 显示从最近到最远的提交日志git reset –hard HEAD^ 回退到上一个版本，HEAD表示当前版本，HEAD^即上一个版本，往上100个版本为HEAD~100git reflog 用来记录我们的每一次命令即commit 的idgit reset –hard commit_id commit_id 为某一版本提交的具体ID名词解释说明 工作区： 即我们电脑上的项目文件夹，版本库 ：即工作区里面的一个叫 .git 的隐藏目录，版本库里面有暂存区，有git 为我们创建的master 分支，以及指向master的一个指针HEAD 管理修改 每次修改，如果不用git add 到暂存区，就不会加入到commit 中git checkout – git-test.txt 让这个文件回到最近一次git commit 或 git add 时的状态，注意–是单独的即后面有空格 ，git checkout 使用版本库里面的版本替换工作区的版本 ，无论工作区是修改还是删除，都可以一键还原。 我测试时为什么不行呢cat git-test.txt 查看文件的内容 远程仓库github 上创建一个仓库就行了，最好与本地仓库同名根据提示：将本地仓库与远程仓库关联并推送到远程123…or push an existing repository from the command linegit remote add origin https://github.com/lqyasl/learn-git.git (关联)git push -u origin master (本地推送到远程) 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。一个项目库第一次推送成功后，后面 只要本地做了提交，就可以 git push origin master 不用加参数-u分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了。前面是先有本地仓库，再有远程库。如何关联远程库。现在，最好的方式是，先创建远程库，再从远程库里面克隆到本地。首先在github上创建一个 仓库 并勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。我这里创建了一个gitskills的库。git clone git@github.com:lqyasl/gitskills.git 或 git clone https://github.com/lqyasl/gitskills.git 等多种方式， 推荐使用前一种，其速度最快。cd gitskills 进入克隆的库ls 展开文件列表 可以看到已经有一叫README.md 的文件了分支管理分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 与其他svn 版本控制系统相比， git 超级快。每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点。每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上。从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变。假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并。合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。实战部分git checkout -b dev 创建dev分支，然后切换到dev分支： 这里git checkout命令加上-b参数表示创建一个分支并切换到这个分支。 checkout这里表示切换的意思。git branch 查看当前分支，git branch命令会列出所有分支，当前分支前面会标一个*号。对README.md 文件做修改，比如加一点内容。然后 git add README.md 以及 git commit -m ‘分支测试’ ，我们就可以在dev分支上正常提交现在，dev分支的工作完成，我们就可以切换回master分支 git checkout master现在，我们把dev分支的工作成果合并到master分支上 git merge dev 这里git merge命令用于合并指定分支到当前分支。注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。合并完成后，就可以放心地删除dev分支了。 git branch -d dev因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。gti branch 查看分支，可以看到只剩下一个master主分支了。创建分支与合并小结 Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 解决冲突创建新的feature1分支，继续我们的新分支开发 git checkout -b feature1修改 README.md 文件的内容在feature1分支上提交 git add README.md 以及 git commit -m ‘AND simple’切换到master分支 git checkout masterGit还会自动提示我们当前master分支比远程的master分支要超前1个提交在master分支上把readme.txt文件的最后一行改为：Creating a new branch is quick &amp; simple.提交README.md 文件现在，master分支和feature1分支各自都分别有新的提交这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看 gti merge feature1 结果显示： Automatic merge failed; fix conflicts and then commit the result.果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件修改README.md 并提交 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。最后，删除feature1分支： git branch -d feature1分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。下面我们实战一下–no-ff方式的git merge：首先，仍然创建并切换dev分支：git checkout -b dev## &emsp;&emsp;今晚到此为止，明天再写。","categories":[{"name":"git","slug":"git","permalink":"https://shulu520.com/categories/git/"}],"tags":[{"name":"git-note","slug":"git-note","permalink":"https://shulu520.com/tags/git-note/"}]},{"title":"Math-random","slug":"Math-random","date":"2019-04-30T16:50:45.000Z","updated":"2019-05-02T15:02:25.641Z","comments":true,"path":"Math/Math-random/","link":"","permalink":"https://shulu520.com/Math/Math-random/","excerpt":"引言：希望你睡不着时，想起的都是那些让你开心的事 常见的问题：如何生成一个区间[min,max]内的随机整数？答案很简单，即 Math.random()*(max-min)+min 以下是一些其他的方法。","text":"引言：希望你睡不着时，想起的都是那些让你开心的事 常见的问题：如何生成一个区间[min,max]内的随机整数？答案很简单，即 Math.random()*(max-min)+min 以下是一些其他的方法。 new Date() - 0 new Date() 日期函数 默认会显示年月日等字符，new Date() - 0 会得到数字“秒” (new Date() - 0)%2239 ,得到取模数值分之一概率的随机数，即[0,2239]范围内一随机数 toString(指定进制) 方法的调用 与parseInt() 方法一样，进制区间为 [2,36]，取36得字母多一些 随便一个随机数.toString(36)得随机字符，但有数字，且长短不一 随机字符串函数，长度固定，且都是字母 从固定的字典中抽取字符构成随机字符串 12345678910// 在大小写字母之间随机生成 x 个字符function randStr(x)&#123; var s = &apos;&apos;; while(s.length &lt; x &amp;&amp; x &gt; 0)&#123; var r = Math.random(); s += String.fromCharCode(Math.floor(r*26) + (r &gt; 0.5 ? 97 : 65)) &#125;; return s;&#125;;console.log(randStr(3)); //KzE 三个随机字符 颜色随机函数1234function randomColor()&#123; var rand = &apos;#&apos;+(&apos;00000&apos;+(Math.random()*0x1000000&lt;&lt;0).toString(16)).slice(-6); return rand;&#125;; 后记 随机数相关得知识还又有很多，后面学到了再来补充笔记","categories":[{"name":"Math","slug":"Math","permalink":"https://shulu520.com/categories/Math/"}],"tags":[{"name":"random","slug":"random","permalink":"https://shulu520.com/tags/random/"}]},{"title":"book-fengchuan","slug":"book-fengchuan","date":"2019-04-30T16:50:45.000Z","updated":"2019-05-19T16:53:54.217Z","comments":true,"path":"book-note/book-fengchuan/","link":"","permalink":"https://shulu520.com/book-note/book-fengchuan/","excerpt":"&emsp;&emsp;深夜时，人会更加容易情绪化，所以无论多难过，都要告诉自己，没有那麽糟糕，睡一觉就好了。","text":"&emsp;&emsp;深夜时，人会更加容易情绪化，所以无论多难过，都要告诉自己，没有那麽糟糕，睡一觉就好了。 相比广告营销，口口相传更有效，分享能让我们感觉良好，因为他会让我们显得高大上。我们更愿意与人分享能提升个人形象的信息。某些产品，思想或行为，经常出现在我们眼前时，他们的影响力和传染力就会大大增加。从古至今，故事一直都是人们分享信息的重要工具。诱因，让人产生联想，看到这个，就会想到那个。打折规则，100元以上，降价多少元，以下为打几折。&emsp;&emsp;那么如何打造-个疯传的产品呢?第一，让你的产品成为一种社交货币，也就是说人们会通过分享它来赢得别人的好感和兴趣;第二，要利用诱因引发消费者的联想;第三，要带动消费者的情绪，让他们不断频繁地分享;第四，让你的产品尽可能出现在大家眼前，让人们不看都不行;第五，记得，简单实用的东西自然会受人欢迎;最后，帮你的产品量身打造一一个足够有意思的故事。&emsp;&emsp;两个可行的建议。首先，可以让你的产品带上点竞争元素。就是说利用人们的游戏心理，大家在玩游戏的时候都喜欢跟别人比赛，获得胜利之后，会得意地和别人分享自己的战绩，同时也就相当于告诉了别人某个产品。所以，如果你的产品有了游戏元素，就能鼓励消费者用你的产品进行某种互动，这样就提高了产品被分享的可能。","categories":[{"name":"book-note","slug":"book-note","permalink":"https://shulu520.com/categories/book-note/"}],"tags":[{"name":"skills","slug":"skills","permalink":"https://shulu520.com/tags/skills/"}]},{"title":"skills-search","slug":"skills-search","date":"2019-04-30T16:50:45.000Z","updated":"2019-05-27T04:49:54.955Z","comments":true,"path":"skills/skills-search/","link":"","permalink":"https://shulu520.com/skills/skills-search/","excerpt":"","text":"口语转变为关键词 关键词之间打上空格 限定在特定网站内 关键词 site:某一站点 注意：站点前不用加www或http 限定文件类型 关键词 filetype:文件格式 限定时间段 关键词 20xx..20xx 注意：中间是两个英文句号 排除某个关键词 关键词 -广告 -推广 将关键词限定在标题中 关键词 intitle:限定内容","categories":[{"name":"skills","slug":"skills","permalink":"https://shulu520.com/categories/skills/"}],"tags":[{"name":"search","slug":"search","permalink":"https://shulu520.com/tags/search/"}]},{"title":"vue-source-guigu","slug":"vue-source-guigu","date":"2019-04-30T10:49:43.000Z","updated":"2019-05-27T04:53:19.309Z","comments":true,"path":"vue/vue-source-guigu/","link":"","permalink":"https://shulu520.com/vue/vue-source-guigu/","excerpt":"&emsp;&emsp;read the fucking source code.","text":"&emsp;&emsp;read the fucking source code. vue 源码分析知识点分析 vue 作为一个 MVVM 框架的基本实现原理准备知识 1 [].slice.call(lis): 将伪数组转换为真数组 slice 方法有浅拷贝的用法，表示截取一部分，不传参数的话就是拷贝原数组 这样更好 Array.prototype.slice.call(lis) 2 node.nodeType: 得到节点类型 节点类型：常用的 document // 文档 Element //元素节点 节点类型 nodeType === 1; Attr //属性 Text //文本 documentFragment // 文档碎片 3 Object.defineProperty(obj, propName, {}): 给对象添加/修改属性(指定描述符) vue 数据代理的核心语法，不支持ie8，面试题 属性描述符： 数据描述符： configurable: true/false 是否可以重新 define enumerable: true/false 是否可以枚举(for..in / keys()) value: 指定初始值 writable: true/false value 是否可以修改 访问描述符：vue的计算属性就是利用get set 方法 get: 回调函数, 根据其他相关的属性动态计算得到当前属性值，根据相关的属性更新（得到）当前的属性 set: 回调函数, 监视当前属性值的变化，更新相关的属性值 ，根据当前的属性更新相关的属性 Object.keys(obj): 得到对象自身可枚举的属性名的数组 obj.hasOwnProperty(prop): 判断 prop 是否是 obj 自身的属性 DocumentFragment: 文档碎片(高效批量更新多个节点) 传言啊 这个 childNodes是正统属性 亲生的 而这个children是野孩子 这个野孩子比较随意 所以用它返回来的就只有DOM元素了 其他的文字啥的 都不返回 而 childNodes比较讲究 事无巨细 都要返回来 但是我还是觉得野孩子乖 所以也获得了几乎所有浏览器的支持 如果你想要DOM节点 直接用野孩子就可以了 12345&lt;ul id=&quot;list&quot;&gt; &lt;li&gt;test1&lt;/li&gt; &lt;li&gt;test2&lt;/li&gt; &lt;li&gt;test3&lt;/li&gt;&lt;/ul&gt; 12345678910111213141516let list = document.getElementById(&quot;list&quot;); // 1. 创建文档碎片 let fragment = document.createDocumentFragment(); // 2. 取出ul中 所有 子节点保存到fragment中 //Array.prototype.slice.call(list.children).forEach(element =&gt; &#123; fragment.appendChild(element); &#125;); // 3.修改fragment中的每一个子元素的内容 Array.prototype.slice.call(fragment.children).forEach(element =&gt; &#123; element.textContent = &apos;舒璐&apos;; &#125;); // 4.将文档碎片插入到list中 list.appendChild(fragment); 数据代理的实现基本实现流程 通过 Object.defineProperty()给 vm 添加与 data 对象的属性对应的属性描述符 所有添加的属性都包含 getter/setter getter/setter 内部去操作 data 中对应的属性数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152相当于Vue的构造函数function MVVM(options) &#123; // 将选项对象保存到vm this.$options = options; // 将data对象保存到vm和datq变量中 var data = this._data = this.$options.data; //将vm保存在me变量中 var me = this; // 遍历data中所有属性 Object.keys(data).forEach(function (key) &#123; // 属性名: name // 对指定属性实现代理 me._proxy(key); &#125;); // 对data进行监视 observe(data, this); // 创建一个用来编译模板的compile对象 this.$compile = new Compile(options.el || document.body, this)&#125;MVVM.prototype = &#123; $watch: function (key, cb, options) &#123; new Watcher(this, key, cb); &#125;, // 对指定属性实现代理 _proxy: function (key) &#123; // 保存vm var me = this; // 给vm添加指定属性名的属性(使用属性描述) Object.defineProperty(me, key, &#123; configurable: false, // 不能再重新定义 enumerable: true, // 可以枚举 // 当通过vm.name读取属性值时自动调用 get: function proxyGetter() &#123; // 读取data中对应属性值返回(实现代理读操作) return me._data[key]; &#125;, // 当通过vm.name = &apos;xxx&apos;时自动调用 set: function proxySetter(newVal) &#123; // 将最新的值保存到data中对应的属性上(实现代理写操作) me._data[key] = newVal; &#125; &#125;); &#125;&#125;; 其中最关键的部分为 1234567891011121314Object.defineProperty(me, key, &#123; configurable: false, // 不能再重新定义 enumerable: true, // 可以枚举 // 当通过vm.name读取属性值时自动调用 get: function proxyGetter() &#123; // 读取data中对应属性值返回(实现代理读操作) return me._data[key]; &#125;, // 当通过vm.name = &apos;xxx&apos;时自动调用 set: function proxySetter(newVal) &#123; // 将最新的值保存到data中对应的属性上(实现代理写操作) me._data[key] = newVal; &#125; &#125;); 模板解析 嵌套调用: a里面调用b,b里面调用c 递归: a 里面调用 a ,a继续调用a即特殊的嵌套调用 模板解析的基本流程 1)将 el 的所有子节点取出, 添加到一个新建的文档 fragment 对象中 2)对 fragment 中的所有层次子节点递归进行编译解析处理 对大括号表达式文本节点进行解析 对元素节点的指令属性进行解析 事件指令解析 一般指令解析 3) 将解析后的 fragment 添加到 el 中显示 模板解析(1): 大括号表达式解析&lt;p&gt;&lt;/p&gt; 根据正则对象得到匹配出的表达式字符串: 子匹配/RegExp.$1 name 从 data 中取出表达式对应的属性值 将属性值设置为文本节点的 textContent 模板解析(2): 事件指令解析从指令名中取出事件名 根据指令的值(表达式)从 methods 中得到对应的事件处理函数对象 给当前元素节点绑定指定事件名和回调函数的 dom 事件监听 指令解析完后, 移除此指令属性 模板解析(3): 一般指令解析得到指令名和指令值(表达式) text/html/class msg/myClass 从 data 中根据表达式得到对应的值 根据指令名确定需要操作元素节点的什么属性 v-text—textContent 属性 v-html—innerHTML 属性 v-class–className 属性 4) 将得到的表达式的值设置到对应的属性上 5) 移除元素的指令属性 call apply bind JavaScript 的一大特点是， 函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念 apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里 bind()最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的this值。 常见的错误就像，将方法从对象中拿出来，然后调用，并且希望this指向原来的对象。 如果不做特殊处理，一般会丢失原来的对象。用bind方法可以 数据绑定 简单地说，就是数据更新，界面改变。 一旦更新了 data 中的某个属性数据, 所有界面上直接使用或间接使用了此属性的节点+更新 数据劫持 数据劫持是 vue 中用来实现数据绑定的一种技术 基本思想: 通过 defineProperty()来监视 data 中所有属性(任意层次)数据的变化, 一旦变化就去更新界面 初始化显示：页面（表达式/指令）能从data中读取数据显示（编译/解析） 更新显示：更新data中的属性数据，.&gt;&gt;&gt; 页面更新 图中黑线表示初始化，红线表示更新时触发 双向数据绑定 双向数据绑定是建立在单向数据绑定(model==&gt;View)的基础之上的 双向数据绑定的实现流程: 在解析 v-model 指令时, 给当前元素添加 input 监听(input事件会在value属性值发生改变时触发，通过js改变value属性值不会触发此事件。只有IE8以上或者谷歌火狐等标准浏览器支持。) 当 input 的 value 发生改变时, 将最新的值赋值给当前表达式所对应的 data 属性 vuex 是vue 的一个插件 简单来说: 对 vue 应用中多个组件的共享状态进行集中式的管理(读/写) 状态自管理应用 state: 驱动应用的数据源（data） view: 以声明方式将 state 映射到视图(模板界面) actions:（在vue中是函数） 响应在 view 上的用户输入导致的状态变化 (包含 n 个*更新状态的方法*) ![](vuenote/2.jpg) 多组件共享状态的问题 多个视图依赖于同一状态 来自不同视图的行为需要变更同一状态 以前的解决办 将数据以及操作数据的行为都定义在父组件 将数据以及操作数据的行为传递给需要的各个子组件(有可能需要多级传递) vuex 就是用来解决这个问题的 vuex 核心概念和 API state vuex 管理的状态对象,它应该是唯一的 mutations 包含多个直接更新 state 的方法(回调函数)的对象 谁来触发: action 中的 commit(&apos;mutation 名称&apos;) 只能包含同步的代码, 不能写异步代码 const mutations = { yyy (state, {data1}) { // 更新 state 的某个属性 } } vuex 人生管理哲学，哈哈State:想一想，你现在心里在意哪些事？ Mutation目标导向: 写下目标，直接改变State Action阶段性执行： 写下行动 ，执行一个个Matation、异步函数、和其它阶段性执行。 Getters: 写下其它指标，根据现有的state得到其他的指标 mapState和mapGetters必须在computed中访问，因为它们返回的是对象，所以需要用拓展符…进行展开。 mapActions则是将Action挂载到methods上，也需要用拓展符…进行展开。 组件中的mapActions([“increment”])与actions 中 increment 函数名一样actions 中 commit(“INCREMENT”)与mutations 中 INCREMENT函数名一样大写的函数名只是为了区分各个函数 可以定义一个mutation-type.js 后记","categories":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/categories/vue/"}],"tags":[{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"hello-friends","slug":"friends","date":"2019-04-23T15:03:21.000Z","updated":"2019-05-27T05:06:59.991Z","comments":true,"path":"hello/friends/","link":"","permalink":"https://shulu520.com/hello/friends/","excerpt":"","text":"&emsp;&emsp;终于等到你，还好我没放弃：来了就好好逛逛，这里既是我的学习园地，也是我的精神家园，欢迎常来看看。在手机上一些效果表现不出来，双击试试看。欢迎来QQ交流(发起临时会话，无需加好友)，也欢迎匿名来撩，无需登录，及时互动。点击右下角聊天按钮，试试吧。 Everything will be okay in the end. If it’s not okay, it’s not the end. 👉来QQ撩我啊","categories":[{"name":"hello","slug":"hello","permalink":"https://shulu520.com/categories/hello/"}],"tags":[]},{"title":"h5-guigu-music","slug":"h5-guigu-music","date":"2019-04-22T14:19:33.000Z","updated":"2019-05-19T16:59:48.714Z","comments":true,"path":"H5/h5-guigu-music/","link":"","permalink":"https://shulu520.com/H5/h5-guigu-music/","excerpt":"&emsp;&emsp;想去的地方，有你才最美丽。","text":"&emsp;&emsp;想去的地方，有你才最美丽。 第一天 像素 适配 图片加载太慢，后面要用纯文字代替，记得更新 rem最终适配代码 123456;(function()&#123; var styleNode = document.createElement(&quot;style&quot;); var w = document.documentElement.clientWidth/16; styleNode.innerHTML=&quot;html&#123;font-size:&quot;+w+&quot;px!important&#125;&quot; document.head.appendChild(styleNode);&#125;)() 1物理像素的实现 用媒体查询的方法 一般用伪元素来做123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;/&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; #test:before&#123; position: absolute; bottom: 0px; content: &quot;&quot;; display: block; width: 100%; height: 1px; background: black; &#125; @media only screen and (-webkit-device-pixel-ratio:2 ) &#123; #test:before&#123; transform: scaleY(.5); &#125; &#125; @media only screen and (-webkit-device-pixel-ratio:3 ) &#123; #test:before&#123; transform: scaleY(.33333333333); &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 第二天 移动端基础事件 querySelectorAll() 匹配满足选择器的所有元素 改变dom结构后一定得再次获取 1234567891011window.onload=function()&#123; //querySelectorAll:获取静态列表 var itemNodes = document.querySelectorAll(&quot;.item&quot;); // 第一次获取 console.log(itemNodes.length) document.body.innerHTML+=&quot;&lt;div class=&apos;item&apos;&gt;&lt;/div&gt;&quot;; itemNodes = document.querySelectorAll(&quot;.item&quot;); // 改变dom结构后一定得再次获取 console.log(itemNodes) for(var i=0;i&lt;itemNodes.length;i++)&#123; itemNodes[i].style.background=&quot;pink&quot;; &#125;&#125; querySelector 获取 querySelectorAll 匹配到的第一个 触屏事件 监听用 addEventListenerpc端12345678910 touchstart mousedown touchmove mousemove 不可能单独触发 可以单独触发 touchend mouseupwindow.onload=function()&#123; var item = document.querySelector(&quot;.item&quot;); item.addEventListener(&quot;touchstart&quot;,function()&#123; console.log(&quot;touchstart&quot;) &#125;)&#125; 移动端事件默认行为 长按选中，橡皮筋效果（下拉）等 全面禁止事件默认行为 在 touchstart事件上，即手指触摸上去的时候就开始禁止 一上来就这段代码，全面禁止事件默认行为12345678910window.onload=function()&#123; document.addEventListener(&quot;touchstart&quot;,function(ev)&#123; ev=ev||event; ev.preventDefault();&#125;)// 单独按需开启 item.addEventListener(&quot;touchstart&quot;,function(ev)&#123; ev=ev||event; ev.stopPropagation();&#125;) 右键菜单的阻止与开启 与自定义右键 全局阻止右键1234567891011121314151617181920212223242526272829 document.oncontextmenu=function()&#123; return false; &#125;// 单独按需开启浏览器的右键菜单 var inner = document.querySelector(&quot;#inner&quot;); inner.oncontextmenu=function(ev)&#123; ev.stopPropagation();&#125;// 也可以自定义右键菜单window.onload=function()&#123; document.oncontextmenu=function(ev)&#123; ev = ev||event; var x = ev.clientX; var y = ev.clientY; var wrap =document.querySelector(&quot;#wrap&quot;); wrap.style.display=&quot;block&quot;; wrap.style.left = x+&quot;px&quot;; wrap.style.top = y+&quot;px&quot;; return false; &#125; // 单击消失 document.onclick=function()&#123; var wrap =document.querySelector(&quot;#wrap&quot;); wrap.style.display=&quot;none&quot;; &#125;&#125; 事件点透 pc端的事件可以在移动端触发 PC端事件有300毫秒延迟 移动端事件不会有延迟 移动端 a 标签跳转方案 并解决误触 123456789101112131415161718192021 // 阻止事件默认行为 document.addEventListener(&quot;touchstart&quot;,function(ev)&#123; ev=ev||event; ev.preventDefault(); &#125;) //移动端a标签的跳转方案 解决误触 var aNodes = document.querySelectorAll(&quot;a&quot;); for(var i=0;i&lt;aNodes.length;i++)&#123; aNodes[i].addEventListener(&quot;touchstart&quot;,function()&#123; this.isMoved=false; &#125;) aNodes[i].addEventListener(&quot;touchmove&quot;,function()&#123; this.isMoved=true; &#125;) aNodes[i].addEventListener(&quot;touchend&quot;,function()&#123; if(!this.isMoved)&#123; location.href=this.href; &#125; &#125;) &#125;&#125; event : //changedTouches: 触发当前事件的手指列表, 最常用//targetTouches: 触发当前事件时元素上的手指列表//touches: 触发当前事件时屏幕上的手指列表常见问题 及解决方法 禁止电话与邮箱,添加标签 1&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no&quot;/&gt; 按需开启 电话与邮箱 12 &lt;a href=&quot;tel:1383838438&quot;&gt;1383838438&lt;/a&gt;&lt;a href=&quot;mailto:2642816105@qq.com&quot;&gt;2642816105&lt;/a&gt; 解决连接按钮高亮问题 1234a &#123; text-decoration:none; // 去下划线 webkit-tap-highlight-color:rgba(0,0,0,0); // 去背景高亮，只需字体高亮&#125; 解决圆角过圆的问题 加属性 webkit-appearance:none 即可 fontboosting 的问题 及显示的字体与设置的大小不一致的现象，加属性 max-height:999999px;即可 无缝华屏 移动端清除浮动：父元素ul元素上加 overflow:hidden 即可 表单：表单高亮：outline:none; 表单内阴影：boder:none; 划屏相关 在谁上面划，即划屏包裹slide-wrapper 划的内容 即slide-content 元素排到一行的方法 浮动 父容器宽度不够会自动换行 另一种技巧 父容器white-space :nowrap; 子元素: display: inline-block;橡皮筋效果 减少每次move 的有效距离，最终的有效距离还是一直在增大 混合 继承 可以单独定义一系列通用的样式，在需要的时候进行调用。从而减少代码的重复 混合：简单 1234567891011121314151617181920&lt;!-- 定义混合 --&gt;.mixin()&#123; &lt;!-- 规则集 --&gt;&#125;&lt;!-- 使用混合 --&gt;#text1&#123; &lt;!-- 相当于将规则集里面的代码cv到这里 --&gt; &lt;!-- 每次使用都是将代码复制到相应位置 --&gt; &lt;!-- 使用几次就有几处相同的代码 --&gt; .mixin();&#125;#text2&#123; .mixin();&#125;#text3&#123; .mixin();&#125;&lt;!-- 多处使用相同的混合 这样写好一点-（手动写）-&gt;#text1,#text2,#text3&#123; .mixin() &#125; 继承：性能好一点 1234567891011121314151617&lt;!-- 定义继承 --&gt;.extend&#123; &lt;!-- 规则集 --&gt;&#125;&lt;!-- 使用继承 --&gt;#text1&#123; &amp;::extend(.extend);&#125;#text2&#123; &amp;::extend(.extend);&#125;#text3&#123; &amp;::extend(.extend);&#125;&lt;!-- 最终编译为 --&gt;#text1,#text2,#text3&#123; &lt;!-- 规则集 ，相当于将规则集里面的代码cv到这里--&gt;&#125;","categories":[{"name":"H5","slug":"H5","permalink":"https://shulu520.com/categories/H5/"}],"tags":[{"name":"H5-note","slug":"H5-note","permalink":"https://shulu520.com/tags/H5-note/"}]},{"title":"markdown-write","slug":"markdown","date":"2019-04-20T14:23:44.000Z","updated":"2019-05-27T05:19:40.953Z","comments":true,"path":"md/markdown/","link":"","permalink":"https://shulu520.com/md/markdown/","excerpt":"故事的开头，多是惊魂一瞥，然后一眼万年。故事的结局，多是渐行渐远，江湖不见。","text":"故事的开头，多是惊魂一瞥，然后一眼万年。故事的结局，多是渐行渐远，江湖不见。 在 xxx.md文件插入html效果 直接写html 即可 内联样式也直接写 这里输入文字，自定义字体大小 这里输入文字，自定义字体颜色这里输入文字，自定义字体背景色这是综合起来的效果 这是综合起来的效果2 首行缩进效果 其中的 &amp;emsp;&amp;emsp; 即缩进两个字最常见 全方大的空白 &amp;emsp;&emsp;&emsp;内容充实的生命就是长久的生命。我们要以行为而不是以时间来衡量生命。 ——小塞涅卡 不断行的空白格&amp;nbsp; &nbsp;以后无论我去哪我都把你带着我看账你帮我打算盘我谈生意你帮我出主意一起把吴家东院发扬光大做到陕西第一天下第一。———那年花开月正圆周莹经典台词 倾斜 单层*示例：倾斜字体 加粗 双层*示例：加粗字体 加粗倾斜 三层*示例：加粗倾斜 删除线 双层~~示例：删除线 单层引用 &gt;加内容 这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容 无序列表 用 - + * 任何一种都可以示例： 无序列表1 无序列表2 无序列表3 表格 : 表头 表头 表头 内容 内容 内容 内容 内容 内容 注：第二行分割表头和内容。-有一个就行，为了对齐，多加了几个 文字默认居左-两边加：表示文字居中-右边加：表示文字居右 代码:单行: javascript vue node ajax 代码块: 、、、.b{ background: red;}、、、 👉有事记得Q我哦","categories":[{"name":"md","slug":"md","permalink":"https://shulu520.com/categories/md/"}],"tags":[]},{"title":"vue-guigug","slug":"vue-guigu","date":"2019-04-17T12:00:21.954Z","updated":"2019-05-27T04:13:10.324Z","comments":true,"path":"vue/vue-guigu/","link":"","permalink":"https://shulu520.com/vue/vue-guigu/","excerpt":"&emsp;&emsp;人生即在于体验，而体验源于去尝试，去折腾，去改变，去塑新。 &emsp;&emsp;要知道：过一个平凡无趣的人生实在太容易了，你可以不读书，不冒险，不运动，不写作，不外出，不折腾…… &emsp;&emsp;但是，人生最后悔的事情就是：我本可以。生活也好，职场也罢，亦同此理；编程则更如其是","text":"&emsp;&emsp;人生即在于体验，而体验源于去尝试，去折腾，去改变，去塑新。 &emsp;&emsp;要知道：过一个平凡无趣的人生实在太容易了，你可以不读书，不冒险，不运动，不写作，不外出，不折腾…… &emsp;&emsp;但是，人生最后悔的事情就是：我本可以。生活也好，职场也罢，亦同此理；编程则更如其是 Vue 的特点 遵循 MVVM 模式 即MVVM 模式的一种实现 编码简洁, 体积小, 运行效率高, 适合移动/PC 端开发 它本身只关注 UI, 可以轻松引入 vue 插件（依赖vue）或其它第三库(不依赖vue)开发项目 MVVM 的理解 M 即 model 模型, 数据对象（data） V 即 view 视图，模板页面 VM 即 viewModel 视图模型 是vue的实例 dom监听 数据绑定 组件 即 局部功能界面 ，是提供某一完整功能的模块模板的理解：动态的html页面，包含了一些js语法代码vue 扩展组件 vue-cli: vue 脚手架 axios: ajax 请求 vue-router: 路由 vuex: 状态管 vue-lazyload: 图片懒加载 vue-scroller: 页面滑动相关 mint-ui: 基于 vue 的 UI 组件库(移动端) element-ui: 基于 vue 的 UI 组件库(PC 端) 编程方式 命令式 如 jquery 声明式 如 vue 数组的扩展-array.some()和array.every()区别 some():方法用于检测数组中的元素是否有满足指定条件的，若满足返回true，否则返回false； every():方法用于检测数组中所有元素是否都符合指定条件，若符合返回true，否则返回false； 挂载元素app new Vue({ el :’#app’ }); new vue({}).$moute(‘#app’) 用于单元测试 vue 指令 v-bind 即 : 强制 动态 数据绑定（属性） v-on 即 @ 绑定事件监听 v-html 内部innerHTML XSS攻击 内容必须是可信赖的 vue 计算属性 computed 什么时候执行 ： 初始化显示，/ 相关的data 数据属性发生变化时触发 各个方法的返回值作为相关的属性值 get 回调函数，当需要读取当前属性值的时候回调，计算并返回当前属性的值 set 回调函数，监视当前属性值的变化，当属性值变化时回调，更新相关的属性数据 计算属性，存在缓存，多次读取，只调用一次getter计算，性能好, 全选时可用计算属性 vue 的方法 methods 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。 然而，不同的是计算属性是基于它们的依赖进行缓存的。只在相关依赖发生改变时它们才会重新求值 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数 如果你不希望有缓存，请用方法来替代 vue 的watch 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器 当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的 绑定 style class :class=”xxx” xxx是字符串或对象 :style=”xxx” xxx是对象 对象更新,数组更新 完全跟新 即重新写这个对象 补充更新 vm.$set(要跟新的对象名,补充的属性名,属性值) 数组更新 vm.$set(要跟新的数组名,更新的下标,具体值) 数组更新检测 变异方法（vue重写原生的方法）即以下这些方法已不再是原生的方法 push pop shift unshift splice sort reverse 使用它们会触发视图更新 注意事项： 利用索引直接设置一个项时/修改数组的长度时 vue不能检测到数组变化 常用事件修饰符 阻止事件冒泡 如@click.stop=”XXX” 传统方法 e.stopPropagation 取消事件默认行为 如 @click.prevent=”xxx” 传统方法 e.preventDefault @click.once=”xxx” 点击事件将只会触发一次 常用按键修饰符 抬起某键时，执行操作 如按回车 @keyup.enter=”xxx” 鼠标修饰符 left right middle 系统修饰键 可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 ctrl alt shift meta 表单数据的自动收集 使用 v-model vue实例的 生命周期（钩子函数） 大致有三个阶段 初始化阶段 beforeCreate created beforeMount mounted 只执行一次 更新阶段 beforeUpdate updated 执行N次 销毁阶段 beforeDestory destoryed 常用的有1：`mounted` （挂载方法） 发送*Ajax* 请求,获取真实dom ，执行定时器等异步任务 2：`beforeDestory` 收尾工作，如清除定时器，解绑操作等 vue 过渡&amp;动画 过渡 ：transition 显示时的效果：xxx-enter-active{…} 隐藏时的效果 ：xxx-leave-active{…} 其中xxx表示 transition元素的name 属性值 动画 ：animation 过滤 vue.filter(‘自定义函数名’，() =&gt; {…}) 指令 ref 为某个元素指定一个唯一的标识，vue对象通过$refs属性访问这个元素对象 v-cloak 防止闪现表达式 与css属性选择器配合 [v-cloak] {display:none} 自定义指令 全局指令： vue.directive(‘指令名’，function(el,binding){…}) 参数el指属性所在的标签对象 binding包含指令相关的数据对象 局部指令： 在vue实例选项中配置directives:{‘指令名’，(el,binding) =&gt; {…},others} vue 自定义插件 plugin Vue 插件是一个包含 install 方法的对象 1234567891011121314151617181920 自定义 Vue 插件 包在匿名函数自执行里面(function () &#123; const MyPlugin = &#123;&#125;; MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或属性 Vue.myGlobalMethod = function () &#123; alert(&apos;Vue 函数对象方法执行&apos;) &#125;; // 2. 添加全局资源 Vue.directive(&apos;my-directive&apos;, function (el, binding) &#123; el.innerHTML = &quot;MyPlugin my-directive &quot; + binding.value &#125;); // 3. 添加实例方法 Vue.prototype.$myMethod = function () &#123; alert(&apos;vue 实例对象方法执行&apos;) &#125;; &#125; window.MyPlugin = MyPlugin;&#125;)() 页面使用插件 1234567891011121314151617181920212223&lt;div id=&quot;demo&quot;&gt;&lt;!--使用自定义指令--&gt;&lt;p v-my-directive=&quot;msg&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;vue-myPlugin.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;//声明使用自定义插件Vue.use(MyPlugin)var vm = new Vue(&#123;el: &apos;#demo&apos;,data: &#123;msg: &apos;atguigu&apos;&#125;&#125;)//调用自定义的静态方法Vue.myGlobalMethod()//调用自定义的对象方法vm.$myMethod()&lt;/script&gt; vue 组件 全局组件 局部组件 vue 组件间通信 父传向子 props 在组件内声明所有的 props 方式一: 只指定名称props: [‘name’, ‘age’, ‘setName’] 方式二: 指定名称和类型props: { name: String, age: Number, setNmae: Function} 方式三: 指定名称/类型/必要性/默认值props: { name: {type: String, required: true, default:xxx},}问题: a. 如果需要向非子后代传递数据必须多层逐层传递 b. 兄弟组件间也不能直接 props 通信, 必须借助父组件才可以 属性校验 123456789101112 要校验的 props : &#123; msg :&#123; type :Number, validator (value)&#123; //validator 属性校验器，可以自定义属性校验 return value &gt; 3; &#125; &#125; arr :&#123; type :Array, default :() =&gt; ([1,2,3]) // 属性校验中，如果是`数组/对象` 需要将默认值返回 &#125;&#125; 子传向父 通过自定义事件 绑定事件监听 // 方式一: 通过 v-on 绑定 @delete_todo=”deleteTodo” // 方式二: 通过$on() this.$refs.xxx.$on(‘delete_todo’, function (todo) { this.deleteTodo(todo) }) 触发事件 // 触发事件(只能在父组件中接收) this.$emit(eventName, data) 问题: 隔代组件或兄弟组件间通信此种方式不合适 vue 自定义事件 我的理解 子组件中 @click=”add” methods 里面 是具体的add方法干的事情 add里面最终 通过this.$emit(“add”,this.msg)通知父级我触发了此事件 并传值给父组件 父组件中 监听@add=”addCounter”methods里面定义addCounter要干啥事，用一个形参接收子组件传来的值 消息订阅与发布(PubSubJS 库) 订阅消息 —-&gt;事件监听 PubSub.subscribe(‘msg’, function(msg, data){}) 发布消息 —–&gt;触发事件 PubSub.publish(‘msg’, data) 优点: 此方式可实现任意关系组件间通信(数据) slot(插槽，占位的) 此方式用于父组件向子组件传递标签数据4.2 复用性 使用 父组件中 使用子组件，slot属性 ：xxx 对应的标签结构 子组件中 定义插槽，slot元素 name属性：不确定的标签结构 1 插槽对应的方法属性等定义在父组件中， 模块导出为函数还是对象的依据要看模块向外暴露一个功能还是多个功能 一个功能即函数 多个功能则对象 ，因为对象可以包含多个方法 ajax 插件相关知识 下载插件 引入插件 声明使用插件 即 Vue.use(名字) 方式一：vue-resource 内部会给vm对象和组件对象添加一个属性：$http $http 有两个方法 get() ,post() 方式二：axios vue.2.X 下载 npm install axios –save // 直接引入模块使用，不用声明 在哪里使用在哪里引入 123456789import axios from &apos;axios&apos; // 发送 ajax 请求axios.get(url).then(response =&gt; &#123; console.log(response.data) // 得到返回结果数据&#125;).catch(error =&gt; &#123; console.log(error.message)&#125;) 数组方法之map方法的特点：数组里面的对象变，但数组对象的个数不变组件名称 路由相关 开发中分为路由组件和非路由组件 路由组件 名称为 views 或 pages 非路由组件 名称为 components 路由器模块命名为router建立index.js文件 路由器模块: src/router/index.js 引入vue import Vue from ‘vue’ 引入VueRouter import VueRouter from ‘vue-router’ 注册使用VueRouter Vue.use(VueRouter) 导出一个VueRouter实例 1234567891011 export default new VueRouter(&#123; routes 数组， routes: [ // 路由配置 k即（path） 和value即（component） &#123; path: &apos;/&apos;, redirect: &apos;/about&apos; &#125;, &#123; path: &apos;/about&apos;, component: About &#125;, ]&#125;) 注册路由器: main.js 1234567 import Vue from &apos;vue&apos; import router from &apos;./router&apos; // 创建 vue 配置路由器new Vue(&#123; el: &apos;#app&apos;, router, render: h =&gt; h(app)&#125;) 使用路由组件标签 12345&lt;!--路由链接--&gt;&lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;&lt;router-link to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;&lt;!--用于渲染当前路由组件--&gt;&lt;router-view&gt;&lt;/router-view&gt; 子路由 children path可以写全或 直接写当前的路由名字（简化写法） 缓存路由组件对象 默认情况下, 被切换的路由组件对象会死亡释放, 再次回来时是重新创建的 如果可以缓存路由组件对象, 可以提高用户体验 123&lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 向路由组件传递数据 方式 1: 路由路径携带参数(param/query) 配置路由 12345children: [&#123; path: &apos;mdetail/:id&apos;, component: MessageDetail&#125;] 路由路径 1&lt;router-link :to=&quot;&apos;/home/message/mdetail/&apos;+m.id&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt; 路由组件中读取请求参数 1this.$route.params.id 方式 2: 属性携带数据 1&lt;router-view :msg=&quot;msg&quot;&gt;&lt;/router-view&gt; 编程式路由导航 即用js 的方法实现而非 标签方式 相关 API 栈的结构 this.$router.push(path): 相当于点击路由链接(可以返回到当前路由界面) this.$router.replace(path): 用新路由替换当前路由(不可以返回到当前路由界面) this.$router.back(): 请求(返回)上一个记录路由 this.$router.go(-1): 请求(返回)上一个记录路由 this.$router.go(1): 请求下一个记录路由 栈 队列 例子 ： 喝醉酒后站着从上面出来即为栈 call 方法调用 让一个函数成为指定对象的方法进行调用 slice.call(lis) 即让slice函数成为lis的方法进行调用","categories":[{"name":"vue","slug":"vue","permalink":"https://shulu520.com/categories/vue/"}],"tags":[{"name":"guigu","slug":"guigu","permalink":"https://shulu520.com/tags/guigu/"}]},{"title":"less-note","slug":"less","date":"2019-04-17T12:00:21.909Z","updated":"2019-04-26T06:53:41.006Z","comments":true,"path":"less/less/","link":"","permalink":"https://shulu520.com/less/less/","excerpt":"君子生非异也，善假于物也.","text":"君子生非异也，善假于物也. less 即css预处理器 vscode 编辑器 下载插件 easy less 声明编码集 @charset “utf-8”声明变量 声明变量(原始值类型) @bb:#ff0000; 使用变量 color:@bb; 声明变量（路劲类型） @img:”../images”; 使用变量 background-image:url(“@{img}/1.jpg”) 声明变量(属性类型) @ww:width; 使用变量 @{ww}:100px; 混合方式 带默认参数 定义 .border-r(@radius:5px){ border-radiis:@radius; } 使用 .box{ .border-r; 传参即.border-r(10px); } 接收多个参数 定义 .box-s(@x, @y, @blur, @color){ box-shadow:@arguments; } 使用 .box{ .box-s(3px,4px,5px,red) } color 函数 了解就行 运算 各种可以计算的都可以计算 包括颜色值 支持运算符 + - * / 即加减乘除命名空间 它用于将mixins分组在通用名称下。 使用命名空间可以避免名称冲突，并从外部封装mixin组12345678910111213141516171819202122定义：#bgcolor()&#123; // 加 () 默认不输出 background: #ffffff; .a&#123; color: #888888; &amp;:hover&#123; color: green; &#125; .b&#123; background: red; &#125; &#125;&#125;使用：.bgcolor1&#123; background: yellow; #bgcolor&gt;.a; // &gt;符号表示选中混合中的每一个样式&#125;.bgcolor2&#123; // #bgcolor&gt;.a&gt;.b; #bgcolor .a .b; // 省略写法：将&gt;换成空格即可&#125; 避免编译 我们能在编译后的css文件中看到 它 编译计算之前的样子 最终的编译计算由浏览器来完成 css3中有这样一个函数calc() less里面 123.box&#123; width:~&apos;calc(300px - 10px)&apos;&#125; 编译完的 css 123.box&#123; width:calc(300px - 10px)&#125; !important css 样式中 用来提升优先级（最高） less 中 一样 常用来调试代码 比如 某一段样式不起作用，不知道是继承还是覆盖等造成的 给他加上 !important 还不起作用的话 就说明代码书写有误","categories":[{"name":"less","slug":"less","permalink":"https://shulu520.com/categories/less/"}],"tags":[]}]}
<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js-design-mode-state]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-state%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;莫辜负这仅有一次的人生。 状态模式介绍 一个对象有状态变化 每次状态变化都会触发一个逻辑 不能总是用if…else来控制 交通信号灯不同颜色的变化 场景 有限状态机(finite) 有限个状态，以及在这些个状态之间的变化 开源的库 javascript-state-machine 写一个简单的Promise 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// 收藏/取消收藏例子import StateMachine from &apos;javascript-state-machine&apos;// 初始化状态机模型let fsm = new StateMachine(&#123; init: &apos;收藏&apos;, transitions: [ &#123; name: &apos;doStore&apos;, from: &apos;收藏&apos;, to: &apos;取消收藏&apos; &#125;, &#123; name: &apos;deleteStore&apos;, from: &apos;收藏&apos;, to: &apos;取消收藏&apos; &#125; ], methods: &#123; // 监听执行收藏 onDoStore() &#123; console.log(&apos;收藏成功&apos;)// 可以post请求 updateText() &#125;, // 监听取消收藏 onDeleteStore() &#123; console.log(&apos;已经取消收藏&apos;)// 可以post请求 updateText() &#125; &#125;import StateMachine from &apos;javascript-state-machine&apos;// 初始化状态机模型let fsm = new StateMachine(&#123; init: &apos;收藏&apos;, transitions: [ &#123; name: &apos;doStore&apos;, from: &apos;收藏&apos;, to: &apos;取消收藏&apos; &#125;, &#123; name: &apos;deleteStore&apos;, from: &apos;收藏&apos;, to: &apos;取消收藏&apos; &#125; ], methods: &#123; // 监听执行收藏 onDoStore() &#123; console.log(&apos;收藏成功&apos;)// 可以post请求 updateText() &#125;, // 监听取消收藏 onDeleteStore() &#123; console.log(&apos;已经取消收藏&apos;)// 可以post请求 updateText() &#125; &#125;&#125;)// 更新按钮的文案function updateText () &#123; btn.text(fsm.state)&#125;let btn = document.getElementById(&apos;btn&apos;)btn.onclick = function () &#123; if (fsm.is(&apos;收藏&apos;)) &#123; fsm.doStore() //这里的函数名与前面的name对应 &#125; else &#123; fsm.deleteStore() &#125;&#125;// 初始化文案updateText()&#125;)// 更新按钮的文案function updateText () &#123; btn.text(fsm.state)&#125;let btn = document.getElementById(&apos;btn&apos;)btn.onclick = function () &#123; if (fsm.is(&apos;收藏&apos;)) &#123; fsm.doStore() //这里的函数名与前面的name对应 &#125; else &#123; fsm.deleteStore() &#125;&#125;// 初始化文案updateText() 设计原则验证 将状态对象和主题对象分离，状态的变化逻辑单独处理 符合开放封闭原则 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-design-mode-iterator]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-iterator%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 介绍 顺序访问一个集合 使用者无需知道内部的结构(封装) 菜鸟教程 代码实现(自己写的初级的 后面es6提供的完善的 for of)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 迭代器(遍历器)class Iterator &#123; constructor(container) &#123; this.list = container.list this.index = 0 &#125; next() &#123; if (this.hasNext()) &#123; return this.list[this.index++] &#125; return null &#125; hasNext() &#123; if (this.index &gt;= this.list.length) &#123; return false &#125; return true &#125;&#125;// 迭代器的容器class Container &#123; constructor(list) &#123; this.list = list &#125; getIterator() &#123; return new Iterator(this) &#125;&#125;let arr = [1,2,3,4,5,6]let container = new Container(arr)let iterator = container.getIterator()while (iterator.hasNext()) &#123; console.log(&apos;iterator.next() :&apos;, iterator.next());&#125;/* iterator.next() : 1 iterator.next() : 2 iterator.next() : 3 iterator.next() : 4 iterator.next() : 5 iterator.next() : 6 */ es6 Iterator 有序集合的数据如: Array Map Set String TypedArray arguments Nodelist 以上数据类型，都有[Symbol.iterator]这个属性 属性值是函数，执行函数返回一个迭代器 这个迭代器就有next方法可以顺序迭代子元素 可以运行Array.prototype[Symbol.iterator]来测试 注意 object 不是有序集合 可以用Map代替 for of12345678910111213141516171819202122232425262728293031323334353637383940414243//封装一个简单的each方法function each (data) &#123; //data是可遍历的 即data[Symbol.iterator]有值 for(let item of data) &#123; console.log(&apos;item :&apos;, item) &#125;&#125;// 测试几种可遍历的数据类型let str = &apos;love&apos;let arr = [1,2,3,4]let map = new Map()map.set(0, &quot;zero&quot;)map.set(1, &quot;one&quot;)let set = new Set([6,7,8,9])each(str)each(arr)each(map)each(set)/* item : l item : o item : v item : e item : 1 item : 2 item : 3 item : 4 item : [ 0, &apos;zero&apos; ] item : [ 1, &apos;one&apos; ] item : 6 item : 7 item : 8 item : 9*/ Map 数据结构 Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。 一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 一个 for…of 循环在每次迭代后会返回一个形式为[key，value]的数组。 一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。 Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。 你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。 Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。 Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。虽然 ES5 开始可以用 map = Obj- ect.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。 Map 在涉及频繁增删键值对的场景下会有些性能优势。 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-design-mode-observer]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-observer%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 介绍 前端运用最广泛的设计模式 当一个对象被修改时，则会自动通知它的依赖对象。 注意，不一定是一对多哦，也可以一对一的。 菜鸟教程 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 主题，保存状态，状态发生变化后触发所有观察者对象class Subject &#123; constructor() &#123; this.state = 0 this.observers = [] &#125; getState() &#123; return this.state &#125; setState(state) &#123; this.state = state this.notifyAllObservers() &#125; // 通知所有的观察者 notifyAllObservers() &#123; this.observers.forEach((observer) =&gt; &#123; observer.update() &#125;) &#125; // 添加新的观察者 attach(observer) &#123; this.observers.push(observer) &#125;&#125;// 观察者class Observer &#123; constructor(name, subject) &#123; this.name = name this.subject = subject this.subject.attach(this) &#125; update() &#123; console.log(`$&#123;this.name&#125; updated, now-state:$&#123;this.subject.getState()&#125;`); &#125;&#125;// 测试let s = new Subject()let o1 = new Observer(&apos;o1&apos;, s)let o2 = new Observer(&apos;o2&apos;, s)let o3 = new Observer(&apos;o3&apos;, s)s.setState(1) s.setState(2)s.setState(3)/* //打印结果 o1 updated, now-state:1 o2 updated, now-state:1 o3 updated, now-state:1 o1 updated, now-state:2 o2 updated, now-state:2 o3 updated, now-state:2 o1 updated, now-state:3 o2 updated, now-state:3 o3 updated, now-state:3*/ 使用场景 网页事件绑定 Promise jQuery callbacks nodejs 自定义事件 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-design-mode-proxy]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-proxy%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 代理模式简介 菜鸟教程 科学上网 明星经纪人 使用场景 网页事件代理 jQuery的 $.proxy() es6的proxy 代码实现明星经纪人 1234567891011121314151617181920212223242526272829303132333435363738394041// 明星let star = &#123; name: &apos;shulu&apos;, age: &apos;18&apos;, phone: &apos;star: 18366666666&apos;&#125;// 经纪人let agent = new Proxy(star, &#123; get(target, key) &#123; if (key === &apos;phone&apos;) &#123; // 返回经纪人(代理)的电话 return &apos;agent: 12353434343&apos; &#125; if (key === &apos;price&apos;) &#123; // 明星不报价，由经纪人报价 return &apos;agent: 1232323$&apos; &#125; return target[key] &#125;, set(target, key, val) &#123; if (key === &apos;customPrice&apos;) &#123; if (val &lt; 10000) &#123; // 最低价格 throw new Error(&apos;价格太低！&apos;) &#125;else&#123; target[key] = val return true &#125; &#125; &#125;&#125;)console.log(&apos;agent.name :&apos;, agent.name) //agent.name : shuluconsole.log(&apos;agent.age :&apos;, agent.age) //agent.age : 18console.log(&apos;agent.phone :&apos;, agent.phone) //agent.phone : agent: 12353434343console.log(&apos;agent.price :&apos;, agent.price) //agent.price : agent: 1232323$agent.customPrice = 1212 //价格太低！agent.customPrice = 100000 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this]]></title>
    <url>%2Fthis%2Fthis%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;认识我自己。 this 当前执行代码的环境对象 mdn权威解释 全局环境 无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。 函数环境 在函数内部，this的值取决于函数被调用的方式。 如果要想把 this 的值从一个环境传到另一个，就要用 call 或者apply 方法。方法来源即Function.prototype.call Function.prototype.bind 使用 call 和 apply 函数的时候，如果传递给 this 的值不是一个对象，JavaScript 会尝试使用内部 ToObject 操作将其转换为对象。 箭头函数 它的this即它外层函数的this。 作为对象的方法 当函数作为对象里的方法被调用时，它们的 this是调用该函数的对象。 原型链中的 this 对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么this指向的是调用这个方法的对象，就像该方法在对象上一样。 getter 与 setter 中的 this 相同的概念也适用于当函数在一个 getter 或者 setter 中被调用。用作 getter 或 setter 的函数都会把 this 绑定到设置或获取属性的对象。作为构造函数 当一个函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象。作为一个DOM事件处理函数 当函数被用作事件处理函数时，它的this指向触发事件的元素。 setTimeout 关于”this”的问题 当你向 setTimeout() (或者其他定时器函数)传递一个函数时,该函数中的this指向跟你的期望可能不同。 解释 由setTimeout()调用的代码运行在与所在函数完全分离的执行环境上。这会导致，这些代码中包含的 this 关键字在非严格模式会指向 window (或全局)对象，严格模式下为 undefined，这和所期望的this的值是不一样的。 即定时器函数是一个异步宏任务，在事件循环中会被分配到对应的任务队列中去等待执行，故执行栈即执行上下文环境即this不是你以为的原来的了。 有事您Q我👇]]></content>
      <categories>
        <category>this</category>
      </categories>
      <tags>
        <tag>mdn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-design-mode-decorator]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-decorator%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 介绍 菜鸟教程 大牛解读es7装饰器 为对象添加功能 不改变其原有的结构和功能 代码演示 画圆 12345678910111213141516171819202122232425class Circle &#123; draw() &#123; console.log(&apos;画一个圆&apos;) &#125;&#125;class Decorator &#123; constructor(circle) &#123; this.circle = circle &#125; draw() &#123; this.circle.draw() this.setRedBorder(this.circle) &#125; setRedBorder(circle) &#123; console.log(&apos;给圆设置红色的边框&apos;) &#125;&#125;// 测试let circle = new Circle()circle.draw() //画一个圆let dec = new Decorator(circle)dec.draw() //画一个圆 给圆设置红色的边框 装饰器 ES7 中的 decorator 同样借鉴了python语法糖，不过依赖于 ES5 的 Object.defineProperty 方法 。 Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 Object.defineProperty(obj, prop, descriptor) obj：要在其上定义属性的对象。 prop：要定义或修改的属性的名称。 descriptor：将被定义或修改的属性描述符。 返回值：被传递给函数的对象。 属性描述符 对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。 数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。 存取描述符是由 getter-setter 函数对描述的属性。 描述符必须是这两种形式之一；不能同时是两者。 数据描述符和存取描述符均具有以下可选键值: configurable 可修改 布尔值 enumerable 可枚举 布尔值 value 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。 writable 可写 布尔值 get 一个给属性提供 getter 的方法 set 一个给属性提供 setter 的方法 Object.assign Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 语法 Object.assign(target, …sources)参数 target 目标对象。 sources 源对象。 返回值 目标对象。 core-decorators装饰器库的使用 安装插件 12345678910111213141516171819202122npm install --save-dev @babel/plugin-proposal-class-properties npm install --save-dev @babel/plugin-proposal-decoratorsnpm install --save-dev babel-plugin-transform-decorators-legacynpm install --save-dev core-decorators当然还有以下依赖的支持&quot;dependencies&quot;: &#123; &quot;@babel/core&quot;: &quot;^7.4.4&quot;, &quot;@babel/plugin-proposal-class-properties&quot;: &quot;^7.4.4&quot;, &quot;@babel/plugin-proposal-decorators&quot;: &quot;^7.4.4&quot;, &quot;@babel/preset-env&quot;: &quot;^7.4.4&quot;, &quot;babel-loader&quot;: &quot;^8.0.5&quot;, &quot;babel-plugin-transform-decorators-legacy&quot;: &quot;^1.3.5&quot;, &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;, &quot;core-decorators&quot;: &quot;^0.20.0&quot;&#125; .babelrc文件的配置 12345678910111213141516171819202122&#123; &quot;presets&quot;: [ [&quot;@babel/preset-env&quot;, &#123; &quot;useBuiltIns&quot;: &quot;usage&quot;,// 在每个文件中使用polyfill时，为polyfill添加特定导入。利用捆绑器只加载一次相同的polyfill。 &quot;modules&quot;: false,// 启用将ES6模块语法转换为其他模块类型，设置为false不会转换模块。 &quot;targets&quot;: &#123; //浏览器兼容 &quot;browsers&quot;: &quot;last 2 versions, not ie &lt;= 9&quot; &#125; &#125;] ], &quot;plugins&quot;: [ [ &quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;legacy&quot;: true &#125; ], [&quot;@babel/plugin-transform-runtime&quot;, &#123; &quot;helpers&quot;: false &#125;] ]&#125; 简单使用 1 123456789101112131415import &#123; readonly &#125; from &apos;core-decorators&apos;class Demo &#123; @readonly sayName() &#123; console.log(&apos;shulu&apos;) &#125;&#125;let demo = new Demo()demo.sayName() //shuludemo.sayName = function () &#123; console.log(&apos;lqy love shulu&apos;) //Uncaught TypeError: Cannot assign to read only property &apos;sayName&apos; of object &apos;#&lt;Demo&gt;&apos;&#125; 简单使用 2 123456789101112import &#123; deprecate &#125; from &apos;core-decorators&apos;class Demo &#123; @deprecate(&apos;此方法即将废除&apos; ,&#123;url: &apos;https://shulu520.com&apos;&#125;) getName() &#123; console.log(&apos;lqy&apos;) &#125;&#125;let demo = new Demo()demo.getName() //lqy DEPRECATION Demo#getName: 此方法即将废除 See https://shulu520.com for more details. 还有多种好用的方法…… 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-design-mode-adapter]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-adapter%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;江南的雨季，西北的惆怅。感君一回顾，思君朝与暮。 设计模式之适配器介绍 菜鸟教程 适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 代码演示 12345678910111213141516171819class OldStandard &#123; oldRequest() &#123; return &apos;老式标准插头&apos; &#125;&#125;class Adapter &#123; constructor() &#123; this.standard = new OldStandard() &#125; newRequest() &#123; let info = this.standard.oldRequest() return `新标准插头---&gt;适配器---&gt;$&#123;info&#125;` &#125;&#125;let adater = new Adapter()let res = adater.newRequest()console.log(&apos;res :&apos;, res) //res : 新标准插头---&gt;适配器---&gt;老式标准插头 经典案例 vue的computed计算属性 设计原则验证 将旧接口和使用者分离 开放封闭原则 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-design-mode-singleton]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-singleton%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;I love the World. 单例模式介绍 菜鸟教程 系统中唯一被使用 一个类只有一个实例 私有化构造函数，外部不能new 只能内部new !!!!! instance实例是唯一被new出来的对象 代码演示123456789101112131415161718192021222324252627class SingleObject &#123; login() &#123; console.log(&apos;login&apos;) &#125; &#125;// 静态方法SingleObject.getInstance = (function() &#123; let instance return function() &#123; if (!instance) &#123; instance = new SingleObject() &#125; return instance &#125;&#125;)()let obj1 = SingleObject.getInstance()obj1.login() //loginlet obj2 = SingleObject.getInstance()obj2.login() //loginconsole.log(&apos;obj1===obj2 :&apos;, obj1===obj2) //obj1===obj2 : truelet obj3 = new SingleObject() //外部不能new,但是无法完全控制console.log(&apos;obj3===obj1 :&apos;, obj3===obj1) //obj3===obj1 : false 单例模式使用场景 jQuery 的 $ 模拟登录框 购物车 vuex react 中的store 代码实现登录框 12345678910111213141516171819202122232425262728293031323334353637383940414243class LoginForm &#123; constructor () &#123; this.state = &apos;hide&apos; &#125; show () &#123; if (this.state === &apos;show&apos;) &#123; console.log(&apos;已经显示&apos;) return &#125; this.state = &apos;show&apos; console.log(&apos;已经登录成功&apos;) &#125; hide () &#123; if (this.state === &apos;hide&apos;) &#123; console.log(&apos;已经隐藏&apos;) return &#125; this.state = &apos;hide&apos; console.log(&apos;已经隐藏成功&apos;) &#125;&#125;// 静态方法LoginForm.getInstance = (() =&gt; &#123; let instance return () =&gt; &#123; if (!instance) &#123; instance = new LoginForm() &#125; return instance &#125;&#125;)()let login1 = LoginForm.getInstance()login1.show() //已经登录成功let login2 = LoginForm.getInstance()login2.show() //已经显示login2.hide() //已经隐藏成功console.log(&apos;login1===login2 :&apos;, login1===login2)// login1===login2 : true// 这就说明login1 和login2是同一个实例 设计原则验证 符合单一职责原则，只实例化唯一的对象 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hotkey-vscode]]></title>
    <url>%2Fhotkey%2Fhotkey-vscode%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;如果你想要个和现在不同的人生，就必须去做你从未做过的事情。努力之后最坏的结果是失败，但不尝试的结果则是无止境的懊悔、怀疑和平庸。 vscode 常用快捷键 上下移动一行： Alt+Up 或 Alt+Down 向上或向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down 同时选中所有匹配： Ctrl+Shift+L Ctrl+D 下一个匹配的也被选中 Alt + 单击 ：插入光标 Ctrl + F2 选择当前字的所有出现 ctrl shift k 删除整行 ctrl shift a 多行注释 ctrl f 当前文件内搜索相关代码，终于找到这个功能了，哈哈，右上角会有弹框，其中有前后箭头，表示搜索的代码上一次、下一次出现的位置，点击直接会跳转到相应的位置，并且侧边上有相应的位置标识。 ctrl - 整体缩小 ctrl = 整体放大 文件/首选项/设置 搜索zoom 根据配置 可以更精细的对大小进行操作 ctrl 加滚轮 col 选第一个 即console.log()的快捷键 且效果很棒 有事您Q我👇]]></content>
      <categories>
        <category>hotkey</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-design-mode-factory]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-factory%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;愿你做一个快乐的小仙女。 介绍 菜鸟教程 代码实现 方法定义 12345678910111213141516// Product产品生产流水线class Product &#123; constructor (name) &#123; this.name = name &#125; getName () &#123; return `my name is $&#123;this.name&#125;` &#125;&#125;// Creator 工厂class Creator &#123; create (name) &#123; return new Product(name) &#125;&#125; 测试 123456789101112131415161718192021/* 普通调用 用户直接面对某一流水线，要产品 用户每次拿产品都得直接与产品流水线打交道*/ // 书写极其麻烦const p1 = new Product(&apos;phone&apos;)const p2 = new Product(&apos;book&apos;)console.log(&apos;p1 :&apos;, p1)console.log(&apos;p2 :&apos;, p2)/* 工厂函数 用户直接面对生产厂家，要产品 也就是说，用户无需知道其内部复杂生产过程*/// 工厂函数将生产流水线封装起来，只对外暴露接口供用户使用const creator = new Creator()//实例化一个工厂const pa = creator.create(&apos;boy&apos;)const pb = creator.create(&apos;girl&apos;)console.log(&apos;pa :&apos;, pa)console.log(&apos;pb :&apos;, pb) 工厂函数的例子 jQuery react.createElement vue异步组件 验证设计原则 构造函数和创建者分离 符合开放封闭原则 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-design-mode-design-philosophy]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-design-philosophy%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; unix/linux设计哲学 小即是美 让每一个程序只做好一件事 快速建立原型 利于快速迭代 舍弃高效率而取可移植性 复用性 采用纯文本来存贮数据 可读性好 软件复用 使用shell脚本 避免强制性的用户界面 让每个程序都称为过滤器 中间件 允许用户定制环境 个性化 操作系统内核小而轻量化 使用小写字母并简写 沉默是金 没有消息是最好的消息 各部分之和大于整体 模块化 寻求90%的解决方案 不必追求完美 SOLID 五大设计原则 S 单一职责原则 每个程序之做好一件事 功能太复杂就拆分，每个部分保持独立 O 开放封闭原则 对扩展开放 对修改封闭 增加需求时 扩展新代码 而非修改已有的代码 L 李氏置换原则 子类能覆盖父类 父类能出现的地方子类就能出现 I 接口独立原则 保持接口的单一独立 避免出现胖接口 D 依赖导致原则 面向接口编程，依赖于抽象而不依赖于具体 使用方只关注接口 而不关注具体类的实现 为什么使用面向对像 面向对象 – 数据结构化 对于计算机 结构化才是简单的 编程 应该简单抽象 UML 类图 即统一建模语言 箭头表示依赖关系， 指向谁即依赖谁 泛化 即继承 空心箭头 由子类指向父类 关联 即引用 实心箭头 由引用者指向被引用者 类图 即一个表格 三行格子 第一格为类 构造函数 第二行为 属性：类型 第三行为 方法：返回值 23种设计模式总览 创建型 工厂模式 单例模式 原型模式 结构型 适配器模式 装饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 行为型 策略模式 模板方法模式 观察者模式 迭代器模式 职责链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式 面试题之弟弟打车12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Car 普通车 class Car &#123; constructor (name, number) &#123; this.name = name this.number = number &#125;&#125;// 慢车class SlowCar extends Car &#123; constructor(name, number) &#123; super(name, number) this.price = 1 &#125;&#125;// 快车class FastCar extends Car &#123; constructor(name, number) &#123; super(name, number) this.price = 2 &#125;&#125;// 旅途行程 （假定行程为5公里）class Trip &#123; constructor(car) &#123; this.car = car &#125; start () &#123; console.log(`行程开始，名称：$&#123;this.car.name&#125;,车牌号：$&#123;this.car.number&#125;`) &#125; end () &#123; console.log(`行程结束，一共$&#123;this.car.price * 5&#125;元`) &#125;&#125;//测试let car = new FastCar(&apos;兰博基尼&apos;, 18)let trip = new Trip(car)trip.start() //行程开始，名称：兰博基尼,车牌号：18trip.end() //行程结束，一共10元 面试题之停车场 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124// 车class Car &#123; constructor (num) &#123; this.num = num &#125;&#125;// 摄像头class Camera &#123; shot (car) &#123;//拍摄 return &#123; num: car.num, inTime: Date.now() &#125; &#125;&#125;// 出口显示屏class Screen &#123; show (car, inTime) &#123; console.log(`车牌号：$&#123;car.num&#125;`) console.log(`停车时间：$&#123;Date.now() - inTime&#125;`) &#125;&#125;// 停车场class Park &#123; constructor (floors) &#123; this.floors = floors || [] this.camera = new Camera() this.screen = new Screen() this.carList = &#123;&#125; // 存储摄像头拍摄的车辆信息 &#125; in (car) &#123; // 通过摄像头获取信息 const info = this.camera.shot(car) // 停到某个停车位 const i = Number.parseInt(Math.random() * 100 % 100) // 某一层 const j = Number.parseInt(Math.random() * 3) const place = this.floors[j].places[i] place.in() //车已停入某一车位 // 记录信息 info.place = place this.carList[car.num] = info &#125; out (car) &#123; // 获取车辆信息 const info = this.carList[car.num] // 将对应的停车位清空 info.place.out() // 显示时间 this.screen.show(car, info.inTime) // 删除记录 // info = null &#125; emptyNum () &#123; return this.floors.map(floor =&gt; &#123; return `第$&#123;floor.index&#125;层有$&#123;floor.emptyPlaceNum()&#125;个空位` &#125;).join(&apos;\n&apos;) &#125;&#125;// 楼层class Floor &#123; constructor (index, places) &#123; this.index = index this.places = places || [] &#125; emptyPlaceNum () &#123; let num = 0 this.places.forEach(place =&gt; &#123; if (place.empty) &#123; num += 1 &#125; &#125;) return num &#125;&#125;// 车位class Place &#123; constructor () &#123; this.empty = true &#125; in () &#123; this.empty = false &#125; out () &#123; this.empty = true &#125;&#125;// 测试// 初始化停车场const floors = []for (let i = 0; i &lt; 3; i++) &#123; const places = [] for (let j = 0; j &lt; 100; j++) &#123; places[j] = new Place() &#125; floors[i] = new Floor(i + 1, places)&#125;const park = new Park(floors)// 初始化车辆const car1 = new Car(18)const car2 = new Car(22)const car3 = new Car(36)console.log(`$&#123;park.emptyNum()&#125;`)console.log(`第一辆车进入`)park.in(car1)console.log(`$&#123;park.emptyNum()&#125;`)console.log(`第二辆车进入`)park.in(car2)console.log(`$&#123;park.emptyNum()&#125;`)console.log(`第一辆车离开`)park.out(car1)console.log(`$&#123;park.emptyNum()&#125;`)console.log(`第二辆车离开`)park.out(car2)console.log(`$&#123;park.emptyNum()&#125;`) 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-design-mode-oop]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-oop%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;you are my baby. webpack的配置 以支持es6的新语法 npm install webpack webpack-cli –save-dev –registry=https://registry.npm.taobao.org 在package.json中 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack --config ./webpack.dev.config.js --mode development&quot;&#125;即在命令行里面运行npm run dev 即可运行webpack 的配置文件 我们更改了配置文件的默认名字 在这里指定他的配置文件为 ./webpack.dev.config.js 即可 npm install webpack-dev-server html-webpack-plugin –save-dev –registry=https://registry.npm.taobao.org 将package.json中的webpack 改为webpack-dev-server 即为开启一个运行本地服务器 babel的es6语法插件解析 npm install –save-dev babel-loader @babel/core @babel/preset-env –registry=https://registry.npm.taobao.org npm install –save-dev @babel/polyfill @babel/plugin-transform-runtime –registry=https://registry.npm.taobao.org class 类 即模板 封装 继承 多态 123456789101112131415//创建类（构造函数）class Person &#123; constructor (name) &#123; //属性 特征 this.name = name &#125; getName () &#123; //方法 函数 return this.name &#125;&#125;//创建对象（实例）let p = new Person(&apos;shulu&apos;)alert(p.getName()) es6面向对象之继承123456789101112131415161718192021222324252627282930// 父类class Person &#123; constructor (name, age) &#123; this.name = name, this.age = age &#125; getName () &#123; return `my name is $&#123;this.name&#125;` &#125; getAge () &#123; return `my age is $&#123;this.age&#125;` &#125;&#125;// 子类 // 继承父类的属性、方法 并添加自己的属性和方法class Student extends Person &#123; constructor (name, age, number) &#123; super(name, age) this.number = number &#125; study () &#123; return `my number is $&#123;this.number&#125;, and i am studying` &#125;&#125;let s = new Student(&apos;shulu&apos;, 18, 23)alert(s.getName())alert(s.getAge())alert(s.study()) es6面向对象之封装 public 完全开放 protected 对子类开放 private 对自己开发 es6 尚不支持， 用typescript来演示trpescript网站测试代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 父类class Person &#123; name //公开的属性 age protected weight //受保护的属性，只有自己和子类可以访问，实例对象可以访问 constructor (name, age) &#123; this.name = name, this.age = age, this.weight = &apos;120&apos; &#125; getName () &#123; return `my name is $&#123;this.name&#125;` &#125; getAge () &#123; return `my age is $&#123;this.age&#125;` &#125; &#125;// 子类 // 继承父类的属性、方法 并添加自己的属性和方法class Student extends Person &#123; number //公开的属性 private boyfriend //自己的私有的属性，只有自己才可以访问，自己的实例都不能用 constructor (name, age, number) &#123; super(name, age) this.number = number this.boyfriend = &apos;lqy&apos; &#125; study () &#123; return `my 学号 is $&#123;this.number&#125;, and i am studying` &#125; getBoyfriend () &#123; return `my boyfriend is $&#123;this.boyfriend&#125;` &#125; getWeight () &#123; return `my weight is $&#123;this.weight&#125;` &#125;&#125;let s = new Student(&apos;shulu&apos;, 18, 23)alert(s.getWeight()) //可以正常访问alert(s.boyfriend()) //报错 girlfriend只能在Student 里面自己使用 es6面向对象之多态 多个子类可以继承一个父类，并扩展自己的方法 1234567891011121314151617181920212223242526272829303132333435363738// 父类class Person &#123; constructor (name) &#123; this.name = name &#125; getName () &#123; return `my name is $&#123;this.name&#125;` &#125;&#125;// 子类A class StudentA extends Person &#123; constructor (name, number) &#123; super(name) this.number = number &#125; study () &#123; return `my 学号 is $&#123;this.number&#125;, and i am studying` &#125;&#125;// 子类Bclass StudentB extends Person &#123; constructor (name, number) &#123; super(name) this.number = number &#125; study () &#123; return `my 学号 is $&#123;this.number&#125;, and i am studying` &#125;&#125;let s1 = new StudentA(&apos;shulu&apos;, 18)let s2 = new StudentB(&apos;lqy&apos;, 19)alert(s1.getName())alert(s1.study())alert(s2.getName())alert(s2.study()) 面向对像实现jQuery的例子1234567891011121314151617181920212223242526272829class jQuery &#123; constructor (selector) &#123; let dom = Array.from(document.querySelectorAll(selector)) let len = dom ? dom.length : 0 dom.forEach((item, index) =&gt; &#123; this[index] = item &#125;) this.len = len this.selector = selector || &apos;&apos; &#125; append (node) &#123; &#125; addClass (className) &#123; &#125; html (data) &#123; &#125; // 好多的方法……&#125;window.$ = function (selector) &#123; return new jQuery(selector)&#125;let $p = $(&apos;p&apos;) // p 标签选择器console.log($p)console.log($p.addClass) 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[responsive-sites]]></title>
    <url>%2Fresponsive-sites%2Fresponsive-sites%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;梦终有你。 视口 布局视口 就像一本书 大小固定 如960px 是设计图纸的大小 可视视口 就像放大镜 在它上面可以移动缩放 是设备屏幕的大小 在这两种视口下，用户需要通过滑动缩放来查看整个页面的不同部分。 理想视口 为了解决以上的问题而制定的视口。是布局视口在一个设备上的最佳尺寸。即让布局视口等于可视视口。 大牛博客视口相关说明 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;/&gt; 爬虫协议robots.txt 把“robots.txt”放在你网站的根目录，并确保他能让访问者（如搜索引擎）访问到。 Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”，网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。 1234User-agent: *Disallow: /admin/Sitemap: https://shulu520.com/sitemap.xmlSitemap: https://shulu520.com/sitemap.hxml 关于humans.txthumans.txt官网 这是什么？ 这是一个TXT文件，其中包含参加该网页设计和建立的人们的信息。 为什么是一个TXT？ 这是因为TXT是一种快速和容易建立的档案格式，而且不是一种有侵扰性的格式。 很多时候业主并不希望作者在为他设计的网站签名，以为这样会降低其功能。 以我们这种方式可以从外部快速便利、经济实惠的显示证明网站作者（不是指网站的主人）。 humans.txt官网格式 12345/* TEAM *//* THANKS *//* SITE */ 项目目录的一些有用的文件 robots.txt humans.txt .editorConfig(编辑器风格配置) .gitignore LICENSE.txt(版权声明，协议是否开源) README.md(项目简介 使用方式 相关链接) CHANGLOG(说明版本更新相关) html页面重要内容 以前没有注意到的细节知识做一总结。 1234567891011121314151617181920网站内的语言为汉语，参考自淘宝网。&lt;html lang=&apos;zh-CN&apos;&gt;&lt;/html&gt;这意味着，会强制浏览器按照最新的标准去渲染。添加”chrome=1“将允许站点在使用了谷歌浏览器内嵌框架（Chrome Frame）的客户端渲染，对于没有使用的，则没有任何影响。&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;/&gt;告诉浏览器启用理想视口来展示页面。不允许用户进行缩放。&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=0&quot; /&gt;条件注释：在body标签下争对IE低版本浏览器的更新提示信息： &lt;!--[if lt IE 8]&gt; &lt;style&gt;html,body&#123;overflow:hidden;height:100%&#125;&lt;/style&gt; &lt;div&gt; &lt;p&gt;您的浏览器版本老的可笑，请到点击下面任一链接更新，以获取最佳的浏览体验。&lt;/p&gt; &lt;a href=&quot;https://www.google.cn/intl/zh-CN/chrome/browser/desktop/&quot; &quot; target=&quot;_blank&quot;&gt;谷歌 Chrome&lt;/a&gt; &lt;a href=&quot;http://www.uc.cn/ucbrowser/download/&quot; target=&quot;_blank&quot;&gt;UC 浏览器&lt;/a&gt;&quot; &lt;a href=&quot;http://browsehappy.com&quot;&gt;各大浏览器更新网站(外网) &lt;/div&gt; &lt;![endif]--&gt; logo 说明 像logo这样重要的图片最好以img标签的形式嵌入页面。 其他的不太重要的图片可以考虑background的形式引入。 样式重置 传统css样式重置resets.css 性能不佳 H5标准的样式重置 GitHub 3万多star npm install normalize.css css单位 px 1px=1像素 em 相对长度单位 em的相对参照物为 父元素的font-size值 em 具有继承的特点 当没有设值时，浏览器的默认em 1em=16px em的缺点 容易错乱 rem 相对长度单位 参照物为HTML根元素 其固定不变 计算简单 没有设值时，浏览器的默认值 1rem=16px 设置 font-size: 62.5% 那么 1rem = 10px css3 的一些样式 文本选中后的样式设置 1234::selection &#123; background-color: pink; text-shadow: none&#125; calc的使用例子 width: calc(33.33333333% - 2rem) css3 box-sizing属性 border-box，border和padding计算入width之内，其实就是怪异模式了 box-sizing: border-box box-sizing:border-box; 将正常的width height的作用范围延申至border的地方。 也就是说，对元素指定宽度和高度包括了 padding 和 border 。 正常的元素宽高给定后，增加padding border他们会往外面阔展大小。 加了这个属性后，再增加padding border 此时元素内容区会向里面缩进。 清除浮动 当元素设置float浮动后，该元素就会脱离文档流并向左/向右浮动，直到碰到父元素或者另一个浮动元素，浮动元素会造成父元素高度塌陷，所以当我们设置float后，需进行相应的清除浮动操作。 清除浮动的原理 触发BFC BFC 块级格式化上下文 一个HTML元素要创建BFC，则满足下列的任意一个或多个条件即可： 1.float的值不是none。2.position的值不是static或者relative。3.display的值是inline-block、table-cell、flex、table-caption或者inline-flex4.overflow的值不是visible BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列 清除浮动方式一 使用额外的标签clear:both 原理：在浮动元素下面添加一个空标签，在这个标签中设置clear：both； 优点：简单，浏览器兼容性好； 缺点：增加页面的标签，造成页面混乱； 方式二 使用overflow属性 原理：父元素定义overflow:hidden，此时，浏览器会自动检查浮动区域的高度； 优点：简单，无需增加新的标签； 缺点：不能和position配合使用，因为超出的尺寸的会被隐藏 方式三 使用伪元素:after清除浮动 原理：原理同方法一有点类似，在元素最后定义一个空的内容，然后让该空的内容来清除浮动； 优点：无需额外的标签，浏览器兼容性好，是目前用的最多的一种清除浮动的方法之一； 缺点：代码稍微复杂点，初学者可能不太能理解其原理； 方式四 推荐 老外大师推荐 12345.clearfix:before,.clearfix:after&#123; content: &apos; &apos;; display: table;&#125; line-height 注意事项 在使用rem 的单位设置时会有点问题 建议使用px的单位 diaplay: inline-block 注意事项 将元素设置为inline-block即行内块元素 多个inline-block元素会排列为一行 对外显示为行内元素 对内为块级元素的特性 带来的问题： 各个元素间会出现一条小缝隙 即是元素间的空白字符 两个标签之间看不见的东西 解决方法： 将元素排列为一行 或去掉元素后面的闭合标签 将闭合标签放到下一个标签的开头部分 还有好多种方法 雪碧图的使用 CSS雪碧 即CSS Sprite，也有人叫它CSS精灵，是一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分 CSS雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。该图片使用CSS background和background-position属性渲染。 省略号的设置12345.box&#123; text-overflow: ellipsis; overflow: hidden; white-space: nowrap;&#125; 有事您Q我👇]]></content>
      <categories>
        <category>responsive-sites</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express]]></title>
    <url>%2Fexpress%2Fexpress%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 有事您Q我👇]]></content>
      <categories>
        <category>express</category>
      </categories>
      <tags>
        <tag>zhuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie-js]]></title>
    <url>%2Fcookie%2Fcookie-js%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 转载 原文链接运用JS设置cookie、读取cookie、删除cookieJavaScript是运行在客户端的脚本，因此一般是不能够设置Session的，因为Session是运行在服务器端的。 而cookie是运行在客户端的，所以可以用JS来设置cookie. 假设有这样一种情况，在某个用例流程中，由A页面跳至B页面，若在A页面中采用JS用变量temp保存了某一变量的值，在B页面的时候，同样需要使用JS来引用temp的变量值，对于JS中的全局变量或者静态变量的生命周期是有限的，当发生页面跳转或者页面关闭的时候，这些变量的值会重新载入，即没有达到保存的效果。解决这个问题的最好的方案是采用cookie来保存该变量的值，那么如何来设置和读取cookie呢？ 首先需要稍微了解一下cookie的结构，简单地说：cookie是以键值对的形式保存的，即key=value的格式。各个cookie之间一般是以“;”分隔。 JS设置cookie: 假设在A页面中要保存变量username的值(“jack”)到cookie中,key值为name，则相应的JS代码为： document.cookie=”name=”+username; JS读取cookie: 假设cookie中存储的内容为：name=jack;password=123 则在B页面中获取变量username的值的JS代码如下： var username=document.cookie.split(“;”)[0].split(“=”)[1]; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//JS操作cookies方法! //写cookies function setCookie(name, value) &#123; var Days = 30; var exp = new Date(); exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 1000); document.cookie = name + &quot;=&quot; + escape(value) + &quot;;expires=&quot; + exp.toGMTString();&#125;//读取cookiesfunction getCookie(name) &#123; var arr, reg = new RegExp(&quot;(^| )&quot; + name + &quot;=([^;]*)(;|$)&quot;); if ((arr = document.cookie.match(reg))) return unescape(arr[2]); else return null;&#125;//删除cookiesfunction delCookie(name) &#123; var exp = new Date(); exp.setTime(exp.getTime() - 1); var cval = getCookie(name); if (cval != null) document.cookie = name + &quot;=&quot; + cval + &quot;;expires=&quot; + exp.toGMTString();&#125;//使用示例setCookie(&quot;name&quot;, &quot;hayden&quot;);alert(getCookie(&quot;name&quot;));//如果需要设定自定义过期时间//那么把上面的setCookie 函数换成下面两个函数就ok;//程序代码function setCookie(name, value, time) &#123; var strsec = getsec(time); var exp = new Date(); exp.setTime(exp.getTime() + strsec * 1); document.cookie = name + &quot;=&quot; + escape(value) + &quot;;expires=&quot; + exp.toGMTString();&#125;function getsec(str) &#123; alert(str); var str1 = str.substring(1, str.length) * 1; var str2 = str.substring(0, 1); if (str2 == &quot;s&quot;) &#123; return str1 * 1000; &#125; else if (str2 == &quot;h&quot;) &#123; return str1 * 60 * 60 * 1000; &#125; else if (str2 == &quot;d&quot;) &#123; return str1 * 24 * 60 * 60 * 1000; &#125;&#125;//这是有设定过期时间的使用示例：//s20是代表20秒//h是指小时，如12小时则是：h12//d是天数，30天则：d30setCookie(&quot;name&quot;, &quot;hayden&quot;, &quot;s20&quot;); 转载 原文链接 有事您Q我👇]]></content>
      <categories>
        <category>cookie</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[localStorage]]></title>
    <url>%2FlocalStorage%2FlocalStorage%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 本地存贮 把一些信息存储到客户端本地 存储到浏览器指定的地方 实现多页面之间的信息共享 本地存贮种类 (xxx.manifest) 本地缓存 H5中的api localStorage H5中的api 小数据的存储 常用 indexDB / webSQL 本地数据库存储 CacheStroge / ApplicationCache cookie 常用 本地存贮使用场景 页面之间的信息通信 性能优化 本地存储信息的局限性 按照域来管理信息 如访问我的网站 则存储到shulu520.com这个域中 不能跨浏览器共享 不能跨域共享 session cookie 的关联 session 服务器端存储 cookie 客户端存储 在服务器端创建session之后，服务器和当前客户端之间会建立一个唯一的标识(sessionID/sid),当前信息存储在对应的sid之下。 当服务器端把一些成功或失败的结果返回给客户端的时候，在响应头信息中会增加set-cookie(客户端cookie)这样的字段，把connect.sid存储到客户端的cookie中。即在客户端本地种下cookie. 当客户端再向服务器发送任何请求的时候，都会把cookie信息带上，传递给服务器. 服务器端根据sid值进行校验。 localStroge vs cookie cookie 兼容所有浏览器 存储大小限制 一个域下能存储4kb左右数据 有过期时间(可以设置) 杀毒软件或浏览器的垃圾清理都可能会把cookie信息强制清除掉 在隐私或无痕浏览模式下，是不会记录cookie的 cookie不是严格的本地存储，因为要和服务器之间来回传输 localStroge 不兼容ie8 及以下 存储大小限制 一个域下能存储5Mb左右数据 本地永久存储(不手动删除的情况下) 杀毒软件或浏览器的垃圾清理暂时不会清理localStroge的信息(新版本google会清理localStroge的) 在隐私或无痕浏览模式下，是会记录localStroge的 localStroge和服务器之间无半毛钱的关系 cookie的设置 document.cookie = ‘’转载 原文链接 localStroge的使用 常用 localStroge.setItem(key, value) 设置 其中value必须是字符串 localStroge.getItem(key) 获取 localStroge.removeItem(key) 删除 localStroge.clear() 清除当前域下的所有的localStroge信息 有事您Q我👇]]></content>
      <categories>
        <category>localStorage</category>
      </categories>
      <tags>
        <tag>zhuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise-zhuf]]></title>
    <url>%2FPromise%2FPromise-zhuf%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; js执行顺序优先级 scncfunction –&gt; micro task –&gt; macro task 同步代码 scncfunction 微任务 micro task 宏任务 macro task 微任务 micro task Process.nextTick 把当前任务放到主栈的最后执行 Promise(async await) 宏任务 macro task 回调函数 ajax 事件绑定 node 中的 fs 三种定时器 setImmediate (nodejs独有) setTimeout setInterval 123setImmediate (() =&gt; &#123; console.log(&apos;shulu&apos;)&#125;) Promise 三种状态 进行中 成功 失败 Promise.all([promise1, promise2, promise3]).then(() =&gt; {……}).catch(){……} 即promise1,2,3都成功则执行then的成功方法，有一个失败则走catch方法。 es6 class 类 class 的本质是 function。 在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。 它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法 constructor 方法是类的默认方法，创建类的实例化对象时被调用 class 的实例化必须通过 new 关键字。 123456789101112class Promise &#123; //constructor 创建类的实例化对象时被调用 constructor () &#123; &#125; //这里写原型上的方法 then() catch()&#125; 手写Promise实现 有事您Q我👇]]></content>
      <categories>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>zhuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-linux]]></title>
    <url>%2Fgit%2Fgit-linux%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;终有一天，我会出现在你的眼前。 个人本地操作篇 显示目录或文件 ls -s / ls -a -s 文件列表 -a 包括隐藏文件 cd cd / cd ../ 可以直接拖动文件进入目录 创建文件夹 mkdir + shulu 创建空文件 touch + lqy 编辑文件 方式一 vim/vi + lqy A或I 键进入插入模式 编辑完成后 Esc 然后:wq 即可保存退出 方式二 向指定的文件输入内容 echo xxx &gt; shulu.txt shulu.txt若不存在则创建 每次编辑都会覆盖之前的内容 查看文件中的内容 cat lqy 删除文件或文件夹 一旦删除 不可恢复 rm + name -rf -r 递归删除 -f 强制删除 -rf 以上二者都有 git status 查看当前文件处于哪一个区域 红色：在工作区 绿色：在暂存区 看不见：已经提交到历史区，三区保持一致了 暂存区删除文件操作 只要新add一下新的内容 即可覆盖前面暂存区不好的代码 根据提示： (use “git reset HEAD …” to unstage) 即git reset HEAD &lt;要删除的file&gt; 或git rm –cached &lt;要删除的file&gt; 代码回滚 一 暂存区回滚 一步回滚操作 将暂存区文件撤回来覆盖工作区新写的不好的代码 git checkout &lt;要撤回的file&gt; (注意 . 表示所有的文件) 暂存区的文件依然在，只是将其拿出来覆盖新写的不好的代码 工作区和暂存区 状态保持一致了 两步回滚操作 git reset HEAD &lt;要删除的file&gt; 把当前暂存区的内容删掉，此时暂存区的内容为上一次add的内容 git checkout 将上一次add的内容拿回来覆盖工作区的不好的代码 代码回滚 二 历史版本回滚 git log 版本信息 若出现了 提交的信息最后有一个end 按Q键即可退出 git reset –hard &lt;版本id&gt; 三区保持一致了 .gitignore文件 添加不用git管理的文件 ctrl + L 清屏 团队协作篇 创建远程仓库 最好创建一个README.md文件 这样远程就会有一个master的分支 有利于后续的操作 创建本地仓库初始化本地仓库连接远程仓库这操作不常用 mkdir repository git init git remote add origin git@github.com:lqyasl/git-zhuf.git git clone 常用 一步操作等于以上三步操作 git clone git@github.com:lqyasl/git-zhuf.git 不同开发者之间的配合 假设有a b 两个开发者不冲突的情况 a b 两人提交修改的是不同的文件 提交之前最好git pull origin master 拉取远程仓库的内容 然后再git push origin master 推送到远程产生冲突的情况 两人同时对相同的文件都做了不一样的修改 解决冲突 若直接弹出vim的内容 正常退出即可 即 输入a 然后按Esc 再按 :wq 若显示MERGEING 则删掉那些特殊符号 ，修改好后退出 无分支开发模式 即只有一个master 分支分支开发模式 新开一个分支即可 git checkout -b deva 即可创建一个deva分支 并且切换到这个分支上 新创建分支的特点：本地master内容会自动同步到deva分支上 在deva分支上完事后 git add . git commit -m ‘……’ git stash 保存当前的工作进度。会分别对暂存区和工作区的状态进行保存 关于这一步操作后面有说明 git checkout master git merge deva git pull origin master git push origin master git stash &amp; git stash pop git stash 保存当前的工作进度。会分别对暂存区和工作区的状态进行保存. git stash pop 恢复工作现场。 软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。 当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交。 并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？ 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来(先git add . 到暂存区 然后 git stash 藏起来)，等以后回来恢复现场后继续工作。 总结： 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除bug分支； 当手头工作没有完成时，先把工作现场git stash一下，然后去bug分支修复bug，修复后，再回到之前的分支git stash pop，将工作现场恢复。 有事您Q我👇]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>zhuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-mooc]]></title>
    <url>%2Fwebpack%2Fwebpack-mooc%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;只要有想见的人，就不是孤身一人。 开始 node 安装 webpack 安装 初始化文件夹 npm init 打包符合node规范的项目 或 npm init -y 生成默认初始化的文件夹 全局安装webpack 不推荐 因为各个项目依赖的webpack版本可能不一样 npm uninstall webpack webpack-cli -g 卸载webpack npm install webpack webpack-cli -D 推荐在项目中独立安装 npm info webpack 打印输出webpack的信息 可以查看你想要的版本是否存在 安装你所需要的版本就行了 npm i webpack@版本号 webpack-cli -D webpack 默认的打包配置文件为webpack.config.js 开始配置 webpack.config.js初步配置 新建webpack.config.js文件 新建src目录 放我们的源代码 webpack.config.js配置如下： 123456789101112//nodejs引入path模块 为commonjs规范const path = require(&apos;path&apos;)module.exports = &#123; mode: development, // 指定运行环境 entry: &apos;./src/index.js&apos;, // 入口文件 output: &#123; // 出口文件 //被编译到你指定的输出路径的文件夹中 path: path.resolve(_dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; //指定打包生成的文件名字 &#125;&#125; package.json 配置scripts命令 简化命打包令为 npm run bundle 12345&#123; &quot;scripts&quot;: &#123; &quot;bundle&quot;: &quot;webpack&quot; //npm run bundle 执行webpack命令 &#125;,&#125; 不同安装的webpack打包形式 未配置scriptsnpx webpack 要打包的文件 配置scripts后npm run bundle 即可 配置打包图片 loader 所谓 loader 只是一个导出为函数的 JavaScript 模块。让 webpack 能够去处理那些非 JavaScript 文件 (webpack 自身只理解 JavaScript) loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块， 然后你就可以利用 webpack 的打包能力，对它们进行处理。 12345678910111213141516171819202122232425const path = require(&apos;path&apos;)module.exports = &#123; mode: &apos;development&apos;, entry: &#123; main: &apos;./src/index.js&apos; &#125;, module: &#123; rules: [&#123; test: /\.(jpg|png|gif)$/,//用于标识出应该被对应的 loader 进行转换的某个或某些文件。 use: &#123;//表示进行转换时，应该使用哪个 loader。 loader: &apos;url-loader&apos;, // loader: &apos;file-loader&apos;, options: &#123; //配置项 name: &apos;[name].[ext]&apos;,//以原来的名字和后缀打包生成文件名 outputPath: &apos;images/&apos;,//打包生成的文件放到dist/images/ limit: 2048 //当图片的大小在2kb以下时直接打包成base64的图片嵌入js文件中 &#125; &#125; &#125;] &#125;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;&#125; 样式loader css-loader 处理各个css文件间的关系 style-loader 将增加一个style标签并插入css文件然后挂载到head标签中 处理sass文件 npm install sass-loader node-sass -D loader 的执行顺序 从下到上 从右到左 处理less文件 首先npm install less –save-dev 再npm i -D less-loader 123456789101112module: &#123; rules: [&#123; test: /\.scss$/, use: [&#123; loader: &quot;style-loader&quot; // 将 JS 字符串生成为 style 节点 &#125;, &#123; loader: &quot;css-loader&quot; // 将 CSS 转化成 CommonJS 模块 &#125;, &#123; loader: &quot;sass-loader&quot; // 将 Sass 编译成 CSS &#125;] &#125;]&#125; 自动添加前缀loader 使用Can I Use中的值为CSS规则添加供应商前缀。 Autoprefixer将使用基于当前浏览器流行度和属性支持的数据为您应用前缀。 npm i -D postcss-loader npm i -D autoprefixer 123456//配置新建postcss.config.jsmodule.exports = &#123; plugins: [ require(&apos;autoprefixer&apos;) ]&#125; 123456789//然后配置webpack.config.js&#123; test: /\.css$/, use: [ &apos;style-loader&apos;, &#123; loader: &apos;css-loader&apos;, options: &#123; importLoaders: 1 &#125; &#125;, &apos;postcss-loader&apos; ]&#125; css-loader 常用的配置 当less(sass)等文件中再引入其他的less(sass)文件时，默认是不会打包引入的文件的， 配置opations 中 importLoaders: 2 后，则会通过’less-loader’, ‘postcss-loader’ 这两个loader的打包 { loader: ‘css-loader’, options: { importLoaders: 2, modules: true //模块化 }},‘less-loader’,‘postcss-loader’ css 打包的模块化 模块中需要哪个样式文件 引入即可import style from ‘./avator.less’ 使用:如 img.classList.add(style.avator) 在avator.less样式中自己写的叫avator的classname 123options: &#123; modules: true //开启css模块化&#125; 字体的引入iconfont file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录。 这就是说，我们可以将它们用于任何类型的文件，包括字体。 src/font一般需要 中如下几种正则中的字体文件 iconfont.css文件，在需要字体的地方引入样式即可 src: url(‘./font/iconfont.eot?t=155948’) url(‘./font/iconfont.ttf?t=155948’) 其中./font为自己加的路劲 其中有个base64格式的路劲不用变 1234test: /\.(woff|woff2|eot|ttf|svg)$/,use: [ &apos;file-loader&apos;] plugin 插件的使用 html-webpack-plugin插件的使用 npm install –save-dev html-webpack-plugin HtmlWebpackPlugin 插件的作用： 会在打包结束后自动生成一个html文件，并把打包生成的js文件自动引入html文件 plugin的作用：在webpack运行到某个时刻的时候，帮我门做一些在事情 就像vue中的生命周期钩子函数 12345678//webpack.config.js中plugins: [ new HtmlWebpackPlugin(&#123; title: &quot;my html template&quot;, //自定义title 默认为webpack app filename: &quot;myindex.html&quot;, //自定义文件名 默认为index.html template: &quot;src/index.html&quot; //以此为模板创建html &#125;)] clean-webpack-plugin 清除旧的打包的文件 1var &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;) 123plugins: [ new CleanWebpackPlugin(),//打包前删除前面旧的dist文件] entry1234entry: &#123; main: &apos;./src/index.js&apos;, sub: &apos;./src/index.js&apos; //再打包生成一个js文件&#125;, output12345output: &#123; publicPath: &apos;https://cdn.abc.com&apos;,//公共前缀路劲如cdn filename: &apos;[name].js&apos;, //以entry的key值作为打包生成的文件名 path: path.resolve(__dirname, &apos;dist&apos;)&#125;, SourceMap 再打包生成main.js文件之后如果代码里出现错误，它会将main.js中错误出现的地方与源码之间做一映射，告诉我们源码中错误出现在哪里，以便我们快速定位bug出处 错误代码使用chrome调试工具直接显示在index.js?b635这个文件打开即可看到源码里面错误出现的位置 123devtool: &apos;cheap-module-eval-source-map&apos;,//development模式推荐使用devtool: &apos;cheap-module-source-map&apos;,//production模式推荐使用 使用WebpackDevServer提升开发效率 npm install webpack-dev-server -D 在webpack.config.js 12345678910111213devServer: &#123; contentBase: &apos;./dist&apos;,//开启一个服务器运行dist里面的内容 open: true ,//自动在浏览器里打开 /* //vue中就是配置的这样的代理 proxy: &#123; &apos;/api&apos;: &apos;http://localhost:3000&apos;//当用户访问api这个地址时proxy将其转到localhost:3000这个地址 &#125;, */ port: 8888//必要时可以自定义端口&#125;, 在 package.json 123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server&quot; //npm run start 开启服务器 自动刷新 目前最常用的 打包生成的dist文件直接放到内存里运行 速度更快&#125;, HotModuleReplacementPlugin 热模块更新1234567891011121314var webpack = require(&apos;webpack&apos;)//配置devServer: &#123; contentBase: &apos;./dist&apos;, open: true, hot: true, //代码更新时只会更新最新变化的部分 不会全部刷新一遍 hotOnly: true&#125;, //配置plugins: [ new webpack.HotModuleReplacementPlugin()] 使用 Babel 处理 ES6 语法1npm install --save-dev babel-loader babel-core babel-preset-env 123456&#123; test: /\.js$/, include: &apos;../src&apos; , // 指定匹配文件的范围 exclude: /node_modules/, loader: &apos;babel-loader&apos;&#125; Tree Shaking 概念详解 把一个模块里面的没有用到的方法摇晃掉 去掉 不打包 如果对一些文件不使用此功能 则配置 package.json 添加 配置 “sideEffects”: [‘不使用此功能的文件’] .babelrc文件配置如下 123456789101112&#123; &quot;presets&quot;: [ [ &quot;env&quot; ,&#123; &quot;targets&quot;: &#123; &quot;chrome&quot;: &quot;67&quot;, &#125;, &quot;useBuiltIns&quot;: &quot;usage&quot; &#125; ] ]&#125; Develoment 和 Production 模式的区分打包 新建webpack.dev.js 开发环境 新建webpack.common.js 公共代码 新建webpack.prod.js 生产环境 详见简书配置 Webpack 和 Code Splitting 代码分割 将外来库的方法与业务逻辑代码分开打包 SplitChunksPlugin 配置参数详解 weback.common.js 1234567891011121314151617181920212223242526optimization: &#123;//优化 splitChunks: &#123; chunks: &apos;all&apos;,//同步异步代码都分割 minSize: 30000,//30kb 分割的最小限度配合cacheGroups //maxSize: 50000,//不常用 minChunks: 1,//当一个模块至少被使用了多少次的时候才代码分割 maxAsyncRequests: 5,//假设有多个库要进行分割，但这里只做分割5个 maxInitialRequests: 3,//不用修改 默认就行了 automaticNameDelimiter: &apos;~&apos;,//组和文件之间的连接符 name: true, cacheGroups: &#123;//缓存组 vendors: &#123; test: /[\\/]node_modules[\\/]/,//在node_modules里面匹配 priority: -10,//优先级和default的优先级作比较， // 若这里的高那么就将符合上面要求的文件打包放到vender组 //filename: &apos;vender.js&apos; &#125;, default: &#123; // minChunks: 2, priority: -20, reuseExistingChunk: true ,//入一个文件已经在之前的步骤中打包过了，那这里就不用再打包了 filename: &apos;common.js&apos; &#125; &#125; &#125;&#125;, Lazy Loading 和 chunk 是什么 懒加载 即当时机成熟的时候再加载代码 promise 必须要有catch() 捕获错误 chunk表示一个文件，默认情况下webpack的输入是一个入口entry文件，输出output也是一个文件，这个文件就是一个chunk，chunkId就是产出时给每个文件一个唯一标识id，chunkhash就是文件内容的md5值，name就是在entry中指定的key值。 123//安装插件npm install --save-dev @babel/plugin-syntax-dynamic-import 12345678910111213141516//src/index.jsasync function getComponent () &#123; const &#123; default: _ &#125; = await import(&apos;lodash&apos;)//异步按需引入lodash函数库 var dom = document.createElement(&apos;div&apos;) dom.innerHTML = _.join([&apos;hello&apos;, &apos;shulu&apos;, &apos;lqy&apos;, &apos;love&apos;, &apos;you&apos;], &apos;^_^&apos;) return dom&#125;document.addEventListener(&apos;click&apos;, () =&gt; &#123; getComponent().then((dom) =&gt; &#123; document.body.appendChild(dom) &#125;).catch((err) =&gt; &#123; console.log(err) &#125;)&#125;) 123456789101112131415//.babelrc&#123; &quot;presets&quot;: [ [ &quot;env&quot; ,&#123; &quot;targets&quot;: &#123; &quot;chrome&quot;: &quot;67&quot;, &#125;, &quot;useBuiltIns&quot;: &quot;usage&quot; &#125; ] ], &quot;plugins&quot;: [&quot;@babel/plugin-syntax-dynamic-import&quot;,]//配置插件&#125; 123456//事实上webpack.common.js的配置如下即可optimization: &#123; splitChunks: &#123; chunks: &apos;all&apos;//同步异步代码都分割 &#125;&#125;, css 模块的分割打包 目前不支持模块热跟新 故在生产环境使用好一些 将webpack.common.js中的css配置文件分别拿到webpack.dev.js 和webpack.prod.js 12345678extract-text-webpack-plugin还不能支持webpack4.0.0以上的版本。 解决办法： npm install -–save-dev extract-text-webpack-plugin@next 会下载到+ extract-text-webpack-plugin@4.0.0-beta.0 然后打包就正常了//npm install --save-dev extract-text-webpack-pluginnpm install --save-dev extract-text-webpack-plugin@next 1234567891011121314151617181920212223242526//webpack.prod.jsconst ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;)//配置module: &#123; rules: [ &#123; test: /\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: [&apos;css-loader&apos;, &apos;postcss-loader&apos;] &#125;) &#125;, &#123; test: /\.less$/, use: ExtractTextPlugin.extract(&#123; fallback: &apos;style-loader&apos;, //如果需要，可以在 sass-loader 之前将 resolve-url-loader 链接进来 use: [&apos;css-loader&apos;, &apos;less-loader&apos;, &apos;postcss-loader&apos;] &#125;) &#125; ]&#125;,plugins: [ new ExtractTextPlugin(&quot;styles.css&quot;),] 12345//package.json 对css文件不使用tree shaking&quot;sideEffects&quot;: [ &quot;*.css&quot;], 12345678//webpack.common.jsoptimization: &#123; usedExports: true, //模块中只引入使用了的方法(函数) splitChunks: &#123; chunks: &apos;all&apos; &#125;&#125;, 将打包后的css压缩代码 1npm i -S optimize-css-assets-webpack-plugin 1234567//webpack.prod.jsconst OptimizeCSSAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;)optimization: &#123; minimizer: [new OptimizeCSSAssetsPlugin(&#123;&#125;)],&#125;, webpack Library库webpack PWA 的打包TypeScript 的打包配置WebpackDevServer 请求转发 devServer.proxy的配置 开发环境development 12345678910111213141516devServer: &#123; proxy: &#123;//代理 &quot;/api&quot;: &#123; //将所有对/api的请求转发到http://shulu520.com/test.json target: &quot;http://shulu520.com/test.json&quot;, //在开发中当后端/api还没有做好时，将路劲变为love.json, 做好后，将这里配置注释掉即可，就不用改源码了 pathRewrite: &#123;&quot;^/api&quot; : &quot;love.json&quot;&#125;, //默认不支持https的 配置后即可支持 secure: false //如果希望代理多个特定路径到同一个目标，可以这样使用 context: [&quot;/auth&quot;, &quot;/api&quot;], &#125;&#125; webpack 打包优化 跟上技术的迭代 工具的更新 在尽可能少的模块上应用loader 约束loader的应用范围 123456&#123; test: /\.js$/, include: path.resolve(__diename, &apos;./src&apos;) exclude: /node_modules/, loader: &apos;babel-loader&apos;&#125; 尽可能少的使用plugin 并确保可靠 官网的推荐 resolve 配置项 参数的合理配置 123456//webpack.common.jsresole: &#123; alias: &#123;// 别名 简化长路劲 Child: path.resolve(__dirname, &apos;./src/a/b/c/Child&apos;) &#125;&#125; 自己编写 Loader 实现代码的装饰 loader 是转译模块源代码的转换规则。 loader 被编写为，接受源代码作为参数的函数， 并返回这些转换过的新版本代码. 手写 pluginbundler 源码编写 (模块分析) 有事您Q我👇]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-advance-four]]></title>
    <url>%2Fjs-advance%2Fjs-advance-four%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这世界为何有那么可爱的人儿，儿童节快乐哦 线程与进程 进程: 程序的一次执行, 它占有一片独有的内存空间 可以通过windows任务管理器查看进程 线程: 是进程内的一个独立执行单元 是程序执行的一个完整流程 是CPU的最小的调度单元 关系 一个进程至少有一个线程(主) 程序是在某个进程中的某个线程执行的 应用程序必须运行在某个进程的某个线程上 一个进程中至少有一个运行的线程: 主线程, 进程启动后自动创建 一个进程内的数据可以供其中的多个线程直接共享 多个进程之间的数据是不能直接共享的 线程池(thread pool): 保存多个线程对象的容器, 实现线程对象的反复利用 何为多进程与多线程? 多进程运行: 一应用程序可以同时启动多个实例运行 多线程: 在一个进程内, 同时有多个线程运行 比较单线程与多线程? 多线程优点：能有效提升CPU的利用率缺点：创建多线程开销 线程间切换开销 死锁与状态同步问题 单线程优点：顺序编程简单易懂缺点：效率低 JS是单线程还是多线程? js是单线程运行的 但使用H5中的 Web Workers可以多线程运行 浏览器运行是单进程还是多进程? 有的是单进程 firefox 老版IE 有的是多进程 chrome 新版IE 如何查看浏览器是否是多进程运行的呢? 任务管理器 —&gt; 进程 浏览器内核 支撑浏览器运行的最核心的程序 不同的浏览器可能不一样 Chrome, Safari : webkit firefox : Gecko IE: Trident 360,搜狗等国内浏览器: Trident + webkit 浏览器内核模块组成 主线程 js引擎模块 : 负责js程序的编译与运行 html,css文档解析模块 : 负责页面文本的解析 DOM/CSS模块 : 负责dom/css在内存中的相关处理 布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象) 分线程 定时器模块 : 负责定时器的管理 DOM事件模块 : 负责事件的管理 网络请求模块 : 负责Ajax请求 js线程 js是单线程执行的(回调函数也是在主线程) H5提出了实现多线程的方案: Web Workers 只能是主线程更新界面 定时器问题: 定时器并不真正完全定时 如果在主线程执行了一个长时间的操作, 可能导致延时才处理 事件处理机制(图) 代码分类 初始化执行代码: 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码 回调执行代码: 处理回调逻辑 js引擎执行代码的基本流程: 初始化代码===&gt;回调代码 模型的2个重要组成部分: 事件管理模块 回调队列 模型的运转流程 执行初始化代码, 将事件回调函数交给对应模块管理 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行 H5 Web Workers 可以让js在分线程执行 Worker 计算斐波那契数列的例子 12345678910//在主线程 创建一个Worker实例对象 var worker = new Worker(&apos;worker.js&apos;) // 其中worker.js为worker文件路劲 // 绑定接收消息的监听 worker.onmessage = function (event) &#123; //通信的数据都在event.data里面 alert(event.data) &#125; // 向分线程发送消息 worker.postMessage(number) 123456789101112// 在分线程 斐波那契数列function fibonacci(n) &#123; //递归调用 return n&lt;=2 ? 1 : fibonacci(n-1) + fibonacci(n-2) &#125;this.onmessage = function (event) &#123; var number = event.data console.log(&apos;分线程接收到主线程发送的数据: &apos;+number) var result = fibonacci(number)//计算斐波那契数列 postMessage(result)&#125; / 分线程中this不再是window 而是另一个全局对象 其有onmessage,postMessage等方法 故在这里可以直接调用 而不可以直接调用window的方法 如alert() // alert is not defind document 方法 等 可以更新页面的方法都不可以调用 只有主线程才可以跟新界面 / 问题: worker内代码不能操作DOM更新UI 不是每个浏览器都支持这个新特性 不能跨域加载JS 慢一点 数据传输过程 来我QQ撩我哦👇]]></content>
      <categories>
        <category>js-advance</category>
      </categories>
      <tags>
        <tag>guigu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-advance-three]]></title>
    <url>%2Fjs-advance%2Fjs-advance-three%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;想起你，内心充满欢喜O(∩_∩)O 对象的创建模式 Object构造函数模式 套路: 先创建空Object对象, 再动态添加属性/方法 适用场景: 起始时不确定对象内部数据 问题: 语句太多 123var obj = new Object()obj.name = &apos;Tom&apos;obj.setName = function(name)&#123;this.name=name&#125; 对象字面量模式 套路: 使用{}创建对象, 同时指定属性/方法 适用场景: 起始时对象内部数据是确定的 问题: 如果创建多个对象, 有重复代码 1234var obj = &#123; name : &apos;Tom&apos;, setName : function(name)&#123;this.name = name&#125;&#125; 工厂函数模式 套路: 通过工厂函数动态创建对象并返回 适用场景: 需要创建多个对象 问题: 对象没有一个具体的类型, 都是Object类型 即通过instanceof判断得到的都是Object类型 类型不够具体 人和🐶均为同一类型 用的不多 只是比较经典 返回一个对象的函数===&gt;工厂函数 联系真实工厂 12345678910function createPerson(name, age) &#123; var obj = &#123; name: name, age: age, setName: function (name) &#123; this.name = name &#125; &#125; return obj&#125; 构造函数模式 套路: 自定义构造函数, 通过new创建实例对象 适用场景: 需要创建多个类型确定的对象 问题: 每个对象都有相同的数据, 浪费内存 123456function Person(name, age) &#123; this.name = name; this.age = age; this.setName = function(name)&#123;this.name=name;&#125;;&#125;new Person(&apos;tom&apos;, 12); 组合模式 (构造函数+原型) 套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上 适用场景: 需要创建多个类型确定的对象 123456function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.setName = function(name)&#123;this.name=name;&#125;;new Person(&apos;tom&apos;, 12); 继承模式 原型链继承 : 得到方法 12345678function Parent() &#123;&#125;Parent.prototype.test = function()&#123;&#125;;function Child() &#123;&#125;Child.prototype = new Parent(); //子类型的原型指向父类型实例Child.prototype.constructor = Child //修正constructor属性重新指向子构造函数var child = new Child(); //有test() 借用构造函数 : 得到属性(假继承) 1234567function Parent(xxx)&#123;this.xxx = xxx&#125;Parent.prototype.test = function()&#123;&#125;;function Child(xxx,yyy)&#123; Parent.call(this, xxx);//借用构造函数 this.Parent(xxx)&#125;var child = new Child(&apos;a&apos;, &apos;b&apos;); //child.xxx为&apos;a&apos;, 但child没有test() 组合继承 (原型链继承+构造函数) 利用原型链实现对父类型对象的方法继承 利用call()借用父类型构建函数初始化相同属性 12345678910function Parent(xxx)&#123;this.xxx = xxx&#125;Parent.prototype.test = function()&#123;&#125;function Child(xxx,yyy)&#123; Parent.call(this, xxx)//借用构造函数 this.Parent(xxx)&#125;Child.prototype = new Parent() //得到test()Child.prototype.constructor = Child //修正constructor属性var child = new Child(); //child.xxx为&apos;a&apos;, 也有test() new一个对象背后做了些什么? 创建一个空对象 给对象设置proto, 值为构造函数对象的prototype属性值 this.proto = Fn.prototype 执行构造函数体(给对象添加属性/方法) 来我QQ撩我哦👇]]></content>
      <categories>
        <category>js-advance</category>
      </categories>
      <tags>
        <tag>guigu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hotkey-listary]]></title>
    <url>%2Fhotkey%2Fhotkey-listary%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;人生如逆旅，我亦是行人。 listary 最常用的快捷键 alt A 打开listary 双击 ctrl 打开listary bing 必应搜索 bd 百度一下 百度网盘 zh 知乎搜索 ctrl N 向下切换选中的目录 ctrl P 向上切换选中的目录 双击桌面 打开listary选项 在任意文件夹/目录下双击 打开listary选项 可以选命令打开cmd &emsp;&emsp;未完待续…… 来我QQ撩我哦👇]]></content>
      <categories>
        <category>hotkey</category>
      </categories>
      <tags>
        <tag>listary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hotkey-windows]]></title>
    <url>%2Fhotkey%2Fhotkey-windows%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 👉Q我吧 windows 最常用快捷键 ctrl w 关闭当前网页 f2键 ：选中后按f2键即可重命名文件，另一种方法，点一下文件名，稍等，再点一下，即可重命名 f4: 重复上步操作 f5: 刷新桌面 刷新网页 f11: 全屏显示网页 shift : 省略号 shift + 数字6 （表示六个点） …… 书名号 shift + &lt;&gt; (小于大于） 分隔号 单独按 数字1 前面的键 《简 · 爱》 Alt + 单击拖动 为矩形选择 AlT + f4 关闭当前程序 删除 选中后 按delete 永久删除 选中后 shift +delete 截屏 PrtSc 截全屏 Alt +PrtSc 截当前窗口 ctrl alt delete 任务管理器 windows 打开开始菜单 ctrl shift n 新建文件夹 window e 打开文件资源管理器 alt tab 切换窗口 window d 回到桌面 &emsp;&emsp;学到了再来补充😝 👉点这里，进入QQ交流]]></content>
      <categories>
        <category>hotkey</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-advance-two]]></title>
    <url>%2Fjs-advance%2Fjs-advance-two%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;又是元气满满的一天😝,文章链接失效，又好了。有惊无险 来我QQ撩我哦👇 原型与原型链 所有函数都有一个特别的属性: prototype : 显式原型属性 所有实例对象都有一个特别的属性: proto : 隐式原型属性 当然所有函数也都有一个特别的属性： proto : 隐式原型属性 且所有函数的 隐式原型 都一样 都等于Function的显式原型 函数的显式原型指向的对象默认是空Object实例对象(但Object不满足) 123console.log(Fn.prototype instanceof Object) // trueconsole.log(Object.prototype instanceof Object) // falseconsole.log(Function.prototype instanceof Object) // true 所有函数都是Function的实例(包含Function自身) 1console.log(Function.__proto__===Function.prototype) Object的原型对象是原型链尽头 1console.log(Object.prototype.__proto__) // null 1234567891011121314151617// 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)console.log(Date.prototype, typeof Date.prototype)function Fun () &#123;//alt + shift +r(重命名rename)&#125;console.log(Fun.prototype) // 默认指向一个Object空对象(没有我们的属性)// 原型对象中有一个属性constructor, 它指向函数对象console.log(Date.prototype.constructor===Date)console.log(Fun.prototype.constructor===Fun)//给原型对象添加属性(一般是方法) ===&gt;实例对象可以访问Fun.prototype.test = function () &#123; console.log(&apos;test()&apos;)&#125;var fun = new Fun()fun.test() 显式原型与隐式原型的关系 函数的prototype: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象 实例对象的proto: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值 原型对象即为当前实例对象的父对象 原型链 所有的实例对象都有proto属性, 它指向的就是原型对象 这样通过proto属性就形成了一个链的结构—-&gt;原型链 当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找 当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作,如果当前对象中没有此属性, 直接添加此属性并设置其值 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上 面试题1 1234567891011121314function A () &#123; ...&#125;A.prototype.n = 1var b = new A()A.prototype = &#123; n: 2, m: 3&#125;var c = new A()console.log(b.n, b.m, c.n, c.m) // 1 undifind 2 3 面试题2 12345678910111213141516function F ()&#123;&#125; Object.prototype.a = function()&#123; console.log(&apos;a()&apos;)&#125;Function.prototype.b = function()&#123; console.log(&apos;b()&apos;)&#125;var f = new F()f.a()f.b() // 找不到,可以看原型链图进行分析F.a()F.b() instanceof是如何判断的? 表达式: A instanceof B 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false Function是通过new自己产生的实例 123456789101112131415161718/*案例1 */function Foo() &#123; &#125;var f1 = new Foo()console.log(f1 instanceof Foo) // trueconsole.log(f1 instanceof Object) // true/*案例2 */console.log(Object instanceof Function) // trueconsole.log(Object instanceof Object) // trueconsole.log(Function instanceof Function) // trueconsole.log(Function instanceof Object) // truefunction Foo() &#123;&#125;console.log(Object instanceof Foo) // false 执行上下文与执行上下文栈 变量提升与函数提升 变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined) 函数提升: 在函数定义语句之前, 就执行该函数 先执行变量提升, 再执行函数提升 123function a() &#123;&#125;var aconsole.log(typeof a) // &apos;function&apos; 123456789101112var c = 1function c(c) &#123; console.log(c) var c = 3&#125;c(2) // 报错 c is not a function过程解析： var c fun c c = 1 c(2) 理解 执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性 执行上下文栈: 用来管理产生的多个执行上下文 分类: 全局: window 函数: 对程序员来说是透明的 生命周期 全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡 函数 : 调用函数时产生, 函数执行完时死亡 包含哪些属性: 全局 : 用var定义的全局变量 ==&gt;undefined 使用function声明的函数 ===&gt;function this ===&gt;window 函数 用var定义的局部变量 ==&gt;undefined 使用function声明的函数 ===&gt;function this ===&gt; 调用函数的对象, 如果没有指定就是window 形参变量 ===&gt;对应实参值 arguments ===&gt;实参列表的伪数组 执行上下文 创建和初始化的过程 全局执行上下文: 在全局代码执行前最先创建一个全局执行上下文(window) 收集一些全局变量, 并初始化 var定义的全局变量==&gt;undefined, 添加为window的属性 function声明的全局函数==&gt;赋值(fun), 添加为window的方法 this==&gt;赋值(window) 开始执行全局代码 函数执行上下文: 在调用函数时, 在执行函数体之前，先创建一个函数执行上下文对象(虚拟的, 存在于栈中) 收集一些局部变量, 并初始化 形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性 arguments==&gt;赋值(实参列表), 添加为执行上下文的属性 var定义的局部变量==&gt;undefined, 添加为执行上下文的属性 function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法 this==&gt;赋值(调用函数的对象) 开始执行函数体代码 执行上下文栈 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象 在全局执行上下文(window)确定后, 将其添加到栈中(压栈) 在函数执行上下文创建后, 将其添加到栈中(压栈) 在当前函数执行完后,将栈顶的对象移除(出栈) 当所有的代码执行完后, 栈中只剩下window 12345678910var a = 10var bar = function (x) &#123; var b = 5 foo(x + b)&#125;var foo = function (y) &#123; var c = 5 console.log(a + c + y)&#125;bar(10) 产生执行上下文的个数 = (N)函数调用次数 + 1 面试题 整个过程中产生了几个执行上下文? 5 依次输出什么? gb: undefined fb: 1 fb: 2 fb: 3 fe: 3 fe: 2 fe: 1 ge: 1 123456789101112console.log(&apos;gb: &apos;+ i)var i = 1foo(1)function foo(i) &#123; if (i == 4) &#123; return &#125; console.log(&apos;fb:&apos; + i) foo(i + 1) // 递归调用: 在函数内部调用自己 console.log(&apos;fe:&apos; + i)&#125;console.log(&apos;ge: &apos; + i) 作用域与作用域链 理解: 作用域: 一块代码区域, 在编码时就确定了, 不会再变化 作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量 产生作用域的个数 = (N)定义函数的个数 + 1 分类: 全局 函数 js没有块作用域(在ES6之前) 作用 作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突 作用域链: 查找变量 区别作用域与执行上下文 作用域: 静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了 执行上下文: 动态的, 执行代码时动态创建, 当执行结束消失 联系: 执行上下文环境是在对应的作用域中的 面试题 12345678910111213141516var x = 10; function fn() &#123; console.log(x); &#125; function show(f) &#123; var x = 20; f(); &#125; show(fn); // 10 /* 解析：作用域在函数创建的时候就确定了，一旦确定就不会变化了 */ 1234567891011121314151617var fn = function () &#123; console.log(fn) &#125; fn() // fn函数体 var obj = &#123; fn2: function () &#123; console.log(fn2) &#125; &#125; obj.fn2() // fn2 is not defind /* 解析： 首先在fn2函数作用域里面找fn2 没有 然后再全局作用域找 也没有 故报错 若为this.fn2 则可以 */ 作用域链和原型链的用处 作用域链用来找变量 原型链用来找方法 在全局直接找一个不存在的方法 a is not defined 而通过window.a 则为undifind 闭包 如何产生闭包? 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包 闭包到底是什么? 使用chrome调试查看 会调试的程序员至少不是初级程序员 理解一: 闭包是嵌套的内部函数(绝大部分人) 初步认识 理解二: 包含被引用变量(函数)的对象(极少数人) 高级认识 注意: 闭包存在于嵌套的内部函数中 产生闭包的条件 函数嵌套 内部函数引用了外部函数的数据(变量/函数) 产生闭包的个数 等于外部函数调用的次数 12345678910//三个button按钮for (var i = 0,length=btns.length; i &lt; length; i++) &#123; (function (j) &#123; var btn = btns[j] btn.onclick = function () &#123; alert(&apos;第&apos;+(j+1)+&apos;个&apos;) &#125; &#125;)(i) &#125;// 共产生三个闭包 因为外部函数共调用了三次，每一闭包内部都保存了各自的变量 常见的闭包 将函数作为另一个函数的返回值 将函数作为实参传递给另一个函数调用 闭包生命周期 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用) 死亡: 在嵌套的内部函数成为垃圾对象时 12345678910111213function fn1() &#123; //此时闭包就已经产生了(函数提升, 内部函数对象已经创建了) var a = 2 function fn2 () &#123; a++ console.log(a) &#125; return fn2&#125;var f = fn1() //f来接收fn2f() // 3f() // 4f = null //闭包死亡(包含闭包的函数对象成为垃圾对象) 作用: 延长局部变量的生命周期 让函数外部能操作内部的局部变量 写一个闭包程序 1234567891011function fn1() &#123; var a = 2 function fn2() &#123; a++ console.log(a) &#125; return fn2&#125;var f = fn1()f()f() 闭包应用: 模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为 循环遍历加监听 JS框架(jQuery)大量使用了闭包 缺点: 变量占用内存的时间可能会过长 可能导致内存泄露 解决: 及时释放 : f = null; //让内部函数对象成为垃圾对象 面试题1 123456789101112131415161718192021222324//代码片段一var name = &quot;The Window&quot;;var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); // the window//代码片段二var name2 = &quot;The Window&quot;;var object2 = &#123; name2 : &quot;My Object&quot;, getNameFunc : function()&#123; var that = this; return function()&#123; return that.name2; &#125;; &#125;&#125;;alert(object2.getNameFunc()()); // my object 内存溢出与内存泄露 内存溢出 一种程序运行出现的错误 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误 内存泄露 占用的内存没有及时释放 内存泄露积累多了就容易导致内存溢出 常见的内存泄露: 意外的全局变量 没有及时清理的计时器或回调函数 闭包 &gt;👉点这里，进入QQ交流]]></content>
      <categories>
        <category>js-advance</category>
      </categories>
      <tags>
        <tag>guigu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-advance-one]]></title>
    <url>%2Fjs-advance%2Fjs-advance-one%2F</url>
    <content type="text"><![CDATA[能够让你后悔的从来不是你做过的事而是你想做却没有去做的事👉Q我吧 数据类型的分类和判断 基本(值)类型 Number —– 任意数值 ——– typeof String —– 任意字符串 —— typeof Boolean —- true/false —– typeof undefined — undefined —– typeof/=== null ——– null ———- === 对象(引用)类型 Object —– 任意对象 —– typeof/instanceof Array —— 一种特别的对象(数值下标)—– instanceof Function —- 一种特别的对象(可以执行，内部数据是有序的) —– typeof 判断 typeof ——– 返回数据类型的字符串表达 不能判断 null和object ， object和array instanceof —- 判断对象的具体类型 a instanceof b 即a是否是b构造函数的一个实例 === ———— 可以判断 undefined 和 null 名词解释 实例 实例对象 类型 类型对象 即构造函数 undefined与null的区别? undefined代表定义未赋值 nulll定义并赋值了, 只是值为null 什么时候给变量赋值为null呢? 初始赋值, 表明将要赋值为对象 结束前, 让对象成为垃圾对象(被垃圾回收器回收) 严格区别变量类型与数据类型? 数据的类型 基本类型 对象类型 变量的类型(变量内存值的类型) 基本类型: 保存就是基本类型的数据 引用类型: 保存的是地址值 数据,变量, 内存的理解 什么是数据? 在内存中可读的, 可传递的保存了特定信息的’东东’ 一切皆数据, 函数也是数据 在内存中的所有操作的目标: 数据 什么是变量? 在程序运行过程中它的值是允许改变的量 一个变量对应一块小内存, 它的值保存在此内存中 什么是内存? 内存条通电后产生的存储空间(临时的) 一块内存包含2个方面的数据 内部存储的数据 地址值数据 内存空间的分类 栈空间: 全局变量和局部变量 堆空间: 对象 内存,数据, 变量三者之间的关系 内存是容器, 用来存储不同数据 变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据 问题: var a = xxx, a内存中到底保存的是什么? xxx是基本数据, 保存的就是这个数据 xxx是对象, 保存的是对象的地址值 xxx是一个变量, 保存的xxx的内存内容(可能是基本数据, 也可能是地址值) 关于引用变量赋值问题 2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据 2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象 1234567891011121314151617181920212223let obj1 = &#123; name: &apos;lqy&apos; &#125;情形一function fn1(obj) &#123; obj.name = &apos;shulu&apos;&#125;fn1(obj1)console.log(obj1.name) // shulu情形二funtion fn2(obj) &#123; obj = &#123;name: &apos;shulu&apos;&#125;&#125;fn2(obj1)console.log(obj1.name) // lqy/*解析：形参obj 在函数内部为 var obj变量执行fn( ) 传入实参obj1 即将obj1的值(这里是地址值)复制一份给obj变量*/ 问题: 在js调用函数时传递变量参数时, 是值传递还是引用传递 理解1: 都是值(基本值/地址值)传递 推荐 理解2: 可能是值传递, 也可能是引用传递(地址值) 问题: JS引擎如何管理内存? 内存生命周期 分配小内存空间, 得到它的使用权 存储数据, 可以反复进行操作 释放小内存空间 释放内存 局部变量: 函数执行完自动释放 对象: 成为垃圾对象==&gt;垃圾回收器回收 对象的理解和使用 什么是对象? 多个数据(属性)的集合 用来保存多个数据(属性)的容器 属性组成: 属性名 : 字符串(标识) 属性值 : 任意类型 属性的分类: 一般 : 属性值不是function 描述对象的状态 方法 : 属性值为function的属性 描述对象的行为 特别的对象 数组: 属性名是0,1,2,3之类的索引 函数: 可以执行的 如何操作内部属性(方法) .属性名 [‘属性名’]: 属性名有特殊字符/属性名是一个变量 问题: 什么时候必须使用[‘属性名’]的方式? 属性名包含特殊字符: - 空格 属性名不确定 函数的理解和使用 什么是函数? 用来实现特定功能的, n条语句的封装体 只有函数类型的数据是可以执行的, 其它的都不可以 为什么要用函数? 提高复用性 便于阅读交流 函数也是对象 instanceof Object===true 函数有属性: prototype 函数有方法: call()/apply() 可以添加新的属性/方法 如何调用(执行)函数? test(): 直接调用 obj.test(): 通过对象调用 new test(): new调用 test.call/apply(obj): 临时让test成为obj的方法进行调用 函数中的this是什么? 任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window 所有函数内部都有一个变量this 它的值是调用函数的当前对象 如何确定this的值? test(): window p.test(): p var p = new test(): 新创建的对象p p.call(obj): obj 1234567891011121314151617181920212223242526272829303132333435function Person(color) &#123; console.log(this) this.color = color; this.getColor = function () &#123; console.log(this) return this.color; &#125;; this.setColor = function (color) &#123; console.log(this) this.color = color; &#125;; &#125; Person(&quot;red&quot;); //this是谁? window var p = new Person(&quot;yello&quot;); //this是谁? p p.getColor(); //this是谁? p var obj = &#123;&#125;; p.setColor.call(obj, &quot;black&quot;); //this是谁? obj var test = p.setColor; test(); //this是谁? window function fun1() &#123; function fun2() &#123; console.log(this); &#125; fun2(); //this是谁? window &#125; fun1(); 匿名函数自调用: 123(function(w, obj)&#123; //实现代码&#125;)(window, obj) 专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式 作用 隐藏实现 不会污染外部(全局)命名空间 用它来编码js模块 回调函数的理解 什么函数才是回调函数? 你定义的 你没有调用 但它最终执行了(在一定条件下或某个时刻) 常用的回调函数 dom事件回调函数 定时器回调函数 ajax请求回调函数(后面讲解) 生命周期回调函数(后面讲解) 问题 js一条语句的后面是否应该加分号？ 是否加分号是编码风格问题，没有应不应该，只有喜不喜欢——尤雨溪 必须加分号的情况： 小括号开头的语句 ;(function () {…})() 方括号的开头 ;[1, 2, 3].forEach(() =&gt; {}) &emsp;&emsp;本篇笔记到此完结。 👉点这里，进入QQ交流]]></content>
      <categories>
        <category>js-advance</category>
      </categories>
      <tags>
        <tag>guigu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-modularize]]></title>
    <url>%2Fjs-modularize%2Fjs-modularize%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 👉来QQ撩我啊 modularize 一阶段 所有的代码都写在一个文件下 即暴露在全局环境下 污染环境 二阶段 将某些api 放到一个对象之中 使用时通过obj.xxx来调用 不安全 因为在别处同样可以通过obj.xxx来将其修改掉 三阶段 匿名函数自执行(闭包) 安全 JQuery 就是这么做的 引入js文件太多 请求过多 依赖模糊 12345678910111213(function( window )&#123; function foo () &#123; ... &#125; ... // 将foo方法挂载到window上的xxx属性对象上 // 调用时xxx.foo()即可 window.xxx = &#123; foo &#125; // 或将foo方法挂载到window上的xxx属性对象上，作为一个函数 // 调用时直接foo()执行即可 window.xxx = foo &#125;)( window ) 模块化规范commonJs 一个js文件就是一个模块 向外暴露1 module.exports = value value可以是任意值 向外暴露2 exports.xxx = value value可以是任意值 引入模块 require(‘包名’) 自己写的文件要相对路劲 AMD define CMD 阿里大牛结合commonjs和AMD写的 卖给老外了 ES6 webpack 模块打包工具 分别暴露 即常规暴露相当于一个模块中有许多个变量export xxx = …export yyy = …export zzz = … 引入时要解构赋值 指名道姓拿到相应的变量import { xxx, yyy, zzz } from ‘路劲’ 统一暴露 默认暴露export default {…} 引入时 import xxx from ‘路劲’ &emsp;&emsp;未完待续…… 👉点这里，跟我聊QQ]]></content>
      <categories>
        <category>js-modularize</category>
      </categories>
      <tags>
        <tag>guigu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IT-proper-nouns]]></title>
    <url>%2FIT%2FIT-proper-nouns%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 👉来QQ撩我啊 api 应用程序接口(Application Programming Interface) cli 命令行界面(Command Line Interface) sdk 软件开发工具包(Software Development Kit) rc 结尾的文件 run control 运行时控制文件 &emsp;&emsp;未完待续…… 👉点这里，跟我QQ聊天呗]]></content>
      <categories>
        <category>IT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[node-koa2]]></title>
    <url>%2Fnode%2Fnode-koa2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;hello my world 开始 github创建仓库 本地git clone 仓库 项目目录下 初始化 npm initnpm start 启动快捷方法 在package.json 中添加配置 12&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node server/index.js&quot;, 添加 .gitignore 文件 1234567891011121314# dependenciesnode_modules# logsnpm-debug.log# System.DS_Store#Generatedist# Buildbulid pug 模板引擎npm i pug -S &emsp;&emsp;未完待续…… write to me by QQ email]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>koa2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[async-fn-note]]></title>
    <url>%2Funcategorized%2Fasync-fn-note%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 正文： &emsp;&emsp; write to me by QQ email]]></content>
  </entry>
  <entry>
    <title><![CDATA[arrow-js-note]]></title>
    <url>%2Farrowjs%2Farrow-js-note%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天是2019年，520，在这特殊的一天我面对的依然是code, but no Object, 我希望有一天能美梦成真——面向对象面向君，不负代码不负卿。 箭头函数的经典题型 有关 this 1234567891011121314151617181920212223242526272829let obj = &#123; id: 01, say: function () &#123; // 这里的this为obj setTimeout(function () &#123; // 这里是匿名函数的this默认为window console.log(&apos;arrow id:&apos;, this.id); // undifind &#125;, 100); &#125;, sayWithThis: function () &#123; // 这里将this的值当成变量存起来 let that = this; setTimeout(function () &#123; console.log(&apos;arrow id:&apos;, that.id); // 01 &#125;, 100); &#125;, sayWithArrow: function () &#123; // 这里的this为obj setTimeout(() =&gt; &#123; console.log(&apos;arrow id:&apos;, this.id); // 01 &#125;, 100); &#125;, sayWithGlobalArrow: () =&gt; &#123; // 这里的this已经为全局的this了 setTimeout(() =&gt; &#123; console.log(&apos;arrow id:&apos;, this.id); // undifind &#125;, 100); &#125;&#125;; &emsp;&emsp;未完待续…… write to me by QQ email]]></content>
      <categories>
        <category>arrowjs</category>
      </categories>
      <tags>
        <tag>arrowjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-qa-note]]></title>
    <url>%2Fgit%2Fgit-qa-note%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 科学上网之后，git 报错 如下错误： 12345ssh: Could not resolve hostname github.com: Name or service not knownfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 解决方法1、找到本机的 host 文件，一般位置是进入 C:\Windows\System32\drivers\etc 2、在host文件的最后一行加上，如果之前已经设置过，可以将ip地址更改为最新的正确的ip地址 192.30.255.112 github.com git185.31.16.184 github.global.ssl.fastly.net &emsp;&emsp;遇到后继续补充…… write to me by QQ email]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git-qa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array-note]]></title>
    <url>%2FArray%2FArray-note%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; reduce 计算数组成员的个数 123const countOccurrences = (arr,val) =&gt; arr.reduce((a,v) =&gt; (v === val ? a + 1 : a), 0)alert(countOccurrences([1,111,2,2,2,3,4], 2)); // 3 max Math.max.apply(null, arr) Math.max(…arr) &emsp;&emsp;未完待续…… write to me by QQ email]]></content>
      <categories>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-blue-note]]></title>
    <url>%2Fnode%2Fnode-blue-note-md%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我本来要忘记你了，可我又做梦了。 node http 模块 GET方式 123456789const http = require(&apos;http); //创建一个服务器var server = http.createServer((req, res) =&gt; &#123; /* 给这个地址随便提交一个表单 http://localhost:8080/aaa 其中 req.url = &apos;/aaa?user=shulu&amp;pass=123&apos; 运用字符串的切割数组的拼接就可以拿到用户名与密码 */&#125;).listen(8080); queryString 模块 GET方式争对这种数据 xxx=…&amp;yyy=…&amp;zzz=… 123const querystring = require(&apos;queryString&apos;);var json = querystring.parse(&apos;user=shulu&amp;pass=123&amp;age=18&apos;);console.log(json) // &#123;&quot;user&quot;: &quot;shulu&quot;, &quot;pass&quot;: &quot;123&quot;, &quot;age&quot;: &quot;18&quot;&#125; url 模块 GET方式争对这种数据 整个url部分 参数为true效果更好 1234567const http = require(&apos;http);const _url = require(&apos;url&apos;);var server = http.createServer((req, res) =&gt; &#123; var obj = _url.parse(req.url, true); var url = obj.pathname; const GET = obj.query;&#125;).listen(8080); http 模块 POST方式 12345678910111213const http = require(&apos;http&apos;);const querystring = require(&apos;querystring&apos;);var server = http.createServer((req, res) =&gt;&#123; //请求数据一样在req中 var str = &apos;&apos;; //data数据大 分多次到达 req.on(&apos;data&apos;, (data) =&gt; &#123; //data事件 str += data; &#125;); req.on(&apos;end&apos;, () =&gt; &#123; var POST = querystring.parse(str) &#125;);&#125;).listen(8888); express 框架 express保留了原生的功能，增加了一些自己的功能 基本使用 123456789const express = require(&apos;express&apos;);var server = express();server.use(&apos;/a.html&apos;, function (req, res) &#123; //res.send() 方法参数可以是json等 //res.write() 参数只能是字符串或buffer res.send(&apos;aaaa&apos;); res.end();&#125;);server.listen(8080); 三种接收处理请求的方法 123server.get()server.post()server.use() express-static 插件 处理静态文件的 1234567const express = require(&apos;express&apos;);const expresStatic = require(&apos;express-static&apos;);var server = express();server.listen(8888);server.use(expresStatic(&apos;./www&apos;)); 中间件 body-parser 解析POST数据 1234server.use(bodyParser.urlencode(&#123; extend: false, //扩展模式 limit: 1024*1024 //限制1M&#125;)); multer 解析post文件 multipart/form-data 格式的表单数据 链式操作 next 1234567server.use(&apos;/&apos;, function (req, res, next) &#123; console.log(&apos;aaa&apos;); next();&#125;);server.use(&apos;/&apos;, function (req, res, next) &#123; console.log(&apos;bbb&apos;);&#125;); 模板引擎 ejspath 模块12345678const path = require(&apos;path&apos;);var str = &apos;c:\\user\\www\\a.html&apos;;var obj = path.parse(str);console.log(obj);//base: 文件名部分 如a.html//ext: 扩展名 如.html//dir: 文件路劲 如c:\\user\\www &emsp;&emsp;未完待续…… write to me by QQ email]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>blue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hotkey-vim]]></title>
    <url>%2Fhotkey%2Fhotkey-vim%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;You only live on this earth once. vim编辑器 vi 加文件名 进入编辑器页面 按下a 键 进入编辑模式 编辑完成 (在英文输入下)按esc退出编辑模式 按:wq 回车 即可保存并退出 vim 复制/剪切/粘贴/撤销操作 按esc退出编辑模式 按v 键进入视图模式 由方向键控制选中的内容区域 复制 y键 剪贴 d键 粘贴 p键 撤销 在命令行模式下用 :u 撤销最近一次操作 快捷强大的vim 浏览器插件 vim能提升我们的浏览速度, 鼠标比键盘简单, 键盘比鼠标快! 快速向下滚动d 快速向上滚动u 滚动到页面顶部gg 滚动到页面底部G 神技! 快速搜索 (相当于浏览器顶部搜索框), 并在新标签打开 大写的O 关闭页面x 恢复页面X 主动脱离焦点esc 比如按下o搜索退出时按esc shift+/,查看所有快捷键 &emsp;&emsp;未完待续…… write to me by QQ email]]></content>
      <categories>
        <category>hotkey</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs-guigu]]></title>
    <url>%2Fnode%2Fnodejs-guigu%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我期待有一天背着背包出现在你的城市。 环境变量 小娜 输入 环境变量 进入环境变量/用户变量/path 点开 里面是一条条的文件路劲 可以新建一个文件的路劲 在这里配置了 相当于 声明了一个 类似于 js 中的全局变量 为作用域链的最高层 可以将一些常用的文件或程序的路劲添加到path下 这样我们就可以在任意的位置访问他们了 进程 线程 进程 负责为程序的运行提供必备的环境 工厂的车间 线程 负责执行进程中的程序 车间工人 单线程 一个人干活 多线程 多人合作干一个活 node.js 事件驱动 非阻塞 异步I/O (性能瓶颈阶段) input写入操作 output读操作 版本 奇数为开发版 偶数为稳定版 在Node中，模块分为三类：一类是底层由C++编写的内建模块，一类是Node提供的核心模块；还有一类是用户编写的模块，称为文件模块。node.js 模块化 新建一个js文件就是一个模块 这个模块里面写的代码其实是包在一个函数里面的 即 123456789101112131415funcyion (exports, require, module, _filename, _dirname) &#123; /* 这里是我们写的代码 外面其实包了一层这个函数 默认不可见 可以通过console.log(arguments.callee) 或 console.log(arguments.callee + &quot;&quot;) 将此函数打印出来 该函数执行时传进了5个参数 所以模块里面的代码是局部变量 exports参数 用来将变量或函数暴露到外边 require参数 用来引入外部的模块 module参数 代表模块本身 exports是module的属性 _filename 当前模块的完整路劲 _dirname 当前模块所在文件夹的路劲 */&#125; module.exports 与exports的区别 module.exports == exports true exports 只能使用.的方式向外暴露 若exports = {} 这样向外暴露的话就修改了exports的引用对象 module.exports 既可以通过.的形式 也可以直接赋值 推荐写法 核心模块 由node 提供的模块 node_moudle中的 引入时直接写模块名字 不需要路劲 文件模块 由我们自己创建的模块 引入时添加./或../等路劲 包 package 包实际上就是一个压缩文件 解压以后还原为目录 规范的目录包含以下文件： -package.json 包描述文件 (必须的) 里面不能写注释 -bin 可执行二进制文件 binary 二进制 -lib js代码 library 库 图书馆 -doc 文档 document -test 单元测试 npm 即 (Node Package Manager) node包管理器 commonjs包规范的是一种理论 npm是其中一种实践 对node而言 npm帮助其完成了第三方模块的发布安和依赖 借助npm 使得node与第三方模块之间形成一个生态系统 查看版本 npm version查看相关的版本 或npm -v npm search 包名 搜索包 npm init 在某一文件夹下初始化该文件夹 帮助我们根据提示生成一个package.json的文件 在初始化后的文件夹下 安装搜索的包 并新建一个index.js 入口文件在里面就可以直接引入math模块使用了 npm install 包名 安装 包 或npm i npm remove 或 npm r 删除包 npm install 包名 杠杠save 安装包并添加到依赖中 npm install 下载当前项目所依赖的包 npm install 包名 -g 全局安装包 一般是安装一些工具 如vue-cli cnpm 也可以用 快速 node在使用下载的包时 会沿着作用域链一直往上找直到磁盘根目录找不到则报错 这就解释了某的包在删除之后依然能用的情况 Buffer （缓冲区） 结构和数组很相似 方法也类似 补充了数组方法的不足 Buffer专门存贮二进制数据的 实际上Buffer中的内存不是通过JavaScript分配的，而是在底层通过C++申请的。也就是我们可以直接通过Buffer来创建内存中的空间。 使用buffer无需引入模块 直接使用即可 Buffer.from(str) 将字符串str转为buffer二进制数据 在buffer中存贮的都是二进制数据 但在显示时都是以16进制的形式显示的 二进制 00-255 或 00-ff 计算机 一个0或一个1 称为一位(bit) 8bit = 1byte(字节) 最小单位 中文一个汉字占用三个字节 创建一个制定大小的buffer Buffer.alloc(10) 10字节大小 可通过索引来操作buffer中的元素 Buffer的大小一旦确定 不能再更该 因为存储空间是连续的 性能好 Buffer与字符串间的转换 支持的编码: ASCII、UTF-8、UTF-16LE/UCS-2、Base64、Binary、Hex 字符串转Buffer Buffer.from(str , [encoding]); Buffer转字符串 buf.toString() buf.toString([encoding] , [start] , [end]); 复制缓冲区 buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]]) 对缓冲区切片 buf.slice([start[, end]]) 拼接缓冲区 Buffer.concat(list[, totalLength]) fs (文件系统) 在Node中，与文件系统的交互是非常重要的，服务器的本质就将本地的文件发送给远程的客户端 核心模块 直接引入使用 const fs = require(‘fs’) fs 模块中所有的操作都有两种形式 同步(会阻塞 带sync) 异步(不会阻塞 带回调函数) fs模块中所有的操作都有两种形式可供选择同步和异步 同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码。异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。 打开文件 fs.open(path, flags[, mode], callback) fs.openSync(path, flags[, mode]) 关闭文件 fs.close(fd, callback) fs.closeSync(fd) fs中提供了四种不同的方式将数据写入文件 简单文件写入 同步文件写入 异步文件写入 流式文件写入 同步文件的写入： 1.打开文件 操作方式为定为写 即 var fd = fs.openSync(path, flags) 参数为字符串类型 path即文件的路劲 flags即 r表示读操作 w表示写入操作 通过返回的描述符fd对文件进行各种操作 2.写入内容数据 fs.writeSync(fd, string) fd文件的描述符 需要传入文件的描述符 string要写入的内容 3.关闭文件 考虑性能 fs.closeSync(fd) 异步文件写入 1.打开文件 123456789101112131415161718fs.open(path, flags, function (err, fd) &#123; if (!err) &#123; 2.在这里往文件写入内容 写操作 fs.write(fd, &apos;要异步写入的内容&apos;, function (err) &#123; if (!err) &#123; console.log(&apos;write success&apos;) &#125; fs.close(fd, function (err) &#123; if (!err) &#123; console.log(&apos;close success&apos;) &#125; &#125;) &#125;) console.log(fd) &#125;else&#123; console.log(err) &#125;&#125;) 返回值为 callback的参数 简单文件写入 简单同步文件 fs.write 简单异步文件 123456fs.writeFile(&apos;hello.txt&apos;, &apos;shulu520&apos;, &#123;flag: &apos;a&apos;&#125; function (err) &#123; //flag: &apos;a&apos; 追加文件内容 不会覆盖原来的 如果文件不存在则创建 flag还有好多的模式 if (!err) &#123; console.log(&apos;write success&apos;) &#125; //文件路劲可以是F:\JSdownload\npm-test 这种 `但是要变为`F:\\JSdownload\\npm-test或F:/JSdownload/npm-test&#125;) 同步 异步 简单文件 的写入都不适合大文件爱的写入 易导致内存溢出 性能差 流式文件写入 12345678910111213141516171819202122232425 创建流 var ws = fs.createWriteStream(path) 监听事件 once绑定一次性的事件 ws.once(&apos;open&apos;, function () &#123; console.log(&apos;stream success&apos;) &#125;) ws.once(&apos;close&apos;, function () &#123; console.log(&apos;stream close&apos;) &#125;) 写入内容 大量内容 ws.write(&apos;写入内容1&apos;) ws.write(&apos;写入内容2&apos;) ws.write(&apos;写入内容3&apos;) ws.write(&apos;写入内容4&apos;) …… 关闭流 在流开始的一方结束流 ws.end()``` + fs中提供了四种读取文件的方式 简单文件读取 同步文件读取 异步文件读取 流式文件读取+ 简单文件读取 简单异步文件读取 const fs = require(‘fs’);fs.readFile(‘shulu.jpg’, (err, data) =&gt; { if(!err) { fs.writeFile(‘桌面路劲/lqy.jpg’, data, () =&gt; { if(!err) { console.log(‘文件写入成功 ‘) } }) }})12+ 流式文件读取 适用于大文件 const fs = require(‘fs’);1.创建读取流const rs = fs.createReadStream(‘shulu.jpg’);2.监听流的开启和关闭rs.once(‘open’, () =&gt; { console.log(‘流打开成功了’)})rs.once(‘close’, () =&gt; { console.log(‘流关闭了’)})3.读取数据rs.on(‘data’, (data) =&gt; { console.log(data) //多次分批读取大数据}) pipe 流方法 12 const fs = require(‘fs’);const rs = fs.createReadStream(‘shulu.mp3’);const ws = fs.createWriteStrem(‘lqy.mp3’);rs.pipe(ws); 读取后直接流入 12345678910111213141516171819202122232425262728+ fs 模块其他操作 检查一个文件是否存在+ 列出文件 fs.readdir(path[, options], callback) fs.readdirSync(path[, options])+ 截断文件 fs.truncate(path, len, callback) fs.truncateSync(path, len)+ 建立目录 fs.mkdir(path[, mode], callback) fs.mkdirSync(path[, mode])+ 验证路径是否存在 fs.existsSync(path)+ 获取文件信息 fs.stat(path, callback) fs.statSync(path)+ 删除文件 fs.unlink(path, callback) fs.unlinkSync(path)+ 删除目录 fs.rmdir(path, callback) fs.rmdirSync(path)+ 重命名文件和目录 fs.rename(oldPath, newPath, callback) fs.renameSync(oldPath, newPath)+ 监视文件更改写入 fs.watchFile(filename[, options], listener) const fs = require(‘fs’);const isExists = fs.existsSync(‘shulu.mp3’);console.log(isExists);` &emsp;&emsp;未完待续……&emsp;&emsp;write to me]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>guigu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-zhuf-01.md]]></title>
    <url>%2Fes6%2Fes6-zhuf-01%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;想要的东西，会以最快的速度来到你的身边。 var 与 let 和 const 的区别新的方法解决了老方法遗留的问题 var 在同一作用域内可以对同一变量重复声明 不能定义常量(控制不了，因为可以修改，写了等于没写) 不支持块级作用域 let 在同一作用域内不能对同一变量重复声明 变量不会提升 变量定义之前使用会报错 有块级作用域 {这里面为块级作用域} 以前js只有两种作用域 一个是全局 一个是函数级 作用域经典问题： for 循环里面套 定时器 当时的解决方法 给定时器包一层自执行的匿名函数并将循环变量传进去 本质上是作用域问题 现在用let声明变量就可以了 const 在同一作用域内不能对同一变量重复声明 专门声明常量 常量声明后不可修改 但若此常量是一个引用类型的话(例如一个对象) 引用对象的属性还是可以改的 例如：定义 const USER = {name: ‘shulu’} 更改为 USER.name = ‘lqy’ 可以的 解构 分解一个对象的解构 解构的时候 等号的两边解构相似 右边必须是一个真实的值 数组的省略赋值 let arr = [1, 2, 3]; let [,,x] = arr 则只拿到x=3的值 模板字符串 以前是字符串拼串 现在是这个符号 可以折行 换行 模板语言的原理 正则实现 面试 带参数的模板字符串 字符串的新方法 返回布尔值 str.startWith(‘http’) str.endsWith(‘.com’) str.includes(‘shulu’) 以前 str.indexOf(‘shulu’) == -1 做判断 str.repeat(10) 重复10次 展开运算符 … 对象合并： Object.assign(obj3, obj2, obj1); 将对象1，2合并为3 obj3 = {…obj1, …obj2} 更简洁 对象的深拷贝 1let obj2 = JSON.parse(JSON.stringify(obj1)) 递归实现对象深拷贝 12345678910111213141516171819202122232425262728//对象深拷贝function deepClone(origin,target)&#123; //target是否存在如果不存在创建空对象 let tar = target || &#123;&#125;, //判断是否为引用数据类型 toStr = Object.prototype.toString, arrType=&apos;[object Array]&apos;; for(let key in origin)&#123; //剥离原型链的数据 if(origin.hasOwnProperty(key))&#123; //判断是否为引用数据类型 对象或数组 if(typeof(origin[key]) === &apos;object&apos; &amp;&amp; origin[key] !== null)&#123; if(toStr.call(origin[key]) === arrType )&#123; tar[key] = []; &#125;else&#123; tar[key] = &#123;&#125;; &#125; deepClone(origin[key],tar[key]); &#125;else&#123; tar[key] = origin[key]; &#125; &#125; &#125; return tar;&#125; 箭头函数箭头函数this 继承自父级，自己本身没有this &emsp;&emsp;未完待续……]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>zhuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-guigu-note]]></title>
    <url>%2Fgit%2Fgit-guigu-note%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在衰老到来之前，做一件值得做的事情。做这件事不是为了别的，而是为了证明自己是好样的。-《似水流年》 复制 选中后 Ctrl+ins 即键盘右上角的insert键粘贴 相应的位置 Shift+ins查看git 配置信息cat ~/.gitconfig状态查看 git status 查看工作区、暂存区状态文件内容查看 cat haha.txt添加操作 git add [file_name]git commit -m ‘说明信息’ [file_name]创建文件 touch haha.txt 或 vim good.txt 字母ll 列出本地库所有文件和文件总数，创建日期 时间 创建人 文件名 git add haha.txt 后 若想返回add前的状态 根据提示 git rm –cached haha.txt 即可返回，此删除只是从暂存区里面删除，工作区的文件还在git commit haha.txt 这里没带-m ‘说明信息’ 回车后会进入vim 编辑器 可以编写大量的说明信息 首先 按a键 进入插入模式，之后就可以进行编辑了。 编辑完了就可以按Esc键退出插入模式，然后输出:wq即可退出vim编辑器，回到git bash界面。 查看提交记录 git log 打印的记录风格： 分散 有作者 邮箱 日期提示，显示内容详细，内容多了，多屏显示控制方式：桥空格为向下翻页，b键为向上翻页，q 键为退出查看 git log –oneline 打印效果为一行 git reflog 打印的记录风格： 紧凑 在一行显示并有提示版本回退数字提示 版本前进后退 基于索引值操作 任意版本穿梭 推荐方法 git reset –hard alfe9cd 这里alfe9cd为某一版本的提交id值即索引值 基于符号 ^ 只能后退 返回上一个版本 git reset –hard HEAD^ 版本倒退三个 git reset –hard HEAD^^^ 基于符号 ~ 只能后退 版本倒退三个 git reset –hard HEAD~3 reset 命令的三个参数对比 –soft 仅仅在本地库移动HEAD指针 –mixed 在本地库移动HEAD指针,重置暂存区 –hard 在本地库移动HEAD指针,重置暂存区,重置工作区，三个区位置保持一致 删除文件 rm aaa.txt git status 显示为 红色 deleted: aaa.txt 提示要add该文件 git add aaa.txt git status 显示为 绿色 表示已添加到暂存区 git commit -m ‘deleted aaa.txt’ 将这次删除操作提交到本地库 删除文件并恢复 前提：删除前 文件的状态提交到了本地库 操作： git reset –hard [指针位置] 删除操作已经提交到本地库：指针位置指向包含删除文件的历史纪录 删除操作尚未提交到本地库：指针位置使用HEAD 比较文件差异 git diff [文件名] 将工作区的文件和暂存区进行比较 git diff [本地库中历史版本] [文件名] 将工作区的文件和本地历史记录比较 git diff 不带文件名 比较多个文件 分支管理 热修复 主分支的bug 更改 分一个 hot_fix 分支 分支的好处： 查看分支 git branch -v 创建分支 git branch hot_fix 切换分支 git checkout hot_fix 切换到这个分支 合并分支 第一步：切换到接受修改的分支(被合并，增加新内容)上 git checkout [接受修改的分支] 第二步：在接受修改的分支上执行命令 git merge [有新内容的分支] 解决合并分支后产生的冲突 分别在两个分支上修改内容 分别提交到本地库 比如都在haha.txt上做修改 将两个分支合并到一个分支上 出现合并冲突 vim haha.txt 查看合并后的状态 HEAD 部分表示当前分支的修改 在一行========之下为另一个分支上做的修改 解决方法： 一：删掉那些特殊符号 并手动将内容修改为满意的状态 期间可能与分支伙伴商量 保存退出 二：git add [文件名] 三：git commit -m &apos;日志说明&apos; 注意：此时commit `一定不能带 文件名` git 原理 哈希算法 明文 加密 得 密文 常见的 md5算法 git 底层 SHA-1算法 github克隆的效果 完整的把远程库克隆到本地 初始化本地库 邀请队员加入 github进入相应的项目 /settings/Collaborators/ 在Search by username 之下 添加成员的github账号名 add collaborator copy invite link 发送给队员（qq或邮箱等方式）等其他方式把邀请链接发送给队员 队员 登录github 后 Accepe invitation 队员拉取操作 pull=fetch+merge git fetch [远程库地址别名] [远程分支名] git merge [远程库地址别名/远程分支名] git pull [远程库地址别名] [远程分支名] 解决冲突 如果不是基于 GitHub 远程库的最新版所做的修改，则不能推送，必须先拉取。 拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即 跨团队协作 外团队人员fork 该项目 git 工作流分支种类 主干分支 master主要负责管理正在运行的生产环境代码。永远保持与正在运行的生产环境完全一致。 开发分支 develop主要负责管理正在开发过程中的代码。一般情况下应该是最新的代码。 bug 修理分支 hotfix主要负责管理生产环境下出现的紧急修复的代码。 从主干分支分出，修理完毕并测试上线后，并回主干分支。并回后，视情况可以删除该分支。 准生产分支（预发布分支） release较大的版本上线前，会从开发分支中分出准生产分支，进行最后阶段的集成测试。该版本上线后，会合并到主干分支。生产环境运行一段阶段较稳定后可以视情况删除。 功能分支 feature为了不影响较短周期的开发工作，一般把中长期开发模块，会从开发分支 中独立出来。 开发完成后会合并到开发分支。&emsp;&emsp;完 更多笔记看git&amp;github.pdf详细笔记]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git-note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-tour]]></title>
    <url>%2Fvue%2Fvue-tour%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;I love three things in this world. Sun, Moon, and You. Sun for morning, Moon for night, and You forever.浮世三千，吾爱有三，日、月与卿。日为朝，月为暮，卿为朝朝暮暮。 A Vue.js project-去哪儿旅行，vue学习练手小项目。 Build Setup1234567891011# install dependenciesnpm install# serve with hot reload at localhost:8080npm run dev# build for production with minificationnpm run build# build for production and view the bundle analyzer reportnpm run build --report css 省略号…123overflow hiddenwhite-space nowraptext-overflow ellipsis 项目初始化 如果这个项目是从github 上克隆来的 初始化时直接 vue init webpack 注意这里不用再加初始化的项目名称 修改 标签 路劲优化，简化 ,在webpack 中配置 build/webpack.base.conf.js 的alias 下面是vue-cli 配置好的 1234alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;),&#125; import HelloWorld from ‘@/components/HelloWorld’ 其中的 @ 表示src目录 在css 样式中 import ‘~@/assets/styles/varibles.styl’ 其中的 ~@ 表示src目录 移动端快速点击 npm i fastclick –save 解决300毫秒延迟 在main.js 中 import fastClick from ‘fastclick’ fastClick.attach(document.body) css代码编辑工具 stylus npm i stylus –save npm i stylus-loader –save 阿里图标 进入网站后 /图标管理/我的项目/新建项目1px 使用的是硅谷外卖 stylus/mixins.styl 使用 @import ‘~@/assets/styles/border.styl’ 某一个样式下 bottom-border-1px(#ccc) 自己传一个色值 github 创建新分支index-swiper本地 git pull 将分支拉到本地切换到这个分支 git checkout index-swiper轮播图 npm i vue-awesome-swiper@2.6.7 –save 官网具体配置 轮播图 index-swiper 开发完成后 git add . git commit -m ‘swiper finished’ git push git checkout master git merge index-swiper 将index-swiper 分支的文件 合并到master主分支 git push 在浏览器中自动打开 config/index.js 修改里面的配置，把autoOpenBrowser:false改为autoOpenBrowser:true即可 布局 高度 height 0padding-bottom 33.9% 用padding-bottom 的值撑开高度 即高宽比 Git出现|MERGING解决 使用git上传或者下拉中出现MERGING，这是合并冲突了 输入命令可以正常跳转：git reset –hard head ajax npm install axios –save config/index.js中配置 12345678proxyTable: &#123; &apos;/api&apos;: &#123; target: &apos;http://localhost:8081&apos;, pathRewrite: &#123; &apos;^/api&apos;: &apos;/static/mock&apos; &#125; &#125; &#125;, vue 文件中 12axios.get(&apos;/api/index.json&apos;) .then(this.getHomeInfoSucc) 解决 swiper 初次显示时为最后一张图的情况 是因为刚开始时是一个空数组 给swiper 加 v-if = “list.length” 即list 传过来有值的时候在加载。 页面滚动 npm install better-scroll –save ref 属性使用注意 如果 ref 的值 是 v-for 循环产生的 使用时 this.$refs[‘A’][0] 即第零相 才是真正的dom 使用函数截流 提示网站性能 在 touchmove 事件中 使用 settimeout 即将一些触发特别快又频繁的代码放到 定时器里面 减少执行次数 vuex 状态管理 npm install vuex –save 安装 src/新建store/index.js 12345678910import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; city: &apos;北京&apos; &#125;&#125;) main.js 12345678910import store from &apos;./store&apos;new Vue(&#123; el: &apos;#app&apos;, router, store, 添加选项store components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;&#125;) 城市选择后 直接跳转到 首页 显示相应的城市 在事件处理 方法里面 12this.$store.dispatch(&apos;changeCity&apos;, city)this.$router.push(&apos;/&apos;) localStorage 的使用 需要在外层加 tyr catch 以防 某谢用户 避了本地存储功能 或浏览器使用隐身模式 12345678910111213141516171819202122232425let defaultCity = &apos;常州&apos;try &#123; if (localStorage.city) &#123; defaultCity = localStorage.city &#125;&#125;catch (e) &#123;&#125;export default new Vuex.Store(&#123; state: &#123; city: defaultCity || &apos;常州&apos; &#125;, actions: &#123; changeCity (ctx,city) &#123; ctx.commit(&apos;changeCity&apos;, city) &#125; &#125;, mutations: &#123; changeCity (state, city) &#123; state.city = city try &#123; localStorage.city = city &#125;catch (e) &#123;&#125; &#125; &#125;&#125;) mapState 的使用 定义import { mapState } from &#39;vuex&#39; 12345678910computed: &#123; ...mapState([&apos;city&apos;]) &#125; 也可以是computed: &#123; ...mapState(&#123; currentCity: &apos;city&apos; &#125;) &#125;, 使用 或 keep-alike 的使用123&lt;keep-alive&gt; &lt;router-view/&gt;&lt;/keep-alive&gt; 相应的组件 数据 加载一次后会保存到内存中 下次调用 直接取 提升性能 vue 实例 选项中多了一个生命 周期钩子函数 activated, 其在页面重新显示，有变动的时候触发 12345activated () &#123; if (this.lastCity !== this.city) &#123; this.getHomeInfo() &#125; &#125; 及时解除全局事件 让其只在当前组件中触发 deactivated 在页面隐藏，页面被替换为新的页面 时触发 123456activated () &#123; window.addEventListener(&apos;scroll&apos;, this.handleScroll) &#125;, deactivated () &#123; window.removeEventListener(&apos;scroll&apos;,this.handleScroll) &#125; 递归组件的使用 在自己组件内部 通过name 选项 的名字 作为递归组件的标签名使用&lt;detail-list :list=&quot;item.children&quot;&gt;&lt;/detail-list&gt; 缓存相关 App.vue 中 Detail 组件不缓存 123&lt;keep-alive exclude=&quot;Detail&quot;&gt; &lt;router-view/&gt;&lt;/keep-alive&gt; 解决不同页面位置的相互影响问题 router/index.js 中加入scrollBehavior选项 123456789101112export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, name: &apos;Home&apos;, component: Home &#125; ], scrollBehavior (to, from, savedPosition) &#123; return &#123;x: 0, y: 0&#125; &#125;&#125;) 解决某些手机浏览器 不支持 promise 的情况 npm install babel-polyfill –save main.js 中 import &#39;babel-polyfill&#39; 项目优化 按需加载js 组件 此方法 只在打包生成的app.js文件特别大（1M左右）的时候使用，小的话，不宜，因为这样会增加http 请求 router/index.js 将import Home from &#39;@/pages/home/Home.vue&#39;引入组件的方式去掉，配置路由为 12345&#123; path: &apos;/&apos;, name: &apos;Home&apos;, component: ( ) =&gt; import(&apos;@/pages/home/Home.vue&apos;) &#125;, 项目上线 npm run build 生成dist 文件夹 将dist 给后端运行 &emsp;&emsp; 项目正在开发完毕。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue-project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http]]></title>
    <url>%2Fhttp%2Fhttp%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; GET POST 的区别 前提:web浏览器环境下的RFC规范GET 用来获取信息，POST用来发送信息 可见性 安全性 数据大小 编码类型 能否收藏为书签，GET可以 刷新，后退按钮，GET无影响，POST重新提交 能否保留到浏览器历史，GET保留 &emsp;&emsp;]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[net-model]]></title>
    <url>%2Fnet%2Fnet-model%2F</url>
    <content type="text"><![CDATA[应用层: 程序，软件，应用层协议，http协议，DNS协议(域名解析)，FTP协议(文件传输协议)，SMTP(邮件传输协议)传输层: 对数据传输的建立和管理，传输层协议，UDP协议(有丢包的可能)，TCP(保证数据的正确性，顺序性)网络层: 好比交通网络，IP协议(IP加端口号来确定一个程序的位置)数据链路层: 两个子层，一个叫逻辑链路控制子层，另一个叫媒体访问控制子层(MAC地址)物理层: 坐公交，扫码骑车。除了五层网络模型之外还有七层网络模型，那么七层网络模型是什么呢？就是将应用层一分为三，分别为：应用层，表示层和会话层。新出来的表示层和会话层没有相应的协议。一般表示层做的是数据格式化，或者加密等操作。]]></content>
      <categories>
        <category>net</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[safe-xss]]></title>
    <url>%2Fsafe%2Fsafe-xss%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;让一个人变强大的最好方式是拥有一个想去保护的人。 XSS攻击究竟是如何一步一步的获取了别人的隐私呢？下面我们就来一步一步的来进行解析。1. 攻击者，上传一片文章或者博客，这边文章中带有一段JS代码，这段代码内容很简单，读取本地Cookie，发送给某个url。2. XX微博的服务器没有对用户上传的内容进行审查，就将内容存储起来。3. 当正常用户访问XX微博的时候，服务器将有问题的文章推送给了这个正常用户。（因为服务器并没有检查哪篇文章有问题，所以它会认为这是一篇正常的文章，以正常的方式推送给用户。）4. 当正常的用户点开这篇文章的时候，攻击者编写的脚本就会在正常的用户的电脑上执行。（因为攻击者的脚本就是在文章的内容中加入一段script代码，浏览器会将script标签中的内容当作js代码来看待，然后执行这段代码）5. 这段带有攻击性的代码可以读取用户本地的cookie内容，并将内容发送给攻击者事先准备好的url。（因为正常用户在本地打开，所以不存在跨域的问题）6. 攻击者收到了发送过来的cookie之后，就可以将cookie内容写入自己的浏览器里，然后就能登录这个正常用户的XX微博了。（因为现在很多网站都做了免登录功能，这个功能主要是依赖于种在浏览器里的cookie，这个cookie中会带有用户的部分信息，当用户在每次进入网站的时候，由于这些cookie的存在，就可以免登录了。我们这个例子中，XSS攻击就是获取到了用户的Cookie，从而在我们的本地来将这份cookie写入到我们的浏览器里，就能登录这个正常用户的帐号了~）我们会发现XSS攻击最大的问题在于，服务器端在用户上传文章内容的时候，没有进行内容审查。其实，我们只要将一些危险的符号进行HTML编码就可以了，比如将‘&lt;’替换为”&lt;”，将‘&gt;’替换为”&gt;”，这样攻击者就无法通过script标签的方式来进行攻击了~]]></content>
      <categories>
        <category>safe</category>
      </categories>
      <tags>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shanjuan]]></title>
    <url>%2Fdiary%2Fdiary-shanjuan%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;juan，我的好朋友，好久不见，今偶然间，美好的回忆又浮现眼前，于是赶紧记下那些美好。 &emsp;&emsp;拿起雪糕想起了你。&emsp;&emsp;雪糕这玩意和辣条一样是我小时候的最爱，只是随着年岁渐长，慢慢留在记忆里了。昨晚室友叫我一起去超市，逛了一圈不知买点啥，看到有人买雪糕，心想，天气热了就买个尝尝吧。打开柜子，拿起雪糕，恍惚间，温暖的记忆又浮现在眼前。&emsp;&emsp;juan，我的高中同学，朋友，那时经常作我的同桌，人美心善，跟同学关系都挺好。当然对我也很好。常给我糖果啊各种小吃的，我用的笔啊书和本子啊经常从juan那直接拿。&emsp;&emsp;我对juan的第一印象：juan是一个可爱的小公主，而且很高洁。机缘巧合之下，我有幸认识了juan，而且常常作同桌。这让我们之间的距离又近了一点。juan是我去到十班最早认识的同学之一。&emsp;&emsp;时间久了，发生过的好多事情我就不记得了。所以我此时此刻在努力的将往事回忆，我生怕等我老了的时候，年轻时的这些美好时光要是再也回想不起来了，那样想想多遗憾啊。&emsp;&emsp;juan对我一直很好，就像对其他人一样。我们除了讨论学习，还聊小时候，聊未来。关于未来，其实都是我在表达对未来的迷惑，而juan一直在开导我。juan说我们可以永远做朋友。&emsp;&emsp;一个雪糕，那是高三时的一天中午你送我的，当时教室里是有其同学的，但是你只送给了我。在高三那个本就燥热的季节，让我清凉了一整个夏天。&emsp;&emsp;如今再拿起雪糕，眼前浮现出都是你对我的好。感谢那时的遇见，让我能有这么美好的回忆。juan，也愿你过得好，有个好对象。要是余生能再见，我想你还是那么的漂亮，那么温柔与大气。&emsp;&emsp;朋友的友谊不是三言两语就道的尽的，但都是埋藏在我的心底里的。 &emsp;&emsp;刚刚看qq空间里你发的说说–有人拿走了你的外卖，🤣🤣🤣]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[skills-search]]></title>
    <url>%2Fskills%2Fskills-search%2F</url>
    <content type="text"><![CDATA[口语转变为关键词 关键词之间打上空格 限定在特定网站内 关键词 site:某一站点 注意：站点前不用加www或http 限定文件类型 关键词 filetype:文件格式 限定时间段 关键词 20xx..20xx 注意：中间是两个英文句号 排除某个关键词 关键词 -广告 -推广 将关键词限定在标题中 关键词 intitle:限定内容]]></content>
      <categories>
        <category>skills</category>
      </categories>
      <tags>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math-random]]></title>
    <url>%2FMath%2FMath-random%2F</url>
    <content type="text"><![CDATA[引言：希望你睡不着时，想起的都是那些让你开心的事 常见的问题：如何生成一个区间[min,max]内的随机整数？答案很简单，即 Math.random()*(max-min)+min 以下是一些其他的方法。 new Date() - 0 new Date() 日期函数 默认会显示年月日等字符，new Date() - 0 会得到数字“秒” (new Date() - 0)%2239 ,得到取模数值分之一概率的随机数，即[0,2239]范围内一随机数 toString(指定进制) 方法的调用 与parseInt() 方法一样，进制区间为 [2,36]，取36得字母多一些 随便一个随机数.toString(36)得随机字符，但有数字，且长短不一 随机字符串函数，长度固定，且都是字母 从固定的字典中抽取字符构成随机字符串 12345678910// 在大小写字母之间随机生成 x 个字符function randStr(x)&#123; var s = &apos;&apos;; while(s.length &lt; x &amp;&amp; x &gt; 0)&#123; var r = Math.random(); s += String.fromCharCode(Math.floor(r*26) + (r &gt; 0.5 ? 97 : 65)) &#125;; return s;&#125;;console.log(randStr(3)); //KzE 三个随机字符 颜色随机函数1234function randomColor()&#123; var rand = &apos;#&apos;+(&apos;00000&apos;+(Math.random()*0x1000000&lt;&lt;0).toString(16)).slice(-6); return rand;&#125;; 后记 随机数相关得知识还又有很多，后面学到了再来补充笔记]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>random</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-liao-note]]></title>
    <url>%2Fgit%2Fgit-liao-note%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;人是不能闲的，一闲就会想得太多，一闲就会感情泛滥，所谓矫情屁事多，空虚寂寞冷，都是因为懒散寂寞闲。 git 的优秀之处 它跟踪并管理的是文件的修改，而非文件。Git有不少命令中有“-”，有时候是“-”，有时候是“–”。学过linux的命令行就懂了，单个”-“ 后面跟的是单个字母的参数，如-m， 两个”–”后面跟的是多个字母的参数，如–readme.txt 在大多数情况下成立的。注意:我的博客页面上显示的效果都只有一个’-‘,若’-‘线条显示的比较细，则表示两个’-‘ 创建本地版本库cd 到目录文件夹下mkdir learn-git 新建文件夹，即版本库（repository）git init 初始化版本库,即把这个目录变成git 可以管理的仓库ctrl + l 清屏，以防代码太多看着难受ls 查看目录下的文件ls -a 查看不可见的文件touch git-test.txt 创建 txt文件 或者用vscode编辑器创建，别用windows 自带的记事本，因为记事本在编码方面有弱智的行为，键盘上的上键 返回上一步命令git add git-test.txt 添加要提交的文件，可多次添加多个文件，将文件添加到暂存区（stage即阶段的意思）git commit -m “添加描述内容，如 这是第一次使用commit提交” 可以一次提交多个文件，默认提交到master 分支时光穿梭机git status 查看仓库当前的状态git diff 查看文件的具体修改的内容 输出变化前后的内容git log 显示从最近到最远的提交日志git reset –hard HEAD^ 回退到上一个版本，HEAD表示当前版本，HEAD^即上一个版本，往上100个版本为HEAD~100git reflog 用来记录我们的每一次命令即commit 的idgit reset –hard commit_id commit_id 为某一版本提交的具体ID名词解释说明 工作区： 即我们电脑上的项目文件夹，版本库 ：即工作区里面的一个叫 .git 的隐藏目录，版本库里面有暂存区，有git 为我们创建的master 分支，以及指向master的一个指针HEAD 管理修改 每次修改，如果不用git add 到暂存区，就不会加入到commit 中git checkout – git-test.txt 让这个文件回到最近一次git commit 或 git add 时的状态，注意–是单独的即后面有空格 ，git checkout 使用版本库里面的版本替换工作区的版本 ，无论工作区是修改还是删除，都可以一键还原。 我测试时为什么不行呢cat git-test.txt 查看文件的内容 远程仓库github 上创建一个仓库就行了，最好与本地仓库同名根据提示：将本地仓库与远程仓库关联并推送到远程123…or push an existing repository from the command linegit remote add origin https://github.com/lqyasl/learn-git.git (关联)git push -u origin master (本地推送到远程) 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。一个项目库第一次推送成功后，后面 只要本地做了提交，就可以 git push origin master 不用加参数-u分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了。前面是先有本地仓库，再有远程库。如何关联远程库。现在，最好的方式是，先创建远程库，再从远程库里面克隆到本地。首先在github上创建一个 仓库 并勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。我这里创建了一个gitskills的库。git clone git@github.com:lqyasl/gitskills.git 或 git clone https://github.com/lqyasl/gitskills.git 等多种方式， 推荐使用前一种，其速度最快。cd gitskills 进入克隆的库ls 展开文件列表 可以看到已经有一叫README.md 的文件了分支管理分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 与其他svn 版本控制系统相比， git 超级快。每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点。每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上。从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变。假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并。合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。实战部分git checkout -b dev 创建dev分支，然后切换到dev分支： 这里git checkout命令加上-b参数表示创建一个分支并切换到这个分支。 checkout这里表示切换的意思。git branch 查看当前分支，git branch命令会列出所有分支，当前分支前面会标一个*号。对README.md 文件做修改，比如加一点内容。然后 git add README.md 以及 git commit -m ‘分支测试’ ，我们就可以在dev分支上正常提交现在，dev分支的工作完成，我们就可以切换回master分支 git checkout master现在，我们把dev分支的工作成果合并到master分支上 git merge dev 这里git merge命令用于合并指定分支到当前分支。注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。合并完成后，就可以放心地删除dev分支了。 git branch -d dev因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。gti branch 查看分支，可以看到只剩下一个master主分支了。创建分支与合并小结 Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 解决冲突创建新的feature1分支，继续我们的新分支开发 git checkout -b feature1修改 README.md 文件的内容在feature1分支上提交 git add README.md 以及 git commit -m ‘AND simple’切换到master分支 git checkout masterGit还会自动提示我们当前master分支比远程的master分支要超前1个提交在master分支上把readme.txt文件的最后一行改为：Creating a new branch is quick &amp; simple.提交README.md 文件现在，master分支和feature1分支各自都分别有新的提交这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看 gti merge feature1 结果显示： Automatic merge failed; fix conflicts and then commit the result.果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件修改README.md 并提交 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。最后，删除feature1分支： git branch -d feature1分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。下面我们实战一下–no-ff方式的git merge：首先，仍然创建并切换dev分支：git checkout -b dev## &emsp;&emsp;今晚到此为止，明天再写。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git-note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[book-fengchuan]]></title>
    <url>%2Fbook-note%2Fbook-fengchuan%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;深夜时，人会更加容易情绪化，所以无论多难过，都要告诉自己，没有那麽糟糕，睡一觉就好了。 相比广告营销，口口相传更有效，分享能让我们感觉良好，因为他会让我们显得高大上。我们更愿意与人分享能提升个人形象的信息。某些产品，思想或行为，经常出现在我们眼前时，他们的影响力和传染力就会大大增加。从古至今，故事一直都是人们分享信息的重要工具。诱因，让人产生联想，看到这个，就会想到那个。打折规则，100元以上，降价多少元，以下为打几折。&emsp;&emsp;那么如何打造-个疯传的产品呢?第一，让你的产品成为一种社交货币，也就是说人们会通过分享它来赢得别人的好感和兴趣;第二，要利用诱因引发消费者的联想;第三，要带动消费者的情绪，让他们不断频繁地分享;第四，让你的产品尽可能出现在大家眼前，让人们不看都不行;第五，记得，简单实用的东西自然会受人欢迎;最后，帮你的产品量身打造一一个足够有意思的故事。&emsp;&emsp;两个可行的建议。首先，可以让你的产品带上点竞争元素。就是说利用人们的游戏心理，大家在玩游戏的时候都喜欢跟别人比赛，获得胜利之后，会得意地和别人分享自己的战绩，同时也就相当于告诉了别人某个产品。所以，如果你的产品有了游戏元素，就能鼓励消费者用你的产品进行某种互动，这样就提高了产品被分享的可能。]]></content>
      <categories>
        <category>book-note</category>
      </categories>
      <tags>
        <tag>skills</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-source-guigu]]></title>
    <url>%2Fvue%2Fvue-source-guigu%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;read the fucking source code. vue 源码分析知识点分析 vue 作为一个 MVVM 框架的基本实现原理准备知识 1 [].slice.call(lis): 将伪数组转换为真数组 slice 方法有浅拷贝的用法，表示截取一部分，不传参数的话就是拷贝原数组 这样更好 Array.prototype.slice.call(lis) 2 node.nodeType: 得到节点类型 节点类型：常用的 document // 文档 Element //元素节点 节点类型 nodeType === 1; Attr //属性 Text //文本 documentFragment // 文档碎片 3 Object.defineProperty(obj, propName, {}): 给对象添加/修改属性(指定描述符) vue 数据代理的核心语法，不支持ie8，面试题 属性描述符： 数据描述符： configurable: true/false 是否可以重新 define enumerable: true/false 是否可以枚举(for..in / keys()) value: 指定初始值 writable: true/false value 是否可以修改 访问描述符：vue的计算属性就是利用get set 方法 get: 回调函数, 根据其他相关的属性动态计算得到当前属性值，根据相关的属性更新（得到）当前的属性 set: 回调函数, 监视当前属性值的变化，更新相关的属性值 ，根据当前的属性更新相关的属性 Object.keys(obj): 得到对象自身可枚举的属性名的数组 obj.hasOwnProperty(prop): 判断 prop 是否是 obj 自身的属性 DocumentFragment: 文档碎片(高效批量更新多个节点) 传言啊 这个 childNodes是正统属性 亲生的 而这个children是野孩子 这个野孩子比较随意 所以用它返回来的就只有DOM元素了 其他的文字啥的 都不返回 而 childNodes比较讲究 事无巨细 都要返回来 但是我还是觉得野孩子乖 所以也获得了几乎所有浏览器的支持 如果你想要DOM节点 直接用野孩子就可以了 12345&lt;ul id=&quot;list&quot;&gt; &lt;li&gt;test1&lt;/li&gt; &lt;li&gt;test2&lt;/li&gt; &lt;li&gt;test3&lt;/li&gt;&lt;/ul&gt; 12345678910111213141516let list = document.getElementById(&quot;list&quot;); // 1. 创建文档碎片 let fragment = document.createDocumentFragment(); // 2. 取出ul中 所有 子节点保存到fragment中 //Array.prototype.slice.call(list.children).forEach(element =&gt; &#123; fragment.appendChild(element); &#125;); // 3.修改fragment中的每一个子元素的内容 Array.prototype.slice.call(fragment.children).forEach(element =&gt; &#123; element.textContent = &apos;舒璐&apos;; &#125;); // 4.将文档碎片插入到list中 list.appendChild(fragment); 数据代理的实现基本实现流程 通过 Object.defineProperty()给 vm 添加与 data 对象的属性对应的属性描述符 所有添加的属性都包含 getter/setter getter/setter 内部去操作 data 中对应的属性数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152相当于Vue的构造函数function MVVM(options) &#123; // 将选项对象保存到vm this.$options = options; // 将data对象保存到vm和datq变量中 var data = this._data = this.$options.data; //将vm保存在me变量中 var me = this; // 遍历data中所有属性 Object.keys(data).forEach(function (key) &#123; // 属性名: name // 对指定属性实现代理 me._proxy(key); &#125;); // 对data进行监视 observe(data, this); // 创建一个用来编译模板的compile对象 this.$compile = new Compile(options.el || document.body, this)&#125;MVVM.prototype = &#123; $watch: function (key, cb, options) &#123; new Watcher(this, key, cb); &#125;, // 对指定属性实现代理 _proxy: function (key) &#123; // 保存vm var me = this; // 给vm添加指定属性名的属性(使用属性描述) Object.defineProperty(me, key, &#123; configurable: false, // 不能再重新定义 enumerable: true, // 可以枚举 // 当通过vm.name读取属性值时自动调用 get: function proxyGetter() &#123; // 读取data中对应属性值返回(实现代理读操作) return me._data[key]; &#125;, // 当通过vm.name = &apos;xxx&apos;时自动调用 set: function proxySetter(newVal) &#123; // 将最新的值保存到data中对应的属性上(实现代理写操作) me._data[key] = newVal; &#125; &#125;); &#125;&#125;; 其中最关键的部分为 1234567891011121314Object.defineProperty(me, key, &#123; configurable: false, // 不能再重新定义 enumerable: true, // 可以枚举 // 当通过vm.name读取属性值时自动调用 get: function proxyGetter() &#123; // 读取data中对应属性值返回(实现代理读操作) return me._data[key]; &#125;, // 当通过vm.name = &apos;xxx&apos;时自动调用 set: function proxySetter(newVal) &#123; // 将最新的值保存到data中对应的属性上(实现代理写操作) me._data[key] = newVal; &#125; &#125;); 模板解析 嵌套调用: a里面调用b,b里面调用c 递归: a 里面调用 a ,a继续调用a即特殊的嵌套调用 模板解析的基本流程 1)将 el 的所有子节点取出, 添加到一个新建的文档 fragment 对象中 2)对 fragment 中的所有层次子节点递归进行编译解析处理 对大括号表达式文本节点进行解析 对元素节点的指令属性进行解析 事件指令解析 一般指令解析 3) 将解析后的 fragment 添加到 el 中显示 模板解析(1): 大括号表达式解析&lt;p&gt;&lt;/p&gt; 根据正则对象得到匹配出的表达式字符串: 子匹配/RegExp.$1 name 从 data 中取出表达式对应的属性值 将属性值设置为文本节点的 textContent 模板解析(2): 事件指令解析从指令名中取出事件名 根据指令的值(表达式)从 methods 中得到对应的事件处理函数对象 给当前元素节点绑定指定事件名和回调函数的 dom 事件监听 指令解析完后, 移除此指令属性 模板解析(3): 一般指令解析得到指令名和指令值(表达式) text/html/class msg/myClass 从 data 中根据表达式得到对应的值 根据指令名确定需要操作元素节点的什么属性 v-text—textContent 属性 v-html—innerHTML 属性 v-class–className 属性 4) 将得到的表达式的值设置到对应的属性上 5) 移除元素的指令属性 call apply bind JavaScript 的一大特点是， 函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念 apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里 bind()最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的this值。 常见的错误就像，将方法从对象中拿出来，然后调用，并且希望this指向原来的对象。 如果不做特殊处理，一般会丢失原来的对象。用bind方法可以 数据绑定 简单地说，就是数据更新，界面改变。 一旦更新了 data 中的某个属性数据, 所有界面上直接使用或间接使用了此属性的节点+更新 数据劫持 数据劫持是 vue 中用来实现数据绑定的一种技术 基本思想: 通过 defineProperty()来监视 data 中所有属性(任意层次)数据的变化, 一旦变化就去更新界面 初始化显示：页面（表达式/指令）能从data中读取数据显示（编译/解析） 更新显示：更新data中的属性数据，.&gt;&gt;&gt; 页面更新 图中黑线表示初始化，红线表示更新时触发 双向数据绑定 双向数据绑定是建立在单向数据绑定(model==&gt;View)的基础之上的 双向数据绑定的实现流程: 在解析 v-model 指令时, 给当前元素添加 input 监听(input事件会在value属性值发生改变时触发，通过js改变value属性值不会触发此事件。只有IE8以上或者谷歌火狐等标准浏览器支持。) 当 input 的 value 发生改变时, 将最新的值赋值给当前表达式所对应的 data 属性 vuex 是vue 的一个插件 简单来说: 对 vue 应用中多个组件的共享状态进行集中式的管理(读/写) 状态自管理应用 state: 驱动应用的数据源（data） view: 以声明方式将 state 映射到视图(模板界面) actions:（在vue中是函数） 响应在 view 上的用户输入导致的状态变化 (包含 n 个*更新状态的方法*) ![](vuenote/2.jpg) 多组件共享状态的问题 多个视图依赖于同一状态 来自不同视图的行为需要变更同一状态 以前的解决办 将数据以及操作数据的行为都定义在父组件 将数据以及操作数据的行为传递给需要的各个子组件(有可能需要多级传递) vuex 就是用来解决这个问题的 vuex 核心概念和 API state vuex 管理的状态对象,它应该是唯一的 mutations 包含多个直接更新 state 的方法(回调函数)的对象 谁来触发: action 中的 commit(&apos;mutation 名称&apos;) 只能包含同步的代码, 不能写异步代码 const mutations = { yyy (state, {data1}) { // 更新 state 的某个属性 } } vuex 人生管理哲学，哈哈State:想一想，你现在心里在意哪些事？ Mutation目标导向: 写下目标，直接改变State Action阶段性执行： 写下行动 ，执行一个个Matation、异步函数、和其它阶段性执行。 Getters: 写下其它指标，根据现有的state得到其他的指标 mapState和mapGetters必须在computed中访问，因为它们返回的是对象，所以需要用拓展符…进行展开。 mapActions则是将Action挂载到methods上，也需要用拓展符…进行展开。 组件中的mapActions([“increment”])与actions 中 increment 函数名一样actions 中 commit(“INCREMENT”)与mutations 中 INCREMENT函数名一样大写的函数名只是为了区分各个函数 可以定义一个mutation-type.js 后记]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>guigu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello-friends]]></title>
    <url>%2Fhello%2Ffriends%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Welcome to my blog,终于等到你，还好我没放弃(^_^)这里有我的学习心得,编程感悟,心情故事等,是我个人在互联网上的一个小窝。来了就好好逛逛，这里既是我的学习园地，也是我的精神家园。 &emsp;&emsp;欢迎来我QQ交流，也欢迎匿名来撩，无需登录哦，点击右下角，进我的聊天室开撩呗。 &emsp;&emsp;Everything will be okay in the end. If it’s not okay, it’s not the end. who am i, What kind of person do I want to be我是谁，自己要成为什么样的人？其实，在做自己喜欢做的事情的时候，往往也逐渐让自己成为自己想要成为的那种人。在学习、工作、生活中，接触各种各样的人，他们是什么样的人？有什么特殊的经历？在阅读的过程中，甚至能接触古今中外的人物，他们是如何度过自己的一生的？每个时代，每个人做的事情也许不一样，都是选择人生道路时经历的心境却是相似的，而那些成功的人生，离不开他们所处的“时势”，更为重要的是他们对于机会的觉察和行动的品质。这些不管时代如何变迁，都是大致相同的。听到的，接触的人多了，也许自己的人生方向也就越来越清晰了，在实际行动中，通过尝试，也许就会发现一条自己要走的路。 12345678910111213141516171819 ) ( /+++=)) ((=+++\ /++++++++// \\+++++++++\ /++++++++++//( /\ )\\++++++++++\ /+++++++++++// \\^^// \\+++++++++++\ _/++++++++++++// &#123;&#123;@::@&#125;&#125; \\++++++++++++\_ /+++++++++++++(( &#123;\/&#125; ))+++++++++++++\ /+++++++++++++++\\ &lt;**&gt; //+++++++++++++++\ /+++++++++++++++++\\ / VV \ //+++++++++++++++++\ /+++++++++++++++++++\\/******\//+++++++++++++++++++\|+/|++++++++++/\++++++(***/\***)++++++/\++++++++++|\+\|/ |+/\+/\+/\/ \+/\++\**|**|**/++/\+/ \/\+/\+/\+| \|v |/ V V V V \+\|*|**|*|/+/ V v V V \| v v /*|*|**|*|*\... v (**|*|**|*|**). . __\*|*|**|*|*/__. . (vvv(VVV)(VVV)vvv). . ............../ / 注感谢原作者的神代码注释，网上流传很多，不知具体出处，愿我等小白借大佬神兽保佑永无bug。^_^ . 来我QQ撩我哦👇]]></content>
      <categories>
        <category>hello</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[h5-guigu-music]]></title>
    <url>%2FH5%2Fh5-guigu-music%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;想去的地方，有你才最美丽。 第一天 像素 适配 图片加载太慢，后面要用纯文字代替，记得更新 rem最终适配代码 123456;(function()&#123; var styleNode = document.createElement(&quot;style&quot;); var w = document.documentElement.clientWidth/16; styleNode.innerHTML=&quot;html&#123;font-size:&quot;+w+&quot;px!important&#125;&quot; document.head.appendChild(styleNode);&#125;)() 1物理像素的实现 用媒体查询的方法 一般用伪元素来做123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;/&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; #test:before&#123; position: absolute; bottom: 0px; content: &quot;&quot;; display: block; width: 100%; height: 1px; background: black; &#125; @media only screen and (-webkit-device-pixel-ratio:2 ) &#123; #test:before&#123; transform: scaleY(.5); &#125; &#125; @media only screen and (-webkit-device-pixel-ratio:3 ) &#123; #test:before&#123; transform: scaleY(.33333333333); &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 第二天 移动端基础事件 querySelectorAll() 匹配满足选择器的所有元素 改变dom结构后一定得再次获取 1234567891011window.onload=function()&#123; //querySelectorAll:获取静态列表 var itemNodes = document.querySelectorAll(&quot;.item&quot;); // 第一次获取 console.log(itemNodes.length) document.body.innerHTML+=&quot;&lt;div class=&apos;item&apos;&gt;&lt;/div&gt;&quot;; itemNodes = document.querySelectorAll(&quot;.item&quot;); // 改变dom结构后一定得再次获取 console.log(itemNodes) for(var i=0;i&lt;itemNodes.length;i++)&#123; itemNodes[i].style.background=&quot;pink&quot;; &#125;&#125; querySelector 获取 querySelectorAll 匹配到的第一个 触屏事件 监听用 addEventListenerpc端12345678910 touchstart mousedown touchmove mousemove 不可能单独触发 可以单独触发 touchend mouseupwindow.onload=function()&#123; var item = document.querySelector(&quot;.item&quot;); item.addEventListener(&quot;touchstart&quot;,function()&#123; console.log(&quot;touchstart&quot;) &#125;)&#125; 移动端事件默认行为 长按选中，橡皮筋效果（下拉）等 全面禁止事件默认行为 在 touchstart事件上，即手指触摸上去的时候就开始禁止 一上来就这段代码，全面禁止事件默认行为12345678910window.onload=function()&#123; document.addEventListener(&quot;touchstart&quot;,function(ev)&#123; ev=ev||event; ev.preventDefault();&#125;)// 单独按需开启 item.addEventListener(&quot;touchstart&quot;,function(ev)&#123; ev=ev||event; ev.stopPropagation();&#125;) 右键菜单的阻止与开启 与自定义右键 全局阻止右键1234567891011121314151617181920212223242526272829 document.oncontextmenu=function()&#123; return false; &#125;// 单独按需开启浏览器的右键菜单 var inner = document.querySelector(&quot;#inner&quot;); inner.oncontextmenu=function(ev)&#123; ev.stopPropagation();&#125;// 也可以自定义右键菜单window.onload=function()&#123; document.oncontextmenu=function(ev)&#123; ev = ev||event; var x = ev.clientX; var y = ev.clientY; var wrap =document.querySelector(&quot;#wrap&quot;); wrap.style.display=&quot;block&quot;; wrap.style.left = x+&quot;px&quot;; wrap.style.top = y+&quot;px&quot;; return false; &#125; // 单击消失 document.onclick=function()&#123; var wrap =document.querySelector(&quot;#wrap&quot;); wrap.style.display=&quot;none&quot;; &#125;&#125; 事件点透 pc端的事件可以在移动端触发 PC端事件有300毫秒延迟 移动端事件不会有延迟 移动端 a 标签跳转方案 并解决误触 123456789101112131415161718192021 // 阻止事件默认行为 document.addEventListener(&quot;touchstart&quot;,function(ev)&#123; ev=ev||event; ev.preventDefault(); &#125;) //移动端a标签的跳转方案 解决误触 var aNodes = document.querySelectorAll(&quot;a&quot;); for(var i=0;i&lt;aNodes.length;i++)&#123; aNodes[i].addEventListener(&quot;touchstart&quot;,function()&#123; this.isMoved=false; &#125;) aNodes[i].addEventListener(&quot;touchmove&quot;,function()&#123; this.isMoved=true; &#125;) aNodes[i].addEventListener(&quot;touchend&quot;,function()&#123; if(!this.isMoved)&#123; location.href=this.href; &#125; &#125;) &#125;&#125; event : //changedTouches: 触发当前事件的手指列表, 最常用//targetTouches: 触发当前事件时元素上的手指列表//touches: 触发当前事件时屏幕上的手指列表常见问题 及解决方法 禁止电话与邮箱,添加标签 1&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no&quot;/&gt; 按需开启 电话与邮箱 12 &lt;a href=&quot;tel:1383838438&quot;&gt;1383838438&lt;/a&gt;&lt;a href=&quot;mailto:2642816105@qq.com&quot;&gt;2642816105&lt;/a&gt; 解决连接按钮高亮问题 1234a &#123; text-decoration:none; // 去下划线 webkit-tap-highlight-color:rgba(0,0,0,0); // 去背景高亮，只需字体高亮&#125; 解决圆角过圆的问题 加属性 webkit-appearance:none 即可 fontboosting 的问题 及显示的字体与设置的大小不一致的现象，加属性 max-height:999999px;即可 无缝华屏 移动端清除浮动：父元素ul元素上加 overflow:hidden 即可 表单：表单高亮：outline:none; 表单内阴影：boder:none; 划屏相关 在谁上面划，即划屏包裹slide-wrapper 划的内容 即slide-content 元素排到一行的方法 浮动 父容器宽度不够会自动换行 另一种技巧 父容器white-space :nowrap; 子元素: display: inline-block;橡皮筋效果 减少每次move 的有效距离，最终的有效距离还是一直在增大 混合 继承 可以单独定义一系列通用的样式，在需要的时候进行调用。从而减少代码的重复 混合：简单 1234567891011121314151617181920&lt;!-- 定义混合 --&gt;.mixin()&#123; &lt;!-- 规则集 --&gt;&#125;&lt;!-- 使用混合 --&gt;#text1&#123; &lt;!-- 相当于将规则集里面的代码cv到这里 --&gt; &lt;!-- 每次使用都是将代码复制到相应位置 --&gt; &lt;!-- 使用几次就有几处相同的代码 --&gt; .mixin();&#125;#text2&#123; .mixin();&#125;#text3&#123; .mixin();&#125;&lt;!-- 多处使用相同的混合 这样写好一点-（手动写）-&gt;#text1,#text2,#text3&#123; .mixin() &#125; 继承：性能好一点 1234567891011121314151617&lt;!-- 定义继承 --&gt;.extend&#123; &lt;!-- 规则集 --&gt;&#125;&lt;!-- 使用继承 --&gt;#text1&#123; &amp;::extend(.extend);&#125;#text2&#123; &amp;::extend(.extend);&#125;#text3&#123; &amp;::extend(.extend);&#125;&lt;!-- 最终编译为 --&gt;#text1,#text2,#text3&#123; &lt;!-- 规则集 ，相当于将规则集里面的代码cv到这里--&gt;&#125;]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>H5-note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown-write]]></title>
    <url>%2Fmd%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[故事的开头，多是惊魂一瞥，然后一眼万年。故事的结局，多是渐行渐远，江湖不见。 在 xxx.md文件插入html效果 直接写html 即可 内联样式也直接写 这里输入文字，自定义字体大小 这里输入文字，自定义字体颜色这里输入文字，自定义字体背景色这是综合起来的效果 这是综合起来的效果2 首行缩进效果 其中的 &amp;emsp;&amp;emsp; 即缩进两个字最常见 全方大的空白 &amp;emsp;&emsp;&emsp;内容充实的生命就是长久的生命。我们要以行为而不是以时间来衡量生命。 ——小塞涅卡 不断行的空白格&amp;nbsp; &nbsp;以后无论我去哪我都把你带着我看账你帮我打算盘我谈生意你帮我出主意一起把吴家东院发扬光大做到陕西第一天下第一。———那年花开月正圆周莹经典台词 倾斜 单层*示例：倾斜字体 加粗 双层*示例：加粗字体 加粗倾斜 三层*示例：加粗倾斜 删除线 双层~~示例：删除线 单层引用 &gt;加内容 这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容 无序列表 用 - + * 任何一种都可以示例： 无序列表1 无序列表2 无序列表3 表格 : 表头 表头 表头 内容 内容 内容 内容 内容 内容 注：第二行分割表头和内容。-有一个就行，为了对齐，多加了几个 文字默认居左-两边加：表示文字居中-右边加：表示文字居右 代码:单行: javascript vue node ajax 代码块: 、、、.b{ background: red;}、、、 👉有事记得Q我哦]]></content>
      <categories>
        <category>md</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue-guigug]]></title>
    <url>%2Fvue%2Fvue-guigu%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;人生即在于体验，而体验源于去尝试，去折腾，去改变，去塑新。 &emsp;&emsp;要知道：过一个平凡无趣的人生实在太容易了，你可以不读书，不冒险，不运动，不写作，不外出，不折腾…… &emsp;&emsp;但是，人生最后悔的事情就是：我本可以。生活也好，职场也罢，亦同此理；编程则更如其是 Vue 的特点 遵循 MVVM 模式 即MVVM 模式的一种实现 编码简洁, 体积小, 运行效率高, 适合移动/PC 端开发 它本身只关注 UI, 可以轻松引入 vue 插件（依赖vue）或其它第三库(不依赖vue)开发项目 MVVM 的理解 M 即 model 模型, 数据对象（data） V 即 view 视图，模板页面 VM 即 viewModel 视图模型 是vue的实例 dom监听 数据绑定 组件 即 局部功能界面 ，是提供某一完整功能的模块模板的理解：动态的html页面，包含了一些js语法代码vue 扩展组件 vue-cli: vue 脚手架 axios: ajax 请求 vue-router: 路由 vuex: 状态管 vue-lazyload: 图片懒加载 vue-scroller: 页面滑动相关 mint-ui: 基于 vue 的 UI 组件库(移动端) element-ui: 基于 vue 的 UI 组件库(PC 端) 编程方式 命令式 如 jquery 声明式 如 vue 数组的扩展-array.some()和array.every()区别 some():方法用于检测数组中的元素是否有满足指定条件的，若满足返回true，否则返回false； every():方法用于检测数组中所有元素是否都符合指定条件，若符合返回true，否则返回false； 挂载元素app new Vue({ el :’#app’ }); new vue({}).$moute(‘#app’) 用于单元测试 vue 指令 v-bind 即 : 强制 动态 数据绑定（属性） v-on 即 @ 绑定事件监听 v-html 内部innerHTML XSS攻击 内容必须是可信赖的 vue 计算属性 computed 什么时候执行 ： 初始化显示，/ 相关的data 数据属性发生变化时触发 各个方法的返回值作为相关的属性值 get 回调函数，当需要读取当前属性值的时候回调，计算并返回当前属性的值 set 回调函数，监视当前属性值的变化，当属性值变化时回调，更新相关的属性数据 计算属性，存在缓存，多次读取，只调用一次getter计算，性能好, 全选时可用计算属性 vue 的方法 methods 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。 然而，不同的是计算属性是基于它们的依赖进行缓存的。只在相关依赖发生改变时它们才会重新求值 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数 如果你不希望有缓存，请用方法来替代 vue 的watch 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器 当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的 绑定 style class :class=”xxx” xxx是字符串或对象 :style=”xxx” xxx是对象 对象更新,数组更新 完全跟新 即重新写这个对象 补充更新 vm.$set(要跟新的对象名,补充的属性名,属性值) 数组更新 vm.$set(要跟新的数组名,更新的下标,具体值) 数组更新检测 变异方法（vue重写原生的方法）即以下这些方法已不再是原生的方法 push pop shift unshift splice sort reverse 使用它们会触发视图更新 注意事项： 利用索引直接设置一个项时/修改数组的长度时 vue不能检测到数组变化 常用事件修饰符 阻止事件冒泡 如@click.stop=”XXX” 传统方法 e.stopPropagation 取消事件默认行为 如 @click.prevent=”xxx” 传统方法 e.preventDefault @click.once=”xxx” 点击事件将只会触发一次 常用按键修饰符 抬起某键时，执行操作 如按回车 @keyup.enter=”xxx” 鼠标修饰符 left right middle 系统修饰键 可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 ctrl alt shift meta 表单数据的自动收集 使用 v-model vue实例的 生命周期（钩子函数） 大致有三个阶段 初始化阶段 beforeCreate created beforeMount mounted 只执行一次 更新阶段 beforeUpdate updated 执行N次 销毁阶段 beforeDestory destoryed 常用的有1：`mounted` （挂载方法） 发送*Ajax* 请求,获取真实dom ，执行定时器等异步任务 2：`beforeDestory` 收尾工作，如清除定时器，解绑操作等 vue 过渡&amp;动画 过渡 ：transition 显示时的效果：xxx-enter-active{…} 隐藏时的效果 ：xxx-leave-active{…} 其中xxx表示 transition元素的name 属性值 动画 ：animation 过滤 vue.filter(‘自定义函数名’，() =&gt; {…}) 指令 ref 为某个元素指定一个唯一的标识，vue对象通过$refs属性访问这个元素对象 v-cloak 防止闪现表达式 与css属性选择器配合 [v-cloak] {display:none} 自定义指令 全局指令： vue.directive(‘指令名’，function(el,binding){…}) 参数el指属性所在的标签对象 binding包含指令相关的数据对象 局部指令： 在vue实例选项中配置directives:{‘指令名’，(el,binding) =&gt; {…},others} vue 自定义插件 plugin Vue 插件是一个包含 install 方法的对象 1234567891011121314151617181920 自定义 Vue 插件 包在匿名函数自执行里面(function () &#123; const MyPlugin = &#123;&#125;; MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或属性 Vue.myGlobalMethod = function () &#123; alert(&apos;Vue 函数对象方法执行&apos;) &#125;; // 2. 添加全局资源 Vue.directive(&apos;my-directive&apos;, function (el, binding) &#123; el.innerHTML = &quot;MyPlugin my-directive &quot; + binding.value &#125;); // 3. 添加实例方法 Vue.prototype.$myMethod = function () &#123; alert(&apos;vue 实例对象方法执行&apos;) &#125;; &#125; window.MyPlugin = MyPlugin;&#125;)() 页面使用插件 1234567891011121314151617181920212223&lt;div id=&quot;demo&quot;&gt;&lt;!--使用自定义指令--&gt;&lt;p v-my-directive=&quot;msg&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;vue-myPlugin.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;//声明使用自定义插件Vue.use(MyPlugin)var vm = new Vue(&#123;el: &apos;#demo&apos;,data: &#123;msg: &apos;atguigu&apos;&#125;&#125;)//调用自定义的静态方法Vue.myGlobalMethod()//调用自定义的对象方法vm.$myMethod()&lt;/script&gt; vue 组件 全局组件 局部组件 vue 组件间通信 父传向子 props 在组件内声明所有的 props 方式一: 只指定名称props: [‘name’, ‘age’, ‘setName’] 方式二: 指定名称和类型props: { name: String, age: Number, setNmae: Function} 方式三: 指定名称/类型/必要性/默认值props: { name: {type: String, required: true, default:xxx},}问题: a. 如果需要向非子后代传递数据必须多层逐层传递 b. 兄弟组件间也不能直接 props 通信, 必须借助父组件才可以 属性校验 123456789101112 要校验的 props : &#123; msg :&#123; type :Number, validator (value)&#123; //validator 属性校验器，可以自定义属性校验 return value &gt; 3; &#125; &#125; arr :&#123; type :Array, default :() =&gt; ([1,2,3]) // 属性校验中，如果是`数组/对象` 需要将默认值返回 &#125;&#125; 子传向父 通过自定义事件 绑定事件监听 // 方式一: 通过 v-on 绑定 @delete_todo=”deleteTodo” // 方式二: 通过$on() this.$refs.xxx.$on(‘delete_todo’, function (todo) { this.deleteTodo(todo) }) 触发事件 // 触发事件(只能在父组件中接收) this.$emit(eventName, data) 问题: 隔代组件或兄弟组件间通信此种方式不合适 vue 自定义事件 我的理解 子组件中 @click=”add” methods 里面 是具体的add方法干的事情 add里面最终 通过this.$emit(“add”,this.msg)通知父级我触发了此事件 并传值给父组件 父组件中 监听@add=”addCounter”methods里面定义addCounter要干啥事，用一个形参接收子组件传来的值 消息订阅与发布(PubSubJS 库) 订阅消息 —-&gt;事件监听 PubSub.subscribe(‘msg’, function(msg, data){}) 发布消息 —–&gt;触发事件 PubSub.publish(‘msg’, data) 优点: 此方式可实现任意关系组件间通信(数据) slot(插槽，占位的) 此方式用于父组件向子组件传递标签数据4.2 复用性 使用 父组件中 使用子组件，slot属性 ：xxx 对应的标签结构 子组件中 定义插槽，slot元素 name属性：不确定的标签结构 1 插槽对应的方法属性等定义在父组件中， 模块导出为函数还是对象的依据要看模块向外暴露一个功能还是多个功能 一个功能即函数 多个功能则对象 ，因为对象可以包含多个方法 ajax 插件相关知识 下载插件 引入插件 声明使用插件 即 Vue.use(名字) 方式一：vue-resource 内部会给vm对象和组件对象添加一个属性：$http $http 有两个方法 get() ,post() 方式二：axios vue.2.X 下载 npm install axios –save // 直接引入模块使用，不用声明 在哪里使用在哪里引入 123456789import axios from &apos;axios&apos; // 发送 ajax 请求axios.get(url).then(response =&gt; &#123; console.log(response.data) // 得到返回结果数据&#125;).catch(error =&gt; &#123; console.log(error.message)&#125;) 数组方法之map方法的特点：数组里面的对象变，但数组对象的个数不变组件名称 路由相关 开发中分为路由组件和非路由组件 路由组件 名称为 views 或 pages 非路由组件 名称为 components 路由器模块命名为router建立index.js文件 路由器模块: src/router/index.js 引入vue import Vue from ‘vue’ 引入VueRouter import VueRouter from ‘vue-router’ 注册使用VueRouter Vue.use(VueRouter) 导出一个VueRouter实例 1234567891011 export default new VueRouter(&#123; routes 数组， routes: [ // 路由配置 k即（path） 和value即（component） &#123; path: &apos;/&apos;, redirect: &apos;/about&apos; &#125;, &#123; path: &apos;/about&apos;, component: About &#125;, ]&#125;) 注册路由器: main.js 1234567 import Vue from &apos;vue&apos; import router from &apos;./router&apos; // 创建 vue 配置路由器new Vue(&#123; el: &apos;#app&apos;, router, render: h =&gt; h(app)&#125;) 使用路由组件标签 12345&lt;!--路由链接--&gt;&lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;&lt;router-link to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;&lt;!--用于渲染当前路由组件--&gt;&lt;router-view&gt;&lt;/router-view&gt; 子路由 children path可以写全或 直接写当前的路由名字（简化写法） 缓存路由组件对象 默认情况下, 被切换的路由组件对象会死亡释放, 再次回来时是重新创建的 如果可以缓存路由组件对象, 可以提高用户体验 123&lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 向路由组件传递数据 方式 1: 路由路径携带参数(param/query) 配置路由 12345children: [&#123; path: &apos;mdetail/:id&apos;, component: MessageDetail&#125;] 路由路径 1&lt;router-link :to=&quot;&apos;/home/message/mdetail/&apos;+m.id&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt; 路由组件中读取请求参数 1this.$route.params.id 方式 2: 属性携带数据 1&lt;router-view :msg=&quot;msg&quot;&gt;&lt;/router-view&gt; 编程式路由导航 即用js 的方法实现而非 标签方式 相关 API 栈的结构 this.$router.push(path): 相当于点击路由链接(可以返回到当前路由界面) this.$router.replace(path): 用新路由替换当前路由(不可以返回到当前路由界面) this.$router.back(): 请求(返回)上一个记录路由 this.$router.go(-1): 请求(返回)上一个记录路由 this.$router.go(1): 请求下一个记录路由 栈 队列 例子 ： 喝醉酒后站着从上面出来即为栈 call 方法调用 让一个函数成为指定对象的方法进行调用 slice.call(lis) 即让slice函数成为lis的方法进行调用]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>guigu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less-note]]></title>
    <url>%2Fless%2Fless%2F</url>
    <content type="text"><![CDATA[君子生非异也，善假于物也. less 即css预处理器 vscode 编辑器 下载插件 easy less 声明编码集 @charset “utf-8”声明变量 声明变量(原始值类型) @bb:#ff0000; 使用变量 color:@bb; 声明变量（路劲类型） @img:”../images”; 使用变量 background-image:url(“@{img}/1.jpg”) 声明变量(属性类型) @ww:width; 使用变量 @{ww}:100px; 混合方式 带默认参数 定义 .border-r(@radius:5px){ border-radiis:@radius; } 使用 .box{ .border-r; 传参即.border-r(10px); } 接收多个参数 定义 .box-s(@x, @y, @blur, @color){ box-shadow:@arguments; } 使用 .box{ .box-s(3px,4px,5px,red) } color 函数 了解就行 运算 各种可以计算的都可以计算 包括颜色值 支持运算符 + - * / 即加减乘除命名空间 它用于将mixins分组在通用名称下。 使用命名空间可以避免名称冲突，并从外部封装mixin组12345678910111213141516171819202122定义：#bgcolor()&#123; // 加 () 默认不输出 background: #ffffff; .a&#123; color: #888888; &amp;:hover&#123; color: green; &#125; .b&#123; background: red; &#125; &#125;&#125;使用：.bgcolor1&#123; background: yellow; #bgcolor&gt;.a; // &gt;符号表示选中混合中的每一个样式&#125;.bgcolor2&#123; // #bgcolor&gt;.a&gt;.b; #bgcolor .a .b; // 省略写法：将&gt;换成空格即可&#125; 避免编译 我们能在编译后的css文件中看到 它 编译计算之前的样子 最终的编译计算由浏览器来完成 css3中有这样一个函数calc() less里面 123.box&#123; width:~&apos;calc(300px - 10px)&apos;&#125; 编译完的 css 123.box&#123; width:calc(300px - 10px)&#125; !important css 样式中 用来提升优先级（最高） less 中 一样 常用来调试代码 比如 某一段样式不起作用，不知道是继承还是覆盖等造成的 给他加上 !important 还不起作用的话 就说明代码书写有误]]></content>
      <categories>
        <category>less</category>
      </categories>
  </entry>
</search>

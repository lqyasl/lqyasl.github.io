<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2020开篇]]></title>
    <url>%2Funcategorized%2F2020%E5%BC%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;代码之路停下久矣，今晚无聊之时，正好试试手，看看那些花里胡哨的操作还是否记的。 &emsp;&emsp;哈哈哈哈哈，还好没忘记，不错不错，阔以阔以，往后继续加油哦。 有事您Q我👇]]></content>
      <tags>
        <tag>2020</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue常见组件之menu]]></title>
    <url>%2Fvue%2Fvue%E5%B8%B8%E8%A7%81%E7%BB%84%E4%BB%B6%E4%B9%8Bmenu%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;常见的首页竖条大菜单 pc端常见的竖条大菜单 vue中以组件的形式来学习菜单 这里以自己写的menu.vue组件为例 左边的菜单项与右边的细节内容展示项为简单并列的dom结构即可，而非多么复杂的结构 而在数据结构方面可以为嵌套的结构 右边只是一块空的展示区，展示左边的某一块内容细节，左边通过鼠标事件改变数据，从而改变右边展示区的内容。 因为左右两边为并列的dom结构而非父子结构，所以左边的鼠标事件(mouseover等)与右边无法衔接(就是鼠标从左边滑到右边后，右边会消失而不是继续展示，这点类似于鼠标的hover事件，通过鼠标hover维持状态的前提是，鼠标在当前元素以及它的子元素之上停留着)，所以我们通过在左右两边都监听鼠标事件来判断情况。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;template&gt; &lt;div class="m-menu"&gt; &lt;dl class="nav" @mouseleave="navLeave"&gt; &lt;dt&gt;全部分类&lt;/dt&gt; &lt;dd v-for="(item, index) in menu" :key="index" @mouseenter="navEnter" &gt; &lt;i :class="item.type" /&gt;&#123;&#123; item.name &#125;&#125;&lt;span class="arrow" /&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;div v-if="kind" class="detail" @mouseenter="detEnter" @mouseleave="detLeave" &gt; &lt;template v-for="(item, index) in curDetail.children"&gt; &lt;h4 :key="index"&gt; &#123;&#123; item.title &#125;&#125; &lt;/h4&gt; &lt;span v-for="(val, idx) in item.child" :key="idx" &gt; &#123;&#123; val &#125;&#125; &lt;/span&gt; &lt;/template&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; kind: '', menu: [ &#123; type: 'food', name: '美食', children: [ &#123; title: '热门美食', child: ['火锅', '烤串', '啤酒', ' 炸鸡', '小龙虾'] &#125; ] &#125;, &#123; type: 'takeout', name: '外面', children: [ &#123; title: '热门外卖', child: ['黄焖鸡', '炒菜', '花生', '榨菜', '水饺'] &#125; ] &#125; ] &#125; &#125;, computed: &#123; curDetail () &#123; return this.menu.filter(item =&gt; item.type === this.kind)[0] &#125; &#125;, methods: &#123; navEnter (e) &#123; this.kind = e.target.querySelector('i').className &#125;, navLeave () &#123; this.timer = setTimeout(() =&gt; &#123; this.kind = '' &#125;, 150) &#125;, detEnter () &#123; clearTimeout(this.timer) &#125;, detLeave () &#123; this.kind = '' &#125; &#125;&#125;&lt;/script&gt; 有事您Q我👇]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>component</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue常见组件之search]]></title>
    <url>%2Fvue%2Fvue%E5%B8%B8%E8%A7%81%E7%BB%84%E4%BB%B6%E4%B9%8Bsearch%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;vue常见组件之search，即大的电商等网站的大搜索框 pc端常见的搜索框组件 这里结合element ui来学习 以下是我写的search.vue组件 当输入框获得焦点而未输入内容时，展示热门搜索 当输入框获得焦点且输入内容时，展示相关的内容(请求数据并展示) 以上两者dom结构为并列结构即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;template&gt; &lt;div class="search-panel"&gt; &lt;el-row class="m-header-searchbar"&gt; &lt;el-col :span="6" class="left"&gt; &lt;img src="//s0.meituan.net/bs/fe-web-meituan/fa5f0f0/img/logo.png" alt="美团"&gt; &lt;/el-col&gt; &lt;el-col :span="12" class="center"&gt; &lt;div class="wrapper"&gt; &lt;el-input v-model="search" placeholder="搜索商家或地点" @focus="foucs" @blur="blur" /&gt; &lt;button class="el-button el-button--primary"&gt; &lt;i class="el-icon-search"&gt;&lt;/i&gt; &lt;/button&gt; &lt;dl class="hotPlace" v-if="isHotList"&gt; &lt;dt&gt;热门搜索&lt;/dt&gt; &lt;dd&gt;火锅&lt;/dd&gt; &lt;dd&gt;火锅&lt;/dd&gt; &lt;dd&gt;火锅&lt;/dd&gt; &lt;/dl&gt; &lt;dl class="searchList" v-if="isSearchList"&gt; &lt;dd&gt;小龙虾&lt;/dd&gt; &lt;dd&gt;小龙虾&lt;/dd&gt; &lt;dd&gt;小龙虾&lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;p class="suggset"&gt; &lt;a href=""&gt;故宫&lt;/a&gt; &lt;a href=""&gt;故宫&lt;/a&gt; &lt;a href=""&gt;故宫&lt;/a&gt; &lt;/p&gt; &lt;ul class="nav"&gt; &lt;li&gt; &lt;nuxt-link to="/" class="takeout"&gt;美团外卖&lt;/nuxt-link&gt; &lt;/li&gt; &lt;li&gt; &lt;nuxt-link to="/" class="movie"&gt;猫眼电影&lt;/nuxt-link&gt; &lt;/li&gt; &lt;li&gt; &lt;nuxt-link to="/" class="hotel"&gt;美团酒店&lt;/nuxt-link&gt; &lt;/li&gt; &lt;li&gt; &lt;nuxt-link to="/" class="apartment"&gt;民宿／公寓&lt;/nuxt-link&gt; &lt;/li&gt; &lt;li&gt; &lt;nuxt-link to="/" class="business"&gt;商家入驻&lt;/nuxt-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/el-col&gt; &lt;el-col :span="6" class="right"&gt; &lt;ul class="security"&gt; &lt;li&gt;&lt;i class="refund"&gt;&lt;/i&gt;&lt;p class="txt"&gt;随时退&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;i class="single"&gt;&lt;/i&gt;&lt;p class="txt"&gt;不满意免单&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;i class="overdue"&gt;&lt;/i&gt;&lt;p class="txt"&gt;过期退&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; search: '', isFoucs: false &#125; &#125;, computed: &#123; isSearchList () &#123; return this.isFoucs &amp;&amp; this.search &#125;, isHotList () &#123; return this.isFoucs &amp;&amp; !this.search &#125; &#125;, methods: &#123; foucs () &#123; this.isFoucs = true &#125;, blur () &#123; this.isFoucs = false &#125; &#125;&#125;&lt;/script&gt; 有事您Q我👇]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>component</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue技术栈-render和jsx]]></title>
    <url>%2Fvue%2Fvue%E6%8A%80%E6%9C%AF%E6%A0%88-render%E5%92%8Cjsx%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 渲染函数和JSX快速掌握 render-function render函数 h函数 有三个参数：第一个参数为必选参数(要渲染的组件或一个标签的字符串)，后两个为可选参数, 第二个参数为一个配置对象 第三个参数为字符串或数组 即元素要显示的文本内容或子节点 在vue中就是通过render函数将组件挂载到页面上的 渲染根组件APP 1render: h =&gt; h(App) 渲染一个元素div 12345678910render: h =&gt; &#123; return h('div', &#123; attrs: &#123; // 写原生的属性attrs对象 id: 'box' &#125;, style: &#123; // 写原生的样式style对象 color: 'red' &#125; &#125;, 'love')&#125; 渲染一个自己封装好的组件 CountTo 12345678910111213141516171819202122232425262728293031render: h =&gt; &#123; return h(CountTo, &#123; // 向组件中最外层元素绑定一个类名 // 'class': 'love sex', // 可以是字符串 // 'class': ['count-to', true ? 'wrapper' : 'box'], // 可以是数组，里面可以用逻辑表达式绑定类名 'class': &#123; 'number': true // 可以是对象 也可以用逻辑表达式 决定属性的有无 &#125;, attrs: &#123;&#125;, style: &#123;&#125;, props: &#123; // 向组件中传值props对象 endValue: 99999999 &#125;, domProps: &#123;&#125;, on: &#123; // 监听组件中抛出的事件 '组件中抛出的事件名' : val =&gt; &#123; // do something &#125; &#125;, nativeOn: &#123; // 绑定监听原生的点击事件 'click': () =&gt; &#123; console.log('click :', '原生的点击事件'); &#125; &#125;, directives:[], // 自定义指令 scopedSlots: &#123;&#125;, // 作用域插槽 slot: '', // 插槽 key: '', // key ref: '' // ref &#125;)&#125; 子节点必须放到一个数组中 12345678910111213141516171819/* 子节点的添加 */render: h =&gt; h('div', [ h('span', '111'), h('p', '222'),])// 可以这样render: h =&gt; h('div', [ h('ul', &#123; on: &#123; 'click': handleClick &#125;, &#125;,[ h('li', &#123; on: &#123; 'click': handleClick &#125; &#125;) ])]) 在render函数中模仿v-for循环产生元素 12345678910111213141516let arrName = [&#123;name: 'shulu'&#125;, &#123;name: 'yachan'&#125;, &#123;name: 'liuqiuyun'&#125;]// 遍历调用h 函数const getArrName = (h) =&gt; arrName.map((item, index) =&gt; &#123; return h('li', &#123; on: &#123; 'click': handleClick &#125;, key: index &#125;, item.name) &#125;)render: h =&gt; h('div',[ h('ul', getArrName(h))]) 函数式组件和JSX views/render-page.vue中引入List列表组件 123456789101112131415161718192021222324252627282930313233343536// views/render-page.vue 中引入List列表组件&lt;template&gt; &lt;div&gt; &lt;list :items="items" :render="renderFunc"&gt;&lt;/list&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import List from '_c/list' // list文件夹下有 index.js 它引入并导出了List组件export default &#123; name: 'RenderPage', components: &#123; List, &#125;, data () &#123; return &#123; items: [ &#123;name: 'yachan'&#125;, &#123;name: 'shulu'&#125;, &#123;name: 'qiuyun'&#125; ] &#125; &#125;, methods: &#123; handleClick () &#123; console.log('click') &#125;, // 父组件使用时自己传入的标签例如i renderFunc (h, name) &#123; // JSX语法 return ( // 绑定事件 on- 前缀 nativeOn-click &lt;i on-click=&#123;this.handleClick&#125; style=&#123;&#123;color: 'pink'&#125;&#125;&gt;&#123;name&#125;&lt;/i&gt; ) &#125; &#125;&#125;&lt;/script&gt; views/List.vue 12345678910111213141516171819202122232425262728293031// views/List.vue&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for="(item, index) in items" :key="index"&gt; &lt;span v-if="!render"&gt;&#123;&#123; item.name &#125;&#125;&lt;/span&gt; &lt;render-dom v-else :render-func="render" :name="item.name"&gt;&lt;/render-dom&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import RenderDom from '_c/render-dom' // 引入函数式组件 shitexport default &#123; name: 'List', components: &#123; // 注册函数式组件 RenderDom &#125;, props: &#123; items: &#123; type: Array, default: () =&gt; [] &#125;, render: &#123; type: Function, default: () =&gt; &#123;&#125; &#125; &#125;&#125;&lt;/script&gt; 函数式组件 1234567891011// 一个普通的对象export default &#123; functional: true, props: &#123; // 接收的值 name: String, renderFunc: Function &#125;, render: (h, ctx) =&gt; &#123; // ctx 上下文环境 return ctx.props.renderFunc(h, ctx.props.name) &#125;&#125; 作用域插槽 属性slot-scope 1&lt;count-to slot-scope="count" :end-value="count.number"&gt;&lt;/count-to&gt; 有事您Q我👇]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>render</tag>
        <tag>jsx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue技术栈-第三方js库的使用]]></title>
    <url>%2Fvue%2Fvue%E6%8A%80%E6%9C%AF%E6%A0%88-%E7%AC%AC%E4%B8%89%E6%96%B9js%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 第三方js库的使用 这里以数字渐变的一个第三方js库为依赖，学习简单的组件的封装 CountUp.js 组件中使用id值 这个countup.js库的第一个参数为一个元素或组件的id值 我们知道id值在页面中是唯一的，所以我们的分装的组件要想复用就得使用不同的id this._uid 每一个vue组件都有唯一的标识 _uid, 我们通过计算属性的getter方法就可以拿到他 组件中获取dom 通过id值 通过ref属性 ref属性在元素上则拿到的是这个元素 ref属性在一个组件上则拿到的是这个组件 组件封装基础 新建components/count-to文件夹，存放我们创建的数字渐变的的组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// components/count-to/count-to.vue &lt;template&gt; &lt;div&gt; &lt;span :id="eleId" ref="number"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; CountUp &#125; from 'countup.js' // 引入countup.js库export default &#123; name: 'CountTo', data () &#123; return &#123; counter: &#123;&#125; &#125; &#125;, props: &#123; /* 最终值 */ endValue: &#123; type: Number, required: true &#125;, opations: &#123; // startVal?: number; // number to start at (0) startVal: 0, // decimalPlaces?: number; // number of decimal places (0) decimalPlaces: 0, // duration?: number; // animation duration in seconds (2) duration: 2, // useGrouping?: boolean; // example: 1,000 vs 1000 (true) useGrouping: true, // useEasing?: boolean; // ease animation (true) useEasing: true, // smartEasingThreshold?: number; // smooth easing for large numbers above this if useEasing (999) smartEasingThreshold: 999, // smartEasingAmount?: number; // amount to be eased for numbers above threshold (333) smartEasingAmount: 333, // separator?: string; // grouping separator (',') separator: ',', // decimal?: string; // decimal ('.') decimal: '.', // easingFn: easing function for animation (easeOutExpo) // easingFn?: (t: number, b: number, c: number, d: number) =&gt; number; // formattingFn?: (n: number) =&gt; string; // this function formats result // prefix?: string; // text prepended to result prefix: '', // suffix?: string; // text appended to result suffix: '' // numerals?: string[]; // numeral glyph substitution &#125; &#125;, mounted () &#123; this.$nextTick(() =&gt; &#123; // dom渲染完成之后调用次回调函数 this.counter = new CountUp(this.eleId, this.endValue , this.opations) &#125;) setTimeout(() =&gt; &#123; // 这个start一定要放在setTimeout等有延迟的方法之中调用 this.counter.start() &#125;, 0) &#125;, computed: &#123; /* 第一个参数 元素的id值 */ eleId () &#123; return `count_up_$&#123;this._uid&#125;` // 每一个组件都有唯一的标识 _uid &#125; &#125;, methods: &#123; getNumber () &#123; // 组件中的dom获取操作 const text = this.$refs.number.innerText let num = text.replace(/[\u4e00-\u9fa5]/g, '').substring(1) return num &#125; &#125;&#125;&lt;/script&gt; components/count-to/index.js 12345// components/count-to/index.jsimport CountTo from './count-to'export default CountTo// 这样们使用这个组件的时候只需要引入components/count-to即可 创建完了组件，下面我们来使用一下 只需要把以下的组件在页面中展示一下 1234567891011121314151617181920212223242526272829303132333435// 新建一个组件 &lt;template&gt; &lt;div&gt; &lt;count-to class="numto" ref="countTo" :end-value="10000.34" :opations="&#123; duration: 10, decimalPlaces: 2, prefix: '金额：', suffix: '元' &#125;"&gt; &lt;/count-to&gt; &lt;button @click="getNum"&gt;getNum&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import CountTo from '_c/count-to' export default &#123; name: 'count_to', components: &#123; CountTo &#125;, methods: &#123; getNum () &#123; console.log(this.$refs.countTo.getNumber()) // 调用子组件的方法 &#125; &#125;&#125;&lt;/script&gt;&lt;style lang="less"&gt; .numto&#123; color:red; &#125;&lt;/style&gt; 有事您Q我👇]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue技术栈-状态管理vuex进阶2]]></title>
    <url>%2Fvue%E6%8A%80%E6%9C%AF%E6%A0%88-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86vuex%E8%BF%9B%E9%98%B62%2Fvue%E6%8A%80%E6%9C%AF%E6%A0%88-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86vuex%E8%BF%9B%E9%98%B62%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; Vuex插件 实现一个简单的本地化存储插件 即浏览器刷新之后状态不会变 123456789101112// store/plugin/saveInlocal.jsexport default (store) =&gt; &#123; // 当 store 初始化后调用 console.log('store初始化了') if (localStorage.state) store.replaceState(JSON.parse(localStorage.state)) store.subscribe((mutation, state) =&gt; &#123; // 每次 mutation 之后调用 // mutation 的格式为 &#123; type, payload &#125; console.log('提交了mutation') localStorage.state = JSON.stringify(state) &#125;)&#125; 1234567// store/index.jsimport saveInLocal from '../store/plugin/saveInLocal'export default new Vuex.Store(&#123; // ... plugins: [ saveInLocal ] // 绑定插件&#125;) Vuex严格模式 不要在发布环境下启用严格模式！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。 在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。 类似于插件，我们可以让构建工具来处理这种情况： 1234const store = new Vuex.Store(&#123; // ... strict: process.env.NODE_ENV !== 'production' // 开发环境开启严格模式调试&#125;) Vuex双向绑定state的某一状态 在计算属性的setter中调用mutation来改变state的状态 123&lt;!-- 双向绑定 --&gt;&lt;input v-model="myNameFromState"/&gt; &lt;p&gt;&#123;&#123; myNameFromState &#125;&#125;&lt;/p&gt; 123456789101112// 任意组件computed: &#123; myNameFromState: &#123; get () &#123; return this.$store.state.myName &#125;, set (value) &#123; // 在计算属性的setter中调用mutation 来改变state this.CHANGE_STATE_MYNAME(value) &#125; &#125;&#125; 123456// store/state.jsconst state = &#123; myName: 'yachan',&#125;export default state 12345678// store/mutations.jsconst mutations = &#123; CHANGE_STATE_MYNAME (state, val) &#123; state.myName = val &#125;&#125;export default mutations 有事您Q我👇]]></content>
      <categories>
        <category>vue技术栈-状态管理vuex进阶2</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue技术栈-状态管理vuex进阶1]]></title>
    <url>%2Fvue%2Fvue%E6%8A%80%E6%9C%AF%E6%A0%88-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86vuex%E8%BF%9B%E9%98%B61%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; vuex之module模块中参数详解 以下以store/module/user.js模块为例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// store/module/user.jsconst state = &#123; sexName: 'yachan mei mei', phoneNumber: 1123&#125;const getters = &#123; addlover: (state) =&gt; &#123; return state.sexName + ' I love you' &#125;, getCode: (state, getters, rootState, rootGetters) =&gt; &#123; // 前两个参数为当前模块的局部的对象，后两个参数为全局的对象 // 通过全局的对象的点操作就可以得到下面每一层级的对象 console.log('state :', state) // 局部 console.log('getters :', getters) // 局部 console.log('getters.addlover :', getters.addlover) // 得到当前模块的getters的某一属性 console.log('rootState :', rootState) // 全局state console.log('rootGetters :', rootGetters) // 全局getters // console.log('rootGetters.nameOnlyLastLetter :', rootGetters.nameOnlyLastLetter) // 得到rootGetters的某一个属性 &#125;&#125;const mutations = &#123; CHANGE_PHONE_NUMBER (state, params) &#123; state.phoneNumber += params &#125;&#125;const actions = &#123; // 查看actions的各个参数 // commit最常用 用于提交mutation someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123; console.log('dispatch :', dispatch) console.log('commit :', commit) console.log('getters :', getters) console.log('rootGetters :', rootGetters) &#125;, // 组合 action 看看dispatch的用处 actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('someMutation') resolve() &#125;, 1000) &#125;) &#125;, // 参数dispatch可以在另外一个 action 中分发其他的action actionB (&#123; dispatch, commit &#125;) &#123; return dispatch('actionA').then(() =&gt; &#123; commit('someOtherMutation') &#125;).catch((err) =&gt; &#123; console.log('err :', err) &#125;) &#125;, // 利用 async / await，我们可以如下组合 action // 假设 getData() 和 getOtherData() 返回的是 Promise async actionC (&#123; commit &#125;) &#123; commit('gotData', await getData()) &#125;, async actionD (&#123; dispatch, commit &#125;) &#123; await dispatch('actionC') // 等待 actionC 完成 commit('gotOtherData', await getOtherData()) &#125;&#125;export default &#123; namespaced: true, // 使用命名空间 state, getters, actions, mutations, modules: &#123; // 还可以嵌套模块 &#125;&#125; 带命名空间的绑定函数 1写起来可能比较繁琐 123456789101112computed: &#123; ...mapState(&#123; a: state =&gt; state.some.nested.module.a, b: state =&gt; state.some.nested.module.b &#125;)&#125;,methods: &#123; ...mapActions([ 'some/nested/module/foo', // -&gt; this['some/nested/module/foo']() 'some/nested/module/bar' // -&gt; this['some/nested/module/bar']() ])&#125; 2简化写法 将模块的空间名称字符串作为第一个参数传递给上述函数 123456789101112computed: &#123; ...mapState('some/nested/module', &#123; a: state =&gt; state.a, b: state =&gt; state.b &#125;)&#125;,methods: &#123; ...mapActions('some/nested/module', [ 'foo', // -&gt; this.foo() 'bar' // -&gt; this.bar() ])&#125; 3创建基于某个命名空间的辅助函数 1234567891011121314151617181920mport &#123; createNamespacedHelpers &#125; from 'vuex'const &#123; mapState, mapActions &#125; = createNamespacedHelpers('some/nested/module')export default &#123; computed: &#123; // 在 `some/nested/module` 中查找 ...mapState(&#123; a: state =&gt; state.a, b: state =&gt; state.b &#125;) &#125;, methods: &#123; // 在 `some/nested/module` 中查找 ...mapActions([ 'foo', 'bar' ]) &#125;&#125; 动态模块注册 在 store 创建之后，你可以使用 store.registerModule 方法注册模块 12&lt;button @click="registerModule"&gt;动态注册模块&lt;/button&gt;&lt;p&gt;&#123;&#123; myMoney &#125;&#125;&lt;/p&gt; 123456789101112131415161718192021// 任意组件import &#123; mapState &#125; from 'vuex'computed: &#123; ...mapState(&#123; myMoney: state =&gt; state.myModule ? state.myModule.myMoney : [] // myModule模块创建完成后获取其状态 &#125;)&#125;,methods: &#123; registerModule () &#123; this.$store.registerModule('myModule', &#123; // 动态创建模块 state: &#123; myMoney: 999999999999 &#125; &#125;) &#125;&#125;// 注册嵌套模块 `nested/myModule`store.registerModule(['nested', 'myModule'], &#123; // ...&#125;) 有事您Q我👇]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue技术栈-状态管理vuex基础]]></title>
    <url>%2Fvue%2Fvue%E6%8A%80%E6%9C%AF%E6%A0%88-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86vuex%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;优美的代码要有好的状态管理，美好的人生也是如此。 Vuex之state mapGetters,mapState是一些属性之类的 要放到computed里面 全局state的使用123456// 全局的state.jsconst state = &#123; myName: 'yachan' // 记录一个值为myName&#125;export default state 123456789// 任意一个组件&lt;p&gt;Vuex-state.maName:&#123;&#123; myName &#125;&#125;&lt;/p&gt; // 展示一下// 获取myNamecomputed: &#123; myName () &#123; return this.$store.state.myName &#125;&#125; modules模块之内的state的使用12345678910111213// module/user.jsconst state = &#123; sexName: '女神'&#125;const mutations = &#123; &#125;const actions = &#123; &#125;export default &#123; state, mutations, actions&#125; 123456789101112131415// 任意组件&lt;p&gt;Vuex-state.sexName:&#123;&#123; sexName &#125;&#125;&lt;/p&gt; // 展示一下import &#123; mapState &#125; from 'vuex' //引入mapStatecomputed: &#123; // sexName () &#123; // 方式一 // return this.$store.state.user.sexName // &#125; ...mapState(&#123; // 方式二 myName: state =&gt; state.myName, sexName: state =&gt; state.user.sexName &#125;)&#125; 命名空间的使用123456789101112131415// 命名空间的使用// module/user.jsconst state = &#123; sexName: '女神'&#125;const mutations = &#123; &#125;const actions = &#123; &#125;export default &#123; namespaced: true, // 命名空间的使用 state, mutations, actions&#125; 123456789101112131415161718// 任意组件// 方式一// import &#123; createNamespacedHelpers &#125; from 'vuex'// const &#123; mapState &#125; = createNamespacedHelpers('user') // 使用命名空间// computed: &#123;// ...mapState(&#123;// sexName: state =&gt; state.sexName// &#125;)// &#125;// 方式二import &#123; mapState &#125; from 'vuex' computed: &#123; ...mapState('user', &#123; // 这里的第一个参数为模块名 sexName: state =&gt; state.sexName &#125;)&#125; Vuex之getters 有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数： 123456// 例如对列表进行过滤并计数computed: &#123; doneTodosCount () &#123; return this.$store.state.todos.filter(todo =&gt; todo.done).length &#125;&#125; 如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。 Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 Getter 接受 state 作为其第一个参数： 12345678910111213141516// store/getters.jsconst getters = &#123; // 定义一个获取state中的myName的最后一个字母的属性 nameOnlyLastLetter: (state) =&gt; &#123; // 这里是全局可以使用的方法 return state.myName.substr(-1, 1) &#125;&#125;export default getters// 在store/index.js中需要引入，并注入Vuex 这里不再演示// 组件中使用&lt;p&gt;nameOnlyLastLetter: &#123;&#123; nameOnlyLastLetter &#125;&#125;&lt;/p&gt; // 展示...mapGetters(['nameOnlyLastLetter']) // 获取 Vuex之mutations mutation 必须同步执行。 mapActions, mapMutations里面是一些方法 要放到methods里面 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。 以下为一个通过mutations改变state中的myName的小例子: 12345678// store/mutations.jsconst mutations = &#123; CHANGE_STATE_MYNAME (state, val) &#123; state.myName = val &#125;&#125;export default mutations 12345678// 任意的组件中// 展示省略methods: &#123; ...mapMutations(['CHANGE_STATE_MYNAME']), // 拿到CHANGE_STATE_MYNAME这个方法 changeName () &#123; this.CHANGE_STATE_MYNAME('liu yachan') // 调用这个方法并传值去直接改变state中的值 &#125;&#125; 动态往state中添加一个状态 123456789101112import vue from 'vue' // 引入vueconst mutations = &#123; CHANGE_STATE_MYNAME (state, val) &#123; state.myName = val &#125;, ADD_AGE (state) &#123; vue.set(state, 'age', '18') // 使用vue.set(对象，'属性', '属性值') &#125;&#125;export default mutations Vuex之Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 1234567891011// api/app.js// 定义一个异步获取数据的方法export const getHobby = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const err = null setTimeout(() =&gt; &#123; if (!err) resolve(&#123;code: 200, info: &#123;hobby: 'sleep'&#125;&#125;) else reject(err) &#125;) &#125;)&#125; 123456789101112131415161718192021222324// store/actions.jsimport &#123; getHobby &#125; from '@/api/app'const actions = &#123; // updateHobby (&#123; commit &#125;) &#123; // getHobby().then(res =&gt; &#123; // const &#123; info: &#123; hobby &#125; &#125; = res // 解构赋值 // commit('UPDATE_HOBBY', hobby) // 在这里提交mutation 并且传值过去 // &#125;).catch((err) =&gt; &#123; // console.log('err :', err) // &#125;) // &#125; async updateHobby (&#123; commit &#125;) &#123; // ES7的async也行 更好 try &#123; const &#123; info: &#123; hobby &#125; &#125; = await getHobby() commit('UPDATE_HOBBY', hobby) &#125; catch (error) &#123; // 一定要捕获错误 console.log('error :', error) &#125; &#125;&#125;export default actions 12345678910// store/actions.jsimport vue from 'vue'const mutations = &#123; UPDATE_HOBBY (state, val) &#123; state.hobby = val // 在这里直接修改state的属性hobby &#125;&#125;export default mutations 123456789101112131415// 任意组件&lt;p class="font-color"&gt;hobby: &#123;&#123;hobby&#125;&#125;&lt;/p&gt; // 展示&lt;button @click="changeHobby"&gt;changeHobby&lt;/button&gt;imoprt &#123; mapState &#125; from 'vuex'computed: &#123; ...mapState(['hobby']) // 获取hobby&#125;,methods: &#123; changeHobby () &#123; this.updateHobby() // 这里调用action里的方法 &#125;&#125; 有事您Q我👇]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue技术栈-状态管理Bus]]></title>
    <url>%2Fvue%2Fvue%E6%8A%80%E6%9C%AF%E6%A0%88-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86Bus%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;好想再见见你…… 状态管理之bus总线 bus即一个空的vue实例 一个中央事件总线bus,可以作为一个简单的组件传递数据,用于解决跨级和兄弟组件通信问题。 在要实现通信的组件间都引入bus，分别触发和监听事件并传递值。 下面是一个兄弟组件间传值的例子： 1234// lib/bus.jsimport Vue from 'vue'export const bus = new Vue() // 创建bus 123456789101112131415161718// views/Email.vue&lt;template&gt; &lt;div&gt; this is email 组件 &lt;input type="button" value="点点我" @click="handleClick"/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; bus &#125; from '@/lib/bus' // 引入busexport default &#123; methods: &#123; handleClick () &#123; bus.$emit('on-click', 'hello-tel') &#125; &#125;&#125;&lt;/script&gt; 1234567891011121314151617181920212223// views/Tel.vue&lt;template&gt; &lt;div&gt; this is tel 组件 &lt;p&gt;value:&#123;&#123; valueFromEmail &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; bus &#125; from '@/lib/bus' // 引入busexport default &#123; data () &#123; return &#123; valueFromEmail: '' &#125; &#125;, created () &#123; bus.$on('on-click', val =&gt; &#123; this.valueFromEmail = val &#125;) &#125;&#125;&lt;/script&gt; 有事您Q我👇]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue技术栈-路由进阶2]]></title>
    <url>%2Fvue%2Fvue%E6%8A%80%E6%9C%AF%E6%A0%88-%E8%B7%AF%E7%94%B1%E8%BF%9B%E9%98%B62%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 完整的导航解析流程 来自官网 导航被触发。 在失活的组件里调用离开守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 路由元信息 定义路由的时候可以配置 meta 字段： 123456789// router.js&#123; path: '/about', name: 'about', component: () =&gt; import('@/views/About'), meta: &#123; // 路由元信息 title: 'about' //页面的title &#125;&#125; 1234// lib/util.jsexport const setTitle = (title) =&gt; &#123; window.document.title = title || 'admin' //默认title为admin&#125; 123456// router/index.js// 全局前置守卫router.beforeEach((to, from, next) =&gt; &#123; // 路由元信息存在时调用设置title的方法 to.meta &amp;&amp; setTitle(to.meta.title) &#125;) 过渡效果 单个路由的过渡 123&lt;transition&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; 一组路由的过渡 1234567891011121314// 例如：App.vue&lt;template&gt; &lt;div id="app"&gt; &lt;div id="nav"&gt; &lt;router-link :to="&#123; name: 'home' &#125;"&gt;Home&lt;/router-link&gt; | &lt;router-link :to="&#123; name: 'about' &#125;"&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;transition-group :name="transitionName"&gt; &lt;router-view key="default"/&gt; &lt;router-view key="email" name="email"/&gt; &lt;router-view key="tel" name="tel"/&gt; &lt;/transition-group&gt; &lt;/div&gt;&lt;/template&gt; 1234567891011121314151617export default &#123; data() &#123; return &#123; transitionName: '', &#125; &#125;, // watch $route 决定使用哪种过渡 watch: &#123; '$route' (to, from) &#123; if (to.name === 'home') &#123; this.transitionName = 'transitionName' &#125; else &#123; this.transitionName = '' &#125; &#125; &#125;&#125; 1234567891011121314151617181920/* 进入 */.transitionName-enter&#123; opacity: 0;&#125;.transitionName-enter-active&#123; transition: opacity 1s ease;&#125;.transitionName-enter-to&#123; opacity: 1;&#125;/* 离开 */.transitionName-leave&#123; opacity: 1;&#125;.transitionName-leave-active&#123; transition: opacity 1s ease;&#125;.transitionName-leave-to&#123; opacity: 0;&#125; 路由懒加载&emsp;&emsp;当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。&emsp;&emsp;如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。 一般用于不常用的页面 12345// 例如404页面&#123; path: '*', // 所有匹配不到的路劲都会走到这里 component: () =&gt; import('@/views/Error_404.vue')&#125; 数据获取 详情见官网 &emsp;&emsp;有时候，进入某个路由后，需要从服务器获取数据。例如，在渲染用户信息时，你需要从服务器获取用户的数据。我们可以通过两种方式来实现： &emsp;&emsp;导航完成之后获取：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示。 &emsp;&emsp;导航完成之前获取：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。 &emsp;&emsp;从技术角度讲，两种方式都不错 —— 就看你想要的用户体验是哪种。 滚动行为&emsp;&emsp;使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。 注意: 这个功能只在支持 history.pushState 的浏览器中可用。 1234567891011// router/index.jsconst router = new Router(&#123; routes, scrollBehavior (to, from, savedPosition) &#123; if (savedPosition) &#123; return savedPosition // 保持原先的滚动位置 &#125; else &#123; return &#123; x: 0, y: 0 &#125; // 想要页面滚到顶部 &#125; &#125;&#125;) 有事您Q我👇]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue技术栈-路由进阶1]]></title>
    <url>%2Fvue%2Fvue%E6%8A%80%E6%9C%AF%E6%A0%88-%E8%B7%AF%E7%94%B1%E8%BF%9B%E9%98%B61%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 路由进阶路由组件传参1 动态路由 传入时props为布尔类型 12345678910111213141516171819202122// router.js 动态路由&#123; path: '/argu/:name', props: true // 布尔形式&#125;// Argue.vue&lt;template&gt; &lt;div&gt; &#123;&#123; name &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; name: &#123; type: String, default: 'yachan' // 默认值不见效果 &#125; &#125;&#125; 路由组件传参2 普通路由 传入时props为对象形式 123456789&#123; path: '/about', props: &#123; // 对象形式 food: 'banana' &#125;&#125;// 对应About.vue的结构同Argu的一样// props接收一下 模板中展示一下 路由组件传参3 普通路由 传入时props为函数形式 123456789&#123; path: '/', props: route =&gt; (&#123; // 函数形式 food: route.query.food // 例如 http://localhost:8080/#/?food=yachan &#125;)&#125;// 对应Home.vue的结构同Argu的一样// props接收一下 模板中展示一下 H5之history模式 默认为哈希模式即路劲中有#号 H5之history模式好看没有#号 12345// router/index.jsexport default new Router(&#123; mode: 'history', // H5 history模式 routes&#125;) 12345// router.js的最后添加&#123; path: '*', // 所有匹配不到的路劲都会走到这里 component: () =&gt; import('@/views/Error_404.vue')&#125; 导航守卫 “导航”表示路由正在发生改变。 即通过跳转或取消的方式守卫导航。 例如：路由跳转前做一些验证，比如登录验证，是网站中的普遍需求。 全局前置守卫 确保要调用 next 方法，否则钩子就不会被 resolved。 123456789101112131415161718// router/index.jsconst router = new Router(&#123; routes&#125;)const HAS_LOGINED = false // 模拟 假设还没有登录router.beforeEach((to, from, next) =&gt; &#123; if (to.name !== 'login') &#123; if (HAS_LOGINED) next() else next(&#123; name: 'login' &#125;) &#125; else &#123; if (HAS_LOGINED) next(&#123; name: 'home' &#125;) else next() &#125;&#125;)export default router 全局后置钩子 然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身 一般用来改变一些跳转前后的样式 1234// 全局后置钩子router.afterEach((to, from) =&gt; &#123; // &#125;) 路由独享的守卫 你可以在路由配置上直接定义 beforeEnter 守卫 1234567891011// router.js&#123; path: '/', name: 'home', component: Home, beforeEnter: (to, from, next) =&gt; &#123; if (from.name === 'about') alert('这是从about页面来的') else alert('这不是从about页面来的') next() // 一定要调用next 钩子 &#125;&#125; 组件内的守卫 可以在路由组件内直接定义以下路由导航守卫： 注意 beforeRouteEnter 是支持给 next 传递回调的唯一守卫 对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了 beforeRouteLeave这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。 12345678910111213141516171819202122232425// 组件内部beforeRouteEnter (to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建 // 不过可以通过回调来解决 // 次回调在页面被渲染完之后才被调用 next(vm =&gt; &#123; // 通过 `vm` 访问组件实例 console.log(vm) //vm即为当前组件实例 this &#125;)&#125;,beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this`&#125;,beforeRouteLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` const leave = confirm('您确定要离开吗？当前编辑的内容还没有被保存') if (leave) next() // 用户点击了确定 则跳转页面 else next(false) // 页面不会跳转&#125; 有事您Q我👇]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue技术栈-路由基础]]></title>
    <url>%2Fvue%2Fvue%E6%8A%80%E6%9C%AF%E6%A0%88-%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 路由基础路由组件12&lt;router-link&gt;内部封装了a标签&lt;router-link/&gt; &lt;router-view/&gt; 该组件为当前路由跳转展示的区域 动态路由12345678910111213141516// router.js&#123; path: '/argu/:name', //这里注意是 /: component: () =&gt; import('@/views/Argu')&#125;// 在Argu.vue中&lt;template&gt; &lt;div&gt; &#123;&#123; $route.params.name &#125;&#125; &lt;/div&gt;&lt;/template&gt;// 在浏览器窗口http://localhost:8083/#/argu/shulu即可在页面上看到 shulu 嵌套路由1234567891011121314151617181920212223242526// router.js&#123; path: '/parent', component: () =&gt; import('@/views/Parent'), children: [ //children是一个数组 好久不写都忘记了 &#123; path: 'child', //这里直接写路劲的名字即可不要‘/’ component: () =&gt; import('@/views/Child') &#125; ]&#125;// Parent.vue&lt;template&gt; &lt;div&gt; i am parent &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;// Child.vue&lt;template&gt; &lt;div&gt; i am child &lt;/div&gt;&lt;/template&gt; 命名路由12345678910// App.vue原来的样子注意router-link&lt;template&gt; &lt;div id="app"&gt; &lt;div id="nav"&gt; &lt;router-link to="/"&gt;Home&lt;/router-link&gt; | &lt;router-link to="/about"&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; 12345678910111213141516171819// App.vue使用命名路由的样子注意router-link// 首先router.js&#123; path: '/', name: 'home', //这里添加一个name属性 component: Home&#125;// App.vue&lt;template&gt; &lt;div id="app"&gt; &lt;div id="nav"&gt; &lt;router-link :to="&#123; name: 'home' &#125;"&gt;Home&lt;/router-link&gt; | &lt;router-link :to="&#123; name: 'about' &#125;"&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; 命名视图12345678910111213141516171819202122// router.js&#123; path: '/named_view', components: &#123; default: () =&gt; import('@/views/Child'), email: () =&gt; import('@/views/Email'), tel: () =&gt; import('@/views/Tel') &#125;&#125;// App.vue&lt;template&gt; &lt;div id="app"&gt; &lt;div id="nav"&gt; &lt;router-link :to="&#123; name: 'home' &#125;"&gt;Home&lt;/router-link&gt; | &lt;router-link :to="&#123; name: 'about' &#125;"&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;router-view/&gt; //渲染默认路由 &lt;router-view name="email"/&gt; //渲染指定路由 &lt;router-view name="tel"/&gt; //渲染制定路由 &lt;/div&gt;&lt;/template&gt; 编程导航路由 即js操作路由 123456789101112131415161718192021222324252627// Home.vue&lt;template&gt; &lt;div class="home"&gt; &lt;button @click="handleClick"&gt;返回上一级&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// @ is an alias to /srcimport HelloWorld from '@/components/HelloWorld.vue'export default &#123; name: 'home', components: &#123; HelloWorld &#125;, methods: &#123; handleClick () &#123; this.$router.go(-1) //回退 // this.$router.back() 回退 // this.$router.replace() //替换 // this.$router.push() //往历史记录里面添加一条记录 &#125; &#125;&#125;&lt;/script&gt; 重定向和别名 重定向 123456789101112// router.js&#123; path: '/yachan', //重定向 redirect: '/' 方式一 // redirect: &#123; // name: 'home' 方式二 // &#125; // redirect: to =&gt; '/' 方式三&#125; 别名 123456&#123; path: '/', alias: '/home_page', //起一个别名 注意前面有 '/' name: 'home', component: Home&#125; 有事您Q我👇]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue技术栈-配置篇]]></title>
    <url>%2Fvue%2Fvue%E6%8A%80%E6%9C%AF%E6%A0%88-%E9%85%8D%E7%BD%AE%E7%AF%87%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 配置项目项目最外层文件的配置 在项目目录下添加 vue.config.js文件并配置为： 1234567891011121314151617const path = require("path")const resolve = dir =&gt; path.join(__dirname, dir)const BASE_URL = process.env.NODE_ENV === "production" ? "/iview-admin" : '/'module.exports = &#123; publicPath: BASE_URL, chainWebpack: config =&gt; &#123; config.resolve.alias .set('@', resolve('src'))//别名，以后使用时@就代替src目录路劲 .set("_c", resolve("src/components")) &#125;, productionSourceMap: false, //打不生成.map文件 速度块一些' devServer: &#123; proxy: 'http://localhost:4000' //跨域配置， &#125;,&#125; src目录的文件配置 添加api文件夹 添加config文件夹里面为index.js 添加directive文件夹里面为index.js 添加lib文件夹里面为tool.js(纯工具文件), util.js 添加mock文件夹里面为index.js配置如下： 12345// 首先 npm install mockjs -Dimport Mock from 'mockjs'// export default Mock 添加router文件夹里面为index.js, router.js配置为： 12345678910// index.jsimport Vue from 'vue'import Router from 'vue-router'import routes from './router'Vue.use(Router)export default new Router(&#123; routes&#125;) 123456789101112131415// router.jsimport Home from '@/views/Home'export default [ &#123; path: '/', name: 'home', component: Home &#125;, &#123; path: '/about', name: 'about', component: () =&gt; import(/* webpackChunkName: "about" */ '@/views/About') &#125;] 添加store文件夹里面为index.js, state.js, actions.js, mutations.js, module文件夹(里面为user.js等) 123456789101112131415161718// index.jsimport Vue from 'vue'import Vuex from 'vuex'import state from './state'import actions from './actions'import mutations from './mutations'import user from './module/user'Vue.use(Vuex)export default new Vuex.Store(&#123; state, mutations, actions, modules: &#123; // 注意这里是modules复数 user &#125;&#125;) 12345678910111213141516// module/user.jsconst state = &#123;&#125;const mutations = &#123;&#125;const actions = &#123;&#125;export default &#123; state, mutations, actions,&#125; 有事您Q我👇]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue技术栈-创建篇]]></title>
    <url>%2Fvue%2Fvue%E6%8A%80%E6%9C%AF%E6%A0%88-%E5%88%9B%E5%BB%BA%E7%AF%87%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;vue技术栈开发实战tallkingData数据可视化前端工程师lison课程学习笔记 创建项目项目初始化创建 经过测试在git bash里面有问题，&gt;这个符号选择配置时切换不起作用，换为cmd窗口之则可以 在一个空的文件夹里面执行 vue create 项目名称 选择手动配置 根据提示选择配置比如vuex等 配置完成后 回车 即可开始创建一个新的项目 下载好依赖之后，根据提示，cd 到项目文件夹，npm run serve 即可开启一个本地服务，和一个线上服务(局域网内可以访问的) 有事您Q我👇]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue官方编码规范指南]]></title>
    <url>%2Fvue%2Fvue%E5%AE%98%E6%96%B9%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; vue 官方编码风格指南 总结 组件名应多个单词命名避免单个单词名词 组件数据 组件的 data 必须是一个函数 Prop 定义 Prop 定义应该尽量详细 避免 v-if 和 v-for 用在一起在同一个元素 组件名中的单词顺序组件名应该以高级别的单词开头，以描述性的修饰词结尾。多级目录的方式在100+组件时才考虑。 完整单词的组件名 Prop 名大小写 驼峰命名 模板中使用中划线的方式 多个特性的元素应该分多行撰写，每个特性一行 应该把复杂计算属性分割为尽可能多的更简单的属性 样式中慎用元素选择器 多用类名 有事您Q我👇]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式基础]]></title>
    <url>%2Fresponsive%2Fm-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;你过得好，那就是我最大的幸福。 响应式开发网页布局方式 固定宽度布局：为网页设置一个固定的宽度，通常以px做为长度单位，常见于PC端网页。 流式布局：为网页设置一个相对的宽度，通常以百分比做为长度单位。 栅格化布局：将网页宽度人为的划分成均等的长度，然后排版布局时则以这些均等的长度做为度量单位，通常利用百分比做为长度单位来划分成均等的长度。 响应式布局：通过检测设备信息，决定网页布局方式，即用户如果采用不同的设备访问同一个网页，有可能会看到不一样的内容，一般情况下是检测设备屏幕的宽度来实现。 注：以上几种布局方式并不是独立存在的，实际开发过程中往往是相互结合使用的。 响应式布局-媒体查询 利用媒体查询可以检测到屏幕的尺寸（主要检测宽度），并设置不同的CSS样式，就可以实现响应式的布局。 响应式布局常用于企业的官网、博客、新闻资讯类型网站，这些网站以浏览内容为主，没有复杂的交互。 响应式开发的目的就是:一个网站能够兼容多种终端 响应式开发的原理：媒体查询 常见媒体类型 通过查询screen的宽度来指定某个宽度区间的网页布局。 1234超小屏幕 (移动设备) w&lt;768px 小屏设备 768 &lt;= w &lt;992中等屏幕 992 =&lt; w &lt;1200宽屏设备 1200px以上 w&gt;=1200 书写方式 一般判断最小宽度 并且由小到大 后面的样式覆盖前面的样式 注意and后面空格的添加 123456789101112131415161718192021body&#123; background-color: pink;&#125;@media screen and (min-width: 768px) &#123; body&#123; background-color: red; &#125;&#125;@media screen and (min-width: 992px) &#123; body&#123; background-color: red; &#125;&#125;@media screen and (min-width: 1200px) &#123; body&#123; background-color: red; &#125;&#125;如果按max-width来算的话 就将值从大往小写 另一种书写方式-更好一些 判断引入满足媒体条件的css样式 12&lt;link rel="stylesheet" href="a.css"&gt;&lt;link rel="stylesheet" href="a.css" media="screen and (min-width: 992px) and (max-width: 1200px)" href="b.css"&gt; 有事您Q我👇]]></content>
      <categories>
        <category>responsive</category>
      </categories>
      <tags>
        <tag>mobile</tag>
        <tag>responsive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[m-移动端-插件]]></title>
    <url>%2Fmobile%2Fm-%E7%A7%BB%E5%8A%A8%E7%AB%AF-%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 移动端插件的使用swiper.js html 结构： 1234567891011121314151617181920&lt;div class="swiper-container"&gt; &lt;ul class="swiper-wrapper clearfix"&gt; &lt;li class="swiper-slide"&gt; &lt;a href="javascript:;"&gt; &lt;img src="./uploads/l1.jpg" alt="" /&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class="swiper-slide"&gt; &lt;a href="javascript:;"&gt; &lt;img src="./uploads/l5.jpg" alt="" /&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class="swiper-pagination"&gt;&lt;/div&gt; &lt;!--分页器。如果放置在swiper-container外面，需要自定义样式。--&gt; &lt;div class="swiper-button-prev"&gt;&lt;/div&gt; &lt;!--左箭头。如果放置在swiper-container外面，需要自定义样式。--&gt; &lt;div class="swiper-button-next"&gt;&lt;/div&gt; &lt;!--右箭头。如果放置在swiper-container外面，需要自定义样式。--&gt;&lt;/div&gt; 常用的配置如下： 12345678910111213141516171819202122232425var mySwiper = new Swiper(".swiper-container", &#123; // autoplay: true, speed: 1000, //轮播速度 autoplay: &#123; disableOnInteraction: false //鼠标操作后重新开启自动轮播 &#125;, loop: true, //轮播图片循环 grabCursor: true, //鼠标操作形状 effect: "cube", //3D旋转效果 cubeEffect: &#123; slideShadows: true, shadow: true, shadowOffset: 50, //阴影距离 shadowScale: 0.8 //阴影缩放比例 &#125;, pagination: &#123; //分页 即小点点 el: ".swiper-pagination" &#125;, navigation: &#123; //左右按钮 nextEl: ".swiper-button-next", prevEl: ".swiper-button-prev" &#125;&#125;); iscroll.js 为滚动起容器增加 position:relative 或者 absolute 样式。 容器需要超出隐藏 html 结构： 1234567&lt;div id="wrapper"&gt; &lt;ul&gt; &lt;li&gt;&amp;#x26C5;&lt;/li&gt; &lt;li&gt;&amp;#x26C5;&lt;/li&gt; &lt;li&gt;&amp;#x26C5;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 常见配置： 1234567891011121314151617181920212223242526// 在文档加载完成之后window.onload = function() &#123; var myScroll = new IScroll("#wrapper", &#123; mouseWheel: true, // 响应鼠标中建 scrollbars: true, // 显示滚动条 interactiveScrollbars: true // 可拖动的滚动条 &#125;); // scrollTo(x, y, time, easing) 滚动到指定的位置 setTimeout(() =&gt; &#123; myScroll.scrollTo(0, -100, 500, IScroll.utils.ease.elastic); &#125;, 1000); // scrollBy(x, y, time, easing) 可以传递X和Y的值从当前位置进行滚动 setTimeout(() =&gt; &#123; myScroll.scrollBy(0, -200, 1000, IScroll.utils.ease.bounce); &#125;, 2000); // scrollToElement(el, time, offsetX, offsetY, easing) //滚动到指定元素的左上角位置。 // 测试时 无效果啊 var wrapper = document.querySelector("#wrapper"); setTimeout(() =&gt; &#123; myScroll.scrollToElement(wrapper, 1000, 0, 0, IScroll.utils.ease.bounce); console.log("1 :", 1); &#125;, 3000);&#125;; better-scroll.js 基于iscroll.js fastclick.js 直接拿来用就行了 touch 有点透效果 click 有延迟效果 fastclick 则无点透 无延迟 适用于 PC 和移动端 这一段代码是从 github 官网上复制来的： 123456789if ("addEventListener" in document) &#123; document.addEventListener( "DOMContentLoaded", function() &#123; FastClick.attach(document.body); &#125;, false );&#125; 有事您Q我👇]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>mobile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mobile-基础]]></title>
    <url>%2Fmobile%2Fm-%E7%A7%BB%E5%8A%A8%E7%AB%AF-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;情感宣言——世界上最好的事，莫过于一句欣赏，一句懂得。 移动端基础 移动设备与 PC 设备最大的差异在于屏幕，这主要体现在屏幕尺寸和屏幕分辨率两个方面。 屏幕尺寸 通常我们所指的屏幕尺寸，实际上指的是屏幕对角线的长度（一般用英寸来度量） 屏幕分辨率 分辨率则一般用像素来度量 px，表示屏幕水平和垂直方向的像素数，例如 1920*1080 指的是屏幕垂直方向和水平方向分别有 1920 和 1080 个像素点而构成。 长度单位 在 Web 开发中可以使用 px（像素）、em、pt（点）、in（英寸）、cm（厘米）做为长度单位，我们最常用 px（像素）做为长度单位。 我们可以将上述的几种长度单位划分成相对长度单位和绝对长度单位。 例如：iPhone3G/S 和 iPhone4/S 的屏幕尺寸都为 3.5 英寸（in）但是屏幕分辨率却分别为 480320px、960480px，由此我们可以得出英寸是一个绝对长度单位，而像素是一个相对长度单位（像素并没有固定的长度）。 像素密度 PPI 利用勾股定理我们可以计算得出 PPI。 PPI 值的越大说明单位尺寸里所能容纳的像素数量就越多，所能展现画面的品质也就越精细，反之就越粗糙。 Retina 即视网膜屏幕，苹果注册的命名方式，意指具有较高 PPI（大于 320）的屏幕。 思考：在屏幕尺寸（英寸）固定时，PPI 和像素大小的关系？ 结论：屏幕尺寸固定时，当 PPI 越大，像素的实际大小就会越小，当 PPI 越小，像素实际大小就越大。(像素是一个相对长度单位) 设备独立像素 随着技术发展，设备不断更新，出现了不同 PPI 的屏幕共存的状态（如 iPhone3G/S 为 163PPI，iPhone4/S 为 326PPI），像素不再是统一的度量单位，这会造成同样尺寸的图像在不同 PPI 设备上的显示大小不一样。 假设你设计了一个 163·163 的蓝色方块，在 PPI 为 163 的屏幕上，那这个方块看起来正好就是 1·1 寸大小，在 PPI 为 326 的屏幕上，这个方块看起来就只有 0.5*0.5 寸大小了。 做为用户是不会关心这些细节的，他们只是希望在不同 PPI 的设备上看到的图像内容差不多大小，所以这时我们需要一个新的单位，这个新的单位能够保证图像内容在不同的 PPI 设备看上去大小应该差不多，这就是独立像素，在 IOS 设备上叫 PT(Point)，Android 设备上叫 DIP(Device independent Pixel)或 DP。 举例说明就是 iPhone 3G（PPI 为 163）1dp = 1px，iPhone 4（PPI 为 326）1dp = 2px。 我们也不难发现，如果想要 iPhone 3G/S 和 iPhone 4/S 图像内容显示一致，可以把 iPhone 4/S 的尺寸放大一倍（它们是一个 2 倍(@2x)的关系），即在 iPhone3G/S 的上尺寸为 44·44px，在 iPhone4/S 上为 88·88px，我们要想实现这样的结果可以设置 44·44dp，这时在 iPhone3G/S 上代表 44·44px，在 iPhone4/S 上代表 88*88px，最终用可以看到的图像差不多大小。 dp 同 px 是有一个对应（比例）关系的，这个对应（比例）关系是操作系统确定并处理，目的是确保不同 PPI 屏幕所能显示的图像大小是一致的，通过 window.devicePixelRatio 可以获得该比例值。 12// 获取设备独立像素 (像素比)window.devicePixelRatio; dp（或 pt）和 px 并不总是绝对的倍数关系（并不总能保证能够整除），而是 window.devicePixelRatio ~= 物理像素/独立像素，然而这其中的细节我们不必关心，因为操作系统会自动帮我们处理好（保证 1dp 在不同的设备上看上去大小差不多）。 像素 物理像素指的是屏幕渲染图像的最小单位，属于屏幕的物理属性，不可人为进行改变，其值大小决定了屏幕渲染图像的品质，我们以上所讨论的都指的是物理像素。 123// 获取屏幕的物理像素尺寸window.screen.width;window.screen.height; CSS 像素，与设备无关像素，指的是通过 CSS 进行网页布局时用到的单位，其默认值(PC 端)是和物理像素保持一致的（1 个单位的 CSS 像素等于 1 个单位的物理像素），但是我们可通缩放来改变其大小。 我们需要理解的是物理像素和 CSS 像素的一个关系，1 个物理像素并不总是等于一个 CSS 像素，通过调整浏览器缩放比例来改变。 2、3 倍图 为了在像素密度高的设备上图片能够清晰显示，而不是被放大显示(会模糊)，设计师要针对不同的像素比设计不同像素的图片。 在设备独立像素为 2 的设备上使用设计师专门为其设计的图片即可。 调试 模拟调试 真机调试 视口 viewport 视口（viewport）是用来约束网站中最顶级块元素 html 的，即它决定了&lt;html&gt;的大小。 PC 设备 viewport 在 PC 设备上 viewport 的大小取决于浏览器窗口的大小，以 CSS 像素做为度量单位。 通过以往 CSS 的知识，我们都能理解&lt;html&gt;的大小是会影响到我们的网页布局的，而 viewport 又决定了&lt;html&gt;的大小，所以 viewport 间接的决定并影响了我们网页的布局。 123// 获取viewport的大小document.documentElement.clientWidth;document.documentElement.clientHeight; 在 PC 端，我们通过调整浏览器窗口可以改变 viewport 的大小，为了保证网页布局不发生错乱，需要给元素设定较大固定宽度。 移动端 viewport 移动设备屏幕普遍都是比较小的，但是大部分的网站又都是为 PC 设备来设计的，要想让移动设备也可以正常显示网页，移动设备不得不做一些处理，通过上面的例子我们可以知道只要 viewport 足够大，就能保证原本为 PC 设备设计的网页也能在移动设备上正常显示，移动设备厂商也的确是这样来处理的。 在移动设备上 viewport 不再受限于浏览器的窗口，而是允许开发人员自由设置 viewport 的大小，通常浏览 器会设置一个默认大小的 viewport，为了能够正常显示那些专为 PC 设计的网页，一般这个值的大小会大于屏幕的尺寸。 如下图为常见默认 viewport 大小（仅供参考） 从图中统计我们得知不同的移动厂商分别设置了一个默认的 viewport 的值，这个值保证大部分网页可以正常在移动设备下浏览。但是通常会产生缩放和滚动条。 产生缩放和滚动条的原因是什么呢？ 进一步对移动设备的 viewport 进行分析，移动设备上有 2 个 viewport（为了方便讲解人为定义的），分别是 layout viewport 和 ideal viewport。 layout viewport 布局视口 指的是我们可以进行网页布局区域的大小，同样是以 CSS 像素做为计量单位，可以通过下面方式获取 123// 获取layout viewportdocument.documentElement.clientWidth;document.documentElement.clientHeight; 通过前面介绍我们知道，如果要保证为 PC 设计的网页在移动设备上布局不发生错乱，移动设备会默认设置一个较大的 viewport（如 IOS 为 980px），这个 viewport 实际指的是 layout viewport。 ideal viewport 理想视口 设备屏幕区域，（以设备独立像素 PT、DP 做为单位）以 CSS 像素做为计量单位，其大小是不可能被改变，通过下面方式可以获取。 1234567// 获取ideal viewport有两种情形// 新设备window.screen.width;window.screen.height;// 老设备window.screen.width / window.devicePixelRatio;window.screen.height / window.devicePixelRatio; 理解两个 viewport 后, 我们来解释为什么网页会被缩放或出现水平滚动条，其原因在于移动设备浏览器会默认设置一个 layout viewport，并且这个值会大于 ideal viewport，那么我们也知道ideal viewport 就是屏幕区域, layout viewport 是我们布局网页的区域，那么最终 layout viewport 是要显示在 ideal viewport 里的，而 layout viewport 大于 ideal viewport 时，于是就出现滚动条了，那么为什么有的移动设备网页内容被缩放了呢？移动设备厂商认为将网页完整显示给用户才最合理，而不该出现滚动条，所以就将 layout viewport 进行了缩放，使其恰好完整显示在 ideal viewport（屏幕）里，其缩放比例为 ideal viewport / layout viewport。 移动浏览器 移动端开发主要是针对 IOS 和 Android 两个操作系统平台的，除此之外还有 Windows Phone。 移动端主要可以分成三大类，系统自带浏览器、应用内置浏览器、第三方浏览器 系统浏览器： 指跟随移动设备操作系统一起安装的浏览器。 应用内置浏览器： 通常在移动设备上都会安装一些 APP 例如 QQ、微信、微博、淘宝等，这些 APP 里往往会内置一个浏览器，我们称这个浏览器为应用内置浏览器（也叫 WebView），这个内置的浏览器一般功能比较简单，并且客户端开发人员可以更改这个浏览器的某些设置，在我们理实的开发里这个浏览器很重要。 第三方浏览器： 指安装在手机的浏览器如 FireFox、Chrome、360 等等。 在 IOS 和 Android 操作系统上自带浏览器、应用内置浏览器都是基于 Webkit 内核的。 屏幕适配 Viewport 详解 经过分析我们得到，移动页面最理想的状态是，避免滚动条且不被默认缩放处理，我们可以通过设置&lt;meta name=&quot;viewport&quot; content=&quot;&quot;&gt;来进行控制，并改变浏览器默认的 layout viewport 的宽度。 viewport 介绍 是由苹果公司为了解决移动设备浏览器渲染页面而提出的解决方案，后来被其它移动设备厂商采纳，其使用参数如下： 123456789101112131415// 通过设置属性content=""实现，中间以逗号分隔// 例如&lt;meta name="viewport" content="width=device-width"&gt;width 设置layout viewport 宽度，其取值可为数值或者device-width。height 设置layout viewport 高度，其取值可为数值或者device-heightinitital-scale设置页面的初始缩放值，为一个数字，可以带小数。maximum-scale允许用户的最大缩放值，为一个数字，可以带小数。minimum-scale允许用户的最小缩放值，为一个数字，可以带小数。user-scalable是否允许用户进行缩放，值为"no"或"yes"。注：device-width 和 device-height就是ideal viewport的宽高 viewport 控制缩放 设置&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&quot;&gt;，这时我们发现网页没有被浏览器设置缩放。 设置&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;，这时我们发现网页也没有被浏览器设设置缩放。 当我们设置 width=device-width，也达到了 initial-scale=1 的效果，得知其实 initial-scale = ideal viewport / layout viewport。 两种方式都可以控制缩放，开发中一般同时设置 width=device-width 和 initial-scale=1.0（为了解决一些兼容问题）参见移动前端开发之 viewport 深入理解，即&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; viewport 避免滚动 我们知道，滚动条是 layout viewport 相对于 ideal viewport 的，所以只要设置 layout viewport 小于或等于 ideal viewport，即&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; 盒子宽度设置为百分比的宽度 适配方案百分比宽度 设置&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 设置页面宽度为百分比 12345width 参照父元素的宽度height 参照父元素的高度padding 参照父元素的宽度border 不支持百分比设置margin 参照父元素的宽度 我们发现这种方案最容易理解，但是在设置元素高度时有非常大的局限性。 因为页面的高度是不固定的。 rem 单位移动端触屏事件事件类型123touchstart: 手指触摸屏幕时触发;touchmove: 手指在屏幕上移动时触发;touchend: 手指离开屏幕时触发; TouchEvent 对象1234touches: 位于屏幕上的所有手指的列表targetTouches: 位于该元素上的所有手指的列表changedTouches：touchstart时包含刚与触摸屏接触的触点，touchend时包含离开触摸屏的触点注：没有对比出touches同targetTouches的差异，推荐使用targetTouches Touch 对象123456clientX/Y 手指相对于layout viewport的水平/垂直像素距离pageX/Y 手指相对于layout viewport的水平/垂直像素距离（含滚动）screenX/Y 手指相对于layout viewport的水平/垂直像素距离（含滚动）（未设置viewport时，screenX/Y在Webview中不正确）target 手指最初与屏幕接触时的元素移动开发通常会设置`&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;`，这时这三对坐标值是完全一样的。 有事您Q我👇]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>mobile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-ES7]]></title>
    <url>%2Fjs-ES7%2Fjs-ES7%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;大家都有不一样的难过和快乐 只是我们总是下意识 拿自己的劣势去和别人的优势来比 ES7ES7之异步async/await函数 概念：真正意义上去解决异步回调的问题，同步流程表达异步操作 本质：Generator的语法糖 1234567891011语法：async function foo()&#123; await 异步操作; await 异步操作；&#125;特点：1、不需要像Generator去调用next方法，遇到await等待，当前的异步操作完成就往下执行2、返回的总是Promise对象，可以用then方法进行下一步操作3、async取代Generator函数的星号*，await取代Generator的yield4、语意上更为明确，使用简单，经临床验证，暂时没有任何副作用 12345678910111213141516171819202122async function sendXhr(url) &#123; return new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; url, type: 'GET', success: data =&gt; resolve(data), error: error =&gt; resolve(false) //技巧 小聪明 // 若调用reject的话 报错用户看不到 &#125;) &#125;)&#125;async function getNews(url) &#123; let result = await sendXhr(url); if (!result) &#123; alert('暂时没有新闻推送...') return; &#125; let result2 = await sendXhr(url); console.log(result, result2);&#125;getNews('http://localhost:3000/news?id=2') ES7扩展指数运算符**1234指数运算符: **let num = 2 ** 3console.log('num :', num);//8 ES7数组扩展includes12345Array.prototype.includes(value) : 判断数组中是否包含指定valuelet arr = [1, 2, 'abc']console.log(arr.includes('a'))// falseconsole.log(arr.includes('abc'))//true 有事您Q我👇]]></content>
      <categories>
        <category>js-ES7</category>
      </categories>
      <tags>
        <tag>ES7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-ES6]]></title>
    <url>%2Fjs-ES6%2Fjs-ES6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我想任何人 在经历时 都不会知道自己正在经历 生平中最幸福的时刻 我们生活中那些被遗漏的美好时光 ES6ES6-2个新的关键字 let/const 块作用域 没有变量提升 不能重复定义 值不可变 const 1234567let a = 2a = 1console.log('a :', a)const B = 4B = 5console.log('B :', B) //报错 常量值不可变 ES6-变量的解构赋值 将包含多个数据的对象(数组)一次赋值给多个变量 数据源: 对象/数组 目标: {a, b}/[a, b] 123456789101112131415161718192021222324//解构 左右两边的数据结构必须一致let obj = &#123; name: 'yachan', sex: '女神', age: 18&#125;let &#123;name, sex&#125; = obj // 对象的解构赋值是按照属性名查找并赋值的console.log('name, sex :', name, sex);//name, sex : yachan 女神function foo (&#123; name, sex &#125;) &#123;//参数为对象时 形参也可以解构赋值 console.log('name, sex :', name, sex)&#125;foo(obj)//name, sex : yachan 女神let arr = [1, 3, 34, 4]let [a, b] = arrlet [,, c, d] = arr //可以用 ','占位// 数组的解构赋值是按下标进行匹配的console.log('a, b :', a, b)//a, b : 1 3console.log('c, d :', c, d);//c, d : 34 4 ES6-各种数据类型的扩展ES6-数值Number的扩展1234561. 二进制与八进制数值表示法: 二进制用0b, 八进制用0o2. Number.isFinite(i) : 判断是否是有限大的数3. Number.isNaN(i) : 判断是否是NaN4. Number.isInteger(i) : 判断是否是整数5. Number.parseInt(str) : 将字符串转换为对应的数值6. Math.trunc(i) : 直接去除小数部分 ES6-字符串String的扩展123456789101112131415161718模板字符串 作用: 简化字符串的拼接 变化的部分使用$&#123;xxx&#125;定义includes(str) : 判断是否包含指定的字符串startsWith(str) : 判断是否以指定字符串开头endsWith(str) : 判断是否以指定字符串结尾repeat(count) : 重复指定次数``` ```jslet str = 'yachanshulu'console.log(str.includes('shu'))//trueconsole.log(str.startsWith('ya'))//trueconsole.log(str.endsWith('lu'))//truelet str2 = str.repeat(2)console.log(str2)//yachanshuluyachanshulu ES6-对象Object的扩展 简化的对象写法 12345678910111213let name = 'Tom';let age = 12;let person = &#123; name, age, getName () &#123; return this.name &#125;, setName (name) &#123; this.name = name &#125;&#125; 将源对象的属性复制到目标对象上 混入 123456789101112131415Object.assign(target, source1, source2..)let obj1 = &#123; name: 'shulu', sex: '女神', getName () &#123; return this.name &#125;&#125;let obj2 = &#123;age: 'shulu', love: '男神'&#125;let o = &#123;&#125;Object.assign(o, obj1, obj2)console.log('o :', o)//o : &#123;name: "shulu", sex: "女神", getName: ƒ, age: "shulu", love: "男神"&#125; 判断2个数据 是否完全相等 1234567Object.is(v1, v2)// Object.is()方法底层是按照字符串去判断的console.log('Object.is(NaN, NaN) :', Object.is(NaN, NaN));// Object.is(NaN, NaN) : trueconsole.log('Object.is(0, -0) :', Object.is(0, -0));// Object.is(0, -0) : false 隐式原型属性 123456789101112131415161718192021222324252627__proto__ 属性 ES6规定可以直接修改这个属性let obj1 = &#123;&#125;, obj2 = &#123;money: 99999999&#125;obj1.__proto__ = obj2 让obj2做obj1的原型对象console.log('obj1 :', obj1);console.log('obj1.money :', obj1.money);// obj1 : &#123;&#125;// obj1.money : 99999999``` ### ES6-数组的扩展```js将伪数组对象或可遍历对象转换为真数组Array.from(v) 将一系列值转换成数组Array.of(v1, v2, v3) 找出第一个满足条件返回true的元素find(function(value, index, arr)&#123;return true&#125;) 找出第一个满足条件返回true的元素下标findIndex(function(value, index, arr)&#123;return true&#125;) ES6-函数的扩展 箭头函数 12345678910用来定义匿名函数基本语法: 没有参数: () =&gt; console.log('xxxx') 一个参数: i =&gt; i+2 大于一个参数: (i,j) =&gt; i+j 函数体不用大括号: 函数体只有一条语句或表达式时 默认返回结果 函数体如果有多个语句, 需要用&#123;&#125;包围使用场景: 多用来定义回调函数 箭头函数的this：箭头函数没有自己的this箭头函数的this是定义的时候决定的 如何判断箭头函数this是谁：看外层是否有函数 有的话就 是外层函数的this 而外层函数的this由调用者决定 没有的话 就是window 1234567891011121314151617let obj = &#123; name: 'yachan', age: 18, getName: () =&gt; &#123; //箭头函数 btn1.onclick = () =&gt; &#123; //箭头函数 console.log(this) &#125; &#125;&#125;obj.getName()//windowobj.getAge = () =&gt; &#123; //与getName的定义一样 btn2.onclick = () =&gt; &#123; console.log(this) &#125;&#125;obj.getAge()//window 形参的默认值 123456定义形参时指定其默认的值function getPoint (x = 0, y = 0) &#123; console.log('x, y :', x, y);&#125;getPoint()//x, y : 0 0getPoint(22, 33) //x, y : 22 33 扩展运算符… 12345678910111213141516171819//rest(可变)参数//通过形参左侧的...来表达, 取代arguments的使用function getNumber (a, ...value) &#123; console.log(a) value.forEach((item, index) =&gt; &#123; console.log(item) &#125;)&#125;getNumber(1, 2, 67)//扩展运算符(...) 可以分解出数组或对象中的数据let arr1 = [1, 6]let arr2 = [2, 3, 4, 5]let arr3 = [...arr1, ...arr2]arr3.sort((x, y) =&gt; x - y)console.log(arr3);//[1, 2, 3, 4, 5, 6] ES6深度克隆deepClone12345678910111213141516171819202122232425262728293031323334353637383940414243// 检测数据类型function checkedType (target) &#123; return Object.prototype.toString.call(target).slice(8, -1) // Object.prototype.toString.call() 返回值[Object xxx]&#125;// 深度克隆function deepClone (target) &#123; let result, //最终返回值 targetType = checkedType(target) //要克隆的目标对象的数据类型 if (targetType === 'Object') &#123; result = &#123;&#125; //初始化为一个空对象 &#125;else if (targetType === 'Array') &#123; result = [] //初始化为一个空数组 &#125;else &#123; return target &#125; // 能走到这里说明要克隆的对象的数据类型为对象或者数组 // 遍历目标对象 for (let i in target) &#123; // 枚举对象则i为key // 枚举数组则i为index if (target.hasOwnProperty(i)) &#123;//目标对象自身的属性 不要原型对象上的属性 let value = target[i] if (checkedType(value) === 'Object' || 'Array') &#123; result[i] = deepClone(value)//递归方法 &#125;else &#123; result[i] = value &#125; &#125; &#125; return result&#125;// 测试代码let arr = [1, &#123;name: 'shulu', age: 18&#125;, [2, 3, &#123;sex: '女神'&#125;]]let cloneArr = deepClone(arr)cloneArr[1].name = 'yachan'cloneArr[2][2].sex = '男生'console.log('cloneArr :', cloneArr);console.log('arr :', arr);// 结果互不干扰 ES6之Symbol一种新的原始数据类型1234567891011121314151617181920212223ES5中对象的属性名都是字符串，容易造成重名，污染环境Symbol：概念：ES6中的添加了一种原始数据类型symbol(已有的原始数据类型：String, Number, boolean, null, undefined, 对象)特点： 1、Symbol属性对应的值是唯一的，解决命名冲突问题 2、Symbol值不能与其他数据进行计算，包括同字符串拼串 3、for in, for of遍历时不会遍历symbol属性。使用： 1、调用Symbol函数得到symbol值 let symbol = Symbol(); let obj = &#123;&#125;; obj[symbol] = 'hello'; 2、传参标识 let symbol = Symbol('one'); let symbol2 = Symbol('two'); console.log(symbol);// Symbol('one') console.log(symbol2);// Symbol('two') 3、内置Symbol值 * 除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。 - Symbol.iterator * 对象的Symbol.iterator属性，指向该对象的默认遍历器方法(后边讲) ES6之set/Map容器结构 容器: 能保存多个数据的对象, 同时必须具备操作内部数据的方法 任意对象都可以作为容器使用, 但有的对象不太适合作为容器使用(如函数) Set的特点: 保存多个value, value是不重复 ====&gt;数组元素去重 Map的特点: 保存多个key–value, key是不重复, value是可以重复的 1234567891011121314API Set()/Set(arr) //arr是一维数组 add(value) delete(value) clear(); has(value) size Map()/Map(arr) //arr是二维数组 set(key, value) delete(key) clear() has(key) size set 12345678910111213let set = new Set([1, 2, 2, 1, 3])console.log('set :', set) //Set(3) &#123;1, 2, 3&#125;console.log('set.size :', set.size);console.log('set.has(2) :', set.has(2));//trueset.add(8)console.log('set :', set);//Set(4) &#123;1, 2, 3, 8&#125;set.delete(1)console.log('set :', set);//&#123;2, 3, 8&#125;set.clear()console.log('set :', set);//&#123;&#125; map 12345678910111213141516//map里面放二维数组 内数组的第一项为key 第二项为valuelet map = new Map([['name', 'shulu'], ['age', 18]])console.log('map :', map)//Map(2) &#123;"name" =&gt; "shulu", "age" =&gt; 18&#125;console.log('map.size :', map.size); //2map.set('sex', '女神')console.log('map :', map);//Map(3) &#123;"name" =&gt; "shulu", "age" =&gt; 18, "sex" =&gt; "女神"&#125;map.delete('age')console.log('map :', map);//&#123;"name" =&gt; "shulu", "sex" =&gt; "女神"&#125;console.log(map.has('name'));//truemap.clear()console.log('map :', map);//Map(0) &#123;&#125; ES6异步1之Promise 解决回调地狱(回调函数的层层嵌套, 编码是不断向右扩展, 阅读性很差) 能以同步编码的方式实现异步调用 在es6之前原生的js中是没这种实现的, 一些第三方框架(jQuery)实现了promise ES6中定义实现API: 12345678910111213141516// 1. 创建promise对象let promise = new Promise((resolve, reject) =&gt; &#123; // 做异步的操作 if(成功) &#123; // 调用成功的回调 resolve(result); &#125; else &#123; // 调用失败的回调 reject(errorMsg); &#125; &#125;) // 2. 调用promise对象的then()promise.then((result) =&gt; &#123; console.log(result)&#125;, (errorMsg) =&gt; &#123; console.log(errorMsg) &#125;) ES6之iterator遍历器指针对象 概念： iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制 作用： 123为各种数据结构，提供一个统一的、简便的访问接口；使得数据结构的成员能够按某种次序排列ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费。 工作原理： 123456创建一个指针对象，指向数据结构的起始位置。第一次调用next方法，指针自动指向数据结构的第一个成员接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员每调用next方法返回的是一个包含value和done的对象，&#123;value: 当前成员的值,done: 布尔值&#125; value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束。 当遍历结束的时候返回的value值是undefined，done值为true 原生具备iterator接口的数据(可用for of遍历) 1234561、Array2、arguments3、set容器4、map容器5、String…… 值得注意的是普通对象{}是不具有iterator接口的 即无法用for..of 来遍历 模拟实现iterator指针对象 12345678910111213141516171819202122232425自定义iterator生成指针对象function mockIterator(arr) &#123; let nextIndex = 0; return &#123; next: function () &#123; return nextIndex&lt;arr.length?&#123;value: arr[nextIndex++], done: false&#125;:&#123;value: undefined, done: true&#125; &#125; &#125;&#125;let arr = [1,2,3,4,5];let iteratorObj = mockIterator(arr);console.log(iteratorObj.next());console.log(iteratorObj.next());console.log(iteratorObj.next());console.log(iteratorObj.next());console.log(iteratorObj.next());console.log(iteratorObj.next());// &#123;value: 1, done: false&#125;// &#123;value: 2, done: false&#125;// &#123;value: 3, done: false&#125;// &#123;value: 4, done: false&#125;// &#123;value: 5, done: false&#125;// &#123;value: undefined, done: true&#125; ES6之for–of循环 可以遍历任何容器 set/map等 数组/类数组 对象 (这个有点不太会) 伪/类对象 字符串 可迭代的对象 arguments 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 遍历字符串let str = 's2wn'for (const iterator of str) &#123; console.log('iterator :', iterator);&#125;// 遍历数组let arr = [1, 2, 'ss']for (const iterator of arr) &#123; console.log('iterator :', iterator);&#125;// 遍历argumentsfunction forArguments () &#123; for (const iterator of arguments) &#123; console.log('iterator :', iterator); &#125;&#125;forArguments(1, 2, 3)//1//2 //3 // 遍历类数组let btns = document.getElementsByClassName('btn')for (const iterator of btns) &#123; console.log('btns :', btns);&#125;// HTMLCollection(3) [div.btn, div.btn, div.btn]// HTMLCollection(3) [div.btn, div.btn, div.btn]// HTMLCollection(3) [div.btn, div.btn, div.btn]// 遍历set容器let set = new Set([1, 2, 3])for (const i of set) &#123; console.log('i :', i);&#125;// 1// 2// 3// 遍历map容器let map = new Map([['name', 'shulu'], ['age', 18], ['sex', '女神']])for (const i of map) &#123; console.log('i :', i);&#125;// ["name", "shulu"]// ["age", 18]// ["sex", "女神"] ES6异步2之Generator函数 相比promise函数解决回调地狱的方法要好一些 调用Generator函数会返回一个遍历器对象即iterator 123456789101112131415161718概念： 1、ES6提供的解决异步编程的方案之一 2、Generator函数是一个状态机，内部封装了不同状态的数据， 3、用来生成遍历器对象 4、可暂停函数(惰性求值), yield可暂停，next方法可启动。每次返回的是yield后的表达式结果特点： 1、function 与函数名之间有一个星号 2、内部用yield表达式来定义不同的状态 例如： function* generatorExample()&#123; let result = yield 'hello'; // 状态值为hello yield 'generator'; // 状态值为generator &#125; 3、generator函数返回的是指针对象(即前面讲的iterator)，而不会执行函数内部逻辑 4、调用next方法函数内部逻辑开始执行，遇到yield表达式停止，返回&#123;value: yield后的表达式结果/undefined, done: false/true&#125; 5、再次调用next方法会从上一次停止时的yield处开始，直到最后 6、yield语句返回结果通常为undefined， 当调用next方法时传参内容会作为启动时yield语句的返回值。 ES6之class类 用 class 定义类 用 constructor() 定义构造方法(相当于构造函数) 一般方法: xxx () {} 必须这么写 用extends来定义子类 继承父类 用super()来调用父类的构造方法 子类方法自定义: 将从父类中继承来的方法重新实现一遍 js中没有方法重载(方法名相同, 但参数不同)的语法 123456789101112131415161718192021222324252627class Person &#123; // 类的构造方法 constructor(name, age) &#123; this.name = name this.age = age &#125; // 类的一般方法 showInfo () &#123; console.log(`my name is $&#123;this.name&#125;.`); console.log(`I am $&#123;this.age&#125; years old.`); &#125;&#125;class starPerson extends Person &#123; constructor (name, age, salary) &#123; super(name, age)//调用父类的构造方法 this.salary = salary &#125; showSalary () &#123; console.log(`my salary is $&#123;this.salary&#125; ￥`); &#125;&#125;let star = new starPerson('yachan', 18, 9999999999)console.log('star :', star);star.showInfo()star.showSalary() ES6之模块化 看js模块化部分 有事您Q我👇]]></content>
      <categories>
        <category>js-ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-ES5]]></title>
    <url>%2Fjs-ES5%2Fjs-ES5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;时间会变魔术——生命之旅是一个不断发现的过程，在每个年龄段都会有它独特的景致。 理解ES 全称: ECMAScript js语言的规范 我们用的js是它的实现 js的组成 ECMAScript(js基础) 扩展–&gt;浏览器端 BOM DOM 扩展–&gt;服务器端 Node.js ES的几个重要的版本 ES5 09年发布 ES6 15年发布 也叫ES2015 ES7 16年发布 也叫ES2016 ES5ES5-严格模式12345678910111213141516171819202122232425运行模式: 正常(混杂)模式与严格模式应用上严格式: 'strict mode';作用: 使得Javascript在更严格的条件下运行 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 消除代码运行的一些不安全之处，保证代码运行的安全需要记住的几个变化 声明定义变量必须用var 禁止自定义的函数中的this关键字指向全局对象 创建eval作用域(就像函数作用域一样), 更安全``` ## ES5-JSON对象* 作用: 用于在json对象/数组与js对象/数组相互转换* JSON.stringify(obj/arr) 将js对象(数组)转换为json对象(数组)```jsvar obj = &#123; name: 'shulu', age: 18&#125;var arr = ['shu', 'lu', 520]console.log(JSON.stringify(obj)) //&#123;"name":"shulu","age":18&#125;console.log(JSON.stringify(arr)); //["shu","lu",520] JSON.parse(json) 将json对象(数组)转换为js对象(数组) ES5-Object扩展12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Object.create(prototype[, descriptors]) : 创建一个新的对象以指定对象为原型创建新的对象指定新的属性, 并对属性进行描述 value : 指定值 writable : 标识当前属性值是否是可修改的, 默认为true enumerable: 是否可被for in枚举 默认false get方法: 用来得到当前属性值的回调函数 set方法: 用来监视当前属性值变化的回调函数var obj = &#123; name: 'shulu', age: 18&#125;var o = &#123;&#125;o = Object.create(obj, &#123; sex: &#123; value: '女神', //属性值 writable: true, //可写可修改 enumerable: true ,//可被for in枚举 configurable: true, //可删除 可配置的属性 &#125;&#125;)function iterator () &#123; for (const key in o) &#123; if (o.hasOwnProperty(key)) &#123; console.log('key :', key) &#125; &#125;&#125;iterator() // key: sexdelete o.sexconsole.log('o :', o) //o: &#123;&#125;var o2 = &#123;&#125;// 以字面量方式创建的空对象就相当于:o2 = Object.create(Object.prototype)``` ```jsObject.defineProperties(object, descriptors) : 为指定对象定义扩展多个属性var obj = &#123; firstName: 'shu', lastName: 'lu',&#125;Object.defineProperties(obj, &#123; fullName: &#123; //联想vue中的计算属性 get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, set: function (data) &#123; var names = data.split(' ') this.firstName = names[0] this.lastName = names[1] &#125; &#125; &#125;)console.log(obj.fullName)// shu luobj.fullName = 'love you'console.log(obj.fullName)// love you 对象的本身就有的的两个方法 get set 1234obj&#123; get propertyName () &#123;...&#125;, set propertyName () &#123;...&#125;,&#125; 1234567891011121314151617var obj = &#123; firstName: 'shu', lastName: 'lu', get fullName () &#123; return this.firstName + ' ' + this.lastName &#125;, set fullName (data) &#123; var names = data.split(' ') this.firstName = names[0] this.lastName = names[1] &#125;&#125;console.log(obj.fullName);// shu luobj.fullName = 'love you'console.log(obj.fullName);// love you//结果和Object.defineProperties()一样 ES5-Array扩展1234567891011121314得到值在数组中的第一个下标Array.prototype.indexOf(value) 得到值在数组中的最后一个下标Array.prototype.lastIndexOf(value) 遍历数组Array.prototype.forEach(function(item, index)&#123; &#125;) 遍历数组 返回一个新的数组 返回加工之后的新数组 变量接收返回值Array.prototype.map(function(item, index)&#123; return &#125;) 遍历数组 过滤出一个新的子数组 返回条件为true的值组成的子数组 变量接收返回值Array.prototype.filter(function(item, index)&#123; return &#125;) 12345678910111213141516171819var arr = [1, 2, 34, 32, 12]arr.forEach(function (item, index) &#123; console.log(item, index);&#125;)// 1 0// 2 1// 34 2// 32 3// 12 4var arr2 = arr.map(function (item, index) &#123; return item += 10&#125;)console.log('arr :', arr2) //[11, 12, 44, 42, 22]var arr3 = arr.filter(function (item, index) &#123; return item &gt; 3&#125;)console.log('arr3 :', arr3);//[34, 32, 12] ES5-Function扩展12345678Function.prototype.bind(obj) 将函数内的this绑定为obj, 并将函数返回 并不会立即调用函数面试题: 区别bind()与call()和apply()fn.bind(obj, 66) 指定函数中的this, 并返回函数, 第二个参数直接传, 常用于指定回调函数的thisfn.call(obj, 66) 指定函数中的this, 并调用函数, 第二个参数直接传fn.apply(obj, [66]) 指定函数中的this, 并调用函数, 第二个参数为数组形式 demo 12345678910111213141516171819202122232425262728293031function foo1 (data) &#123; console.log('this :', this) console.log('data :', data)&#125;function foo2 (data) &#123; console.log('this :', this) console.log('data :', data)&#125;function foo3 (data) &#123; console.log('this :', this) console.log('data :', data)&#125;var obj = &#123; name: 'yachan', sex: '女神'&#125;var bar = foo1.bind(obj, 18)bar()//this : &#123;name: "yachan", sex: "女神"&#125; //data : 18foo2.call(obj, 19)//this : &#123;name: "yachan", sex: "女神"&#125; //data : 19foo3.apply(obj, [20])//this : &#123;name: "yachan", sex: "女神"&#125;//data : 20// bind常用于指定回调函数的thissetTimeout(function () &#123; console.log('this :', this) //this : &#123;name: "yachan", sex: "女神"&#125;&#125;.bind(obj), 1000) ES5-Date扩展 Date.now() : 得到当前时间值 有事您Q我👇]]></content>
      <categories>
        <category>js-ES5</category>
      </categories>
      <tags>
        <tag>ES5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax-跨域-jsonp]]></title>
    <url>%2Fajax-%E8%B7%A8%E5%9F%9F%2Fajax-%E8%B7%A8%E5%9F%9F-jsonp%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 这世界很美——我要变成这个世界的一部分，变成哪些努力的人的一部分，变成这个人世界依旧美好的一部分。 ajax跨域之jsonp同源策略&emsp;&emsp;同源策略是浏览器的一种安全策略，所谓同源请求url地址中的协议、域名、端口都相同，只要其中之不同就是跨域 跨域常用方法jsonp原理 jsonp仅仅支持get请求 静态script标签的src实现进行跨域请求不常用 存在的问题： 必须保证加载的顺序 不方便传递参数 动态创建script标签，通过标签的src属性发送请求常用 123456789101112var script = document.createElement('script')script.src = 'http://taobao.com/data.php?callback=foo&amp;name=shulu&amp;age=18'var head = document.getElementsByTagName('head')[0]head.appendChild(script)// 前端定义函数function foo (data) &#123; console.log('data :', data)&#125;// 服务器返回一个【函数调用】即 foo(实参)// ?callback=foo 通过这样设置后 函数名字就有前端决定// 'callback' 这个字符串必须与后端一致 即有后端决定 jQuery中的jsonp&emsp;&emsp;jQuery中将jsonp的方法封装到了$.ajax()的方法中 使用方法跟$.ajax()差不多注意点： 12345678dataType: 'jsonp' //必须指定为jsonpjsonp: 'cb' //若后端获取回调函数的名字时用cb这个变量，//这里就要指定为'cb',来迎合后端，一般情况下，为'callback'jsonpCallback: 'foo'//自定义回调函数的名字，,即callback这个键的值//jQuery默认会生成一个很长的名字 12345678910111213$.ajax(&#123; type: 'get', url: 'http://taobao.com/data.php?callback=foo&amp;name=shulu&amp;age=18', dataType: 'jsonp', jsonp: 'cb', jsonpCallback: 'foo', success: function (data) &#123; console.log(data) &#125;, error: function (error) &#123; console.log(error) &#125;&#125;) 模仿实现jQuery中的jsonp1234567891011121314151617181920212223242526272829303132333435363738394041function ajax (obj) &#123; let defaults = &#123; url: '#', dataType: 'jsonp', jsonp: 'callback', data: &#123;&#125;, success: function (data) &#123; console.log(data) &#125; &#125; for (const key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; defaults[key] = obj[key] &#125; &#125; // 默认的回调函数名称 1.1.11为jquery的版本号 let cbName = 'jQuery' + ('1.1.11' + Math.random().replace(/\D/g,'') + '_' + (new Date().getTime())) if (defaults.jsonpCallback) &#123; cbName = defaults.jsonpCallback &#125; // 定义回调函数 给window上添加一个方法 window[cbName] = function (data) &#123; defaults.success(data) &#125; // 处理参数 拼接成字符串参数 let param = '' for (const key in defaults.data) &#123; if (defaults.data.hasOwnProperty(key)) &#123; param += key + '=' + defaults.data[key] + '&amp;' param = '&amp;' + param &#125; &#125; let script = document.createElement('script') script.src = defaults.url + '?' + defaults.jsonp + '=' + cbName + param let head = document.getElementsByTagName('head')[0] head.appendChild(script)&#125; 模仿jQuery中的ajax中封装的jsonp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107function ajax (obj) &#123; let defaults = &#123; type: 'get', url: '#', async: true, dataType: 'jsonp', jsonp: 'callback', data: &#123;&#125;, success: function (data) &#123; console.log(data) &#125; &#125; for (const key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; defaults[key] = obj[key] &#125; &#125; if (defaults.dataType === 'jsonp') &#123; ajax4jsonp(defaults) &#125; else &#123; ajax4json(defaults) &#125; function ajax4jsonp (defaults) &#123; // 默认的回调函数名称 1.1.11为jquery的版本号 let cbName = 'jQuery' + ('1.1.11' + Math.random().replace(/\D/g,'') + '_' + (new Date().getTime())) if (defaults.jsonpCallback) &#123; cbName = defaults.jsonpCallback &#125; // 定义回调函数 给window上添加一个方法 window[cbName] = function (data) &#123; defaults.success(data) &#125; // 处理参数 拼接成字符串参数 let param = '' for (const key in defaults.data) &#123; if (defaults.data.hasOwnProperty(key)) &#123; param += key + '=' + defaults.data[key] + '&amp;' param = '&amp;' + param &#125; &#125; let script = document.createElement('script') script.src = defaults.url + '?' + defaults.jsonp + '=' + cbName + param let head = document.getElementsByTagName('head')[0] head.appendChild(script) &#125; function ajax4json (defaults) &#123; // 1 创建Ajax对象 let xhr = new XMLHttpRequest() // 处理defaults.data 将对象形式参数拼接成参数字符串 // 即 name=yachan&amp;age=18 的形式 let param = '' for (const key in defaults.data) &#123; if (defaults.data.hasOwnProperty(key)) &#123; param += key + '=' + defaults.data[key] + '&amp;' &#125; &#125; // 去掉最后一个&amp;符号 if (param) &#123; param = param.substring(0, param.length - 1) &#125; // 若为get请求 则直接往url后面拼接参数 if (defaults.type === 'get') &#123; defaults.url += '?' + encodeURI(param) //编码中文 防止出现乱码 &#125; // 若为post请求 let data = null if (defaults.type === 'post') &#123; data = param // 设置请求头(必须设置) xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded') &#125; // 2 准备发送 设置发送参数 xhr.open(defaults.type, defaults.url, defaults.async) // 3 发送请求 执行发送动作 xhr.send(data) // 若为同步请求 不经过回调函数 if (!defaults.async) &#123; if (defaults.dataType === 'json') &#123; return JSON.parse(xhr.responseText) &#125;else&#123; return xhr.responseText &#125; &#125; // 4 指定回调函数(异步) 处理服务器返回值 xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (shr.status === 200) &#123; let data = xhr.responseText if (defaults.dataType === 'json') &#123; data = JSON.parse(data) &#125; defaults.success(data) &#125; &#125; &#125; &#125;&#125; jsonp案例之百度智能搜索提示12345&lt;div id="container"&gt; &lt;input type="text" id="keyword" name="keyword" placeholder="请输入搜索内容……"&gt; &lt;input type="button" value="百度一下" id="query"&gt; &lt;div id="info"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617#container&#123; width: 400px; height: 300px; background-color: #ccc; margin: 100px auto; text-align: center&#125;#keyword&#123; width: 300px;&#125;input&#123; height: 30px; font-size: 18px&#125;#query&#123; width: 80px;&#125; 1234567891011121314151617181920212223$(function () &#123; $('#keyword').keyup(function () &#123; var ul = document.createElement('ul') var info = document.getElementById('info') info.innerHTML = '' //清空之前的内容 var kw = $(this).val() $.ajax(&#123; url: 'https://www.baidu.com/sugrec?pre=1&amp;p=3&amp;ie=utf-8&amp;json=1&amp;prod=pc&amp;from=pc_web&amp;sugsid=1458,21089,29522,29518,29099,29568,28833,29221,22160', jsonp: 'cb', data: &#123;wd: kw&#125;, dataType: 'jsonp', success: function (data) &#123; var query = data.g for (let i = 0; i &lt; query.length; i++) &#123; var li = document.createElement('li') li.innerText = query[i].q ul.appendChild(li) &#125; info.appendChild(ul) &#125; &#125;) &#125;)&#125;) 有事您Q我👇]]></content>
      <categories>
        <category>ajax-跨域</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax]]></title>
    <url>%2Fajax%2Fajax%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;全力以赴——全力以赴就是想尽所有的办法，用尽所有的资源。 ajax即XMLHttpRequest&emsp;&emsp;Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。&emsp;&emsp;Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。&emsp;&emsp;传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 原生ajax1234567891011// 创建XMLHttpRequestvar xhr = new XMLHttpRequest()// 准备发送请求 请求方式 地址 是否异步xhr.open('get', 'xxx.com/data', true) //true异步// 执行发送动作xhr.send(null)// 指定回调函数xhr.onreadystatechange = function () &#123; &#125; jQuery中的ajax1234567891011$.ajax(&#123; type: '请求方式', url: '请求地址', dataType: 'json', success: function (data) &#123; // do something &#125;, error: function (data) &#123; // do something &#125;&#125;) 模仿封装jQuery中的ajax123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function ajax (obj) &#123; // Ajax默认参数 let defaults = &#123; type: 'get', data: &#123;&#125;, url: '#', dataType: 'text', async: true, success: function (data) &#123; console.log(data) &#125; &#125; // 遍历obj对象 覆盖defaults对象 没有覆盖的即为默认值 for (const key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; defaults[key] = obj[key] &#125; &#125; // 1 创建Ajax对象 let xhr = new XMLHttpRequest() // 处理defaults.data 将对象形式参数拼接成参数字符串 // 即 name=yachan&amp;age=18 的形式 let param = '' for (const key in defaults.data) &#123; if (defaults.data.hasOwnProperty(key)) &#123; param += key + '=' + defaults.data[key] + '&amp;' &#125; &#125; // 去掉最后一个&amp;符号 if (param) &#123; param = param.substring(0, param.length - 1) &#125; // 若为get请求 则直接往url后面拼接参数 if (defaults.type === 'get') &#123; defaults.url += '?' + encodeURI(param) //编码中文 防止出现乱码 &#125; // 若为post请求 let data = null if (defaults.type === 'post') &#123; data = param // 设置请求头(必须设置) xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded') &#125; // 2 准备发送 设置发送参数 xhr.open(defaults.type, defaults.url, defaults.async) // 3 发送请求 执行发送动作 xhr.send(data) // 若为同步请求 不经过回调函数 if (!defaults.async) &#123; if (defaults.dataType === 'json') &#123; return JSON.parse(xhr.responseText) &#125;else&#123; return xhr.responseText &#125; &#125; // 4 指定回调函数(异步) 处理服务器返回值 xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (shr.status === 200) &#123; let data = xhr.responseText if (defaults.dataType === 'json') &#123; data = JSON.parse(data) &#125; defaults.success(data) &#125; &#125; &#125;&#125; 有事您Q我👇]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-Regex]]></title>
    <url>%2FRegex%2Fjs-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;淡定的人生不寂寞——繁华过后是寂寞，绚烂过后是平淡，保持淡定的人，一定是最美丽最幸福的人。 正则表达式&emsp;&emsp; 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 正则表达式的作用 给定的字符串是否符合正则表达式的过滤逻辑(匹配) 可以通过正则表达式，从字符串中获取我们想要的特定部分(提取) 强大的字符串替换能力(替换) 正则表达式的组成&emsp;&emsp; 普通字符&emsp;&emsp; 特殊字符(元字符)：正则表达式中有特殊意义的字符 常用元字符串 元字符 说明 \d 匹配数字 \D 匹配任意非数字的字符 \w 匹配字母或数字或下划线 \W 匹配任意不是字母，数字，下划线 \s 匹配任意的空白符 \S 匹配任意不是空白符的字符 . 匹配除换行符以外的任意单个字符 ^ 表示匹配行首的文本(以谁开始) $ 表示匹配行尾的文本(以谁结束) 限定符 限定符 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 其它1234567891011121314[] 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思[^] 匹配除中括号以内的内容\ 转义符| 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱() 从两个直接量中选择一个，分组 eg：gr(a|e)y匹配gray和grey()作为分组来使用，获取分组匹配到的结果用Regex.$1 $2 $3....来获取var reg = /(\d&#123;4&#125;)-\d&#123;1,2&#125;-\d&#123;1,2&#125;/;if (reg.test(dateStr)) &#123; console.log(RegExp.$1);&#125;[\u4e00-\u9fa5] 匹配汉字 任意一个汉字 正则表达式的方法Regexp对象 有两个&emsp;&emsp; test()检测 布尔值&emsp;&emsp; exec()提取 只返回一个匹配到的结果 若要提取多个值则得循环进行提取 String对象 有四个&emsp;&emsp; match()提取多个内容 返回一个数组 &emsp;&emsp; replace(reg, 替换字符)替换&emsp;&emsp; replace的参数可以是函数而不是字符串，每个匹配都会调用该函数，它返回的字符串将作为替换的文本使用。 &emsp;&emsp; split(delimiter, limit) 切割字符串 返回一个字符串数组 1234567split()方法可以把调用它的字符串分解为一个字串数组，使用的分隔符是它的参数。参数：delimiter：字符串或者正则表达式，从该参数指定的地方分割字符串。limit：指定返回数组的最大长度，如果没有设置该参数，则整个字符串都会被分割。 &emsp;&emsp; search() 查找并且返回第一个匹配字串的第一个字符的位置。如果没有找到任何匹配的字串，则返回-1。 非贪婪模式 ?表示&emsp;&emsp; 所谓的”贪婪”的意思就是，如果符合要求就一直往后匹配，一直到无法匹配为止，这就是贪婪模式。&emsp;&emsp; 所谓的非贪婪模式就是一旦匹配到合适的就结束，不在继续匹配下去了。 12345贪婪模式的标示符：+，？，*，&#123;n&#125;,&#123;n,&#125;,&#123;n,m&#125;非贪婪模式: +？，？？，*？？，&#123;n&#125;?，&#123;n,&#125;?,&#123;n,m&#125;? 有事您Q我👇]]></content>
      <categories>
        <category>Regex</category>
      </categories>
      <tags>
        <tag>Regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-obj-clone]]></title>
    <url>%2FdeepClone%2Fjs-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;步履不停——只管走过去，不要都逗留着去采了花朵来保存，因为一路上花朵会继续开放。 深度克隆数据类型 数据分为基本的数据类型(String, Number, boolean, Null, Undefined)和对象数据类型 基本数据类型：特点： 存储的是该对象的实际数据 对象数据类型：特点： 存储的是该对象在栈中引用，真实的数据存放在堆内存里 复制数据基本数据类型存放的就是实际的数据，可直接复制12let number2 = 2;let number1 = number2; 克隆数据：对象/数组 区别： 浅拷贝/深度拷贝 1234判断： 拷贝是否产生了新的数据还是拷贝的是数据的引用知识点：对象数据存放的是对象在栈内存的引用，直接复制的是对象的引用let obj = &#123;username: 'kobe'&#125;let obj1 = obj; // obj1 复制了obj在栈内存的引用 常用的拷贝技术 12345671. arr.concat(): 数组浅拷贝2. arr.slice(): 数组浅拷贝3. Object.assign() 对象浅拷贝4. JSON.parse(JSON.stringify(arr/obj)): 数组或对象深拷贝, 但不能处理函数数据5. 浅拷贝包含函数数据的对象/数组6. 深拷贝包含函数数据的对象/数组 深度克隆123456789101112131415161718192021222324252627282930313233343536373839404142// 检测数据类型function checkedType (target) &#123; return Object.prototype.toString.call(target).slice(8, -1) // Object.prototype.toString.call() 返回值[Object xxx]&#125;// 深度克隆function deepClone (target) &#123; let result, //最终返回值 targetType = checkedType(target) //要克隆的目标对象的数据类型 if (targetType === 'Object') &#123; result = &#123;&#125; //初始化为一个空对象 &#125;else if (targetType === 'Array') &#123; result = [] //初始化为一个空数组 &#125;else &#123; return target &#125; // 能走到这里说明要克隆的对象的数据类型为对象或者数组 // 遍历目标对象 for (let i in target) &#123; // 枚举对象则i为key // 枚举数组则i为index if (target.hasOwnProperty(i)) &#123;//目标对象自身的属性 不要原型对象上的属性 let value = target[i] if (checkedType(value) === 'Object' || 'Array') &#123; result[i] = deepClone(value)//递归方法 &#125;else &#123; result[i] = value &#125; &#125; &#125; return result&#125;// 测试代码let arr = [1, &#123;name: 'shulu', age: 18&#125;, [2, 3, &#123;sex: '女神'&#125;]]let cloneArr = deepClone(arr)cloneArr[1].name = 'yachan'cloneArr[2][2].sex = '男生'console.log('cloneArr :', cloneArr);console.log('arr :', arr); 有事您Q我👇]]></content>
      <categories>
        <category>deepClone</category>
      </categories>
      <tags>
        <tag>clone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-inherit]]></title>
    <url>%2Fjs-oop%2Fjs-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;坚持下去——哪有什么天才，坚持做你喜欢的事情，这本身就是一种天赋。 一：原型继承–适合继承父类原型上的-方法 即把父类构造函数的一个实例赋值给子类构造函数作为原型对象 实现demo1234567891011121314151617181920212223242526// 父类function Person (name, age, sex) &#123; this.name = name this.age = age this.sex = sex&#125;Person.prototype.test = function () &#123; console.log('Person父类原型上的方法test')&#125;// 子类function Student (score) &#123; this.score = score&#125;// 子类构造函数的原型对象初始化时只能传一次值// 所以后面子类实例化时无法设置继承自父类构造函数的参数Student.prototype = new Person('ls', 18, '男')Student.prototype.constructor = Student //修正constructor的指向var student1 = new Student(80)var student2 = new Student(90)console.dir(student1) //name等属性都设置不了console.dir(student2) //name等属性都设置不了console.log('student1.test() :', student1.test()) //可以调用 原型继承的缺点：&emsp;&emsp;继承时无法设置父类构造函数的参数，即无法个性化继承来的属性值&emsp;&emsp;还有：父类原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！ 二：借用构造函数(假继承)–适合继承父类构造函数的-属性 在子类构造函数中使用call执行父类构造函数 demo实现12345678910111213141516171819202122232425function Person (name, age, sex) &#123; this.name = name this.age = age this.sex = sex&#125;Person.prototype.test = function () &#123; console.log('Person父类原型上的方法')&#125;function Student (name, age, sex, score) &#123; Person.call(this, name, age, sex) this.score = score&#125;var s1 = new Student('娅蝉', 18, '女', 99)var s2 = new Student('秋云', 22, '男', 66)console.log('s1 :', s1) //okconsole.log('s2 :', s2) //okconsole.log('s1.test :', s1.test) //undefined console.log('s1.test() :', s1.test()) //报错// 因为test方法在父类的原型对象上，只有其实例才可以调用// 子类借用父类构造函数，并没有生成实例去调用父类原型上的方法 借用构造函数的缺点： 显而易见的，子类实例继承不了父类原型上的方法 三：组合继承=原型继承+借用构造函数1234567891011121314151617181920212223function Person (name, age, sex) &#123; this.name = name this.age = age this.sex = sex&#125;Person.prototype.test = function () &#123; return 'Person父类原型上的方法'&#125;function Student (name, age, sex, score) &#123; Person.call(this, name, age, sex) this.score = score&#125;Student.prototype = new Person()Student.prototype.constructor = Student //修正constructor的指向var s3 = new Student('娅蝉', 18, '女', 99)var s4 = new Student('秋云', 22, '男', 66)console.log('s1 :', s3) //okconsole.log('s2 :', s4) //okconsole.log('s3.test() :', s3.test()) //ok 组合继承的优化–寄生组合式继承&emsp;&emsp;1. 在借用构造函数中，已经继承到了父类的属性，所以原型继承中只继承父类的方法就行了 12将 Student.prototype = new Person()优化为：Student.prototype = Person.prototype &emsp;&emsp;2. 经过上一次优化后，将父类原型对象的值(地址值)赋给子类，此时父类子类的原型对象为同一个对象，修改其中的一个另一个也会跟着变。给子类原型添加某方法，父类原型也有了这个方法，这显然不是我们想要的结果。 &emsp;&emsp;3. Object.create()方法创建一个新对象，使用现有的对象(当作参数)来提供新创建的对象的proto。这里不是直接引用Parent.prototype，而是借助它创建一个新的对象，从而实现父子构造函数原型对象的隔离。 最佳版本： 12最优解为：Student.prototype = Object.create(Person.prototype) 测试 12345678910111213141516171819202122232425262728function Person (name, age, sex) &#123; this.name = name this.age = age this.sex = sex&#125;Person.prototype.test = function () &#123; console.log('hello,' + this.name)&#125;function Student (name, age, sex, score) &#123; Person.call(this, name, age, sex) this.score = score&#125;Student.prototype = Object.create(Person.prototype)Student.prototype.constructor = StudentStudent.prototype.sayHi = function () &#123; console.log('hi,' + this.name);&#125;var s3 = new Student('娅蝉', 18, '女', 99)var s4 = new Student('秋云', 22, '男', 66)console.log('s3 :', s3)console.log('s4 :', s4)s3.test()s4.sayHi() //完美 扩展-Object.cerate方法的实现123456function createObject (obj) &#123; function F () &#123;&#125; F.prototype = obj return new F()&#125;//亲测有效 四：ES6之calss类继承 用 class 定义类 用 constructor() 定义构造方法(相当于构造函数) 一般方法: xxx () {} 必须这么写 用extends来定义子类 继承父类 用super()来调用父类的构造方法 子类方法自定义: 将从父类中继承来的方法重新实现一遍 js中没有方法重载(方法名相同, 但参数不同)的语法 123456789101112131415161718192021222324252627class Person &#123; // 类的构造方法 constructor(name, age) &#123; this.name = name this.age = age &#125; // 类的一般方法 showInfo () &#123; console.log(`my name is $&#123;this.name&#125;.`); console.log(`I am $&#123;this.age&#125; years old.`); &#125;&#125;class starPerson extends Person &#123; constructor (name, age, salary) &#123; super(name, age)//调用父类的构造方法 this.salary = salary &#125; showSalary () &#123; console.log(`my salary is $&#123;this.salary&#125; ￥`); &#125;&#125;let star = new starPerson('yachan', 18, 9999999999)console.log('star :', star);star.showInfo()star.showSalary() 有事您Q我👇]]></content>
      <categories>
        <category>js-oop</category>
      </categories>
      <tags>
        <tag>inherit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-BOM-web-api]]></title>
    <url>%2Fjs-BOM%2Fjs-%E7%BB%84%E6%88%90-BOM-web-api%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; BOM模态框操作 alert() 只有确定按钮 confirm() 可带提示文本 确定取消按钮 prompt() 可带提示文本 带文本输入框 确定取消按钮 12345678910if (window.confirm("Do you really want to leave?")) &#123; alert("Thanks for Visiting!")&#125;let sign = prompt("你是什么星座的?")if (sign == "天蝎座")&#123; alert("哇! 我也是天蝎座的耶!")&#125; window.prompt('你觉得很幸运吗?','是的') 默认为是的 window页面加载&emsp;&emsp;window.onload() 当页面加载完成执行 当页面完全加载所有内容（包括图像、脚本文件、CSS 文件等）执行&emsp;&emsp;window.onunload() 当用户退出页面时执行 浏览器窗口活跃监听-页面失去焦点获得焦点123456789 window.onblur = function () &#123; document.title = '欢迎你嗷~~^-^' setTimeout(() =&gt; &#123; document.title = '原来的title' &#125;, 1000);&#125; window.onfocus = function () &#123; document.title = '别离开我嘛^-^'&#125; location对象 location对象是window对象下的一个属性. location可以获取或者设置浏览器地址栏的URL URL 统一资源定位符 (Uniform Resource Locator, URL) URL的组成 12345678910111213scheme://host:port/path?query#fragmentscheme:通信协议 常用的http,ftp,maito等host:主机 服务器(计算机)域名系统 (DNS) 主机名或 IP 地址。port:端口号 整数，可选，省略时使用方案的默认端口，如http的默认端口为80。path:路径 由零或多个'/'符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。query:查询 可选，用于给动态网页传递参数，可有多个参数，用'&amp;'符号隔开，每个参数的名和值用'='符号隔开。例如：name=zsfragment:信息片断 字符串，锚点. 1234567891011let url = document.createElement('a');url.href = 'https://developer.mozilla.org/en-US/search?q=URL#search-results-close-container';console.log(url.href); // https://developer.mozilla.org/en-US/search?q=URL#search-results-close-containerconsole.log(url.protocol); // https:console.log(url.host); // developer.mozilla.orgconsole.log(url.hostname); // developer.mozilla.orgconsole.log(url.port); // (blank - https assumes port 443)console.log(url.pathname); // /en-US/searchconsole.log(url.search); // ?q=URLconsole.log(url.hash); // #search-results-close-containerconsole.log(url.origin); // https://developer.mozilla.org history对象 back() forward() go() window.navigator对象&emsp;&emsp;window.navigator.userAgent 通过userAgent可以判断用户浏览器的类型&emsp;&emsp;window.navigator.platform 通过platform可以判断浏览器所在的系统平台类型. 高度宽度offset偏移量 client可视区 scroll滚动条 screen屏幕 body身上 12345678910111213网页可见区域宽：document.body.clientWidth 网页可见区域高：document.body.clientHeight 网页被卷去的高：document.body.scrollTop 网页被卷去的左：document.body.scrollLeft 网页正文全文宽：document.body.scrollWidth 网页正文全文高：document.body.scrollHeight 浏览器上边框距离屏幕上边框：window.screenTop 浏览器左边框距离屏幕左边框：window.screenLeft 屏幕分辨率的高：window.screen.height 屏幕分辨率的宽：window.screen.width element元素身上 123456789101112131415161718192021222324252627clientWidth和clientHeight：元素的可视部分宽度和高度即content宽 + padding(有则加上两边padding) - 滚动条宽(有则减去就行)clientLeft和clientTop：元素的border部分宽度和高度offsetParent：用于获取定位的父级元素offsetWidth和offsetHeight：整个容器的宽高,以一个外人的角度看即元素的border+padding+content的宽度和高度该属性和其内部的内容是否超出元素大小无关，只和本来设置的border以及width和height有关。offsetLeft参照最近的定位父级，没有则参照body即定位父级的border-left + 自身定位的left + 自身的margin-leftscrollWidth子元素整个宽 + 自身padding-leftscrollTop和scrollLeft：这对元素是可读写的，指的是当元素其中的内容超出其宽高的时候，元素被卷起的宽度和高度。 demo瀑布流123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;瀑布流&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #box &#123; position: relative; margin: 0 auto &#125; img &#123; width: 220px; display: block; &#125; .item &#123; box-shadow: 2px 2px 2px #999; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="box"&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/0.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/1.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/22.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/3.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/4.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/5.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/6.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/7.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/8.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/9.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/10.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/11.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/12.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/13.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/14.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/15.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/16.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/17.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/18.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/19.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/20.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/21.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/22.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/1.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/0.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/11.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/10.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/14.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/20.jpg" alt=""&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;img style="width:200px" src="waterfall/17.jpg" alt=""&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var box = document.getElementById('box'); var items = box.children; // 定义每一列之间的间隙 为10像素 var gap = 10; window.onload = function () &#123; // 一进来就调用一次 waterFall(); // 封装成一个函数 function waterFall() &#123; // 1- 确定列数 = 页面的宽度 / 图片的宽度 var pageWidth = getClient().width; var itemWidth = items[0].offsetWidth; var columns = parseInt(pageWidth / (itemWidth + gap)); var arr = []; for (var i = 0; i &lt; items.length; i++) &#123; if (i &lt; columns) &#123; // 2- 确定第一行 items[i].style.top = 0; items[i].style.left = (itemWidth + gap) * i + 'px'; arr.push(items[i].offsetHeight); &#125; else &#123; // 其他行 // 3- 找到数组中最小高度 和 它的索引 var minHeight = arr[0]; var index = 0; for (var j = 0; j &lt; arr.length; j++) &#123; if (minHeight &gt; arr[j]) &#123; minHeight = arr[j]; index = j; &#125; &#125; // 4- 设置下一行的第一个盒子位置 // top值就是最小列的高度 + gap items[i].style.top = arr[index] + gap + 'px'; // left值就是最小列距离左边的距离 items[i].style.left = items[index].offsetLeft + 'px'; // 5- 修改最小列的高度 // 最小列的高度 = 当前自己的高度 + 拼接过来的高度 + 间隙的高度 arr[index] = arr[index] + items[i].offsetHeight + gap; &#125; &#125; &#125; // 页面尺寸改变时实时触发 var timer = null; window.onresize = function () &#123; //节流操作 clearTimeout(timer); timer = setTimeout(function () &#123; waterFall(); // console.log(1); &#125;, 200); &#125;; // 当加载到第30张的时候 var timer1 = null; window.onscroll = function () &#123; clearTimeout(timer1); //节流操作 timer1 = setTimeout(function () &#123; if (getClient().height + getScrollTop() &gt;= items[items.length - 1].offsetTop) &#123; // 模拟 ajax 获取数据 var datas = [ "waterfall/ac83da565dfbb2ba9d8df0e8b360f0ee.jpg", "waterfall/c452a945a2649696beb03d892176d031.jpg", "waterfall/ac83da565dfbb2ba9d8df0e8b360f0ee.jpg", "waterfall/c452a945a2649696beb03d892176d031.jpg", "waterfall/ac83da565dfbb2ba9d8df0e8b360f0ee.jpg" ]; for (var i = 0; i &lt; datas.length; i++) &#123; var div = document.createElement("div"); div.className = "item"; div.innerHTML = '&lt;img style="width:200px" src="' + datas[i] + '" alt=""&gt;'; box.appendChild(div); &#125; waterFall(); &#125; &#125;, 200); &#125;; &#125;; // clientWidth 处理兼容性 function getClient() &#123; return &#123; width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth, height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight &#125; &#125; // scrollTop兼容性处理 function getScrollTop() &#123; return window.pageYOffset || document.documentElement.scrollTop; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 有事您Q我👇]]></content>
      <categories>
        <category>js-BOM</category>
      </categories>
      <tags>
        <tag>BOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-DOM]]></title>
    <url>%2FDOM%2Fjs-%E7%BB%84%E6%88%90-DOM-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; dom获取 JS获取DOM元素的方法（8种） 123456789通过ID获取 getElementById通过name属性 getElementsByName通过标签名 getElementsByTagName通过类名 getElementsByClassName获取html的方法 document.documentElement获取body的方法 document.body通过选择器获取一个元素 querySelector通过选择器获取一组元素 querySelectorAll html属性操作dataset H5自定义属性操作&emsp;&emsp;在通过dataset添加自定义属性的时候，不能带有”data-“。浏览器会自动添加data-。&emsp;&emsp;data-前缀后面的属性名称也可以带有连字符。&emsp;&emsp;当使用dataset属性进行动态操作的时候，需要转换连字符为驼峰写法，结果显示为连字符。 123456添加自定义属性 并赋值div.dataset.shulu="舒璐";div.dataset.lqyLove = "哈哈哈" //想要lqy-love写法，但得驼峰写法，最终显示为lqy-love 浏览器查看结果为：&lt;div data-shulu="舒璐" data-lqy-love="哈哈哈"&gt;&lt;/div&gt; getAttribute/setAttribute属性操作 getAttribute() 获取标签行内属性 setAttribute() 设置标签行内属性 removeAttribute() 移除标签行内属性 如果一个属性可能不存在于指定的元素上，在调用 getAttribute() 之前，你应该使用 element.hasAttribute() 来检测该属性是否存在。 dataset与getAttribute/setAttribute的区别: getAttribute和setAttribute方法也可以设置和获取元素的属性，主要区别如下： 上述两方法更加博爱，无论是否符合data-*语法格式，都可以顺利获取或者设置。 dataset则是专门针对符合HTML5规范的自定义属性的管理，更加方便。 dataset属性返回值是DOMStringMap对象，也就是说针对DOMStringMap对象的操作，然后影响到HTML元素，而getAttribute/setAttribute方法则是针对字符串的操作。 获取操作样式属性 获取元素的行间样式属性 element.style.样式属性 读取的样式是最终样式属性 getComputedStyle(element, 样式属性) 取相应属性值得时候都是采用的 CSS 驼峰式写法. element.style 既支持读也支持写，我们通过 element.style 即可改写元素的样式。 而 getComputedStyle 仅支持读并不支持写入。我们可以通过使用 getComputedStyle 读取样式，通过 element.style 修改样式 12345获取最终样式属性方法function getComputed (ele, prop) &#123; return ele.currentStyle ? ele.currentStyle(prop) : window.getComputedStyle(ele, null)[prop]&#125; classList 类名操作 add()：添加样式类。 item()：返回指定索引的样式类。 remove()：删除指定样式类。 toggle()：切换样式类 contains() 检查是否包含某属性 1234567891011app.classList.add('love')console.log(app.classList.item(0))app.classList.remove('lqy')document.addEventListener('click', () =&gt; &#123; app.classList.toggle('love')&#125;)console.log( app.classList.contains('shulu')) 节点操作 appendChild() insertBefore() removeChild() replaceChild() 1234567891011var body = document.body;var div = document.createElement('div');body.appendChild(div);var firstEle = body.children[0];body.insertBefore(div, firstEle);body.removeChild(firstEle);var text = document.createElement('p');body.replaceChild(text, div); 节点/元素层级获取 节点包括了text文本节点等 元素只是就是HTML元素 12345678910let app = document.getElementById('app') console.log(app.parentNode) // 父节点console.log(app.childNodes) // 子节点集合console.log(app.children) // 子元素console.log(app.nextSibling) // 下一个兄弟节点console.log(app.previousSibling) // 下一个兄弟节点console.log(app.firstChild) // 第一个子节点console.log(app.lastChild) // 最后一个子节点console.log(app.nextElementSibling) // 下一个兄弟元素console.log(app.previousElementSibling) // 上一个兄弟元素 Dom事件##基本概念 Dom事件级别 123Dom 0级事件：element.onclick = function() &#123;...&#125;Dom 2级事件：element.addEventListener('click', function() &#123;...&#125;)Dom 3级事件：element.addEventListener('keyup', function() &#123;...&#125;) 鼠标事件 键盘事件 Dom事件模型 事件捕获 由上到下 事件冒泡 由下到上 Dom事件流 捕获阶段 由上到下 目标阶段 冒泡阶段 由下到上 描述Dom事件捕获的具体流程123456window document html (用js获取html标签：document.documentElement) body ... 目标元素 捕获阶段触发事件 addEventListener的第三个参数为true即可12345678910111213span.addEventListener('click', () =&gt; &#123; console.log('span') console.log('以上事件为捕获阶段触发的')&#125;, true)window.addEventListener('click', () =&gt; &#123; console.log('window')&#125;, true)document.addEventListener('click', () =&gt; &#123; console.log('document')&#125;, true)document.documentElement.addEventListener('click', () =&gt; &#123; console.log('html')&#125;, true) 冒泡阶段触发事件12345678910111213window.addEventListener('click', () =&gt; &#123; console.log('window')&#125;)document.addEventListener('click', () =&gt; &#123; console.log('document')&#125;)document.documentElement.addEventListener('click', () =&gt; &#123; console.log('html')&#125;)span.addEventListener('click', () =&gt; &#123; console.log('以下事件为冒泡阶段触发的') console.log('span')&#125;) Event对象的常见应用123456789101112131415161718192021222324event.preventDefault() 阻止默认事件event.stopPropagation() 阻止事件冒泡event.stopImmediatePropagation() 阻止事件冒泡并且阻止相同事件的其他侦听器被调用。event.currentTarget 事件的当前目标。它总是指向事件绑定的元素。通常为父元素。代理事件的元素。event.target 触发事件的对象 (某个DOM元素) 的引用。通常为子元素。 常见如 event.target.nodeName.toLowerCase() == 'li'const p = document.querySelector('p');p.addEventListener("click", (event) =&gt; &#123; alert("我是p元素上被绑定的第一个监听函数"); &#125;, false);p.addEventListener("click", (event) =&gt; &#123; alert("我是p元素上被绑定的第二个监听函数"); event.stopImmediatePropagation(); //执行stopImmediatePropagation方法,阻止click事件冒泡,并且阻止p元素上绑定的其他click事件的事件监听函数的执行.&#125;, false);p.addEventListener("click",(event) =&gt; &#123; alert("我是p元素上被绑定的第三个监听函数"); // 该监听函数排在上个函数后面，该函数不会被执行&#125;, false); 自定义事件 创建一个自定义事件 123456789let myevent = new Event('custom')// 监听事件btn.addEventListener('custom', () =&gt; &#123; alert('custom事件触发了')&#125;)// 触发事件 自定义触发条件setTimeout(() =&gt; &#123; btn.dispatchEvent(myevent)&#125;,1000) 有事您Q我👇]]></content>
      <categories>
        <category>DOM</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-ECMAScript]]></title>
    <url>%2FECMAScript%2Fjs-%E7%BB%84%E6%88%90-ES-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;珍惜自己——何必为昨天的泪，打湿今天的阳光。 运算符的优先级 圆括号 最高 () 成员访问 . 和[] 后置递增和递减 a++ 和 a– 逻辑非、一元正号和负号、前置递增和递减 !a +a -a ++a –a 以及typeof 幂运算 2**3 乘法 除法 取模 a*3 a/3 a%3 加减法 a+3 a-3 关系运算符 大于小于 大于等于 小于等于 以及instanceof 相等运算符 == != === !== 逻辑运算符 先逻辑与&amp;&amp; 后逻辑非|| 条件运算符 (三目) … ? … : … 赋值运算符 = += -= *= /= %= switch 该语句在比较值时使用的是全等操作符, 因此不会发生类型转换 #布尔类型的隐式转换 流程控制语句会把后面的值隐式转换成布尔类型 转换为true 非空字符串 非0数字 true 任何对象 转换成false 空字符串 0 false null undefined continue和break break:立即跳出整个循环，即循环结束，开始执行循环后面的内容（直接跳到大括号） continue:立即跳出当前循环，继续下一次循环（跳到i++的地方） 123456789let sum = 0for (let i = 0; i &lt; 10; i++) &#123; if (i % 2 == 0) continue sum += i&#125;alert(sum) 代码调试过去调试js的方式 alert() console.log() 断点调试 断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。 调试步骤1浏览器中按F12--&gt;sources--&gt;找到需要调试的文件--&gt;在程序的某一行设置断点 调试中的相关操作1234567Watch: 监视，通过watch可以监视变量的值的变化，非常的常用。点击右上角的+号即可添加要监视的变量。F10: 程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。F11：程序单步执行，还会进入函数一步步执行F8：跳到下一个断点处，如果后面没有断点了，则程序执行结束。 tips:监视变量，不要监视表达式，因为监视了表达式，那么这个表达式也会执行。 代码调试的能力非常重要，只有学会了代码调试，才能学会自己解决bug的能力。初学者不要觉得调试代码麻烦就不去调试，知识点花点功夫肯定学的会，但是代码调试这个东西，自己不去练，永远都学不会。 #词法作用域 变量的作用域是在定义时决定而不是执行时决定，也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。 js预解析 JavaScript代码的执行是由浏览器中的JavaScript解析器来执行的。JavaScript解析器执行JavaScript代码的时候，分为两个过程：预解析过程和代码执行过程 预解析过程： 把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值。 把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用。 先提升var，再提升function new关键字 构造函数 ，是一种特殊的函数。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。 构造函数用于创建一类对象，首字母要大写。 构造函数要和new一起使用才有意义。 new在执行时会做四件事情 1234new会在内存中创建一个新的空对象new 会让this指向这个新的对象执行构造函数 目的：给这个新对象加属性和方法new会返回这个新对象 简单数据类型 Number、String、Boolean、Undefined、Null Number类型 数值范围 1234最小值：Number.MIN_VALUE，这个值为： 5e-324最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308无穷大：Infinity无穷小：-Infinity 数值判断 123- NaN：not a number- NaN 与任何值都不相等，包括他本身- isNaN: is not a number String类型 字符串长度length属性用来获取字符串的长度 str面试题 判断一个字符串中出现次数最多的字符，统计这个次数 123456789101112131415161718let str = 'abachgabdjsabas'let obj = &#123;&#125;for (let i = 0; i &lt; str.length; i++) &#123; let item = [str[i]] obj[item] ? obj[item]++ : obj[item] = 1&#125;let max = obj[0], char = ''for (const key in obj) &#123; if (max &lt; obj[key]) &#123; max = obj[key] char = key &#125;&#125;console.log('char :', char);console.log('max :', max); Boolean类型 Boolean字面量：true和false，区分大小写 计算机内部存储：true为1，false为0 Undefined和Null undefined表示一个声明了没有赋值的变量，变量只声明的时候值默认是undefined null表示一个空，变量的值如果想为null，必须手动设置 字面量 在源代码中一个固定值的表示法。 复杂数据类型 Object 数据类型转换 如何使用谷歌浏览器，快速的查看数据类型？ 字符串的颜色是黑色的，数值类型是蓝色的，布尔类型也是蓝色的，undefined和null是灰色的 转换成字符串类型 toString() 12var num = 5;console.log(num.toString()); String() 1String()函数存在的意义：有些值没有toString()，这个时候可以使用String()。比如：undefined和null 拼接字符串方式 num + “”，当 + 两边一个操作符是字符串类型，一个操作符是其它类型的时候，会先把其它类型转换成字符串再进行字符串拼接，返回字符串 转换成数值类型 Number() 1Number()可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回NaN parseInt() 12var num1 = parseInt("12.3abc"); // 返回12，如果第一个字符是数字会解析直到遇到非数字结束var num2 = parseInt("abc123"); // 返回NaN，如果第一个字符不是数字或者符号就直接返回NaN parseFloat() 1234parseFloat()把字符串转换成浮点数parseFloat()和parseInt非常相似，不同之处在与parseFloat会解析第一个. 遇到第二个.或者非数字结束如果解析的内容里只有整数，解析成整数 +，-0等运算 1234var str = '500';console.log(+str); // 取正console.log(-str); // 取负console.log(str - 0); // number: 500 转换成布尔类型 Boolean() 120 ''(空字符串) null undefined NaN 会转换成false 其它都会转换成true Date对象 创建 Date 实例用来处理日期和时间。 Date 对象基于1970年1月1日（世界标准时间）起的毫秒数。 1234// 获取当前时间，UTC世界时间，距1970年1月1日（世界标准时间）起的毫秒数var now = new Date();console.log(now.valueOf()); // 获取距1970年1月1日（世界标准时间）起的毫秒数或now.getTime() Date构造函数的参数 毫秒数 1498099000356 new Date(1498099000356) 日期格式字符串 ‘2015-5-1’ new Date(‘2015-5-1’) 年、月、日 new Date(2015, 4, 1) // 月份从0开始 日期格式化方法1234567toString() // 转换成字符串valueOf() // 获取毫秒值// 下面格式化日期的方法，在不同浏览器可能表现不一致，一般不用toDateString()toTimeString()toLocaleDateString()toLocaleTimeString() 获取日期指定部分12345678910getTime() // 返回毫秒数和valueOf()结果一样， // valueOf()内部调用的getTime()getMilliseconds() getSeconds() // 返回0-59getMinutes() // 返回0-59getHours() // 返回0-23getDay() // 返回星期几 0周日 6周6getDate() // 返回当前月的第几天getMonth() // 返回月份，***从0开始***getFullYear() //返回4位的年份 如 2016 案例 写一个函数，格式化日期对象，返回yyyy-MM-dd HH:mm:ss的形式 123456789101112131415161718192021222324252627let nowDate = new Date()function formatDate(d) &#123; function getTowNum (num) &#123; return num = num &lt; 10 ? '0' + num : num &#125; //如果date不是日期对象，返回 if (!d instanceof Date) &#123; return; &#125; let year = d.getFullYear(), month = d.getMonth() + 1, date = d.getDate(), hour = d.getHours(), minute = d.getMinutes(), second = d.getSeconds(); month = getTowNum(month) date = getTowNum(date) hour = getTowNum(hour) minute = getTowNum(minute) second = getTowNum(second) return year + '-' + month + '-' + date + ' ' + hour + ':' + minute + ':' + second;&#125;console.log('formatDate(nowDate) :', formatDate(nowDate)); 计算时间差，返回相差的天/时/分/秒12345678910111213141516171819function getInterval(start, end) &#123; // interval间距 let day, hour, minute, second, interval; interval = end - start; interval /= 1000; // 得到秒数 day = Math.round(interval / 60 /60 / 24); hour = Math.round(interval / 60 /60 % 24); minute = Math.round(interval / 60 % 60); second = Math.round(interval % 60); return &#123; day: day, hour: hour, minute: minute, second: second &#125;&#125;let futureDate = new Date(2020, 6, 15)console.log('getInterval(nowDate, futureDate) :', getInterval(nowDate, futureDate)); 数组与字符串的转换123456let arr = [1,2,3,4]let str = 'shululqy'console.log('arr.toString() :', arr.toString());console.log('arr.join() :', arr.join());console.log('str.split(',') :', str.split('').join('')); 面试-反转数组12345678910111213141516function myReverse(arr) &#123; if (!arr || arr.length == 0) &#123; return []; &#125; for (var i = 0; i &lt; arr.length / 2; i++) &#123; var tmp = arr[i]; arr[i] = arr[this.length - i - 1]; arr[arr.length - i - 1] = tmp; &#125; return arr;&#125;var array = ['a', 'b', 'c'];console.log(myReverse(array));console.log(array.reverse()); 面试123456789101112131415161718// 找到数组中每一个a出现的位置var array = ['c', 'a', 'z', 'a', 'x', 'a'];function getPosition (array, n) &#123; let arr = [] for (let i = 0; i &lt; array.length; i++) &#123; //if (n === array[i]) &#123; // arr.push(i) //&#125; n === array[i] &amp;&amp; arr.push(i) &#125; let position = arr.map( item =&gt; item + 1).toString() return position&#125;console.log( getPosition(array, 'a')); //2,4,6 面试-编写方法-数组去重1234567891011121314var array = ['c', 'a', 'z', 'a', 'x', 'a'];function uni (array) &#123; let arr = [] for (let i = 0; i &lt; array.length; i++) &#123; if (arr.indexOf(array[i]) === -1) &#123; //indexOf === -1 就是没找到 arr.push(array[i]) &#125; &#125; return arr&#125;console.log('uni(array) :', uni(array)); 有事您Q我👇]]></content>
      <categories>
        <category>ECMAScript</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm]]></title>
    <url>%2Fnpm%2Fnpm%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;随意切换 npm 镜像源。 nrm（node registry manager） nrm 可以解决 npm 镜像访问慢的问题，还可以对各个 npm 的镜像进行速度测试，随意切换 npm 镜像源。 安装 nrm npm install nrm -g nrm 是 npm 的一个模块，我们可以直接使用 npm 进行安装。 对镜像源进行测速 nrm test 我们可以使用 nrm 对 npm 的源进行测速，然后使用当前网络下最快的源。 *代表当前源，从我目前的网速来看，这几个源的状态都还不错，我还是使用 npm 源，因为不会有一些奇怪的 bug 产生。根据你的网速自行选择，如果 npm 源速度不错的话，还是建议使用 npm 源，其次才是 cnpm 和 taobao。 切换源 nrm use taobao 我们在切换源之前要知道具体的源对应的链接，这个时候如果去网上找的话，那就太麻烦了，nrm 也就没什么作用了。 我们切换源的时候，直接使用简称就可以.这个时候再通过 nrm ls 查看源的列表，就会发现我们切换成功了。 有事您Q我👇]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>nrm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5-newApi]]></title>
    <url>%2FH5%2FH5-newApi%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; online网络状态 我们可以通过window.navigator.onLine来检测，用户当前的网络状况，返回一个布尔值， 但是不同浏览器会存在差异. 所以HTML5 给我们提供了2个事件: online和offline 1234567891. 当网络连接到时候 弹出 p 显示网络连接 然后消失window.addEventListener('online', function() &#123; $(".tips").text("网络已连接").fadeIn(500).delay(1000).fadeOut();&#125;)2. 当网络断开到时候 弹出 p 显示网络已断开 然后消失window.addEventListener('offline', function() &#123; $(".tips").text("哎呀，网络断开了").fadeIn(500).delay(1000).fadeOut();&#125;) dom.requestFullScreen()全屏显示 全屏显示可以是任意元素 H5 API 存在兼容性问题 ie9 + 即使高版本浏览器有兼容性问题 不同浏览器需要添加不同的前缀 webkit moz o ms 1234/* 注意兼容性问题 全屏显示伪类选择器 */div:-webkit-full-screen &#123; background-color: pink;&#125; 123456&lt;div&gt; &lt;img src="pic1.png" height="300" alt=""&gt; &lt;button id="full"&gt;全屏显示&lt;/button&gt; &lt;button id="cancelFull"&gt;取消全屏&lt;/button&gt; &lt;button id="isFull"&gt;是否全屏&lt;/button&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031let div = document.querySelector("div");// 1 单击全屏显示document.querySelector("#full").onclick = function() &#123;// 能力检测 做一个兼容性的解决方法 if(div.requestFullScreen) &#123; // 正常浏览器 div.requestFullScreen(); &#125; else if (div.webkitRequestFullScreen) &#123; // webkit 内核 div.webkitRequestFullScreen(); &#125; else if (div.mozRequestFullScreen) &#123; // moz div.mozRequestFullScreen(); &#125; else if (div.msRequestFullscreen) &#123; // ms 微软 这里面有个坑 别掉进去了 div.msRequestFullscreen(); // ms 里面这样写msRequestFullscreen() s是小写的 &#125; else &#123; // 欧朋 div.oRequestFullScreen(); &#125;&#125;// 2 取消全屏 跟元素没有关系 跟 document有关系document.querySelector("#cancelFull").onclick = function() &#123; document.webkitCancelFullScreen(); // document 退出全屏&#125;// 3 是否全屏显示document.querySelector("#isFull").onclick = function() &#123; alert(document.webkitIsFullScreen); // webkit是否存在 全屏状态&#125; input type=file文件读取并显示demo-可以把上传的文件，文本内容显示到页面？12&lt;input type="file" multiple &gt; //multiple可选择多个文件&lt;div&gt;&lt;/div&gt; 1234567891011121314151617181. 上传我们的文件 let file = document.querySelector("input");let div = document.querySelector("div");当input发生改变的时候 下拉菜单 select 也是这个事件 onchangefile.onchange = function() &#123; console.log(this.files); // 上传文件组成的集合 2. 选择我们要的文件， 进行读取文件里面的内容 let reader = new FileReader(); // 初始化一个文件读取对象reader reader.readAsText(this.files[0]); // 读取this.files[0] 第一个文件对象 3. 读取完毕把读取的内容显示到页面中 reader.onload = function() &#123; div.innerHTML = this.result; //result存储着读取后的内容，这里为文本 &#125;&#125; 上传完毕图片显示缩略图(自己写img的宽高)到页面上123456789101112131415161718&lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;&quot; multiple &gt; &lt;img src=&quot;&quot; alt=&quot;&quot; width=&quot;100&quot;&gt;let file = document.querySelector(&quot;input&quot;);let img = document.querySelector(&quot;img&quot;);file.onchange = function() &#123; let reader = new FileReader(); reader.readAsDataURL(this.files[0]); reader.onload = function() &#123; console.log(this.result); // result为 data: URL 即base64格式的字符串 img.src = this.result; // 把读取的内容赋值给图片 src &#125;&#125; files对象 由于HTML5中我们可以通过为表单元素添加multiple属性，因此我们通过input上传文件后得到的是一个files对象（伪数组形式）。 FileReader对象 FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容. let reader = new FileReader; 可以实例化一个对象 实例方法 FileReader.readAsDataURL() 读取结果为data: URL格式的字符串 FileReader.readAsText() 读取结果为文本字符串 事件监听 onload 当读取完成时触发 属性 result 文件读取结果内容 地理定位 谷歌地理位置定位navigator.geolocation，咱们不用 百度地图 百度地图api 有地理名片等等好多的功能 拖拽 在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。 draggable 属性：就是标签元素要设置draggable=true，否则不会有效果 注意：链接和图片默认是可拖动的，不需要 draggable 属性。 csdn 拖拽和释放 拖拽：drag 释放：drop 拖拽指的是鼠标点击源对象后一直移动对象不松手，一但松手即释放了 拖拽API的相关事件 拖拽API总共就是7个函数！！ 被拖动的源对象可以触发的事件： ondragstart：源对象开始被拖动 ondrag：源对象被拖动过程中(鼠标可能在移动也可能未移动) ondragend：源对象被拖动结束 拖动源对象可以进入到上方的目标对象可以触发的事件： ondragenter：目标对象被源对象拖动着进入 ondragover：目标对象被源对象拖动着悬停在上方 ondragleave：源对象拖动着离开了目标对象 ondrop：源对象拖动着在目标对象上方释放/松手 在拖动的源对象事件和目标对象事件间传递数据 HTML5为所有的拖动相关事件提供了一个新的属性： e.dataTransfer { } 数据传递对象 用于在源对象和目标对象的事件间传递数据 源对象上的事件处理中保存数据： e.dataTransfer.setData( k, v ); k-v必须都是string类型 目标对象上的事件处理中读取数据： let v = e.dataTransfer.getData( k ); HTML5新增的文件操作对象： File： 代表一个文件对象 FileList： 代表一个文件列表对象，类数组 FileReader：用于从文件中读取数据 FileWriter：用于向文件中写出数据 相关函数： 1234567891011121314div.ondrop = function(e)&#123; let file = e.dataTransfer.files[0]; //找到拖放的文件 let reader = new FileReader(); //创建文件读取器 reader.readAsURLData(file); //读取文件内容 reader.onload = function()&#123; //读取完成 img.src = reader.result; //使用读取到的数据 &#125;&#125; demo-从桌面(客户端电脑)拖拽上传头像 好玩好玩 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//样式#container &#123; border: 1px solid #aaa; border-radius: 3px; padding: 10px; margin: 10px; min-height: 400px;&#125;//dom&lt;h3&gt;请拖动您的照片到下方方框区域&lt;/h3&gt;&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;//javascript//监听document的drop事件——取消其默认行为：在新窗口中打开图片document.ondragover = function(e)&#123; e.preventDefault(); //使得drop事件可以触发&#125;document.ondrop = function(e)&#123; e.preventDefault(); //阻止在新窗口中打开图片，否则仍然会执行下载操作！！！&#125;//监听div#container的drop事件，设法读取到释放的图片数据，显示出来container.ondragover = function(e)&#123; e.preventDefault();&#125;container.ondrop = function(e)&#123; console.log(&apos;客户端拖动着一张图片释放了...&apos;) //当前的目标对象读取拖放源对象存储的数据 //console.log(e.dataTransfer); //显示有问题 //console.log(e.dataTransfer.files.length); //拖进来的图片的数量 let f0 = e.dataTransfer.files[0]; //console.log(f0); //文件对象 File //从文件对象中读取数据 let fr = new FileReader(); //fr.readAsText(f0); //从文件中读取文本字符串 fr.readAsDataURL(f0); //从文件中读取URL数据 fr.onload = function()&#123; console.log(&apos;读取文件完成&apos;) console.log(fr.result); let img = new Image(); img.src = fr.result; //URL数据 container.appendChild(img); &#125;&#125; demo-元素单向拖动1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//样式div &#123; width: 200px; height: 200px; border: 1px solid red; float: left; margin: 10px;&#125;div:nth-child(2) &#123; border: 1px solid green;&#125;p &#123; height: 25px; background-color: pink; line-height: 25px; text-align: center;&#125;//dom&lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot; draggable=&quot;true&quot;&gt;拖拽内容1&lt;/p&gt; &lt;p id=&quot;p2&quot; draggable=&quot;true&quot;&gt;拖拽内容2&lt;/p&gt;&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;//javascriptlet obj = null; // 用于存放我们拖放对象 源对象document.ondragstart = function(event) &#123; obj = event.target; // 把当前对象给 obj 然后追加到 新目标对象里面就阔以了&#125;let target = document.querySelector(&quot;#div2&quot;);target.ondragover = function(e) &#123; // 如果想要触发 ondrop 事件 则需要在over 里面 阻止 默认行为 return false; // e.preventDefault()&#125;target.ondrop = function() &#123; // 目标对象. appendChild(源对象) this.appendChild(obj); // 拖拽的时候 ，不用删除原来的 &#125; demo-垃圾箱效果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//stylediv &#123; width: 200px; height: 200px; border: 1px solid red; float: left; margin: 10px;&#125;div:nth-child(2) &#123; width: 300px; line-height: 200px; text-align: center; border: 1px solid green;&#125;p &#123; height: 25px; background-color: pink; line-height: 25px; text-align: center; margin-top: 5px;&#125;//dom&lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot; class=&quot;drag&quot; draggable=&quot;true&quot;&gt;拖拽内容1&lt;/p&gt; &lt;p id=&quot;p2&quot; class=&quot;drag&quot; draggable=&quot;true&quot;&gt;拖拽内容2&lt;/p&gt; &lt;p id=&quot;p3&quot; class=&quot;drag&quot; draggable=&quot;true&quot;&gt;拖拽内容3&lt;/p&gt;&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;垃圾箱&lt;/div&gt;//js let dragList = document.querySelectorAll(&apos;.drag&apos;);//找到全部p元素for(let i=0; i&lt;dragList.length; i++)&#123; //遍历p元素 let p = dragList[i]; p.ondragstart = function(e) &#123; e.dataTransfer.setData(&apos;PlaneID&apos;,this.id);//保存数据--该img元素的id console.log(&apos;this.id :&apos;, this.id); //元素的id属性值 &#125;&#125;let target = document.querySelector(&quot;#div2&quot;);target.ondragover = function(e) &#123; return false; // e.preventDefault()&#125;target.ondrop = function(e) &#123; //删除被拖动的源对象 let id = e.dataTransfer.getData(&apos;PlaneID&apos;);//得到数据--id值 let p = document.getElementById(id); //根据id值找到相关的元素 p.parentNode.removeChild(p); //从父元素中删除子节点&#125; demo-来回拖动元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//csssection&#123; border: 1px solid red; width: 606px; height: 202px;&#125;div &#123; width: 200px; height: 200px; border: 1px solid red; float: left;&#125;div:nth-child(2) &#123; border: 1px solid green;&#125;div:nth-child(3)&#123; border: 1px solid blue;&#125;p &#123; height: 25px; background-color: pink; line-height: 25px; text-align: center; margin-bottom: 5px;&#125;//dom&lt;section id=&quot;section&quot;&gt; &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot; draggable=&quot;true&quot;&gt;拖拽内容1&lt;/p&gt; &lt;p id=&quot;p2&quot; draggable=&quot;true&quot;&gt;拖拽内容2&lt;/p&gt; &lt;p id=&quot;p3&quot; draggable=&quot;true&quot;&gt;拖拽内容3&lt;/p&gt; &lt;p id=&quot;p4&quot; draggable=&quot;true&quot;&gt;拖拽内容4&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; &lt;div id=&quot;div3&quot;&gt;&lt;/div&gt;&lt;/section&gt;//js let section = document.getElementById(&apos;section&apos;)section.ondragstart = function(event) &#123; // 当我们开始拖拽的时候，就存储数据 // 记录 当前源对象的id 名字 event.dataTransfer.setData(&quot;dragId&quot;, event.target.id); &#125; section.ondragover = function(e) &#123; return false; // e.preventDefault()&#125; section.ondrop = function(event) &#123; // 获取 dataTransfer里面的数据 var id = event.dataTransfer.getData(&quot;dragId&quot;); event.target.appendChild(document.getElementById(id)); // 因为我们追加的 源对象p id 只是id名字，需要通过id 获取元素 追加到目标对象里面 // 所以我们 document.getElementById(id)&#125; storage本地存储 随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案。 存储特性 设置、读取方便、页面刷新不丢失数据 容量较大，sessionStorage约5M、localStorage约20M 只能存储字符串，可以将对象JSON.stringify() 编码后存储 方法详解 setItem(key, value) 设置存储内容 getItem(key) 读取存储内容 removeItem(key) 删除键值为key的存储内容 clear() 清空所有存储内容 window.sessionStorage 生命周期为关闭浏览器窗口 在同一个窗口(页面)下数据可以共享 即小范围 短周期 window.localStorage 永久生效，除非手动删除 关闭页面也会存在 可以多窗口（页面）共享（同一浏览器可以共享） 即大范围 长周期 其它新的存储方案 WebSQL IndexDB demo-window.sessionStorage12345678910111213141516171819202122232425262728293031323334353637383940&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;br /&gt;&lt;br /&gt;&lt;button id=&quot;setData&quot;&gt;设置数据&lt;/button&gt;&lt;button id=&quot;getData&quot;&gt;获取数据&lt;/button&gt;&lt;button id=&quot;delData&quot;&gt;删除数据&lt;/button&gt;&lt;button id=&quot;getAge&quot;&gt;getAge&lt;/button&gt;var username = document.querySelector(&quot;#username&quot;);// 点击按钮存取数据 window.sessionStorage.setItem(&quot;age&quot;, 18);window.sessionStorage.setItem(&quot;address&quot;, &quot;北京&quot;);getAge.onclick = function () &#123; alert(window.sessionStorage.getItem(&quot;address&quot;))&#125;document.querySelector(&quot;#setData&quot;).onclick = function() &#123;// 点击之后得到 username 里面值 var val = username.value; // 存储数据 // window.sessionStorage.setItem(key, value) 设置存储内容 window.sessionStorage.setItem(&quot;username&quot;, val);&#125; // 点击按钮获得数据 document.querySelector(&quot;#getData&quot;).onclick = function() &#123; // 获得数据 // window.sessionStorage.getItem(key) 读取存储内容 alert(window.sessionStorage.getItem(&quot;username&quot;)) ;&#125;document.querySelector(&quot;#delData&quot;).onclick = function() &#123; // window.sessionStorage.removeItem(key) 删除键值为key的存储内容 // window.sessionStorage.removeItem(&quot;username&quot;); // 删除所有的 数据 window.sessionStorage.clear();&#125; demo-window.localStorage123456789101112131415161718192021222324&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;br /&gt;&lt;br /&gt;&lt;button id=&quot;setData&quot;&gt;设置数据-userName&lt;/button&gt;&lt;button id=&quot;getData&quot;&gt;获取数据-userName&lt;/button&gt;&lt;button id=&quot;delData&quot;&gt;删除数据-userName&lt;/button&gt;var username = document.querySelector(&quot;#username&quot;); window.localStorage.setItem(&quot;age&quot;, 18); window.localStorage.setItem(&quot;address&quot;, &quot;北京&quot;);document.querySelector(&quot;#setData&quot;).onclick = function() &#123; var val = username.value; window.localStorage.setItem(&quot;username&quot;, val);&#125;document.querySelector(&quot;#getData&quot;).onclick = function() &#123; alert(window.localStorage.getItem(&quot;username&quot;)) ;&#125;document.querySelector(&quot;#delData&quot;).onclick = function() &#123; window.localStorage.removeItem(&quot;username&quot;); // 删除所有的 数据 // window.localStorage.clear(); 这个清楚要慎用 &#125; manifest-appcache应用缓存 HTML5中我们可以轻松的构建一个离线（无网络状态）应用，只需要创建一个cache manifest文件。 缓存优势 可配置需要缓存的资源 网络无连接应用仍可用 本地读取缓存资源，提升访问速度，增强用户体验 减少请求，缓解服务器负担 缓存清单 一个普通文本文件，其中列出了浏览器应缓存以供离线访问的资源，推荐使用.appcache为后缀名 例如我们创建了一个名为demo.appcache的文件，然后在需要应用缓存在页面的根元素(html)添加属性manifest=”demo.appcache”，路径要保证正确。 manifest文件格式 顶行写CACHE MANIFEST CACHE: 换行 指定我们需要缓存的静态资源，如.css、image、js等 NETWORK: 换行 指定需要在线访问的资源，可使用通配符 FALLBACK: 换行 当被缓存的文件找不到时的备用资源 缓存其它知识 CACHE: 可以省略，这种情况下将需要缓存的资源写在CACHE MANIFEST 可以指定多个CACHE: NETWORK: FALLBACK:，无顺序限制 ＃表示注释，只有当demo.appcache文件内容发生改变时或者手动清除缓存后，才会重新缓存。 chrome 可以通过chrome://appcache-internals/工具和离线（offline）模式来调试管理应用缓存 demo-图片缓存1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot; manifest=&quot;study.appcache&quot;&gt; &lt;!-- study.appcache 引入 缓存清单 --&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;缓存&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;images/img1.jpg&quot; &gt; &lt;img src=&quot;images/img2.jpg&quot; &gt; &lt;img src=&quot;images/img3.jpg&quot; &gt; &lt;img src=&quot;images/img4.jpg&quot; &gt;&lt;/body&gt;&lt;/html&gt; 缓存清单study.appcache文件 1234567891011121314151617181920212223242526CACHE MANIFEST# 上面必须是第一行 CACHE:#此部分写需要缓存的资源 （#是注释的意思）./images/img1.jpg./images/img2.jpg./images/img3.jpg./images/img4.jpgNETWORK:#此部分要写需要有网络才可访问的资源，无网络不访问./images/img1.jpg./images/img2.jpg#*FALLBACK:#当访问不到某个资源的情况下，自动由另一个资源替换./images/img4.jpg ./images/img5.jpg audio/video-多媒体 w3c 方法： load() 重新加载音频/视频元素 play() 开始播放音频/视频 pause() 暂停当前播放的音频/视频 属性： autoplay 设置或返回是否在加载完成后随即播放音频/视频 controls 设置或返回音频/视频是否显示控件（比如播放/暂停等） currentSrc 返回当前音频/视频的 URL currentTime 设置或返回音频/视频中的当前播放位置（以秒计） duration 返回当前音频/视频的长度（以秒计） ended 返回音频/视频的播放是否已结束 loop 设置或返回音频/视频是否应在结束时重新播放 paused 设置或返回音频/视频是否暂停 等等 事件： oncanplay 当浏览器可以播放音频/视频时 ontimeupdate 当目前的播放位置已更改时 ended 当目前的播放列表已结束时 error 当在音频/视频加载期间发生错误时 progress 当浏览器正在下载音频/视频时 等等 大神博客video.js 有事您Q我👇]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>H5-newApi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5-Document-header]]></title>
    <url>%2FH5%2FH5-Document-header%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; HTML5头部分 文档元数据 元数据（Metadata）含有页面的相关信息，包括样式、脚本及数据，能帮助一些软件（例如 搜索引擎、浏览器 等等）更好地运用和渲染页面。对于样式和脚本的元数据，可以直接在网页里定义，也可以链接到包含相关信息的外部文件。 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;/&gt; &lt;title&gt;shulu&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;/&gt; &lt;meta name=&quot;description&quot; content=&quot;网站描述内容&quot;/&gt; &lt;meta name=&quot;keywords&quot; content=&quot;网站关键字&quot;/&gt;&lt;/head&gt; 文档版本类型声明 HTML5的文档类型，参照淘宝网 &lt;!DOCTYPE html&gt; 规定网页内容使用的语言 简体中文，参照淘宝网 &lt;html lang=&quot;zh-CN&quot;&gt; 字符设定 万国语，参照淘宝网 &lt;meta charset=&quot;utf-8&quot;&gt; 强制IE浏览器渲染方式 对于IE浏览器，如果用户安装了GCF，则使用GCF来渲染页面，如果未安装GCF则使用最高版本的IE内核来进行渲染。 Google Chrome Frame(谷歌内嵌浏览器框架GCF) 参照淘宝网 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;/&gt; title 网站的标题 网站描述内容&lt;meta name=&quot;description&quot; content=&quot;网站描述内容&quot;/&gt; 网站关键字&lt;meta name=&quot;keywords&quot; content=&quot;网站关键字&quot;/&gt; 视口设置1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;/&gt; 有事您Q我👇]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>H5-Document-header</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5-Element]]></title>
    <url>%2FH5%2FH5-Element%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; HTML5是Web中核心语言HTML的新规范，现在先学习H5的基础部分-H5新元素。 先学习HTML常见的元素标签 HTML（英文Hyper Text Markup Language的缩写）中文译为“超文本标签语言”，主要是通过HTML标签对网页中的文本、图片、声音等内容进行描述。 MDN-HTML-Element html标签： 作用所有HTML中标签的一个根节点。 head标签： 作用：用于存放：title,meta,base,style,script,link 注意在head标签中我们必须要设置的标签是title title标签： 作用：让页面拥有一个属于自己的标题。 body标签： 作用：页面在的主体部分，用于存放所有的HTML标签： h系列标题标签 单词缩写:head头部即标题 为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即&lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;和&lt;h6&gt; 注意：h1 标签因为重要，尽量少用, 一般h1都是给logo使用。 p段落标签 单词缩写:paragraph段落 是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。 div span标签 div、span 是没有语义的，是我们网页布局主要的2个盒子。 div 就是division的缩写，分割，分区的意思。 span, 跨度，跨距；范围 img图像标签 单词缩写：image图像 src属性用于指定图像文件的路径和文件名，他是img标签的必需属性。 a链接标签锚点定位 单词缩写:anchor 的缩写 。基本解释 锚, 铁锚. 在HTML中创建超链接非常简单，只需用标签环绕需要被链接的对象即可. 123456789101112131415161718192021222324&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt;href：用于指定链接目标的url地址，当为标签应用href属性时，它就具有了超链接的功能。 Hypertext Reference的缩写。意思是超文本引用target：用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，_blank为在新窗口中打开方式。注意：1.外部链接 需要添加 http:// www.baidu.com2.内部链接 直接链接内部页面名称即可 比如 &lt; a href=&quot;index.html&quot;&gt; 首页 &lt;/a &gt;3.如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=&quot;#&quot;)，表示该链接暂时为一个空链接。4.不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。锚点定位:通过创建锚点链接，用户能够快速定位到目标内容。创建锚点链接分为两步：1.使用href=”#id名“链接文本创建链接文本。2.使用相应的id名标注跳转目标的位置。 注释标签 在HTML中还有一种特殊的标签——注释标签。如果需要在HTML文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。其基本语法格式如下：​ 1&lt;!-- 注释语句 --&gt; 注释内容不会显示在浏览器窗口中，但是作为HTML文档内容的一部分，也会被下载到用户的计算机上，查看源代码时就可以看到。 ul无序列表 无序列表的各个列表项之间没有顺序级别之分，是并列的。 123&lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。&lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。 ol有序列表 所有特性基本与ul 一致。但是实际工作中，较少用 ol . 自定义列表（理解） 定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。 用的还可以： 12345678910&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ...&lt;/dl&gt; Web组件元素 slot 插槽 template HTML内容模板 table表格标签 存在即是合理的。表格的现在还是较为常用的一种标签，但不是用来布局，常见为处理表格式数据。 MDN-table 123456789101112131415161718192021222324252627282930313233创建简单的表格&lt;table&gt; &lt;tr&gt; &lt;th colspan=&quot;3&quot;&gt;表头文本会加粗居中&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;table: 用于定义一个表格。tr: 用于定义表格中的一行，必须嵌套在table标签中，在 table 中包含几对 tr，就有几行表格。td：用于定义表格中的单元格，必须嵌套在tr标签中，一对 tr中包含几对td，就表示该行中有多少列（或多少个单元格）。th: 表头标签,表头一般位于表格的第一行或第一列，其文本加粗居中.注意：1. &lt;tr&gt;&lt;/tr&gt;中只能嵌套&lt;td&gt;&lt;/td&gt;2. &lt;td&gt;&lt;/td&gt;标签，他就像一个容器，可以容纳所有的元素表格结构（了解）在使用表格进行布局时，可以将表格划分为头部、主体和页脚（页脚因为有兼容性问题，此处不在赘述）&lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部。&lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主体。合并单元格跨行合并：rowspan 跨列合并：colspan表格不要纠结于外观，那是CSS 的作用。 form表单标签(掌握) 现实中的表单，类似我们去银行办理信用卡填写的单子。目的是为了收集用户信息。 在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时也需要表单。 在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。 表单控件：包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 提示信息：一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。 表单域：他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 input标签 控件(重点) 表单 &lt;input&gt;类型type,如果未指定此属性，则采用的默认类型为text. 以下为type属性的常见类型： 1234567891011121314151617181920212223242526checkbox： 复选框。使用 checked 属性指示控件是否被选择。file：此控件可以让用户选择文件。使用 accept 属性可以定义控件可以选择的文件类型。password：一个值被遮盖的单行文本字段。使用 maxlength 指定可以输入的值的最大长度 。radio：单选按钮。在同一个”单选按钮组“中，所有单选按钮的 name 属性使用同一个值。reset：用于将表单所内容设置为空的按钮。submit：用于提交表单的按钮。tel: HTML5新类型，tel类型的元素用于让用户输入和编辑电话号码。其中最明显的就是移动浏览器— 特别是在手机上 — 可能会选择提供为输入电话号码而优化的自定义键盘。使用电话号码的特定输入类型也使添加自定义验证和处理电话号码更方便。email输入邮箱格式search搜索框（体现语义化） 全局 &lt;input&gt; 属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152type 要呈现的控件类型.accept 如果该元素的 type 属性的值是file,则该属性表明了服务器端可接受的文件类型；否则它将被忽略。autocomplete HTML5新属性这个属性表示这个控件的值是否可被浏览器自动填充。autofocus HTML5这个布尔属性允许您指定的表单控件在页面加载时具有焦点（自动获得焦点）checked如果该元素的type属性的值为radio或者checkbox,则该布尔属性的存在与否表明了该控件是否是默认选择状态.disabled这个布尔属性表示此表单控件不可用。特别是在禁用的控件中，click 事件将不会被分发 。并且，禁用的控件的值在提交表单时也不会被提交。max HTML5 此项目的最大（数字或日期时间）值，且不得小于其最小值（min属性）值。min HTML5 此项目的最小（数字或日期时间）值，且不得大于其最大值（最大属性）值。minlength 元素值的长度 属性为输入的最小长度;maxlength HTML5 元素值的长度如果 type 的值是text, email, search, password, tel, 或 url，那么这个属性指明了用户最多可以输入的字符个数（按照Unicode编码方式计数）.译者注:ie10+name控件的名称，与表单数据一起提交。pattern HTML5检查控件值的正则表达式.。pattern必须匹配整个值，而不仅仅是某些子集.。使用title属性来描述帮助用户的模式.。当类型属性的值为text, search, tel, url 或 email时，此属性适用，否则将被忽略。译者注:ie10+placeholder HTML5提示用户输入框的作用。required HTML5这个属性指定用户在提交表单之前必须为该元素填充值. multiple 多文件上传，input type=filesize控件的初始大小。可以使用 size 属性来控制输入框的物理大小value控件的初始值. 此属性是可选的.list提供建议值 input 元素造型, 你可以使用各种与颜色相关的属性来设置input元素的样式。与文本输入相关的元素特有的一个不常见的特性是CSS caret-color属性，该属性允许你设置用于绘制文本输入插入符的颜色. input的demo-输入电话号码1234567891011121314151617181920212223242526272829&lt;style&gt; #telNo&#123; caret-color: red; /* 插入光标的颜色 */ &#125; #telNo:invalid+span:after &#123; position: absolute; content: &apos;✖&apos;; padding-left: 5px; color: #8b0000; &#125; #telNo:valid+span:after &#123; position: absolute; content: &apos;✓&apos;; padding-left: 5px; color: #009000; &#125;&lt;/style&gt;&lt;form &gt; &lt;fieldset&gt; //控件组 效果就是一个边框线 &lt;legend&gt;输入电话号码&lt;/legend&gt; //内容相关说明 &lt;label for=&quot;telNo&quot;&gt;Phone number: &lt;/label&gt; &lt;input id=&quot;telNo&quot; size=&quot;12&quot; autofocus name=&quot;telNo&quot; type=&quot;tel&quot; placeholder=&quot;请输入电话号码&quot; maxlength=&quot;11&quot; required list=&quot;defaultTels&quot; pattern=&quot;^(0|86|17951)?(13[0-9]|15[012356789]|166|17[3678]|18[0-9]|14[57])[0-9]&#123;8&#125;$&quot;&gt; &lt;span class=&quot;validity&quot;&gt;&lt;/span&gt; &lt;datalist id=&quot;defaultTels&quot;&gt; //选项建议列表 &lt;option value=&quot;13161122239&quot;&gt; &lt;option value=&quot;15161122239&quot;&gt; &lt;/datalist&gt; &lt;/fieldset&gt;&lt;/form&gt; label标签(理解) label 标签为 input 元素定义标注（标签）。 作用：用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点. 如何绑定元素呢？for 属性规定 label 与哪个表单元素绑定。 123&lt;label for=&quot;male&quot;&gt;Male&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; value=&quot;male&quot;&gt; textarea控件(文本域) 如果需要输入大量的信息.通过textarea控件可以轻松地创建多行文本输入框. 123&lt;textarea cols=&quot;每行中的字符数&quot; rows=&quot;显示的行数&quot;&gt; 文本内容&lt;/textarea&gt; select下拉菜单标签12345&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt;&lt;/select&gt; form表单域 在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。 123&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单名称&quot;&gt; 各种表单控件……&lt;/form&gt; 常用属性： Action 在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址。 method 用于设置表单数据的提交方式，其取值为get或post。 name 用于指定表单的名称，以区分同一个页面中的多个表单。 注意：每个表单都应该有自己表单域。 HTML5 新标签 XHTML属于XML，是HTML进行XML严格化的结果 HTML5不属于XML，比XHTML宽松，比如input属性checked直接写这样就行了,而不用写checked=”checked”。 HTML标签的语义化 所谓标签语义化，就是指标签的含义。 为什么要有语义化标签 方便代码的阅读和维护 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容 使用语义化标签会具有更好地搜索引擎优化 核心：合适的地方给一个最为合理的标签。 语义是否良好： 当我们去掉CSS之后，网页结构依然组织有序，并且有良好的可读性。 不管是谁都能看懂这块内容是什么。 遵循的原则：先确定语义的HTML ，再选合适的CSS。 HTML5样式标签 em 语义化的标签表强调，而i标签是纯样式的标签，表斜体，H5不推荐使用，一般用来做图标。 H5常用结构新标签 header：定义文档的页眉 nav：定义导航链接的部分 footer：定义文档或节的页脚 article：标签规定独立的自包含内容 section：定义文档中的节（section、区段） aside：定义其所处内容之外的内容,如广告 article 元素表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。 section 表示文档中的一个区域（或节），比如，内容中的一个专题组，一般来说会有包含一个标题（heading）。一般通过是否包含一个标题 (h1-h6 元素) 作为子节点来辨识每一个section。 audio标签 多媒体 用于在文档中表示音频内容。 autoplay 自动播放 controls 是否显不默认播放控件 loop 循环播放 更多关于audio的内容查看本博客H5-audio专栏部分。 video标签 多媒体 HTML5通过video标签来解决音频播放的问题。 autoplay 自动播放 controls 是否显示默认播放控件 loop 循环播放 width 设置播放窗口宽度 height 设置播放窗口的高度 更多关于video的内容查看本博客H5-video专栏部分。 有事您Q我👇]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>H5-Element</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[browser-core]]></title>
    <url>%2Fbrowser%2Fbrowser-core%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;了解主流浏览器的核心-内核，为了应付面试，也有助于我们在不同内核的浏览器中测试网页的渲染效果。 browser主流浏览器及其内核 浏览器内核是浏览器的核心，也称“渲染引擎”，用来解释网页语法并渲染到网页上。 浏览器内核决定了浏览器该如何显示网页内容以及页面的格式信息。 不同的浏览器内核对网页的语法解释也不同，因此网页开发者需要在不同内核的浏览器中测试网页的渲染效果。 browser国际市场 1994年诞生IE浏览器； IE浏览器内核：Trident内核，也是俗称的IE内核； 1995年诞生Opera浏览器； Opera浏览器内核：最初是自己的Presto内核，后来加入谷歌大军，从Webkit又到了Blink内核； 2003年诞生Safari浏览器； Safari浏览器内核：Webkit内核； 2004年诞生Firefox浏览器； Firefox浏览器内核：Gecko内核，俗称Firefox内核； 2008年诞生Chrome浏览器； Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，2013年以后到现在是Blink内核； browser国内市场 360浏览器、 猎豹浏览器内核：IE+Chrome双内核； 搜狗、 遨游、 QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）； 百度浏览器、 世界之窗内核：IE内核； 2345浏览器内核：好像以前是IE内核，现在也是IE+Chrome双内核了； UC浏览器内核：这个众口不一，UC说是他们自己研发的U3内核，但好像还是基于Webkit和Trident，还有说是基于火狐内核。 移动端的浏览器内核 移动端的浏览器内核主要说的是系统内置浏览器的内核。 目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等。 其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit。 Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink。 Windows Phone 8 系统浏览器内核是 Trident。 browser有关说明 大家的误解，一直认为的chrome内核就是由苹果公司最先选择的算是KHTML引擎的分支-Webkit，这大概是苹果公司至今说不清道不明的伤痛吧~~chromium fork 自开源引擎 webkit，却把 WebKit 的代码梳理得可读性提高很多。 2013年4月3日，谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器内核 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实Blink引擎就是也就是Webkit的分支，就像Webkit是KHTML的分支一样。Blink引擎现在是谷歌公司与Opera Software共同研发。 win10 edge浏览器 EdgeHTML内核; 据有关消息，微软即将发布的新版 Edge 浏览器很可能同时包含谷歌的 Blink 和 自身的Trident两个浏览器内核，方便浏览器给那些为 IE 设计的网站提供向后兼容性。换句话说，就是要把未来的Windows 10默认浏览器替换成只是换了一个皮肤的Chrome。采用Chromium内核的Edge浏览器测试版已经放出了安装包。在用完之后，我最惊叹的一点，就是它能做得多么像是Chrome。这款Edge基本上可以让一个习惯使用Chrome的用户无缝切换，菜单布局，功能设置等等分毫不差。为了做到体验上的完全对接，Edge这一测试版甚至连浏览器标签页一行、后退前进等按钮和地址栏一行和书签栏一行的高度都做到了跟Chrome平齐。 还有在手机微信上内嵌的浏览器，因为它采用QQ浏览器的X5内核，同时因为跟微信深度耦合，并且要调用很多通过微信实现的系统能力，所以出现了有些网页必须专门适配微信的局面。 Web标准（重点） 通过了解以上浏览器的内核不同，我们知道他们工作原理、解析肯定不同，显示就会有差别。通过web标准的约束，尽量使同一套代码在不同的浏览器有相同的结构、表现和行为。 Web 标准的好处 让Web的发展前景更广阔 内容能被更广泛的设备访问 更容易被搜寻引擎搜索 降低网站流量费用 使网站更易于维护 提高页面浏览速度 Web 标准构成 Web标准不是某一个标准，而是由W3C和其他标准化组织制定的一系列标准的集合。 主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。 结构标准：结构用于对网页元素进行整理和分类，主要包括XML和XHTML两个部分。 样式标准：表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS。 行为标准：行为是指网页模型的定义及交互的编写，主要包括DOM和ECMAScript两个部分。 有事您Q我👇]]></content>
      <categories>
        <category>browser</category>
      </categories>
      <tags>
        <tag>browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass]]></title>
    <url>%2Fsass%2Fcss3-sass%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;学习使用css预处理器sass让我们更爽地敲css代码。 css预处理器-sass介绍 sass使用ruby语言编写，下载使用有些不方便，使用cnpm成功率高 vscode 下载EasySass运行插件。 注意：下载的是node-sass, sass的文件后缀是.scss 项目是npm init 过的 cnpm install node-sass 编写.scss后缀的文件后，自动会生成对应文件名的.css文件,以及压缩过的对应文件名的.min.css文件 css预处理器的作用 帮助我们更好的组织css代码 提高代码的复用率 提升可维护性 sass嵌套 选择器之间可以嵌套 反映层级和约束 sass变量-$ 复用常用的个别属性 123456789//定义变量$fontSize: 18px;$bgColor: red;//使用变量.child&#123; font-size: $font-size + 2px; background-color: $bgColor; &#125; sass运算 支持加减乘除多种运算。 1font-size: $font-size + 2px; sass混入-Mixin 复用css代码片段 1234567891011121314151617$color: pink;$bgColor: blue;$fontSize: 18px;//定义混入//注意：这里base是一个代码片段的名字@mixin base($color, $h, $bgc, $fontSize)&#123; color: $color; height: $h; background: $bgc; font-size: $fontSize;&#125;//使用混入.wrap&#123; @include base(yellow, 300px, $bgColor, $fontSize)&#125; sass继承-extend 复用css代码片段 生成的样式中，样式片段没有重复 @extend会增加选择器之间的联系，然后把他们堆在一起。 123456789// 一个普通的类就是一个extend.button&#123; color: yellow;&#125;// 使用extendh2&#123; @extend .button;&#125; sass中mixin的优缺点 优点：@mixin主要的优势就是它能够接受参数。 优点：还能直接给@mixin传递样式片段。 缺点：生成的代码会变得肿胀。 sass中extend的优缺点 优点：生成的样式中，样式片段没有重复。 缺点：@extend会增加选择器之间的联系，然后把他们堆在一起。被继承的选择器和继承别人的选择器可能会在样式表的不同位置，这就导致维护困难，放置顺序，或者需要差异化的一些问题。 缺点：@extend命令不够灵活。不能向它传递参数，它原本是啥样就是啥样。 sass中mixin vs extend @mixin和@extend都能帮助你模块化代码，然后更加方便地在样式表中复用一些样式片段。 从结果上看，mixin是直接把代码复制过来，而extend是将有公共样式的选择器提取出来，用分组选择器把他们放在一起。 你可能会问，到底什么时候使用@mixin，什么时候使用@extend? 总结：在大作数情况下@mixin会比@extend更好，但是它们俩都有自己的一席之地。当样式和选择器之间的关系在某些方面比较紧密的时候，使用@extend。除此之外，你可以使用@mixin在任何地方。 sass循环-loop 生成一些复杂有规律的代码片段 123456//直接使用for循环，生成各自宽度的col-1 ~ col-12的css代码片段。@for $i from 1 to 12 &#123; .col-#&#123;$i&#125;&#123; width: 1000px/12*$i; &#125;&#125; sass文件模块化@import123@import &quot;./header&quot;; .scss后缀可以省略@import &quot;./nav&quot;; @import &quot;./footer&quot; sass中css预处理器框架 Compass 提供现成的mixin, 类似js类库，封装常用功能。 有事您Q我👇]]></content>
      <categories>
        <category>sass</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less]]></title>
    <url>%2Fless%2Fcss3-less%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;学习使用css预处理器less让我们更爽地敲css代码。 css预处理器-less介绍 less使用nodejs编写，下载使用都方便 vscode 下载EasyLess运行插件。 项目是npm init 过的 npm i less 即可使用 编写.less后缀的文件后，自动会生成对应文件名的.css文件 css预处理器的作用 帮助我们更好的组织css代码 提高代码的复用率 提升可维护性 less嵌套 选择器之间可以嵌套 反映层级和约束 less变量-@ 复用常用的个别属性 123456789//定义变量@font-size: 18px;@bgColor: red; //使用变量.child&#123; font-size: @font-size + 2px; background-color: @bgColor; &#125; less运算 支持加减乘除多种运算。 less混入-Mixin 复用常用的css代码片段 1234567891011121314151617@color: pink;@bgColor: blue;@fontSize: 18px;//定义混入//注意：这里.base是一个类名.base(@color, @h, @bgc, @fontSize)&#123; color: @color; height: @h; background: @bgc; font-size: @fontSize;&#125;//使用混入.wrap&#123; .base(yellow, 300px, @bgColor, @fontSize)&#125; less继承-extend 复用css代码片段 生成的样式中，样式片段没有重复 &amp;:extend()会增加选择器之间的联系，然后把他们堆在一起。 123456789// 一个普通的类就是一个extend.box&#123; color: @color;&#125;// 使用extendh2&#123; &amp;:extend(.box);&#125; less中mixin和extend的优缺点 同sass中的一样，参考sass部分 less循环 生成一些复杂有规律的代码片段 less中没有循环的方法,但是我们可以在mixin中使用递归方法模拟循环。 12345678910//在mixin中使用递归方法模拟循环。.gen-col(@n) when (@n &gt; 0) &#123; .gen-col(@n - 1); .col-@&#123;n&#125; &#123; width: 1000px/12*@n; &#125;&#125;//调用循环，生成各自宽度的col-1 ~ col-12的css代码片段。.gen-col(12); less文件模块化@import123@import &quot;./header&quot;; .less后缀可以省略@import &quot;./nav&quot;; @import &quot;./footer&quot;; less中css预处理器框架 Lesshat EST(百度大牛编写) 提供现成的mixin, 类似js类库，封装常用功能。 EST的介绍使用 est 是一个基于 Less 的样式工具库，帮助您更轻松地书写 Less 代码。 est 提供了一系列方便快捷的 mixin，只在调用时才输出代码。est 不希望提供直接给 HTML 调用的类名，用「样式类」污染 HTML 代码的语义。当然您也可以根据自己的项目需求基于 est 搭建样式类库，提供类名接口来进行快速开发。 官网教程 123456789101112131415161718192021222324252627282930313233使用 Git 获取代码：git clone https://github.com/ecomfe/est.git然后在 Less 代码中引入。@import &quot;est/src/all.less&quot;;官网导航介绍：variables 全局变量设置。normalize 用来归一化不同浏览器下的页面样式。reset 进行全局样式重置。即 .global-reset()shapes 提供绘制基本形状的功能effects 提供预设视觉效果。layout 提供常见的基础布局。grid 帮助生成自定义的栅格布局。 clockhand 提供顺时针简写的功能。typography 文字排版相关功能。util 常用辅助类工具函数。compatibility 提供基础的兼容性封装。// ...your own awesome less code starts here... 有事您Q我👇]]></content>
      <categories>
        <category>less</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3-BFC]]></title>
    <url>%2Fcss3%2Fcss3-BFC%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;BFC就是页面上的一个独立容器，容器里面的元素不会影响到外面的元素，反之亦然。学习页面布局，css-BFC的知识要重点掌握。 BFC-块级格式化上下文BFC规则、特性 Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻box的margin会发生重叠 BFC的区域不会与float box的重叠，紧贴着浮动盒子的边缘 计算BFC的高度时，浮动元素也参与计算。 BFC就是页面上的一个独立容器，容器里面的元素不会影响到外面的元素，反之亦然。 块级元素的BFC创立条件 float属性不为none position属性为absolute或fixed display属性为inline-block、table相关、flex overflow属性不为visible(以上最常用的是overflow: hidden, 副作用少) BFC的用途 清除浮动: 这时可以让父元素生成BFC，即解决子因子元素浮动而父级高度塌陷问题 解决外边距合并问题：假设有两个p元素，可以在其中一个p上包裹容器，然后触发其BFC，这样两个p就不在同一个BFC，因此就不会发生重叠 自适应两栏布局: 即左边盒子浮动，右边盒子触发BFC 有事您Q我👇]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3-flex]]></title>
    <url>%2Fcss3%2Fcss3-flex%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; flex 规定了弹性元素如何伸长或缩短以适应flex容器中的可用空间。 Flexbox即 Flexible Box Module（弹性盒模型） Flexbox同一时间只能控制行或列中的一个维度。对于二维控制需要 grid网格布局。 主轴 即X轴方向(默认) 侧轴 即Y轴方向(默认) 侧轴垂直于主轴 flex 各个属性父元素-伸缩容器 display: flex; 声明使用伸缩布局 flex-direction: row(默认); 定义了主轴的方向(正方向或反方向)。 1234flex-direction: row; x轴方向flex-direction: row-reverse; -X轴方向flex-direction: column; Y轴方向flex-direction: column-reverse; -Y轴方向 justify-content 主轴上项目的对齐方式。 1234567justify-content: center; 居中排列 justify-content: start; 从行首起始位置开始排列 justify-content: end; 从行尾位置开始排列 justify-content: space-between; 均匀排列每个元素 首个元素放置于起点，末尾元素放置于终点 justify-content: space-around; 均匀排列每个元素 每个元素周围分配相同的空间 justify-content: space-evenly; 均匀排列每个元素 每个元素之间的间隔相等 align-items 侧轴上项目的对齐方式–针对单行即子元素只有一行(不换行) 1234align-items: center; align-items: start;align-items: end; align-items: stretch; 拉伸子元素的高度以适应父元素的高度(子元素不给高度的情况) align-content 侧轴上项目的对齐方式–针对多行即子元素有多行(换行) 12345678align-content: center; 将项目放置在中点 align-content: start; 最先放置项目 align-content: end; 最后放置项目 align-content: space-between; 均匀分布项目 第一项与起始点齐平，最后一项与终止点齐平 align-content: space-around; 均匀分布项目 项目在两端有一半大小的空间align-content: space-evenly; 均匀分布项目 项目周围有相等的空间 align-content: stretch; 均匀分布项目 拉伸‘自动’-大小的项目以充满容器 flex-wrap 是否允许子元素换行显示 123flex-wrap: nowrap; 默认不换行flex-wrap: wrap; 换行flex-wrap: wrap-reverse; 换行并反向显示 12345678910111213141516//demo 水平垂直对齐三条属性就搞定html,body&#123; height: 100%;&#125;body&#123; display: flex; justify-content: center; align-items: center;&#125;#app&#123; width: 300px; height: 300px; background-color: red;&#125;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; flex-flow 简写属性 弹性流 flex-direction 和 flex-wrap 属性的简写 子元素-伸缩项目 flex: 1或2等无单位的数值，表示这个子元素占几份父元素的空间，当然子元素也可以指定宽度。简写属性， 是flex-grow、 flex-shrink 和 flex-basis 的简写。 order: -1或1、2等无单位的数值，表示子元素的排列顺序，数值越小排列越靠前 justify-self: 对齐主轴方向的某个项目 align-self 对齐侧轴方向的单个项目 扩展css属性 min-width: 如500px; 盒子可伸缩最小宽度 max-width: 如1000px; 盒子可伸缩最大宽度 有事您Q我👇]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3-animation]]></title>
    <url>%2Fcss3%2Fcss3-animation%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 动画定义 关键帧@keyframes1234567891011@keyframes animiationName&#123; keyframes-selector&#123; css-style; &#125;&#125;animiationName:必写项，定义动画的名称keyframes-selector：必写项，动画持续时间的百分比,两个状态点的时候，可以用from、to,多组动画状态时使用百分比。 from：0% to：100%css-style：css声明 动画使用 animation animation属性是一个简写属性形式: （可以用来描述可动画的属性） 可动画属性的列表：https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties 简写属性animation1234567891011121314animation： animation-name 动画名称 animation-duration 持续时间 animation-timing-function 速度曲线 (同过渡) animation-delay 延时执行 animation-iteration-count 执行次数 animation-direction 动画方向 animation-fill-mode 设置动画在执行之前和之后如何将样式应用于其目标。值forwards可以使其保持最终状态而不是恢复到原始状态(默认) animation-play-state 设置动画状态 running 当前动画正在运行。 paused 当前动画以被停止。 在每个动画定义中，顺序很重要：可以被解析为 的第一个值被分配给animation-duration, 第二个分配给 animation-delay。 无缝滚动 有事您Q我👇]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>guigu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3-transform]]></title>
    <url>%2Fcss3%2Fcss3-transform%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; transform transform 属性 , 只对 block 级元素生效！ transform 2D旋转 rotate1234transform:rotate(angle/弧度); 正值:顺时针旋转 rotate(360deg/2Π)负值:逆时针旋转 rotate(-360deg/-2Π)只能设单值。正数表示顺时针旋转，负数表示逆时针旋转 平移 translate12345678910X方向平移:transform: translateX(tx)Y方向平移:transform: translateY(ty) 二维平移：transform: translate(tx[, ty])； 如果ty没有指定，它的值默认为0。 可设单值，也可设双值。正数表示XY轴正向位移，负数为反向位移。设单值表示只X轴位移，Y轴坐标不变，例如transform: translate(100px);等价于transform: translate(100px,0);百分比：translateX(50%) 向右平移自己宽度的一半 拓展-定位的盒子居中对齐-优美写法 定位的盒子居中对齐优美写法 123456789101112131415//样式#app&#123; position: absolute; top: 50%; //父级高度的50% left: 50%; transform: translate(-50%, -50%);//自己宽高的50%，无需手动计算 width: 300px; height: 300px; background-color: deeppink;&#125;//dom结构&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 定位的盒子居中对齐传统写法 1234567891011121314151617181920212223242526272829303132写法一：/* #app&#123; position: absolute; top: 50%; left: 50%; margin-top: -150px; margin-left: -150px; width: 300px; height: 300px; background-color: deeppink;&#125; */写法二：/*#app&#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto; width: 300px; height: 300px; background-color: deeppink;&#125; */ 倾斜 skew123456789101112131415transform:skewX(45deg);X方向倾斜:transform: skewX(angle) skewX(45deg):参数值以deg为单位 代表与y轴之间的角度Y方向倾斜:transform: skewY(angle) skewY(45deg):参数值以deg为单位 代表与x轴之间的角度二维倾斜:transform: skew(ax[, ay]); 如果ay未提供，在Y轴上没有倾斜 skew(45deg,15deg):参数值以deg为单位 第一个参数代表与y轴之间的角度 第二个参数代表与x轴之间的角度 单值时表示只X轴扭曲，Y轴不变，如transform: skew(30deg);等价于 transform: skew(30deg, 0); 考虑到可读性，不推荐用单值，应该用transform: skewX(30deg);。skewY表示只Y轴扭曲，X轴不变 正值:拉正斜杠方向的两个角 负值:拉反斜杠方向的两个角 缩放 scale123456789101112131415transform:scale(2);X方向缩放:transform: scaleX(sx); Y方向缩放:transform: scaleY(sy);二维缩放 :transform: scale(sx[, sy]); (如果sy 未指定，默认认为和sx的值相同) 要缩小请设0.01～0.99之间的值，要放大请设超过1的值。例如缩小一倍可以transform: scale(.5); 放大一倍可以transform: scale(2);如果只想X轴缩放，可以用scaleX(.5)相当于scale(.5, 1)。同理只想Y轴缩放，可以用scaleY(.5)相当于scale(1, .5)正值:缩放的程度负值:不推荐使用（有旋转效果）单值时表示只X轴,Y轴上缩放粒度一样，如transform: scale(2);等价于transform: scale(2,2); 基点的变换 transform-origin transform-origin 属性让你更改一个元素变形的基点。 12345678910 一个值：必须是&lt;length&gt;，&lt;percentage&gt;，或 left, center, right, top, bottom关键字中的一个。 两个值：其中一个必须是&lt;length&gt;，&lt;percentage&gt;，或left, center, right关键字中的一个。另一个必须是&lt;length&gt;，&lt;percentage&gt;，或top, center, bottom关键字中的一个。 三个值：前两个值和只有两个值时的用法相同。第三个值必须是&lt;length&gt;。它始终代表Z轴偏移量。 transform 3D3D缩放1234transform: scaleZ(number)transform: scale3d(scaleX,scaleY,scaleZ); 如果只设置scaleZ(number)，你会发现元素并没有被扩大或压缩，scaleZ(number)需要和translateZ(length)配合使用，number乘以length得到的值，是元素沿Z轴移动的距离，从而使得感觉被扩大或压缩 3D旋转123456789CSS3中的3D旋转主要包括四个功能函数rotateX(angle) rotateY(angle) rotateZ(angle)等价于rotate(angle) rotate3d(x,y,z,angle)x, y, z分别接受一个数值(number),用来计算矢量方向(direction vector)，矢量方向是三维空间中的一条线, 从坐标系原点到x, y, z值确定的那个点，元素围绕这条线旋转angle指定的值 3D平移 translateZ 它不能是百分比 值 12345transform: translateZ(length)是3D Transformaton特有的，其他两个2D中就有translateZ 它不能是百分比 值transform: translate3d(translateX,translateY,translateZ); 景深perspective 景深是指相机对焦点前后相对清晰的成像范围。在光学中，尤其是录影或是摄影，是一个描述在空间中，可以清楚成像的距离范围。虽然透镜只能够将光聚 到某一固定的距离，远离此点则会逐渐模糊，但是在某一段特定的距离内，影像模糊的程度是肉眼无法察觉的，这段距离称之为景深。 简单的理解，景深就是我们的肉眼距离显示器的距离，景深越大，元素离我们越远，效果就不好，在我们CSS3中，perspective用于激活一个3D空间，属性值就是景深大小（默认none无景深） 应用景深的元素称为“舞台元素”，舞台元素的所有后代元素都会受影响，（如果后代元素中也添加了perspective属性，效果会叠加而不是覆盖） perspective、perspective-origin设置在父元素上，对后代元素起作用。 1234567891011transform: perspective(depth);depth的默认值是none，可以设置为一个长度值，这个长度是沿着Z轴距离坐标原点的距离。1000px被认为是个正常值若使用perspective()函数，那么他必须被放置在transform属性的首位，如果放在其他函数之后，则会被忽略perspective: depth;同perspective()函数一样，depth的默认值是none，可以设置为一个长度值，这个长度是沿着Z轴距离坐标原点的距离。他们唯一的区别是，perspective属性是被用于元素的后代元素，而不是元素本身；就是说，为某个元素设置perspective属性后，是对这个元素的子元素起作用，而不是这个元素本身。perspective-origin同perspective属性，也是设置在父元素上，对后代元素起作用。 这个属性来设置你在X, Y轴坐标确定的那个点来看这个元素，Z轴是被perspective属性设置的 1000px被认为是个正常值 若使用perspective()函数，那么他必须被放置在transform属性的首位，如果放在其他函数之后，则会被忽略 perspective属性是设置在容器被作用于后代元素，而不是容器元素本身 backface-visibility 此功能某些浏览器尚在开发中 属性 backface-visibility 指定当元素背面朝向观察者时是否可见。 visible 背面朝向用户时可见。 hidden 背面朝向用户时不可见。 transform-style 此功能某些浏览器尚在开发中 属性 transform-style 设置元素的子元素是位于 3D 空间中还是平面中。 flat 设置元素的子元素位于该元素的平面中。 preserve-3d 指示元素的子元素应位于 3D 空间中。 灭点 指的是立体图形各条边的延伸线所产生的相交点。透视点的消失点 有事您Q我👇]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>guigu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3-transition]]></title>
    <url>%2Fcss3%2Fcss3-transition%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 过渡 transition简写属性transition transition是一个简写属性 CSS 过渡 由简写属性 transition 定义是最好的方式，可以避免属性值列表长度不一，节省调试时间 默认值： transition-delay: 0s 属性规定了在过渡效果开始作用之前需要等待的时间。 transition-duration: 0s 属性以秒或毫秒为单位指定过渡动画所需的时间。 transition-property: all 默认值为 all，表示所有可被动画的属性都表现出过渡动画 transition-timing-function: ease 通过这个函数会建立一条加速度曲线，因此在整个transition变化过程中，变化速度可以不断改变 transition-timing-function属性值 ease：（加速然后减速）默认值，ease函数等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0). linear：（匀速），linear 函数等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0). ease-in：(加速)，ease-in 函数等同于贝塞尔曲线(0.42, 0, 1.0, 1.0). ease-out：（减速），ease-out 函数等同于贝塞尔曲线(0, 0, 0.58, 1.0). ease-in-out：（加速然后减速），ease-in-out 函数等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) cubic-bezier： 贝塞尔曲线 step-start：等同于steps(1,start) step-end：等同于steps(1,end) steps(,[,[start|end]]?) 第一个参数：必须为正整数，指定函数的步数 第二个参数：指定每一步的值发生变化的时间点（默认值end） 当属性值的列表长度不一致时 要过渡的属性的个数与对应的给出的时间列表长度不一致时，不够的时候，关于时间的会重复列表，关于transition-timing-function的时候使用的是默认值ease 超出的情况下是会被全部截掉的 检测过渡是否完成–争对属性而言的 当过渡完成时触发一个事件，在符合标准的浏览器下，这个事件是 transitionend, 在 WebKit 下是 webkitTransitionEnd 每一个拥有过渡的属性在其完成过渡时都会触发一次transitionend事件 在transition完成前设置 display: none，事件同样不会被触发 注意 在transition属性中，各个值的书写顺序是很重要的：第一个可以解析为时间的值会被赋值给transition-duration，第二个可以解析为时间的值会被赋值给transition-delay 关于时间要带单位 推荐抒写顺序 过渡时间 过渡样式 过渡形式 延迟时间 兼容性 transition 可以不用厂商前缀，不过鉴于标准刚刚稳定，对于基于 Webkit的浏览器仍然需要厂商前缀。如果想兼容旧版本的浏览器那么也需要厂商前缀（例如Firefox 15 及之前版本, Opera 12 及之前版本) 拓展-贝塞尔曲线 以物理学的角度看：贝塞尔曲线是一条位移时间曲线，其斜率表示速度。 transition: 3s all cubic-bezier(0.445, 0.05, 0.55, 0.95) 0s 有事您Q我👇]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>guigu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3-new-ui]]></title>
    <url>%2Fcss3%2Fcss3-new-ui%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 新增文本样式opacity 透明度，性能高 值为0~1 rgba rgba(0, 0, 0, .5) 颜色表示，a表示透明度 可以实现以前不能实现的样式—背景透明文字不透明 文字阴影 text-shadow: 1px 1px 1px pink, 1px 1px 1px orange; 参数为 x、y轴方向偏移阴影，以及模糊值，颜色 可以叠加阴影，第一个在最上面 浮雕文字 元素模糊123h1&#123; filter: blur(5px)&#125; 模糊背景 文字描边 只有webkit内核才支持：-webkit-text-stroke（准确的来说不能算是css3的东西，但需要大家知道） 123div&#123; -webkit-text-stroke: pink 5px;&#125; 文字排版 direction:控制文字的方向 一定要配合unicode-bidi:bidi-override;来使用 1234div&#123; direction: rtl; 从右向左 unicode-bidi: bidi-override;&#125; 单行文本溢出显示省略号123456// 前提是这个元素不是靠内容撑开的div&#123; white-space: nowrap; 首先不换行 overflow: hidden; 溢出隐藏 text-overflow: ellipsis; 文本显示省略号&#125; 多行文本溢出显示省略号123456789101112131415p&#123; position: relative; height: 40px; 高度为行高的整数倍，防止超出的文字露出 line-height: 20px; overflow: hidden; 溢出隐藏&#125;p:after&#123; 将::after换为:after兼容ie8 content: &quot;...&quot;; position: absolute; right: 0; bottom: 0; padding-left: 40px; background: linear-gradient(to right, transparent, #fff 55%); 添加渐变背景可避免文字只显示一半&#125; 盒模型新增样式 img、input属于行内替换元素。 替换元素就是浏览器根据元素的标签和属性，来决定元素的具体显示内容 替换元素一般有内在尺寸，所以具有width和height，可以设定。 图片居中demo用容器的伪元素给图片做一个兄弟元素(高度=容器的高度，inline-block)，并让他两个基线对齐，就实现了图片的垂直居中 123456789101112131415161718192021//样式#app&#123; width: 500px; height: 500px; border: 1px solid red; text-align: center;&#125;#app::after&#123; content: &quot;&quot;; display: inline-block; height: 100%; vertical-align: middle;&#125;img&#123; vertical-align: middle;&#125;//dom结构&lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./love.gif&quot; alt=&quot;shulu&quot;&gt;&lt;/div&gt; 盒模型阴影 box-shadow box-shadow: 5px 5px 5px 5px pink 即x偏移量 | y偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 可以做不占空间的边框。这个也挺好。 demo 一个元素生成哆啦A梦的图，即是这个元素的多个不同的阴影的叠加效果，配合border-radius，以及前后的两个伪元素。 倒影 -webkit-box-reflect 设置元素的倒影（准确的来说不能算是css3的东西，但需要大家知道） 倒影的方向 第一个值，above, below, right, left 倒影的距离 第二个值，长度单位 渐变 第三个值 123img&#123; -webkit-box-reflect: left&#125; resize 该属性允许你控制一个元素的可调整大小性。 一定要配合overflow：auto使用 both 允许用户在水平和垂直方向上调整元素的大小。 horizontal 水平方向 vertical 垂直方向 1234567#text&#123; width: 100px; height: 100px; background-color: pink; overflow: auto; resize: both;&#125; box-sizing 该属性用于更改用于计算元素宽度和高度的默认的 CSS 盒子模型。可以使用此属性来模拟不正确支持CSS盒子模型规范的浏览器的行为。 box-sizing 属性用于更改用于计算元素宽度和高度的默认的 CSS 盒子模型。可以使用此属性来模拟不正确支持CSS盒子模型规范的浏览器的行/列为。 默认值：content-box 不可继承 1234567content-box默认值，标准盒子模型。 width 与 height 只包括内容的宽和高， 不包括边框（border），内边距（padding），外边距（margin）。注意: 内边距, 边框 &amp; 外边距 都在这个盒子的外部。 比如. 如果 .box &#123;width: 350px&#125;; 而且 &#123;border: 10px solid black;&#125; 那么在浏览器中的渲染的实际宽度将是370px;尺寸计算公式： width = 内容的宽度， height = 内容的高度。 宽度和高度都不包含内容的边框（border）和内边距（padding）。 123456border-boxwidth 和 height 属性包括内容，内边距和边框，但不包括外边距。这是当文档处于 Quirks模式 时Internet Explorer使用的盒模型。这里的维度计算为： width = border + padding + 内容的 width， height = border + padding + 内容的 height。 新增UI样式圆角 border-radius 传统的圆角生成方案，必须使用多张图片作为背景图案 CSS3圆角的出现，使得我们再也不必浪费时间去制作这些图片了，而且还有其他多个优点： 12345678910111213* 减少维护的工作量。图片文件的生成、更新、编写网页代码，这些工作都不再需要了。* 提高网页性能。由于不必再发出多余的HTTP请求，网页的载入速度将变快。* 增加视觉可靠性。某些情况下（网络拥堵、服务器出错、网速过慢等等），背景图片会下载失败，导致视觉效果不佳。CSS3就不会发生这种情况. 注意 百分比值在旧版本的 Chrome 和 Safari 中不支持。(fixed in Sepember 2010)在 11.50 版本以前的 Opera 中实现有问题。Gecko 2.0 (Firefox 4) 版本前实现不标准：水平半轴和垂直半轴都相对于盒子模型的宽度。在旧版本的 iOS (iOS 5 之前) 和 Android 中 (WebKit 532 之前) 不支持。 扩展-绝对定位模拟固定定位 固定定位在ie6以及移动端的兼容性不太好，故需要模拟实现 html,body,#wrap三者的高度都为100%，即都等于文档视口的高度。 默认滚动条在document上，可以设置在一个全局的容器#wrap(高度=视口的高度，overflow: auto)身上 初始包含块：是一个与视窗等大小、等位置的矩形，滚动默认滚动条它会跟着动 body作为父级(没有定位)，绝对定位的元素是相对于这个初始包含块定位的 禁止系统滚动条后，初始包含块便不会再动了 这样绝对定位的元素也不会动了，即模拟了固定定位的效果 demo 123456789101112131415161718192021222324252627282930//样式html,body&#123; height: 100%; /* 禁止系统滚动条 */ overflow: hidden;&#125;#wrap&#123; /* 将滚动条设置到我们的容器上 */ height: 100%; overflow-y: auto;&#125;#app&#123; /* 为了撑开容器看到滚动条 */ height: 3000px;&#125;#red&#123; /* 绝对定位的元素，实现了固定定位的效果 */ position: absolute; top: 0; left: 0; width: 100px; height: 100px; background-color: red;&#125;//dom结构&lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;red&quot;&gt;&lt;/div&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/div&gt; 边框图片 border-image 属性允许在元素的边框上绘制图像。这使得绘制复杂的外观组件更加简单，使用 border-image 时，其将会替换掉 border-style 属性所设置的边框样式如实线solid。 123456border-image-source: url(./love.jpg) 图片border-image-slice: 百分比该属性会通过规范将图片明确的分割为9个区域：四个角，四边以及中心区域。图片见 MDNborder-image-width: 定义图像边框宽度。 border-image-outset: 定义边框图像可超出边框盒的大小border-image-repeat: 定义图片如何填充边框。stretch(拉伸),repeat，round（平铺） css2背景 background-color background-image background-position background-repeat 1234repeat-x repeat-y repeat no-repeat css3背景新增 background-origin设置背景渲染的起始位置 123border-boxpadding-box(默认)content-box background-clip 设置背景裁剪位置 -webkit-background-clip 按文字剪贴背景(文字有透明才行) background-size 设置背景图片大小 background 是CSS简写属性，用来集中设置各种背景属性。 线性渐变-背景图片渐变 background-image: linear-gradient(red,blue); 为了创建一个线性渐变，你需要设置一个起始点和一个方向（指定为一个角度）。你还要定义终止色。终止色就是你想让浏览器去平滑的过渡过去，并且你必须指定至少两种，当然也会可以指定更多的颜色去创建更复杂的渐变效果。 默认从上到下发生渐变 linear-gradient(red,blue); 改变渐变方向：（top bottom left right） linear-gradient(to 结束的方向,red,blue); 使用角度 linear-gradient(角度,red,blue); 颜色节点的分布（第一个不写为0%，最后一个不写为100%） linear-gradient(red 长度或者百分比,blue 长度或者百分比); 重复渐变 repeating-linear-gradient(60deg,red 0,blue 30%); 径向渐变-背景图片渐变 background-image: radial-gradient(red,blue); radial-gradient() 函数创建一个，用来展示由原点（渐变中心）辐射开的颜色渐变 默认均匀分布 radial-gradient(red,blue); 不均匀分布 radial-gradient(red 50%,blue 70%); 改变渐变的形状 radial-gradient(circle ,red,blue) circle ellipse（默认为椭圆） 渐变形状的大小 radial-gradient(closest-corner circle ,red,blue) closest-side 最近边 farthest-side 最远边 closest-corner 最近角 farthest-corner 最远角（默认值） 改变圆心 radial-gradient(closest-corner circle at 10px 10px,red,blue); 剪切元素 clip-path 该属性可以创建一个只有元素的部分区域可以显示的剪切区域。区域内的部分显示，区域外的隐藏。剪切区域是被引用内嵌的URL定义的路径或者外部svg的路径，或者作为一个形状例如circle()。 配合svg实现ios圆角 有事您Q我👇]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>guigu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哲学]]></title>
    <url>%2F%E5%93%B2%E5%AD%A6%2F%E5%93%B2%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 有事您Q我👇]]></content>
      <categories>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>philosophy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电影学]]></title>
    <url>%2F%E7%94%B5%E5%BD%B1%E5%AD%A6%2F%E7%94%B5%E5%BD%B1%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;人生苦短，我只看经典电影。 有事您Q我👇]]></content>
      <categories>
        <category>电影学</category>
      </categories>
      <tags>
        <tag>movie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心理学]]></title>
    <url>%2F%E5%BF%83%E7%90%86%E5%AD%A6%2F%E5%BF%83%E7%90%86%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 有事您Q我👇]]></content>
      <categories>
        <category>心理学</category>
      </categories>
      <tags>
        <tag>psychology</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活中的经济学]]></title>
    <url>%2F%E7%BB%8F%E6%B5%8E%E5%AD%A6%2F%E7%BB%8F%E6%B5%8E%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;物以稀为贵。 有事您Q我👇]]></content>
      <categories>
        <category>经济学</category>
      </categories>
      <tags>
        <tag>economics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3-font]]></title>
    <url>%2Fcss3%2Fcss3-font%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 位图vs矢量图位图 位图图像（bitmap），亦称为点阵图像或栅格图像，是由称作像素（图片元素）的单个点组成的。这些点可以进行不同的排列和染色以构成图样。当放大位图时，可以看见赖以构成整个图像的无数单个方块。扩大位图尺寸的效果是增大单个像素，从而使线条和形状显得参差不齐。然而，如果从稍远的位置观看它，位图图像的颜色和形状又显得是连续的。用数码相机拍摄的照片、扫描仪扫描的图片以及计算机截屏图等都属于位图。位图的特点是可以表现色彩的变化和颜色的细微过渡，产生逼真的效果，缺点是在保存时需要记录每一个像素的位置和颜色值，占用较大的存储空间。常用的位图处理软件有Photoshop（同时也包含矢量功能） 矢量图 矢量图[vector]，也叫做向量图，简单的说，就是缩放不失真的图像格式。矢量图是通过多个对象的组合生成的，对其中的每一个对象的纪录方式，都是以数学函数来实现的，也就是说，矢量图实际上并不是象位图那样纪录画面上每一点的信息，而是纪录了元素形状及颜色的算法，当你打开一付矢量图的时候，软件对图形象对应的函数进行运算，将运算结果[图形的形状和颜色]显示给你看。无论显示画面是大还是小，画面上的对象对应的算法是不变的，所以，即使对画面进行倍数相当大的缩放，其显示效果仍然相同[不失真]。 位图与矢量图的区别 最大的区别，矢量图形与分辨率无关，可以将它缩放到任意大小和以任意分辨率在输出设备上打印出来，都不会影响清晰度，而位图是由一个一个像素点产生，当放大图像时，像素点也放大了，但每个像素点表示的颜色是单一的，所以在位图放大后就会出现咱们平时所见到的马赛克状。 位图表现的色彩比较丰富，可以表现出色彩丰富的图象，可逼真表现自然界各类实物；而矢量图形色彩不丰富，无法表现逼真的实物，矢量图常常用来表示标识、图标、Logo等简单直接的图像。 由于位图表现的色彩比较丰富，所以占用的空间会很大，颜色信息越多，占用空间越大，图像越清晰，占用空间越大；由于矢量图形表现的图像颜色比较单一，所以所占用的空间会很小。 字体图标的好处 图片不但增加了总文件的大小，还增加了很多额外的”http请求”，这都会大大降低网页的性能的。图片还有一个缺点就是不能很好的进行“缩放”，因此，有时候在“响应式设计”中需要使用图像的最好解决方案就是不去使用图片。 很容易任意地缩放； 很容易地改变颜色； 很容易地产生阴影； 可以拥有透明效果； 一般来说，有先进的浏览器支持； 可以使用CSS来装饰（可以得到CSS很好支持）； 可以快速转化形态（做出一些变化，如 :hover等）； 可以做出跟图片一样可以做的事情（改变透明度、旋转度，等）； 本身体积更小，但携带的信息并没有削减。 不用每次修改都还得重新切图替换。 自定义字体1234567891011121314//样式@font-face&#123; font-family: &apos;自定义的名字&apos;; src: url(&apos;../font/字体名称.eot&apos;); src:url(&apos;../font/字体名称.woff&apos;) format(&apos;woff&apos;), url(&apos;../font/字体名称.ttf&apos;) format(&apos;truetype&apos;), url(&apos;../font/字体名称.svg&apos;) format(&apos;svg&apos;);&#125; h1&#123; font-size:36px; color:#ccc; font-family: &quot;自定义的名字&quot;; &#125; 字体图标 字体图标就是运用了css3的自定义字体 有专门的网站可以做字体 常使用阿里巴巴字体图标库 有事您Q我👇]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>guigu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3-selectors]]></title>
    <url>%2Fcss3%2Fcss3-selectors%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;走到世界尽头。那风从哪里吹来，云又将飘向哪儿，世界的尽头在何方，想知道答案，唯有往前走。 css的全称 Cascading Style Sheets CSS3选择器规范地址：https://www.w3.org/TR/2011/REC-css3-selectors-20110929/ CSS3选择最新选择器规范: https://www.w3.org/TR/selectors 样式表的组成 规则—&gt;选择器+声明块 —&gt;css属性+css属性值组成的键值对 浏览器读取选择器的顺序 从右往左 即从小范围开始找 属性继承：有的属性有继承性有的没有，学习选择器时要注意到这一点 继承：html元素可以从父元素那里继承一部分css属性，即使当前元素没有定义该属性。 比如：color有继承性 而border没有 基本选择器 通配符选择器 * { margin: 0; padding: 0; border: none; } 元素选择器 body { background: #eee; } 类选择器 .list { list-style: square; } ID选择器 #list { width: 500px; margin: 0 auto; } 后代选择器 .list li { margin-top: 10px; background: #abcdef; } 基本选择器扩展 子元素选择器 12#wrap &gt; .inner &#123;color: pink;&#125;也可称为直接后代选择器,此类选择器只能匹配到直接后代，不能匹配到深层次的后代元素 相邻兄弟选择器 12#wrap #first + .inner &#123;color: #f00;&#125;它只会匹配紧跟着的兄弟元素 通用兄弟选择器 12#wrap #first ~ div &#123; border: 1px solid;&#125;它会匹配所有的兄弟元素(不需要紧跟) 选择器分组 12h1,h2,h3&#123;color: pink;&#125; 此处的逗号我们称之为结合符 属性选择器存在和值属性选择器 [attr]：该选择器选择包含 attr 属性的所有元素，不论 attr 的值为何。 [attr=val]：该选择器仅选择 attr 属性被赋值为 val 的所有元素。 [attr~=val]：表示带有以 attr 命名的属性的元素，并且该属性是一个以空格作为分隔的值列表，其中至少一个值为val。 子串值属性选择器 [attr|=val] : 选择attr属性的值是val（包括val）或以val-开头的元素。 [attr^=val] : 选择attr属性的值以val开头（包括val）的元素。 [attr$=val] : 选择attr属性的值以val结尾（包括val）的元素。 [attr*=val] : 选择attr属性的值中包含字符串val的元素。 伪类与伪元素选择器 伪类：其出现是为了拿到元素的一些状态 伪元素：其出现是为了拿到css tree以外的元素 链接伪类 注意:link，:visited，:target是作用于链接元素的！ :link 表示作为超链接，并指向一个未访问的地址的所有锚 :visited 表示作为超链接，并指向一个已访问的地址的所有锚 :target 代表一个特殊的元素，它的id是URI的片段标识符 使用 :target实现最简单的选项卡 demo 123456789101112131415161718192021//样式：div&#123; width: 100px; height: 100px; color: red; background: #ccc; font-size: 33px; display: none;&#125;:target&#123; display: block;&#125;//dom结构&lt;a href=&quot;#div1&quot;&gt;div1&lt;/a&gt;&lt;a href=&quot;#div2&quot;&gt;div2&lt;/a&gt;&lt;a href=&quot;#div3&quot;&gt;div3&lt;/a&gt;&lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt;&lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt; 动态伪类 注意:hover，:active基本可以作用于所有的元素！ :hover 表示悬浮到元素上 :active 表示匹配被用户激活的元素（点击按住时） 由于a标签的:link和:visited可以覆盖了所有a标签的状态， 所以当:link，:visited，:hover，:active同时出现在a标签 身上时 :link和:visited不能放在最后！！！ 隐私与:visited选择器 只有下列的属性才能被应用到已访问链接： color background-color border-color 表单相关伪类 :enabled 匹配可编辑的表单 :disable 匹配被禁用的表单 :checked 匹配被选中的表单 :focus 匹配获焦的表单 demo单选按钮:checked 12345678910111213141516171819202122232425262728293031323334353637//样式：label&#123; position: relative; display: block; width: 100px; height: 100px; border-radius: 50%; overflow: hidden; border: 1px solid &#125;label &gt; span&#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0&#125;input:checked + span&#123; background-color: red;&#125;.float&#123; float: left;&#125;//dom结构&lt;label class=&quot;float&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;love&quot;&gt; &lt;span&gt;&lt;/span&gt;&lt;/label&gt;&lt;label class=&quot;float&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;love&quot;&gt; &lt;span&gt;&lt;/span&gt;&lt;/label&gt;&lt;label class=&quot;float&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;love&quot;&gt; &lt;span&gt;&lt;/span&gt;&lt;/label&gt; 结构性伪类 index的值从1开始计数！！！！ index可以为变量n(只能是n) index可以为even odd .wrap ele:nth-child(index) 表示匹配#wrap中第index的子元素 这个子元素必须是ele .wrap ele:nth-of-type(index) 表示匹配#wrap中第index的ele子元素 除此之外:nth-child和:nth-of-type有一个很重要的区别！！ nth-of-type以元素为中心！！！ :nth-child(index)系列 12345:nth-child(index)系列 :first-child:last-child:nth-last-child(index):only-child (相当于:first-child:last-child 或者 :nth-child(1):nth-last-child(1) :nth-of-type(index)系列 123456789:nth-of-type(index)系列:first-of-type:last-of-type:nth-last-type(index):only-of-type (相当于:first-of-type:last-of-type 或者 :nth-of-type(1):nth-last-of-type(1)``` - :not 非 :not 非面试题：常用来做前后边框div &gt; a:not(:last-of-type){ border-right: 1px solid} 12345678910111213141516171819- :empty(内容必须是空的，有空格都不行，有attr没关系)- :nth-child选择要求相对严格些- :nth-of-type选择要求相对宽松些- 在一个容器中只有一种子元素则二者没什么区别## 伪元素- ::after 常用来清除浮动- ::before- ::firstLetter- ::firstLine- ::selection 鼠标选中后的自定义样式## css声明的优先级### 选择器的特殊性- 选择器的特殊性由选择器本身的组件确定，特殊性值表述为4个部分，如 0,0,0,0- 一个选择器的具体特殊性如下确定： 通配符选择器的特殊性为0,0,0,0对于选择器中的给定的各个元素和伪元素，加0,0,0,1对于选择器中给定的各个类属性，属性选择，或伪类，加 0,0,1,0对于选择器中给定的ID属性值，加 0,1,0,0内联声明的特殊性都是1,0,0,0 结合符对选择器特殊性没有一点贡献继承没有特殊性 123456 - 特殊性 1,0,0,0 大于所有以0开头的特殊性(不进位)- 选择器的特殊性最终都会授予给其对应的声明- 如果多个规则与同一个元素匹配，而且有些声明互相冲突时，特殊性越大的越占优势- **注意：id选择器和属性选择器** div[id=”test”]（0,0,1,1） 和 #test（0,1,0,0） ` 重要声明 !important 有时某个声明比较重要，超过了所有其他声明，css2.1就称之为重要声明 并允许在这些声明的结束分号之前插入 !important 来标志 必须要准确的放置 !important 否则声明无效。 !important 总是要放在声明的最后，即分号的前面 标志为 !important的声明并没有特殊的特殊性值，不过要与非重要声明分开考虑。 实际上所有的重要声明会被浏览器分为一组，重要声明的冲突会在其内部解决 非重要声明也会被分为一组，非重要声明的冲突也会在其内部解决 如果一个重要声明与非重要声明冲突，胜出的总是重要声明 样式继承 继承没有特殊性，甚至连0特殊性都没有 0特殊性要比无特殊性来的强 也就是说通配符选择器的样式比继承来的样式特殊性高 css样式来源 css样式的来源大致有三种 创作人员 读者 用户代理 css样式权重 读者的重要声明 即用户的操作 创作人员的重要声明 即我猿 创作人员的正常声明 读者的正常声明 用户代理的声明 即浏览器 层叠样式表 找出所有相关的规则，这些规则都包含一个选择器 计算声明的优先级 先按来源排序 在按选择器的特殊性排序 最终按顺序 有事您Q我👇]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>guigu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios]]></title>
    <url>%2Faxios%2Fajax-axios%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;每一个不曾起舞的日子，都是对生命的一种辜负。 axios 基于promise用于浏览器和node.js的http客户端 特点 支持浏览器和node.js 支持promise 能拦截请求和响应 能转换请求和响应数据 能取消请求 自动转换JSON数据 浏览器端支持防止CSRF(跨站请求伪造) 1npm i axios 12345678910111213141516171819202122/* 发起一个GET请求 */// 可以参数直接拼接axios.get(&apos;/user?ID=12345&apos;) .then((result) =&gt; &#123; console.log(result) &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;)// 或者这样axios.get(&apos;/user&apos;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then((result) =&gt; &#123; console.log(result) &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;) 123456789101112/* 发起一个POST请求 */axios.post(&apos;/user&apos;, &#123; name: &apos;shulu&apos;, age: &apos;18&apos;&#125;).then((result) =&gt; &#123; console.log(result)&#125;).catch((err) =&gt; &#123; console.log(err)&#125;) 1234567/* 同时发起多个请求 */ let sendArr = [axios.get(&apos;/user/123&apos;), axios.get(&apos;/user/123/pions&apos;)]axios.all(sendArr) .then(axios.spread((resA, resB) =&gt; &#123; // 这里就可以拿到响应resA, resB&#125;)) 123456789101112131415/* 一些最最常用的请求配置项 */// 公共 URLaxios.defaults.baseURL = &apos;https://some-domain.com/api/&apos; // 定义POST请求中请求主体向服务器发送内容的格式，这里是项目中常用的格式// 这里似乎有点问题，得再看看axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;// 添加一个响应拦截器// 直接将响应的结果过滤得到我们最想要的data即响应主体数据axios.interceptors.response.use(res =&gt; res.data)// 自定义对HTTP响应状态码的处理axios.defaults.validateStatus = (status =&gt; &#123;……&#125;) 有事您Q我👇]]></content>
      <categories>
        <category>axios</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[tcp]]></title>
    <url>%2Ftcp%2Ftcp%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;什么时候，我们之间才会握手呢。 tcp 三次握手 我们来聊聊三次握手，我们看到这个问题的时候，第一个疑问是，啥叫握手？俩机器之间怎么还能握手呢？我怎么没发现我家电脑有手？ 第二个疑问是，为啥要三次？两次不行吗？我觉得握一下就行了~为啥要握三次？流氓~那么现在我们有没有清楚为什么不能是两次握手了呢？ 我们假设现在有A 和 B 两个之间要进行通信往来。 第一次握手只能让B知道A能发，第二次握手让A知道了B能收能发，但是这个时候B还不知道A能收，所以A需要发出信息，证明自己收到了B的回复~所以必须要三次才能让两台机器都知道对方能收能发。 tcp四次挥手 以一句话来说明四次挥手的根本目的，四次挥手核心就在于四个时间节点，分别是： A告诉B发完了， B告诉A知道发完了，(接收还需要一段时间的) B告诉A收完了， A告诉B知道收完了。 有事您Q我👇]]></content>
      <categories>
        <category>tcp</category>
      </categories>
      <tags>
        <tag>net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-design-mode-others]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-others%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; &lt;!–more– 中介者模式 代码演示 // 执行者(前线士兵)class Receiver { exec() { console.log(‘前线士兵 执行命令’) }} // 命令对象(由鼓手传递 开打开打！！！)class Command { constructor(receiver) { this.receiver = receiver } cmd() { console.log(‘命令对象开始传递 “开打开打！！！”‘) this.receiver.exec() }} // 发布命令者(将军)class Invoker { constructor(command) { this.command = command } invoke() { console.log(‘发布命令: 开打开打！！！’) this.command.cmd() }}// 士兵let soldier = new Receiver()// 鼓手let drummer = new Command(soldier)// 将军let general = new Invoker(drummer)// 将军发布命令general.invoke() ` 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-design-mode-prototype]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-prototype%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 简单示例123456789101112131415161718192021const prototype = &#123; getName() &#123; return `first-name: $&#123;this.firstName&#125;, last-name: $&#123;this.lastName&#125;` &#125;, say() &#123; console.log(&apos;love you&apos;) &#125;&#125;// 克隆自己，生成一个新的对象// Object.create()用到了原型模式的思想// 基于一个原型创建一个对象let x = Object.create(prototype)x.lastName = &apos;shulu&apos;x.firstName = &apos;lqy love&apos;x.say() //love youconsole.log(&apos;x.getName() :&apos;, x.getName())//打印为 x.getName() : first-name: lqy love, last-name: shulu 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-design-mode-state]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-state%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;莫辜负这仅有一次的人生。 状态模式介绍 一个对象有状态变化 每次状态变化都会触发一个逻辑 不能总是用if…else来控制 交通信号灯不同颜色的变化 场景 有限状态机(finite) 有限个状态，以及在这些个状态之间的变化 开源的库 javascript-state-machine 写一个简单的Promise 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// 收藏/取消收藏例子import StateMachine from &apos;javascript-state-machine&apos;// 初始化状态机模型let fsm = new StateMachine(&#123; init: &apos;收藏&apos;, transitions: [ &#123; name: &apos;doStore&apos;, from: &apos;收藏&apos;, to: &apos;取消收藏&apos; &#125;, &#123; name: &apos;deleteStore&apos;, from: &apos;收藏&apos;, to: &apos;取消收藏&apos; &#125; ], methods: &#123; // 监听执行收藏 onDoStore() &#123; console.log(&apos;收藏成功&apos;)// 可以post请求 updateText() &#125;, // 监听取消收藏 onDeleteStore() &#123; console.log(&apos;已经取消收藏&apos;)// 可以post请求 updateText() &#125; &#125;import StateMachine from &apos;javascript-state-machine&apos;// 初始化状态机模型let fsm = new StateMachine(&#123; init: &apos;收藏&apos;, transitions: [ &#123; name: &apos;doStore&apos;, from: &apos;收藏&apos;, to: &apos;取消收藏&apos; &#125;, &#123; name: &apos;deleteStore&apos;, from: &apos;收藏&apos;, to: &apos;取消收藏&apos; &#125; ], methods: &#123; // 监听执行收藏 onDoStore() &#123; console.log(&apos;收藏成功&apos;)// 可以post请求 updateText() &#125;, // 监听取消收藏 onDeleteStore() &#123; console.log(&apos;已经取消收藏&apos;)// 可以post请求 updateText() &#125; &#125;&#125;)// 更新按钮的文案function updateText () &#123; btn.text(fsm.state)&#125;let btn = document.getElementById(&apos;btn&apos;)btn.onclick = function () &#123; if (fsm.is(&apos;收藏&apos;)) &#123; fsm.doStore() //这里的函数名与前面的name对应 &#125; else &#123; fsm.deleteStore() &#125;&#125;// 初始化文案updateText()&#125;)// 更新按钮的文案function updateText () &#123; btn.text(fsm.state)&#125;let btn = document.getElementById(&apos;btn&apos;)btn.onclick = function () &#123; if (fsm.is(&apos;收藏&apos;)) &#123; fsm.doStore() //这里的函数名与前面的name对应 &#125; else &#123; fsm.deleteStore() &#125;&#125;// 初始化文案updateText() 设计原则验证 将状态对象和主题对象分离，状态的变化逻辑单独处理 符合开放封闭原则 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-design-mode-iterator]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-iterator%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 介绍 顺序访问一个集合 使用者无需知道内部的结构(封装) 菜鸟教程 代码实现(自己写的初级的 后面es6提供的完善的 for of)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 迭代器(遍历器)class Iterator &#123; constructor(container) &#123; this.list = container.list this.index = 0 &#125; next() &#123; if (this.hasNext()) &#123; return this.list[this.index++] &#125; return null &#125; hasNext() &#123; if (this.index &gt;= this.list.length) &#123; return false &#125; return true &#125;&#125;// 迭代器的容器class Container &#123; constructor(list) &#123; this.list = list &#125; getIterator() &#123; return new Iterator(this) &#125;&#125;let arr = [1,2,3,4,5,6]let container = new Container(arr)let iterator = container.getIterator()while (iterator.hasNext()) &#123; console.log(&apos;iterator.next() :&apos;, iterator.next());&#125;/* iterator.next() : 1 iterator.next() : 2 iterator.next() : 3 iterator.next() : 4 iterator.next() : 5 iterator.next() : 6 */ es6 Iterator 有序集合的数据如: Array Map Set String TypedArray arguments Nodelist 以上数据类型，都有[Symbol.iterator]这个属性 属性值是函数，执行函数返回一个迭代器 这个迭代器就有next方法可以顺序迭代子元素 可以运行Array.prototype[Symbol.iterator]来测试 注意 object 不是有序集合 可以用Map代替 for of12345678910111213141516171819202122232425262728293031323334353637383940414243//封装一个简单的each方法function each (data) &#123; //data是可遍历的 即data[Symbol.iterator]有值 for(let item of data) &#123; console.log(&apos;item :&apos;, item) &#125;&#125;// 测试几种可遍历的数据类型let str = &apos;love&apos;let arr = [1,2,3,4]let map = new Map()map.set(0, &quot;zero&quot;)map.set(1, &quot;one&quot;)let set = new Set([6,7,8,9])each(str)each(arr)each(map)each(set)/* item : l item : o item : v item : e item : 1 item : 2 item : 3 item : 4 item : [ 0, &apos;zero&apos; ] item : [ 1, &apos;one&apos; ] item : 6 item : 7 item : 8 item : 9*/ Map 数据结构 Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。 一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 一个 for…of 循环在每次迭代后会返回一个形式为[key，value]的数组。 一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。 Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。 你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。 Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。 Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。虽然 ES5 开始可以用 map = Obj- ect.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。 Map 在涉及频繁增删键值对的场景下会有些性能优势。 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-design-mode-observer]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-observer%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 介绍 前端运用最广泛的设计模式 当一个对象被修改时，则会自动通知它的依赖对象。 注意，不一定是一对多哦，也可以一对一的。 菜鸟教程 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 主题，保存状态，状态发生变化后触发所有观察者对象class Subject &#123; constructor() &#123; this.state = 0 this.observers = [] &#125; getState() &#123; return this.state &#125; setState(state) &#123; this.state = state this.notifyAllObservers() &#125; // 通知所有的观察者 notifyAllObservers() &#123; this.observers.forEach((observer) =&gt; &#123; observer.update() &#125;) &#125; // 添加新的观察者 attach(observer) &#123; this.observers.push(observer) &#125;&#125;// 观察者class Observer &#123; constructor(name, subject) &#123; this.name = name this.subject = subject this.subject.attach(this) &#125; update() &#123; console.log(`$&#123;this.name&#125; updated, now-state:$&#123;this.subject.getState()&#125;`); &#125;&#125;// 测试let s = new Subject()let o1 = new Observer(&apos;o1&apos;, s)let o2 = new Observer(&apos;o2&apos;, s)let o3 = new Observer(&apos;o3&apos;, s)s.setState(1) s.setState(2)s.setState(3)/* //打印结果 o1 updated, now-state:1 o2 updated, now-state:1 o3 updated, now-state:1 o1 updated, now-state:2 o2 updated, now-state:2 o3 updated, now-state:2 o1 updated, now-state:3 o2 updated, now-state:3 o3 updated, now-state:3*/ 使用场景 网页事件绑定 Promise jQuery callbacks nodejs 自定义事件 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-design-mode-proxy]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-proxy%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 代理模式简介 菜鸟教程 科学上网 明星经纪人 使用场景 网页事件代理 jQuery的 $.proxy() es6的proxy 代码实现明星经纪人 1234567891011121314151617181920212223242526272829303132333435363738394041// 明星let star = &#123; name: &apos;shulu&apos;, age: &apos;18&apos;, phone: &apos;star: 18366666666&apos;&#125;// 经纪人let agent = new Proxy(star, &#123; get(target, key) &#123; if (key === &apos;phone&apos;) &#123; // 返回经纪人(代理)的电话 return &apos;agent: 12353434343&apos; &#125; if (key === &apos;price&apos;) &#123; // 明星不报价，由经纪人报价 return &apos;agent: 1232323$&apos; &#125; return target[key] &#125;, set(target, key, val) &#123; if (key === &apos;customPrice&apos;) &#123; if (val &lt; 10000) &#123; // 最低价格 throw new Error(&apos;价格太低！&apos;) &#125;else&#123; target[key] = val return true &#125; &#125; &#125;&#125;)console.log(&apos;agent.name :&apos;, agent.name) //agent.name : shuluconsole.log(&apos;agent.age :&apos;, agent.age) //agent.age : 18console.log(&apos;agent.phone :&apos;, agent.phone) //agent.phone : agent: 12353434343console.log(&apos;agent.price :&apos;, agent.price) //agent.price : agent: 1232323$agent.customPrice = 1212 //价格太低！agent.customPrice = 100000 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-this]]></title>
    <url>%2Fthis%2Fthis%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;认识我自己。 this&emsp;&emsp;当前执行代码的环境对象 mdn权威解释 全局环境&emsp;&emsp;无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。 函数环境&emsp;&emsp;在函数内部，this的值取决于函数被调用的方式。&emsp;&emsp;如果要想把 this 的值从一个环境传到另一个，就要用 call 或者apply 方法。方法来源即Function.prototype.call Function.prototype.bind&emsp;&emsp;使用 call 和 apply 函数的时候，如果传递给 this 的值不是一个对象，JavaScript 会尝试使用内部 ToObject 操作将其转换为对象。 &emsp;&emsp;箭头函数&emsp;&emsp;它的this即它外层函数的this。 &emsp;&emsp;作为对象的方法&emsp;&emsp;当函数作为对象里的方法被调用时，它们的 this是调用该函数的对象。 &emsp;&emsp;原型链中的 this &emsp;&emsp;对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么this指向的是调用这个方法的对象，就像该方法在对象上一样。&emsp;&emsp; getter 与 setter 中的 this 相同的概念也适用于当函数在一个 getter 或者 setter 中被调用。用作 getter 或 setter 的函数都会把 this 绑定到设置或获取属性的对象。作为构造函数 &emsp;&emsp; 当一个函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象。作为一个DOM事件处理函数 &emsp;&emsp; 当函数被用作事件处理函数时，它的this指向触发事件的元素。 &emsp;&emsp; setTimeout 关于”this”的问题 &emsp;&emsp; 当你向 setTimeout() (或者其他定时器函数)传递一个函数时,该函数中的this指向跟你的期望可能不同。 &emsp;&emsp; 解释： &emsp;&emsp; 由setTimeout()调用的代码运行在与所在函数完全分离的执行环境上。这会导致，这些代码中包含的 this 关键字在非严格模式会指向 window (或全局)对象，严格模式下为 undefined，这和所期望的this的值是不一样的。 &emsp;&emsp; 即定时器函数是一个异步宏任务，在事件循环中会被分配到对应的任务队列中去等待执行，故执行栈即执行上下文环境即this不是你以为的原来的了。 Function.prototype.call() 函数的一种调用方法 Function构造函数的原型对象上的call方法 该方法接受的是一个参数列表：如 1， 2， 3 语法 fun.call(thisArg, arg1, arg2, …) 参数 thisArg 在 fun 函数运行时指定的 this 值。 if(thisArg == undefined|null) this = window， if(thisArg == number|boolean|string) this == new Number()|new Boolean()| new String() arg1, arg2, … 指定的参数列表。 返回值 使用调用者提供的 this 值和参数调用该函数的返回值。若该方法没有返回值，则返回 undefined。 call方法的应用 call() 提供新的 this 值给当前调用的函数/方法。 可以使伪数组调用数组的方法 Function.prototype.apply() 函数的一种调用方法 Function构造函数的原型对象上的call方法 该方法接受的是一个参数数组：如 [1, 2, 3] apply 与 call() 非常相似，不同之处在于提供参数的方式。apply方法的应用调用Math对象的max方法求数组的最大值1234var numbers = [5, 6, 2, 3, 7];var max = Math.max.apply(null, numbers);console.log('max :', max); 用 apply 将数组添加到另一个数组1234var array = ['a', 'b'];var items = [0, 1, 2];array.push.apply(array, items);console.log(array);// [ 'a', 'b', 0, 1, 2 ] Function.prototype.bind() bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。 返回值 返回一个原函数的拷贝，并拥有指定的this值和初始参数。 bind方法的应用配合setTimeout绑定this12345678910var obj = &#123; name: 'yc', getName: function () &#123; setTimeout(function () &#123; console.log('this.name :', this.name) &#125;.bind(this), 1000) &#125;&#125;obj.getName() //this.name : yc 有事您Q我👇]]></content>
      <categories>
        <category>this</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-design-mode-decorator]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-decorator%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 介绍 菜鸟教程 大牛解读es7装饰器 为对象添加功能 不改变其原有的结构和功能 代码演示 画圆 12345678910111213141516171819202122232425class Circle &#123; draw() &#123; console.log(&apos;画一个圆&apos;) &#125;&#125;class Decorator &#123; constructor(circle) &#123; this.circle = circle &#125; draw() &#123; this.circle.draw() this.setRedBorder(this.circle) &#125; setRedBorder(circle) &#123; console.log(&apos;给圆设置红色的边框&apos;) &#125;&#125;// 测试let circle = new Circle()circle.draw() //画一个圆let dec = new Decorator(circle)dec.draw() //画一个圆 给圆设置红色的边框 装饰器 ES7 中的 decorator 同样借鉴了python语法糖，不过依赖于 ES5 的 Object.defineProperty 方法 。 Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 Object.defineProperty(obj, prop, descriptor) obj：要在其上定义属性的对象。 prop：要定义或修改的属性的名称。 descriptor：将被定义或修改的属性描述符。 返回值：被传递给函数的对象。 属性描述符 对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。 数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。 存取描述符是由 getter-setter 函数对描述的属性。 描述符必须是这两种形式之一；不能同时是两者。 数据描述符和存取描述符均具有以下可选键值: configurable 可修改 布尔值 enumerable 可枚举 布尔值 value 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。 writable 可写 布尔值 get 一个给属性提供 getter 的方法 set 一个给属性提供 setter 的方法 Object.assign Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 语法 Object.assign(target, …sources)参数 target 目标对象。 sources 源对象。 返回值 目标对象。 core-decorators装饰器库的使用 安装插件 12345678910111213141516171819202122npm install --save-dev @babel/plugin-proposal-class-properties npm install --save-dev @babel/plugin-proposal-decoratorsnpm install --save-dev babel-plugin-transform-decorators-legacynpm install --save-dev core-decorators当然还有以下依赖的支持&quot;dependencies&quot;: &#123; &quot;@babel/core&quot;: &quot;^7.4.4&quot;, &quot;@babel/plugin-proposal-class-properties&quot;: &quot;^7.4.4&quot;, &quot;@babel/plugin-proposal-decorators&quot;: &quot;^7.4.4&quot;, &quot;@babel/preset-env&quot;: &quot;^7.4.4&quot;, &quot;babel-loader&quot;: &quot;^8.0.5&quot;, &quot;babel-plugin-transform-decorators-legacy&quot;: &quot;^1.3.5&quot;, &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;, &quot;core-decorators&quot;: &quot;^0.20.0&quot;&#125; .babelrc文件的配置 12345678910111213141516171819202122&#123; &quot;presets&quot;: [ [&quot;@babel/preset-env&quot;, &#123; &quot;useBuiltIns&quot;: &quot;usage&quot;,// 在每个文件中使用polyfill时，为polyfill添加特定导入。利用捆绑器只加载一次相同的polyfill。 &quot;modules&quot;: false,// 启用将ES6模块语法转换为其他模块类型，设置为false不会转换模块。 &quot;targets&quot;: &#123; //浏览器兼容 &quot;browsers&quot;: &quot;last 2 versions, not ie &lt;= 9&quot; &#125; &#125;] ], &quot;plugins&quot;: [ [ &quot;@babel/plugin-proposal-decorators&quot;, &#123; &quot;legacy&quot;: true &#125; ], [&quot;@babel/plugin-transform-runtime&quot;, &#123; &quot;helpers&quot;: false &#125;] ]&#125; 简单使用 1 123456789101112131415import &#123; readonly &#125; from &apos;core-decorators&apos;class Demo &#123; @readonly sayName() &#123; console.log(&apos;shulu&apos;) &#125;&#125;let demo = new Demo()demo.sayName() //shuludemo.sayName = function () &#123; console.log(&apos;lqy love shulu&apos;) //Uncaught TypeError: Cannot assign to read only property &apos;sayName&apos; of object &apos;#&lt;Demo&gt;&apos;&#125; 简单使用 2 123456789101112import &#123; deprecate &#125; from &apos;core-decorators&apos;class Demo &#123; @deprecate(&apos;此方法即将废除&apos; ,&#123;url: &apos;https://shulu520.com&apos;&#125;) getName() &#123; console.log(&apos;lqy&apos;) &#125;&#125;let demo = new Demo()demo.getName() //lqy DEPRECATION Demo#getName: 此方法即将废除 See https://shulu520.com for more details. 还有多种好用的方法…… 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-design-mode-adapter]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-adapter%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;江南的雨季，西北的惆怅。感君一回顾，思君朝与暮。 设计模式之适配器介绍 菜鸟教程 适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 代码演示 12345678910111213141516171819class OldStandard &#123; oldRequest() &#123; return &apos;老式标准插头&apos; &#125;&#125;class Adapter &#123; constructor() &#123; this.standard = new OldStandard() &#125; newRequest() &#123; let info = this.standard.oldRequest() return `新标准插头---&gt;适配器---&gt;$&#123;info&#125;` &#125;&#125;let adater = new Adapter()let res = adater.newRequest()console.log(&apos;res :&apos;, res) //res : 新标准插头---&gt;适配器---&gt;老式标准插头 经典案例 vue的computed计算属性 设计原则验证 将旧接口和使用者分离 开放封闭原则 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-design-mode-singleton]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-singleton%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;I love the World. 单例模式介绍 菜鸟教程 系统中唯一被使用 一个类只有一个实例 私有化构造函数，外部不能new 只能内部new !!!!! instance实例是唯一被new出来的对象 代码演示123456789101112131415161718192021222324252627class SingleObject &#123; login() &#123; console.log(&apos;login&apos;) &#125; &#125;// 静态方法SingleObject.getInstance = (function() &#123; let instance return function() &#123; if (!instance) &#123; instance = new SingleObject() &#125; return instance &#125;&#125;)()let obj1 = SingleObject.getInstance()obj1.login() //loginlet obj2 = SingleObject.getInstance()obj2.login() //loginconsole.log(&apos;obj1===obj2 :&apos;, obj1===obj2) //obj1===obj2 : truelet obj3 = new SingleObject() //外部不能new,但是无法完全控制console.log(&apos;obj3===obj1 :&apos;, obj3===obj1) //obj3===obj1 : false 单例模式使用场景 jQuery 的 $ 模拟登录框 购物车 vuex react 中的store 代码实现登录框 12345678910111213141516171819202122232425262728293031323334353637383940414243class LoginForm &#123; constructor () &#123; this.state = &apos;hide&apos; &#125; show () &#123; if (this.state === &apos;show&apos;) &#123; console.log(&apos;已经显示&apos;) return &#125; this.state = &apos;show&apos; console.log(&apos;已经登录成功&apos;) &#125; hide () &#123; if (this.state === &apos;hide&apos;) &#123; console.log(&apos;已经隐藏&apos;) return &#125; this.state = &apos;hide&apos; console.log(&apos;已经隐藏成功&apos;) &#125;&#125;// 静态方法LoginForm.getInstance = (() =&gt; &#123; let instance return () =&gt; &#123; if (!instance) &#123; instance = new LoginForm() &#125; return instance &#125;&#125;)()let login1 = LoginForm.getInstance()login1.show() //已经登录成功let login2 = LoginForm.getInstance()login2.show() //已经显示login2.hide() //已经隐藏成功console.log(&apos;login1===login2 :&apos;, login1===login2)// login1===login2 : true// 这就说明login1 和login2是同一个实例 设计原则验证 符合单一职责原则，只实例化唯一的对象 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hotkey-vscode]]></title>
    <url>%2Fhotkey%2Fhotkey-vscode%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;如果你想要个和现在不同的人生，就必须去做你从未做过的事情。努力之后最坏的结果是失败，但不尝试的结果则是无止境的懊悔、怀疑和平庸。 vscode 常用快捷键 上下移动一行： Alt+Up 或 Alt+Down 向上或向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down 同时选中所有匹配： Ctrl+Shift+L Ctrl+D 下一个匹配的也被选中 Alt + 单击 ：插入光标 Ctrl + F2 选择当前字的所有出现 ctrl shift k 删除整行 ctrl shift a 多行注释 ctrl f 当前文件内搜索相关代码，终于找到这个功能了，哈哈，右上角会有弹框，其中有前后箭头，表示搜索的代码上一次、下一次出现的位置，点击直接会跳转到相应的位置，并且侧边上有相应的位置标识。 ctrl - 整体缩小 ctrl = 整体放大 文件/首选项/设置 搜索zoom 根据配置 可以更精细的对大小进行操作 ctrl 加滚轮 col 选第一个 即console.log()的快捷键 且效果很棒 有事您Q我👇]]></content>
      <categories>
        <category>hotkey</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-design-mode-factory]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-factory%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;愿你做一个快乐的小仙女。 介绍 菜鸟教程 代码实现 方法定义 12345678910111213141516// Product产品生产流水线class Product &#123; constructor (name) &#123; this.name = name &#125; getName () &#123; return `my name is $&#123;this.name&#125;` &#125;&#125;// Creator 工厂class Creator &#123; create (name) &#123; return new Product(name) &#125;&#125; 测试 123456789101112131415161718192021/* 普通调用 用户直接面对某一流水线，要产品 用户每次拿产品都得直接与产品流水线打交道*/ // 书写极其麻烦const p1 = new Product(&apos;phone&apos;)const p2 = new Product(&apos;book&apos;)console.log(&apos;p1 :&apos;, p1)console.log(&apos;p2 :&apos;, p2)/* 工厂函数 用户直接面对生产厂家，要产品 也就是说，用户无需知道其内部复杂生产过程*/// 工厂函数将生产流水线封装起来，只对外暴露接口供用户使用const creator = new Creator()//实例化一个工厂const pa = creator.create(&apos;boy&apos;)const pb = creator.create(&apos;girl&apos;)console.log(&apos;pa :&apos;, pa)console.log(&apos;pb :&apos;, pb) 工厂函数的例子 jQuery react.createElement vue异步组件 验证设计原则 构造函数和创建者分离 符合开放封闭原则 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-design-mode-design-philosophy]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-design-philosophy%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; unix/linux设计哲学 小即是美 让每一个程序只做好一件事 快速建立原型 利于快速迭代 舍弃高效率而取可移植性 复用性 采用纯文本来存贮数据 可读性好 软件复用 使用shell脚本 避免强制性的用户界面 让每个程序都称为过滤器 中间件 允许用户定制环境 个性化 操作系统内核小而轻量化 使用小写字母并简写 沉默是金 没有消息是最好的消息 各部分之和大于整体 模块化 寻求90%的解决方案 不必追求完美 SOLID 五大设计原则 S 单一职责原则 每个程序之做好一件事 功能太复杂就拆分，每个部分保持独立 O 开放封闭原则 对扩展开放 对修改封闭 增加需求时 扩展新代码 而非修改已有的代码 L 李氏置换原则 子类能覆盖父类 父类能出现的地方子类就能出现 I 接口独立原则 保持接口的单一独立 避免出现胖接口 D 依赖导致原则 面向接口编程，依赖于抽象而不依赖于具体 使用方只关注接口 而不关注具体类的实现 为什么使用面向对像 面向对象 – 数据结构化 对于计算机 结构化才是简单的 编程 应该简单抽象 UML 类图 即统一建模语言 箭头表示依赖关系， 指向谁即依赖谁 泛化 即继承 空心箭头 由子类指向父类 关联 即引用 实心箭头 由引用者指向被引用者 类图 即一个表格 三行格子 第一格为类 构造函数 第二行为 属性：类型 第三行为 方法：返回值 23种设计模式总览 创建型 工厂模式 单例模式 原型模式 结构型 适配器模式 装饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 行为型 策略模式 模板方法模式 观察者模式 迭代器模式 职责链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式 面试题之弟弟打车12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Car 普通车 class Car &#123; constructor (name, number) &#123; this.name = name this.number = number &#125;&#125;// 慢车class SlowCar extends Car &#123; constructor(name, number) &#123; super(name, number) this.price = 1 &#125;&#125;// 快车class FastCar extends Car &#123; constructor(name, number) &#123; super(name, number) this.price = 2 &#125;&#125;// 旅途行程 （假定行程为5公里）class Trip &#123; constructor(car) &#123; this.car = car &#125; start () &#123; console.log(`行程开始，名称：$&#123;this.car.name&#125;,车牌号：$&#123;this.car.number&#125;`) &#125; end () &#123; console.log(`行程结束，一共$&#123;this.car.price * 5&#125;元`) &#125;&#125;//测试let car = new FastCar(&apos;兰博基尼&apos;, 18)let trip = new Trip(car)trip.start() //行程开始，名称：兰博基尼,车牌号：18trip.end() //行程结束，一共10元 面试题之停车场 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124// 车class Car &#123; constructor (num) &#123; this.num = num &#125;&#125;// 摄像头class Camera &#123; shot (car) &#123;//拍摄 return &#123; num: car.num, inTime: Date.now() &#125; &#125;&#125;// 出口显示屏class Screen &#123; show (car, inTime) &#123; console.log(`车牌号：$&#123;car.num&#125;`) console.log(`停车时间：$&#123;Date.now() - inTime&#125;`) &#125;&#125;// 停车场class Park &#123; constructor (floors) &#123; this.floors = floors || [] this.camera = new Camera() this.screen = new Screen() this.carList = &#123;&#125; // 存储摄像头拍摄的车辆信息 &#125; in (car) &#123; // 通过摄像头获取信息 const info = this.camera.shot(car) // 停到某个停车位 const i = Number.parseInt(Math.random() * 100 % 100) // 某一层 const j = Number.parseInt(Math.random() * 3) const place = this.floors[j].places[i] place.in() //车已停入某一车位 // 记录信息 info.place = place this.carList[car.num] = info &#125; out (car) &#123; // 获取车辆信息 const info = this.carList[car.num] // 将对应的停车位清空 info.place.out() // 显示时间 this.screen.show(car, info.inTime) // 删除记录 // info = null &#125; emptyNum () &#123; return this.floors.map(floor =&gt; &#123; return `第$&#123;floor.index&#125;层有$&#123;floor.emptyPlaceNum()&#125;个空位` &#125;).join(&apos;\n&apos;) &#125;&#125;// 楼层class Floor &#123; constructor (index, places) &#123; this.index = index this.places = places || [] &#125; emptyPlaceNum () &#123; let num = 0 this.places.forEach(place =&gt; &#123; if (place.empty) &#123; num += 1 &#125; &#125;) return num &#125;&#125;// 车位class Place &#123; constructor () &#123; this.empty = true &#125; in () &#123; this.empty = false &#125; out () &#123; this.empty = true &#125;&#125;// 测试// 初始化停车场const floors = []for (let i = 0; i &lt; 3; i++) &#123; const places = [] for (let j = 0; j &lt; 100; j++) &#123; places[j] = new Place() &#125; floors[i] = new Floor(i + 1, places)&#125;const park = new Park(floors)// 初始化车辆const car1 = new Car(18)const car2 = new Car(22)const car3 = new Car(36)console.log(`$&#123;park.emptyNum()&#125;`)console.log(`第一辆车进入`)park.in(car1)console.log(`$&#123;park.emptyNum()&#125;`)console.log(`第二辆车进入`)park.in(car2)console.log(`$&#123;park.emptyNum()&#125;`)console.log(`第一辆车离开`)park.out(car1)console.log(`$&#123;park.emptyNum()&#125;`)console.log(`第二辆车离开`)park.out(car2)console.log(`$&#123;park.emptyNum()&#125;`) 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-design-mode-oop]]></title>
    <url>%2Fjs-design-mode%2Fjs-design-mode-oop%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;you are my baby. webpack的配置 以支持es6的新语法 npm install webpack webpack-cli –save-dev –registry=https://registry.npm.taobao.org 在package.json中 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack --config ./webpack.dev.config.js --mode development&quot;&#125;即在命令行里面运行npm run dev 即可运行webpack 的配置文件 我们更改了配置文件的默认名字 在这里指定他的配置文件为 ./webpack.dev.config.js 即可 npm install webpack-dev-server html-webpack-plugin –save-dev –registry=https://registry.npm.taobao.org 将package.json中的webpack 改为webpack-dev-server 即为开启一个运行本地服务器 babel的es6语法插件解析 npm install –save-dev babel-loader @babel/core @babel/preset-env –registry=https://registry.npm.taobao.org npm install –save-dev @babel/polyfill @babel/plugin-transform-runtime –registry=https://registry.npm.taobao.org class 类 即模板 封装 继承 多态 123456789101112131415//创建类（构造函数）class Person &#123; constructor (name) &#123; //属性 特征 this.name = name &#125; getName () &#123; //方法 函数 return this.name &#125;&#125;//创建对象（实例）let p = new Person(&apos;shulu&apos;)alert(p.getName()) es6面向对象之继承123456789101112131415161718192021222324252627282930// 父类class Person &#123; constructor (name, age) &#123; this.name = name, this.age = age &#125; getName () &#123; return `my name is $&#123;this.name&#125;` &#125; getAge () &#123; return `my age is $&#123;this.age&#125;` &#125;&#125;// 子类 // 继承父类的属性、方法 并添加自己的属性和方法class Student extends Person &#123; constructor (name, age, number) &#123; super(name, age) this.number = number &#125; study () &#123; return `my number is $&#123;this.number&#125;, and i am studying` &#125;&#125;let s = new Student(&apos;shulu&apos;, 18, 23)alert(s.getName())alert(s.getAge())alert(s.study()) es6面向对象之封装 public 完全开放 protected 对子类开放 private 对自己开发 es6 尚不支持， 用typescript来演示trpescript网站测试代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 父类class Person &#123; name //公开的属性 age protected weight //受保护的属性，只有自己和子类可以访问，实例对象可以访问 constructor (name, age) &#123; this.name = name, this.age = age, this.weight = &apos;120&apos; &#125; getName () &#123; return `my name is $&#123;this.name&#125;` &#125; getAge () &#123; return `my age is $&#123;this.age&#125;` &#125; &#125;// 子类 // 继承父类的属性、方法 并添加自己的属性和方法class Student extends Person &#123; number //公开的属性 private boyfriend //自己的私有的属性，只有自己才可以访问，自己的实例都不能用 constructor (name, age, number) &#123; super(name, age) this.number = number this.boyfriend = &apos;lqy&apos; &#125; study () &#123; return `my 学号 is $&#123;this.number&#125;, and i am studying` &#125; getBoyfriend () &#123; return `my boyfriend is $&#123;this.boyfriend&#125;` &#125; getWeight () &#123; return `my weight is $&#123;this.weight&#125;` &#125;&#125;let s = new Student(&apos;shulu&apos;, 18, 23)alert(s.getWeight()) //可以正常访问alert(s.boyfriend()) //报错 girlfriend只能在Student 里面自己使用 es6面向对象之多态 多个子类可以继承一个父类，并扩展自己的方法 1234567891011121314151617181920212223242526272829303132333435363738// 父类class Person &#123; constructor (name) &#123; this.name = name &#125; getName () &#123; return `my name is $&#123;this.name&#125;` &#125;&#125;// 子类A class StudentA extends Person &#123; constructor (name, number) &#123; super(name) this.number = number &#125; study () &#123; return `my 学号 is $&#123;this.number&#125;, and i am studying` &#125;&#125;// 子类Bclass StudentB extends Person &#123; constructor (name, number) &#123; super(name) this.number = number &#125; study () &#123; return `my 学号 is $&#123;this.number&#125;, and i am studying` &#125;&#125;let s1 = new StudentA(&apos;shulu&apos;, 18)let s2 = new StudentB(&apos;lqy&apos;, 19)alert(s1.getName())alert(s1.study())alert(s2.getName())alert(s2.study()) 面向对像实现jQuery的例子1234567891011121314151617181920212223242526272829class jQuery &#123; constructor (selector) &#123; let dom = Array.from(document.querySelectorAll(selector)) let len = dom ? dom.length : 0 dom.forEach((item, index) =&gt; &#123; this[index] = item &#125;) this.len = len this.selector = selector || &apos;&apos; &#125; append (node) &#123; &#125; addClass (className) &#123; &#125; html (data) &#123; &#125; // 好多的方法……&#125;window.$ = function (selector) &#123; return new jQuery(selector)&#125;let $p = $(&apos;p&apos;) // p 标签选择器console.log($p)console.log($p.addClass) 有事您Q我👇]]></content>
      <categories>
        <category>js-design-mode</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[responsive-sites]]></title>
    <url>%2Fresponsive-sites%2Fresponsive-sites%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;梦终有你。 视口 布局视口 就像一本书 大小固定 如960px 是设计图纸的大小 可视视口 就像放大镜 在它上面可以移动缩放 是设备屏幕的大小 在这两种视口下，用户需要通过滑动缩放来查看整个页面的不同部分。 理想视口 为了解决以上的问题而制定的视口。是布局视口在一个设备上的最佳尺寸。即让布局视口等于可视视口。 大牛博客视口相关说明 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;/&gt; 爬虫协议robots.txt 把“robots.txt”放在你网站的根目录，并确保他能让访问者（如搜索引擎）访问到。 Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”，网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。 1234User-agent: *Disallow: /admin/Sitemap: https://shulu520.com/sitemap.xmlSitemap: https://shulu520.com/sitemap.hxml 关于humans.txthumans.txt官网 这是什么？ 这是一个TXT文件，其中包含参加该网页设计和建立的人们的信息。 为什么是一个TXT？ 这是因为TXT是一种快速和容易建立的档案格式，而且不是一种有侵扰性的格式。 很多时候业主并不希望作者在为他设计的网站签名，以为这样会降低其功能。 以我们这种方式可以从外部快速便利、经济实惠的显示证明网站作者（不是指网站的主人）。 humans.txt官网格式 12345/* TEAM *//* THANKS *//* SITE */ 项目目录的一些有用的文件 robots.txt humans.txt .editorConfig(编辑器风格配置) .gitignore LICENSE.txt(版权声明，协议是否开源) README.md(项目简介 使用方式 相关链接) CHANGLOG(说明版本更新相关) html页面重要内容 以前没有注意到的细节知识做一总结。 1234567891011121314151617181920网站内的语言为汉语，参考自淘宝网。&lt;html lang=&apos;zh-CN&apos;&gt;&lt;/html&gt;这意味着，会强制浏览器按照最新的标准去渲染。添加”chrome=1“将允许站点在使用了谷歌浏览器内嵌框架（Chrome Frame）的客户端渲染，对于没有使用的，则没有任何影响。&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;/&gt;告诉浏览器启用理想视口来展示页面。不允许用户进行缩放。&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0,user-scalable=0&quot; /&gt;条件注释：在body标签下争对IE低版本浏览器的更新提示信息： &lt;!--[if lt IE 8]&gt; &lt;style&gt;html,body&#123;overflow:hidden;height:100%&#125;&lt;/style&gt; &lt;div&gt; &lt;p&gt;您的浏览器版本老的可笑，请到点击下面任一链接更新，以获取最佳的浏览体验。&lt;/p&gt; &lt;a href=&quot;https://www.google.cn/intl/zh-CN/chrome/browser/desktop/&quot; &quot; target=&quot;_blank&quot;&gt;谷歌 Chrome&lt;/a&gt; &lt;a href=&quot;http://www.uc.cn/ucbrowser/download/&quot; target=&quot;_blank&quot;&gt;UC 浏览器&lt;/a&gt;&quot; &lt;a href=&quot;http://browsehappy.com&quot;&gt;各大浏览器更新网站(外网) &lt;/div&gt; &lt;![endif]--&gt; logo 说明 像logo这样重要的图片最好以img标签的形式嵌入页面。 其他的不太重要的图片可以考虑background的形式引入。 样式重置 传统css样式重置resets.css 性能不佳 H5标准的样式重置 GitHub 3万多star npm install normalize.css css单位 px 1px=1像素 em 相对长度单位 em的相对参照物为 父元素的font-size值 em 具有继承的特点 当没有设值时，浏览器的默认em 1em=16px em的缺点 容易错乱 rem 相对长度单位 参照物为HTML根元素 其固定不变 计算简单 没有设值时，浏览器的默认值 1rem=16px 设置 font-size: 62.5% 那么 1rem = 10px css3 的一些样式 文本选中后的样式设置 1234::selection &#123; background-color: pink; text-shadow: none&#125; calc的使用例子 width: calc(33.33333333% - 2rem) css3 box-sizing属性 border-box，border和padding计算入width之内，其实就是怪异模式了 box-sizing: border-box box-sizing:border-box; 将正常的width height的作用范围延申至border的地方。 也就是说，对元素指定宽度和高度包括了 padding 和 border 。 正常的元素宽高给定后，增加padding border他们会往外面阔展大小。 加了这个属性后，再增加padding border 此时元素内容区会向里面缩进。 清除浮动 当元素设置float浮动后，该元素就会脱离文档流并向左/向右浮动，直到碰到父元素或者另一个浮动元素，浮动元素会造成父元素高度塌陷，所以当我们设置float后，需进行相应的清除浮动操作。 清除浮动的原理 触发BFC BFC 块级格式化上下文 一个HTML元素要创建BFC，则满足下列的任意一个或多个条件即可： 1.float的值不是none。2.position的值不是static或者relative。3.display的值是inline-block、table-cell、flex、table-caption或者inline-flex4.overflow的值不是visible BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列 清除浮动方式一 使用额外的标签clear:both 原理：在浮动元素下面添加一个空标签，在这个标签中设置clear：both； 优点：简单，浏览器兼容性好； 缺点：增加页面的标签，造成页面混乱； 方式二 使用overflow属性 原理：父元素定义overflow:hidden，此时，浏览器会自动检查浮动区域的高度； 优点：简单，无需增加新的标签； 缺点：不能和position配合使用，因为超出的尺寸的会被隐藏 方式三 使用伪元素:after清除浮动 原理：原理同方法一有点类似，在元素最后定义一个空的内容，然后让该空的内容来清除浮动； 优点：无需额外的标签，浏览器兼容性好，是目前用的最多的一种清除浮动的方法之一； 缺点：代码稍微复杂点，初学者可能不太能理解其原理； 方式四 推荐 老外大师推荐 12345.clearfix:before,.clearfix:after&#123; content: &apos; &apos;; display: table;&#125; line-height 注意事项 在使用rem 的单位设置时会有点问题 建议使用px的单位 diaplay: inline-block 注意事项 将元素设置为inline-block即行内块元素 多个inline-block元素会排列为一行 对外显示为行内元素 对内为块级元素的特性 带来的问题： 各个元素间会出现一条小缝隙 即是元素间的空白字符 两个标签之间看不见的东西 解决方法： 将元素排列为一行 或去掉元素后面的闭合标签 将闭合标签放到下一个标签的开头部分 还有好多种方法 雪碧图的使用 CSS雪碧 即CSS Sprite，也有人叫它CSS精灵，是一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分 CSS雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。该图片使用CSS background和background-position属性渲染。 省略号的设置12345.box&#123; text-overflow: ellipsis; overflow: hidden; white-space: nowrap;&#125; 有事您Q我👇]]></content>
      <categories>
        <category>responsive-sites</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express]]></title>
    <url>%2Fexpress%2Fexpress%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 有事您Q我👇]]></content>
      <categories>
        <category>express</category>
      </categories>
      <tags>
        <tag>zhuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie-js]]></title>
    <url>%2Fcookie%2Fcookie-js%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 转载 原文链接运用JS设置cookie、读取cookie、删除cookieJavaScript是运行在客户端的脚本，因此一般是不能够设置Session的，因为Session是运行在服务器端的。 而cookie是运行在客户端的，所以可以用JS来设置cookie. 假设有这样一种情况，在某个用例流程中，由A页面跳至B页面，若在A页面中采用JS用变量temp保存了某一变量的值，在B页面的时候，同样需要使用JS来引用temp的变量值，对于JS中的全局变量或者静态变量的生命周期是有限的，当发生页面跳转或者页面关闭的时候，这些变量的值会重新载入，即没有达到保存的效果。解决这个问题的最好的方案是采用cookie来保存该变量的值，那么如何来设置和读取cookie呢？ 首先需要稍微了解一下cookie的结构，简单地说：cookie是以键值对的形式保存的，即key=value的格式。各个cookie之间一般是以“;”分隔。 JS设置cookie: 假设在A页面中要保存变量username的值(“jack”)到cookie中,key值为name，则相应的JS代码为： document.cookie=”name=”+username; JS读取cookie: 假设cookie中存储的内容为：name=jack;password=123 则在B页面中获取变量username的值的JS代码如下： var username=document.cookie.split(“;”)[0].split(“=”)[1]; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//JS操作cookies方法! //写cookies function setCookie(name, value) &#123; var Days = 30; var exp = new Date(); exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 1000); document.cookie = name + &quot;=&quot; + escape(value) + &quot;;expires=&quot; + exp.toGMTString();&#125;//读取cookiesfunction getCookie(name) &#123; var arr, reg = new RegExp(&quot;(^| )&quot; + name + &quot;=([^;]*)(;|$)&quot;); if ((arr = document.cookie.match(reg))) return unescape(arr[2]); else return null;&#125;//删除cookiesfunction delCookie(name) &#123; var exp = new Date(); exp.setTime(exp.getTime() - 1); var cval = getCookie(name); if (cval != null) document.cookie = name + &quot;=&quot; + cval + &quot;;expires=&quot; + exp.toGMTString();&#125;//使用示例setCookie(&quot;name&quot;, &quot;hayden&quot;);alert(getCookie(&quot;name&quot;));//如果需要设定自定义过期时间//那么把上面的setCookie 函数换成下面两个函数就ok;//程序代码function setCookie(name, value, time) &#123; var strsec = getsec(time); var exp = new Date(); exp.setTime(exp.getTime() + strsec * 1); document.cookie = name + &quot;=&quot; + escape(value) + &quot;;expires=&quot; + exp.toGMTString();&#125;function getsec(str) &#123; alert(str); var str1 = str.substring(1, str.length) * 1; var str2 = str.substring(0, 1); if (str2 == &quot;s&quot;) &#123; return str1 * 1000; &#125; else if (str2 == &quot;h&quot;) &#123; return str1 * 60 * 60 * 1000; &#125; else if (str2 == &quot;d&quot;) &#123; return str1 * 24 * 60 * 60 * 1000; &#125;&#125;//这是有设定过期时间的使用示例：//s20是代表20秒//h是指小时，如12小时则是：h12//d是天数，30天则：d30setCookie(&quot;name&quot;, &quot;hayden&quot;, &quot;s20&quot;); 转载 原文链接 有事您Q我👇]]></content>
      <categories>
        <category>cookie</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Promise-zhuf]]></title>
    <url>%2FPromise%2FPromise-zhuf%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; js执行顺序优先级 scncfunction –&gt; micro task –&gt; macro task 同步代码 scncfunction 微任务 micro task 宏任务 macro task 微任务 micro task Process.nextTick 把当前任务放到主栈的最后执行 Promise(async await) 宏任务 macro task 回调函数 ajax 事件绑定 node 中的 fs 三种定时器 setImmediate (nodejs独有) setTimeout setInterval 123setImmediate (() =&gt; &#123; console.log(&apos;shulu&apos;)&#125;) Promise 三种状态 进行中 成功 失败 Promise.all([promise1, promise2, promise3]).then(() =&gt; {……}).catch(){……} 即promise1,2,3都成功则执行then的成功方法，有一个失败则走catch方法。 es6 class 类 class 的本质是 function。 在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。 它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法 constructor 方法是类的默认方法，创建类的实例化对象时被调用 class 的实例化必须通过 new 关键字。 123456789101112class Promise &#123; //constructor 创建类的实例化对象时被调用 constructor () &#123; &#125; //这里写原型上的方法 then() catch()&#125; 手写Promise实现 有事您Q我👇]]></content>
      <categories>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>zhuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-linux]]></title>
    <url>%2Fgit%2Fgit-linux%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;终有一天，我会出现在你的眼前。 个人本地操作篇 显示目录或文件 ls -s / ls -a -s 文件列表 -a 包括隐藏文件 cd cd / cd ../ 可以直接拖动文件进入目录 创建文件夹 mkdir + shulu 创建空文件 touch + lqy 编辑文件 方式一 vim/vi + lqy A或I 键进入插入模式 编辑完成后 Esc 然后:wq 即可保存退出 方式二 向指定的文件输入内容 echo xxx &gt; shulu.txt shulu.txt若不存在则创建 每次编辑都会覆盖之前的内容 查看文件中的内容 cat lqy 删除文件或文件夹 一旦删除 不可恢复 rm + name -rf -r 递归删除 -f 强制删除 -rf 以上二者都有 git status 查看当前文件处于哪一个区域 红色：在工作区 绿色：在暂存区 看不见：已经提交到历史区，三区保持一致了 暂存区删除文件操作 只要新add一下新的内容 即可覆盖前面暂存区不好的代码 根据提示： (use “git reset HEAD …” to unstage) 即git reset HEAD &lt;要删除的file&gt; 或git rm –cached &lt;要删除的file&gt; 代码回滚 一 暂存区回滚 一步回滚操作 将暂存区文件撤回来覆盖工作区新写的不好的代码 git checkout &lt;要撤回的file&gt; (注意 . 表示所有的文件) 暂存区的文件依然在，只是将其拿出来覆盖新写的不好的代码 工作区和暂存区 状态保持一致了 两步回滚操作 git reset HEAD &lt;要删除的file&gt; 把当前暂存区的内容删掉，此时暂存区的内容为上一次add的内容 git checkout 将上一次add的内容拿回来覆盖工作区的不好的代码 代码回滚 二 历史版本回滚 git log 版本信息 若出现了 提交的信息最后有一个end 按Q键即可退出 git reset –hard &lt;版本id&gt; 三区保持一致了 .gitignore文件 添加不用git管理的文件 ctrl + L 清屏 团队协作篇 创建远程仓库 最好创建一个README.md文件 这样远程就会有一个master的分支 有利于后续的操作 创建本地仓库初始化本地仓库连接远程仓库这操作不常用 mkdir repository git init git remote add origin git@github.com:lqyasl/git-zhuf.git git clone 常用 一步操作等于以上三步操作 git clone git@github.com:lqyasl/git-zhuf.git 不同开发者之间的配合 假设有a b 两个开发者不冲突的情况 a b 两人提交修改的是不同的文件 提交之前最好git pull origin master 拉取远程仓库的内容 然后再git push origin master 推送到远程产生冲突的情况 两人同时对相同的文件都做了不一样的修改 解决冲突 若直接弹出vim的内容 正常退出即可 即 输入a 然后按Esc 再按 :wq 若显示MERGEING 则删掉那些特殊符号 ，修改好后退出 无分支开发模式 即只有一个master 分支分支开发模式 新开一个分支即可 git checkout -b deva 即可创建一个deva分支 并且切换到这个分支上 新创建分支的特点：本地master内容会自动同步到deva分支上 在deva分支上完事后 git add . git commit -m ‘……’ git stash 保存当前的工作进度。会分别对暂存区和工作区的状态进行保存 关于这一步操作后面有说明 git checkout master git merge deva git pull origin master git push origin master git stash &amp; git stash pop git stash 保存当前的工作进度。会分别对暂存区和工作区的状态进行保存. git stash pop 恢复工作现场。 软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。 当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交。 并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？ 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来(先git add . 到暂存区 然后 git stash 藏起来)，等以后回来恢复现场后继续工作。 总结： 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除bug分支； 当手头工作没有完成时，先把工作现场git stash一下，然后去bug分支修复bug，修复后，再回到之前的分支git stash pop，将工作现场恢复。 有事您Q我👇]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>zhuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-mooc]]></title>
    <url>%2Fwebpack%2Fwebpack-mooc%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;只要有想见的人，就不是孤身一人。 开始 node 安装 webpack 安装 初始化文件夹 npm init 打包符合node规范的项目 或 npm init -y 生成默认初始化的文件夹 全局安装webpack 不推荐 因为各个项目依赖的webpack版本可能不一样 npm uninstall webpack webpack-cli -g 卸载webpack npm install webpack webpack-cli -D 推荐在项目中独立安装 npm info webpack 打印输出webpack的信息 可以查看你想要的版本是否存在 安装你所需要的版本就行了 npm i webpack@版本号 webpack-cli -D webpack 默认的打包配置文件为webpack.config.js 开始配置 webpack.config.js初步配置 新建webpack.config.js文件 新建src目录 放我们的源代码 webpack.config.js配置如下： 123456789101112//nodejs引入path模块 为commonjs规范const path = require(&apos;path&apos;)module.exports = &#123; mode: development, // 指定运行环境 entry: &apos;./src/index.js&apos;, // 入口文件 output: &#123; // 出口文件 //被编译到你指定的输出路径的文件夹中 path: path.resolve(_dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; //指定打包生成的文件名字 &#125;&#125; package.json 配置scripts命令 简化命打包令为 npm run bundle 12345&#123; &quot;scripts&quot;: &#123; &quot;bundle&quot;: &quot;webpack&quot; //npm run bundle 执行webpack命令 &#125;,&#125; 不同安装的webpack打包形式 未配置scriptsnpx webpack 要打包的文件 配置scripts后npm run bundle 即可 配置打包图片 loader 所谓 loader 只是一个导出为函数的 JavaScript 模块。让 webpack 能够去处理那些非 JavaScript 文件 (webpack 自身只理解 JavaScript) loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块， 然后你就可以利用 webpack 的打包能力，对它们进行处理。 12345678910111213141516171819202122232425const path = require(&apos;path&apos;)module.exports = &#123; mode: &apos;development&apos;, entry: &#123; main: &apos;./src/index.js&apos; &#125;, module: &#123; rules: [&#123; test: /\.(jpg|png|gif)$/,//用于标识出应该被对应的 loader 进行转换的某个或某些文件。 use: &#123;//表示进行转换时，应该使用哪个 loader。 loader: &apos;url-loader&apos;, // loader: &apos;file-loader&apos;, options: &#123; //配置项 name: &apos;[name].[ext]&apos;,//以原来的名字和后缀打包生成文件名 outputPath: &apos;images/&apos;,//打包生成的文件放到dist/images/ limit: 2048 //当图片的大小在2kb以下时直接打包成base64的图片嵌入js文件中 &#125; &#125; &#125;] &#125;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;&#125; 样式loader css-loader 处理各个css文件间的关系 style-loader 将增加一个style标签并插入css文件然后挂载到head标签中 处理sass文件 npm install sass-loader node-sass -D loader 的执行顺序 从下到上 从右到左 处理less文件 首先npm install less –save-dev 再npm i -D less-loader 123456789101112module: &#123; rules: [&#123; test: /\.scss$/, use: [&#123; loader: &quot;style-loader&quot; // 将 JS 字符串生成为 style 节点 &#125;, &#123; loader: &quot;css-loader&quot; // 将 CSS 转化成 CommonJS 模块 &#125;, &#123; loader: &quot;sass-loader&quot; // 将 Sass 编译成 CSS &#125;] &#125;]&#125; 自动添加前缀loader 使用Can I Use中的值为CSS规则添加供应商前缀。 Autoprefixer将使用基于当前浏览器流行度和属性支持的数据为您应用前缀。 npm i -D postcss-loader npm i -D autoprefixer 123456//配置新建postcss.config.jsmodule.exports = &#123; plugins: [ require(&apos;autoprefixer&apos;) ]&#125; 123456789//然后配置webpack.config.js&#123; test: /\.css$/, use: [ &apos;style-loader&apos;, &#123; loader: &apos;css-loader&apos;, options: &#123; importLoaders: 1 &#125; &#125;, &apos;postcss-loader&apos; ]&#125; css-loader 常用的配置 当less(sass)等文件中再引入其他的less(sass)文件时，默认是不会打包引入的文件的， 配置opations 中 importLoaders: 2 后，则会通过’less-loader’, ‘postcss-loader’ 这两个loader的打包 { loader: ‘css-loader’, options: { importLoaders: 2, modules: true //模块化 }},‘less-loader’,‘postcss-loader’ css 打包的模块化 模块中需要哪个样式文件 引入即可import style from ‘./avator.less’ 使用:如 img.classList.add(style.avator) 在avator.less样式中自己写的叫avator的classname 123options: &#123; modules: true //开启css模块化&#125; 字体的引入iconfont file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录。 这就是说，我们可以将它们用于任何类型的文件，包括字体。 src/font一般需要 中如下几种正则中的字体文件 iconfont.css文件，在需要字体的地方引入样式即可 src: url(‘./font/iconfont.eot?t=155948’) url(‘./font/iconfont.ttf?t=155948’) 其中./font为自己加的路劲 其中有个base64格式的路劲不用变 1234test: /\.(woff|woff2|eot|ttf|svg)$/,use: [ &apos;file-loader&apos;] plugin 插件的使用 html-webpack-plugin插件的使用 npm install –save-dev html-webpack-plugin HtmlWebpackPlugin 插件的作用： 会在打包结束后自动生成一个html文件，并把打包生成的js文件自动引入html文件 plugin的作用：在webpack运行到某个时刻的时候，帮我门做一些在事情 就像vue中的生命周期钩子函数 12345678//webpack.config.js中plugins: [ new HtmlWebpackPlugin(&#123; title: &quot;my html template&quot;, //自定义title 默认为webpack app filename: &quot;myindex.html&quot;, //自定义文件名 默认为index.html template: &quot;src/index.html&quot; //以此为模板创建html &#125;)] clean-webpack-plugin 清除旧的打包的文件 1var &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;) 123plugins: [ new CleanWebpackPlugin(),//打包前删除前面旧的dist文件] entry1234entry: &#123; main: &apos;./src/index.js&apos;, sub: &apos;./src/index.js&apos; //再打包生成一个js文件&#125;, output12345output: &#123; publicPath: &apos;https://cdn.abc.com&apos;,//公共前缀路劲如cdn filename: &apos;[name].js&apos;, //以entry的key值作为打包生成的文件名 path: path.resolve(__dirname, &apos;dist&apos;)&#125;, SourceMap 再打包生成main.js文件之后如果代码里出现错误，它会将main.js中错误出现的地方与源码之间做一映射，告诉我们源码中错误出现在哪里，以便我们快速定位bug出处 错误代码使用chrome调试工具直接显示在index.js?b635这个文件打开即可看到源码里面错误出现的位置 123devtool: &apos;cheap-module-eval-source-map&apos;,//development模式推荐使用devtool: &apos;cheap-module-source-map&apos;,//production模式推荐使用 使用WebpackDevServer提升开发效率 npm install webpack-dev-server -D 在webpack.config.js 12345678910111213devServer: &#123; contentBase: &apos;./dist&apos;,//开启一个服务器运行dist里面的内容 open: true ,//自动在浏览器里打开 /* //vue中就是配置的这样的代理 proxy: &#123; &apos;/api&apos;: &apos;http://localhost:3000&apos;//当用户访问api这个地址时proxy将其转到localhost:3000这个地址 &#125;, */ port: 8888//必要时可以自定义端口&#125;, 在 package.json 123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server&quot; //npm run start 开启服务器 自动刷新 目前最常用的 打包生成的dist文件直接放到内存里运行 速度更快&#125;, HotModuleReplacementPlugin 热模块更新1234567891011121314var webpack = require(&apos;webpack&apos;)//配置devServer: &#123; contentBase: &apos;./dist&apos;, open: true, hot: true, //代码更新时只会更新最新变化的部分 不会全部刷新一遍 hotOnly: true&#125;, //配置plugins: [ new webpack.HotModuleReplacementPlugin()] 使用 Babel 处理 ES6 语法1npm install --save-dev babel-loader babel-core babel-preset-env 123456&#123; test: /\.js$/, include: &apos;../src&apos; , // 指定匹配文件的范围 exclude: /node_modules/, loader: &apos;babel-loader&apos;&#125; Tree Shaking 概念详解 把一个模块里面的没有用到的方法摇晃掉 去掉 不打包 如果对一些文件不使用此功能 则配置 package.json 添加 配置 “sideEffects”: [‘不使用此功能的文件’] .babelrc文件配置如下 123456789101112&#123; &quot;presets&quot;: [ [ &quot;env&quot; ,&#123; &quot;targets&quot;: &#123; &quot;chrome&quot;: &quot;67&quot;, &#125;, &quot;useBuiltIns&quot;: &quot;usage&quot; &#125; ] ]&#125; Develoment 和 Production 模式的区分打包 新建webpack.dev.js 开发环境 新建webpack.common.js 公共代码 新建webpack.prod.js 生产环境 详见简书配置 Webpack 和 Code Splitting 代码分割 将外来库的方法与业务逻辑代码分开打包 SplitChunksPlugin 配置参数详解 weback.common.js 1234567891011121314151617181920212223242526optimization: &#123;//优化 splitChunks: &#123; chunks: &apos;all&apos;,//同步异步代码都分割 minSize: 30000,//30kb 分割的最小限度配合cacheGroups //maxSize: 50000,//不常用 minChunks: 1,//当一个模块至少被使用了多少次的时候才代码分割 maxAsyncRequests: 5,//假设有多个库要进行分割，但这里只做分割5个 maxInitialRequests: 3,//不用修改 默认就行了 automaticNameDelimiter: &apos;~&apos;,//组和文件之间的连接符 name: true, cacheGroups: &#123;//缓存组 vendors: &#123; test: /[\\/]node_modules[\\/]/,//在node_modules里面匹配 priority: -10,//优先级和default的优先级作比较， // 若这里的高那么就将符合上面要求的文件打包放到vender组 //filename: &apos;vender.js&apos; &#125;, default: &#123; // minChunks: 2, priority: -20, reuseExistingChunk: true ,//入一个文件已经在之前的步骤中打包过了，那这里就不用再打包了 filename: &apos;common.js&apos; &#125; &#125; &#125;&#125;, Lazy Loading 和 chunk 是什么 懒加载 即当时机成熟的时候再加载代码 promise 必须要有catch() 捕获错误 chunk表示一个文件，默认情况下webpack的输入是一个入口entry文件，输出output也是一个文件，这个文件就是一个chunk，chunkId就是产出时给每个文件一个唯一标识id，chunkhash就是文件内容的md5值，name就是在entry中指定的key值。 123//安装插件npm install --save-dev @babel/plugin-syntax-dynamic-import 12345678910111213141516//src/index.jsasync function getComponent () &#123; const &#123; default: _ &#125; = await import(&apos;lodash&apos;)//异步按需引入lodash函数库 var dom = document.createElement(&apos;div&apos;) dom.innerHTML = _.join([&apos;hello&apos;, &apos;shulu&apos;, &apos;lqy&apos;, &apos;love&apos;, &apos;you&apos;], &apos;^_^&apos;) return dom&#125;document.addEventListener(&apos;click&apos;, () =&gt; &#123; getComponent().then((dom) =&gt; &#123; document.body.appendChild(dom) &#125;).catch((err) =&gt; &#123; console.log(err) &#125;)&#125;) 123456789101112131415//.babelrc&#123; &quot;presets&quot;: [ [ &quot;env&quot; ,&#123; &quot;targets&quot;: &#123; &quot;chrome&quot;: &quot;67&quot;, &#125;, &quot;useBuiltIns&quot;: &quot;usage&quot; &#125; ] ], &quot;plugins&quot;: [&quot;@babel/plugin-syntax-dynamic-import&quot;,]//配置插件&#125; 123456//事实上webpack.common.js的配置如下即可optimization: &#123; splitChunks: &#123; chunks: &apos;all&apos;//同步异步代码都分割 &#125;&#125;, css 模块的分割打包 目前不支持模块热跟新 故在生产环境使用好一些 将webpack.common.js中的css配置文件分别拿到webpack.dev.js 和webpack.prod.js 12345678extract-text-webpack-plugin还不能支持webpack4.0.0以上的版本。 解决办法： npm install -–save-dev extract-text-webpack-plugin@next 会下载到+ extract-text-webpack-plugin@4.0.0-beta.0 然后打包就正常了//npm install --save-dev extract-text-webpack-pluginnpm install --save-dev extract-text-webpack-plugin@next 1234567891011121314151617181920212223242526//webpack.prod.jsconst ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;)//配置module: &#123; rules: [ &#123; test: /\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: [&apos;css-loader&apos;, &apos;postcss-loader&apos;] &#125;) &#125;, &#123; test: /\.less$/, use: ExtractTextPlugin.extract(&#123; fallback: &apos;style-loader&apos;, //如果需要，可以在 sass-loader 之前将 resolve-url-loader 链接进来 use: [&apos;css-loader&apos;, &apos;less-loader&apos;, &apos;postcss-loader&apos;] &#125;) &#125; ]&#125;,plugins: [ new ExtractTextPlugin(&quot;styles.css&quot;),] 12345//package.json 对css文件不使用tree shaking&quot;sideEffects&quot;: [ &quot;*.css&quot;], 12345678//webpack.common.jsoptimization: &#123; usedExports: true, //模块中只引入使用了的方法(函数) splitChunks: &#123; chunks: &apos;all&apos; &#125;&#125;, 将打包后的css压缩代码 1npm i -S optimize-css-assets-webpack-plugin 1234567//webpack.prod.jsconst OptimizeCSSAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;)optimization: &#123; minimizer: [new OptimizeCSSAssetsPlugin(&#123;&#125;)],&#125;, webpack Library库webpack PWA 的打包TypeScript 的打包配置WebpackDevServer 请求转发 devServer.proxy的配置 开发环境development 12345678910111213141516devServer: &#123; proxy: &#123;//代理 &quot;/api&quot;: &#123; //将所有对/api的请求转发到http://shulu520.com/test.json target: &quot;http://shulu520.com/test.json&quot;, //在开发中当后端/api还没有做好时，将路劲变为love.json, 做好后，将这里配置注释掉即可，就不用改源码了 pathRewrite: &#123;&quot;^/api&quot; : &quot;love.json&quot;&#125;, //默认不支持https的 配置后即可支持 secure: false //如果希望代理多个特定路径到同一个目标，可以这样使用 context: [&quot;/auth&quot;, &quot;/api&quot;], &#125;&#125; webpack 打包优化 跟上技术的迭代 工具的更新 在尽可能少的模块上应用loader 约束loader的应用范围 123456&#123; test: /\.js$/, include: path.resolve(__diename, &apos;./src&apos;) exclude: /node_modules/, loader: &apos;babel-loader&apos;&#125; 尽可能少的使用plugin 并确保可靠 官网的推荐 resolve 配置项 参数的合理配置 123456//webpack.common.jsresole: &#123; alias: &#123;// 别名 简化长路劲 Child: path.resolve(__dirname, &apos;./src/a/b/c/Child&apos;) &#125;&#125; 自己编写 Loader 实现代码的装饰 loader 是转译模块源代码的转换规则。 loader 被编写为，接受源代码作为参数的函数， 并返回这些转换过的新版本代码. 手写 pluginbundler 源码编写 (模块分析) 有事您Q我👇]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>mooc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-advance-four]]></title>
    <url>%2Fjs-advance%2Fjs-advance-four%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这世界为何有这么可爱的人儿，儿童节快乐哦 线程与进程 进程: 程序的一次执行, 它占有一片独有的内存空间 可以通过windows任务管理器查看进程 线程: 是进程内的一个独立执行单元 是程序执行的一个完整流程 是CPU的最小的调度单元 关系 一个进程至少有一个线程(主) 程序是在某个进程中的某个线程执行的 应用程序必须运行在某个进程的某个线程上 一个进程中至少有一个运行的线程: 主线程, 进程启动后自动创建 一个进程内的数据可以供其中的多个线程直接共享 多个进程之间的数据是不能直接共享的 线程池(thread pool): 保存多个线程对象的容器, 实现线程对象的反复利用 何为多进程与多线程? 多进程运行: 一应用程序可以同时启动多个实例运行 多线程: 在一个进程内, 同时有多个线程运行 比较单线程与多线程? 多线程优点：能有效提升CPU的利用率缺点：创建多线程开销 线程间切换开销 死锁与状态同步问题 单线程优点：顺序编程简单易懂缺点：效率低 JS是单线程还是多线程? js是单线程运行的 但使用H5中的 Web Workers可以多线程运行 浏览器运行是单进程还是多进程? 有的是单进程 firefox 老版IE 有的是多进程 chrome 新版IE 如何查看浏览器是否是多进程运行的呢? 任务管理器 —&gt; 进程 浏览器内核 支撑浏览器运行的最核心的程序 不同的浏览器可能不一样 Chrome, Safari : webkit firefox : Gecko IE: Trident 360,搜狗等国内浏览器: Trident + webkit 浏览器内核模块组成 主线程 js引擎模块 : 负责js程序的编译与运行 html,css文档解析模块 : 负责页面文本的解析 DOM/CSS模块 : 负责dom/css在内存中的相关处理 布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象) 分线程 定时器模块 : 负责定时器的管理 DOM事件模块 : 负责事件的管理 网络请求模块 : 负责Ajax请求 js线程 js是单线程执行的(回调函数也是在主线程) H5提出了实现多线程的方案: Web Workers 只能是主线程更新界面 定时器问题: 定时器并不真正完全定时 如果在主线程执行了一个长时间的操作, 可能导致延时才处理 事件处理机制(图) 代码分类 初始化执行代码: 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码 回调执行代码: 处理回调逻辑 js引擎执行代码的基本流程: 初始化代码===&gt;回调代码 模型的2个重要组成部分: 事件管理模块 回调队列 模型的运转流程 执行初始化代码, 将事件回调函数交给对应模块管理 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行 H5 Web Workers 可以让js在分线程执行 Worker 计算斐波那契数列的例子 12345678910//在主线程 创建一个Worker实例对象 var worker = new Worker(&apos;worker.js&apos;) // 其中worker.js为worker文件路劲 // 绑定接收消息的监听 worker.onmessage = function (event) &#123; //通信的数据都在event.data里面 alert(event.data) &#125; // 向分线程发送消息 worker.postMessage(number) 123456789101112// 在分线程 斐波那契数列function fibonacci(n) &#123; //递归调用 return n&lt;=2 ? 1 : fibonacci(n-1) + fibonacci(n-2) &#125;this.onmessage = function (event) &#123; var number = event.data console.log(&apos;分线程接收到主线程发送的数据: &apos;+number) var result = fibonacci(number)//计算斐波那契数列 postMessage(result)&#125; / 分线程中this不再是window 而是另一个全局对象 其有onmessage,postMessage等方法 故在这里可以直接调用 而不可以直接调用window的方法 如alert() // alert is not defind document 方法 等 可以更新页面的方法都不可以调用 只有主线程才可以跟新界面 / 问题: worker内代码不能操作DOM更新UI 不是每个浏览器都支持这个新特性 不能跨域加载JS 慢一点 数据传输过程 来我QQ撩我哦👇]]></content>
      <categories>
        <category>js-advance</category>
      </categories>
      <tags>
        <tag>guigu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-advance-three]]></title>
    <url>%2Fjs-advance%2Fjs-advance-three%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;想起你，内心充满欢喜O(∩_∩)O 对象的创建模式 Object构造函数模式 套路: 先创建空Object对象, 再动态添加属性/方法 适用场景: 起始时不确定对象内部数据 问题: 语句太多 123var obj = new Object()obj.name = &apos;Tom&apos;obj.setName = function(name)&#123;this.name=name&#125; 对象字面量模式 套路: 使用{}创建对象, 同时指定属性/方法 适用场景: 起始时对象内部数据是确定的 问题: 如果创建多个对象, 有重复代码 1234var obj = &#123; name : &apos;Tom&apos;, setName : function(name)&#123;this.name = name&#125;&#125; 工厂函数模式 套路: 通过工厂函数动态创建对象并返回 适用场景: 需要创建多个对象 问题: 对象没有一个具体的类型, 都是Object类型 即通过instanceof判断得到的都是Object类型 类型不够具体 人和🐶均为同一类型 用的不多 只是比较经典 返回一个对象的函数===&gt;工厂函数 联系真实工厂 12345678910function createPerson(name, age) &#123; var obj = &#123; name: name, age: age, setName: function (name) &#123; this.name = name &#125; &#125; return obj&#125; 构造函数模式 套路: 自定义构造函数, 通过new创建实例对象 适用场景: 需要创建多个类型确定的对象 问题: 每个对象都有相同的数据, 浪费内存 123456function Person(name, age) &#123; this.name = name; this.age = age; this.setName = function(name)&#123;this.name=name;&#125;;&#125;new Person(&apos;tom&apos;, 12); 组合模式 (构造函数+原型) 套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上 适用场景: 需要创建多个类型确定的对象 123456function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.setName = function(name)&#123;this.name=name;&#125;;new Person(&apos;tom&apos;, 12); 继承模式 原型链继承 : 得到方法 12345678function Parent() &#123;&#125;Parent.prototype.test = function()&#123;&#125;;function Child() &#123;&#125;Child.prototype = new Parent(); //子类型的原型指向父类型实例Child.prototype.constructor = Child //修正constructor属性重新指向子构造函数var child = new Child(); //有test() 借用构造函数 : 得到属性(假继承) 1234567function Parent(xxx)&#123;this.xxx = xxx&#125;Parent.prototype.test = function()&#123;&#125;;function Child(xxx,yyy)&#123; Parent.call(this, xxx);//借用构造函数 this.Parent(xxx)&#125;var child = new Child(&apos;a&apos;, &apos;b&apos;); //child.xxx为&apos;a&apos;, 但child没有test() 组合继承 (原型链继承+构造函数) 利用原型链实现对父类型对象的方法继承 利用call()借用父类型构建函数初始化相同属性 12345678910function Parent(xxx)&#123;this.xxx = xxx&#125;Parent.prototype.test = function()&#123;&#125;function Child(xxx,yyy)&#123; Parent.call(this, xxx)//借用构造函数 this.Parent(xxx)&#125;Child.prototype = new Parent() //得到test()Child.prototype.constructor = Child //修正constructor属性var child = new Child(); //child.xxx为&apos;a&apos;, 也有test() new一个对象背后做了些什么? 创建一个空对象 给对象设置proto, 值为构造函数对象的prototype属性值 this.proto = Fn.prototype 执行构造函数体(给对象添加属性/方法) 来我QQ撩我哦👇]]></content>
      <categories>
        <category>js-advance</category>
      </categories>
      <tags>
        <tag>guigu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hotkey-listary]]></title>
    <url>%2Fhotkey%2Fhotkey-listary%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;人生如逆旅，我亦是行人。 listary 最常用的快捷键 alt A 打开listary 双击 ctrl 打开listary bing 必应搜索 bd 百度一下 百度网盘 zh 知乎搜索 ctrl N 向下切换选中的目录 ctrl P 向上切换选中的目录 双击桌面 打开listary选项 在任意文件夹/目录下双击 打开listary选项 可以选命令打开cmd &emsp;&emsp;未完待续…… 来我QQ撩我哦👇]]></content>
      <categories>
        <category>hotkey</category>
      </categories>
      <tags>
        <tag>listary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hotkey-windows]]></title>
    <url>%2Fhotkey%2Fhotkey-windows%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 👉Q我吧 windows 最常用快捷键 ctrl w 关闭当前网页 f2键 ：选中后按f2键即可重命名文件，另一种方法，点一下文件名，稍等，再点一下，即可重命名 f4: 重复上步操作 f5: 刷新桌面 刷新网页 f11: 全屏显示网页 shift : 省略号 shift + 数字6 （表示六个点） …… 书名号 shift + &lt;&gt; (小于大于） 分隔号 单独按 数字1 前面的键 《简 · 爱》 Alt + 单击拖动 为矩形选择 AlT + f4 关闭当前程序 删除 选中后 按delete 永久删除 选中后 shift +delete 截屏 PrtSc 截全屏 Alt +PrtSc 截当前窗口 ctrl alt delete 任务管理器 windows 打开开始菜单 ctrl shift n 新建文件夹 window e 打开文件资源管理器 alt tab 切换窗口 window d 回到桌面 &emsp;&emsp;学到了再来补充😝 👉点这里，进入QQ交流]]></content>
      <categories>
        <category>hotkey</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-advance-two]]></title>
    <url>%2Fjs-advance%2Fjs-advance-two%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;又是元气满满的一天😝,文章链接失效，又好了。有惊无险 来我QQ撩我哦👇 原型与原型链 所有函数都有一个特别的属性: prototype : 显式原型属性 所有实例对象都有一个特别的属性: proto : 隐式原型属性 当然所有函数也都有一个特别的属性： proto : 隐式原型属性 且所有函数的 隐式原型 都一样 都等于Function的显式原型 函数的显式原型指向的对象默认是空Object实例对象(但Object不满足) 123console.log(Fn.prototype instanceof Object) // trueconsole.log(Object.prototype instanceof Object) // falseconsole.log(Function.prototype instanceof Object) // true 所有函数都是Function的实例(包含Function自身) 1console.log(Function.__proto__===Function.prototype) Object的原型对象是原型链尽头 1console.log(Object.prototype.__proto__) // null 1234567891011121314151617// 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)console.log(Date.prototype, typeof Date.prototype)function Fun () &#123;//alt + shift +r(重命名rename)&#125;console.log(Fun.prototype) // 默认指向一个Object空对象(没有我们的属性)// 原型对象中有一个属性constructor, 它指向函数对象console.log(Date.prototype.constructor===Date)console.log(Fun.prototype.constructor===Fun)//给原型对象添加属性(一般是方法) ===&gt;实例对象可以访问Fun.prototype.test = function () &#123; console.log(&apos;test()&apos;)&#125;var fun = new Fun()fun.test() 显式原型与隐式原型的关系 函数的prototype: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象 实例对象的proto: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值 原型对象即为当前实例对象的父对象 原型链 所有的实例对象都有proto属性, 它指向的就是原型对象 这样通过proto属性就形成了一个链的结构—-&gt;原型链 当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找 当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作,如果当前对象中没有此属性, 直接添加此属性并设置其值 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上 面试题1 1234567891011121314function A () &#123; ...&#125;A.prototype.n = 1var b = new A()A.prototype = &#123; n: 2, m: 3&#125;var c = new A()console.log(b.n, b.m, c.n, c.m) // 1 undifind 2 3 面试题2 12345678910111213141516function F ()&#123;&#125; Object.prototype.a = function()&#123; console.log(&apos;a()&apos;)&#125;Function.prototype.b = function()&#123; console.log(&apos;b()&apos;)&#125;var f = new F()f.a()f.b() // 找不到,可以看原型链图进行分析F.a()F.b() instanceof是如何判断的? 表达式: A instanceof B 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false Function是通过new自己产生的实例 123456789101112131415161718/*案例1 */function Foo() &#123; &#125;var f1 = new Foo()console.log(f1 instanceof Foo) // trueconsole.log(f1 instanceof Object) // true/*案例2 */console.log(Object instanceof Function) // trueconsole.log(Object instanceof Object) // trueconsole.log(Function instanceof Function) // trueconsole.log(Function instanceof Object) // truefunction Foo() &#123;&#125;console.log(Object instanceof Foo) // false 执行上下文与执行上下文栈 变量提升与函数提升 变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined) 函数提升: 在函数定义语句之前, 就执行该函数 先执行变量提升, 再执行函数提升 123function a() &#123;&#125;var aconsole.log(typeof a) // &apos;function&apos; 123456789101112var c = 1function c(c) &#123; console.log(c) var c = 3&#125;c(2) // 报错 c is not a function过程解析： var c fun c c = 1 c(2) 理解 执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性 执行上下文栈: 用来管理产生的多个执行上下文 分类: 全局: window 函数: 对程序员来说是透明的 生命周期 全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡 函数 : 调用函数时产生, 函数执行完时死亡 包含哪些属性: 全局 : 用var定义的全局变量 ==&gt;undefined 使用function声明的函数 ===&gt;function this ===&gt;window 函数 用var定义的局部变量 ==&gt;undefined 使用function声明的函数 ===&gt;function this ===&gt; 调用函数的对象, 如果没有指定就是window 形参变量 ===&gt;对应实参值 arguments ===&gt;实参列表的伪数组 执行上下文 创建和初始化的过程 全局执行上下文: 在全局代码执行前最先创建一个全局执行上下文(window) 收集一些全局变量, 并初始化 var定义的全局变量==&gt;undefined, 添加为window的属性 function声明的全局函数==&gt;赋值(fun), 添加为window的方法 this==&gt;赋值(window) 开始执行全局代码 函数执行上下文: 在调用函数时, 在执行函数体之前，先创建一个函数执行上下文对象(虚拟的, 存在于栈中) 收集一些局部变量, 并初始化 形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性 arguments==&gt;赋值(实参列表), 添加为执行上下文的属性 var定义的局部变量==&gt;undefined, 添加为执行上下文的属性 function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法 this==&gt;赋值(调用函数的对象) 开始执行函数体代码 执行上下文栈 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象 在全局执行上下文(window)确定后, 将其添加到栈中(压栈) 在函数执行上下文创建后, 将其添加到栈中(压栈) 在当前函数执行完后,将栈顶的对象移除(出栈) 当所有的代码执行完后, 栈中只剩下window 12345678910var a = 10var bar = function (x) &#123; var b = 5 foo(x + b)&#125;var foo = function (y) &#123; var c = 5 console.log(a + c + y)&#125;bar(10) 产生执行上下文的个数 = (N)函数调用次数 + 1 面试题 整个过程中产生了几个执行上下文? 5 依次输出什么? gb: undefined fb: 1 fb: 2 fb: 3 fe: 3 fe: 2 fe: 1 ge: 1 123456789101112console.log(&apos;gb: &apos;+ i)var i = 1foo(1)function foo(i) &#123; if (i == 4) &#123; return &#125; console.log(&apos;fb:&apos; + i) foo(i + 1) // 递归调用: 在函数内部调用自己 console.log(&apos;fe:&apos; + i)&#125;console.log(&apos;ge: &apos; + i) 作用域与作用域链 理解: 作用域: 一块代码区域, 在编码时就确定了, 不会再变化 作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量 产生作用域的个数 = (N)定义函数的个数 + 1 分类: 全局 函数 js没有块作用域(在ES6之前) 作用 作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突 作用域链: 查找变量 区别作用域与执行上下文 作用域: 静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了 执行上下文: 动态的, 执行代码时动态创建, 当执行结束消失 联系: 执行上下文环境是在对应的作用域中的 面试题 12345678910111213141516var x = 10; function fn() &#123; console.log(x); &#125; function show(f) &#123; var x = 20; f(); &#125; show(fn); // 10 /* 解析：作用域在函数创建的时候就确定了，一旦确定就不会变化了 */ 1234567891011121314151617var fn = function () &#123; console.log(fn) &#125; fn() // fn函数体 var obj = &#123; fn2: function () &#123; console.log(fn2) &#125; &#125; obj.fn2() // fn2 is not defind /* 解析： 首先在fn2函数作用域里面找fn2 没有 然后再全局作用域找 也没有 故报错 若为this.fn2 则可以 */ 作用域链和原型链的用处 作用域链用来找变量 原型链用来找方法 在全局直接找一个不存在的方法 a is not defined 而通过window.a 则为undifind 闭包 如何产生闭包? 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包 闭包到底是什么? 使用chrome调试查看 会调试的程序员至少不是初级程序员 理解一: 闭包是嵌套的内部函数(绝大部分人) 初步认识 理解二: 包含被引用变量(函数)的对象(极少数人) 高级认识 注意: 闭包存在于嵌套的内部函数中 产生闭包的条件 函数嵌套 内部函数引用了外部函数的数据(变量/函数) 产生闭包的个数 等于外部函数调用的次数 12345678910//三个button按钮for (var i = 0,length=btns.length; i &lt; length; i++) &#123; (function (j) &#123; var btn = btns[j] btn.onclick = function () &#123; alert(&apos;第&apos;+(j+1)+&apos;个&apos;) &#125; &#125;)(i) &#125;// 共产生三个闭包 因为外部函数共调用了三次，每一闭包内部都保存了各自的变量 常见的闭包 将函数作为另一个函数的返回值 将函数作为实参传递给另一个函数调用 闭包生命周期 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用) 死亡: 在嵌套的内部函数成为垃圾对象时 12345678910111213function fn1() &#123; //此时闭包就已经产生了(函数提升, 内部函数对象已经创建了) var a = 2 function fn2 () &#123; a++ console.log(a) &#125; return fn2&#125;var f = fn1() //f来接收fn2f() // 3f() // 4f = null //闭包死亡(包含闭包的函数对象成为垃圾对象) 作用: 延长局部变量的生命周期 让函数外部能操作内部的局部变量 写一个闭包程序 1234567891011function fn1() &#123; var a = 2 function fn2() &#123; a++ console.log(a) &#125; return fn2&#125;var f = fn1()f()f() 闭包应用: 模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为 循环遍历加监听 JS框架(jQuery)大量使用了闭包 缺点: 变量占用内存的时间可能会过长 可能导致内存泄露 解决: 及时释放 : f = null; //让内部函数对象成为垃圾对象 面试题1 123456789101112131415161718192021222324//代码片段一var name = &quot;The Window&quot;;var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); // the window//代码片段二var name2 = &quot;The Window&quot;;var object2 = &#123; name2 : &quot;My Object&quot;, getNameFunc : function()&#123; var that = this; return function()&#123; return that.name2; &#125;; &#125;&#125;;alert(object2.getNameFunc()()); // my object 内存溢出与内存泄露 内存溢出 一种程序运行出现的错误 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误 内存泄露 占用的内存没有及时释放 内存泄露积累多了就容易导致内存溢出 常见的内存泄露: 意外的全局变量 没有及时清理的计时器或回调函数 闭包 &gt;👉点这里，进入QQ交流]]></content>
      <categories>
        <category>js-advance</category>
      </categories>
      <tags>
        <tag>guigu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-advance-one]]></title>
    <url>%2Fjs-advance%2Fjs-advance-one%2F</url>
    <content type="text"><![CDATA[能够让你后悔的从来不是你做过的事而是你想做却没有去做的事👉Q我吧 数据类型的分类和判断 基本(值)类型 Number —– 任意数值 ——– typeof String —– 任意字符串 —— typeof Boolean —- true/false —– typeof undefined — undefined —– typeof/=== null ——– null ———- === 对象(引用)类型 Object —– 任意对象 —– typeof/instanceof Array —— 一种特别的对象(数值下标)—– instanceof Function —- 一种特别的对象(可以执行，内部数据是有序的) —– typeof 判断 typeof ——– 返回数据类型的字符串表达 不能判断 null和object ， object和array instanceof —- 判断对象的具体类型 a instanceof b 即a是否是b构造函数的一个实例 === ———— 可以判断 undefined 和 null 名词解释 实例 实例对象 类型 类型对象 即构造函数 undefined与null的区别? undefined代表定义未赋值 nulll定义并赋值了, 只是值为null 什么时候给变量赋值为null呢? 初始赋值, 表明将要赋值为对象 结束前, 让对象成为垃圾对象(被垃圾回收器回收) 严格区别变量类型与数据类型? 数据的类型 基本类型 对象类型 变量的类型(变量内存值的类型) 基本类型: 保存就是基本类型的数据 引用类型: 保存的是地址值 数据,变量, 内存的理解 什么是数据? 在内存中可读的, 可传递的保存了特定信息的’东东’ 一切皆数据, 函数也是数据 在内存中的所有操作的目标: 数据 什么是变量? 在程序运行过程中它的值是允许改变的量 一个变量对应一块小内存, 它的值保存在此内存中 什么是内存? 内存条通电后产生的存储空间(临时的) 一块内存包含2个方面的数据 内部存储的数据 地址值数据 内存空间的分类 栈空间: 全局变量和局部变量 堆空间: 对象 内存,数据, 变量三者之间的关系 内存是容器, 用来存储不同数据 变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据 问题: var a = xxx, a内存中到底保存的是什么? xxx是基本数据, 保存的就是这个数据 xxx是对象, 保存的是对象的地址值 xxx是一个变量, 保存的xxx的内存内容(可能是基本数据, 也可能是地址值) 关于引用变量赋值问题 2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据 2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象 1234567891011121314151617181920212223let obj1 = &#123; name: &apos;lqy&apos; &#125;情形一function fn1(obj) &#123; obj.name = &apos;shulu&apos;&#125;fn1(obj1)console.log(obj1.name) // shulu情形二funtion fn2(obj) &#123; obj = &#123;name: &apos;shulu&apos;&#125;&#125;fn2(obj1)console.log(obj1.name) // lqy/*解析：形参obj 在函数内部为 var obj变量执行fn( ) 传入实参obj1 即将obj1的值(这里是地址值)复制一份给obj变量*/ 问题: 在js调用函数时传递变量参数时, 是值传递还是引用传递 理解1: 都是值(基本值/地址值)传递 推荐 理解2: 可能是值传递, 也可能是引用传递(地址值) 问题: JS引擎如何管理内存? 内存生命周期 分配小内存空间, 得到它的使用权 存储数据, 可以反复进行操作 释放小内存空间 释放内存 局部变量: 函数执行完自动释放 对象: 成为垃圾对象==&gt;垃圾回收器回收 对象的理解和使用 什么是对象? 多个数据(属性)的集合 用来保存多个数据(属性)的容器 属性组成: 属性名 : 字符串(标识) 属性值 : 任意类型 属性的分类: 一般 : 属性值不是function 描述对象的状态 方法 : 属性值为function的属性 描述对象的行为 特别的对象 数组: 属性名是0,1,2,3之类的索引 函数: 可以执行的 如何操作内部属性(方法) .属性名 [‘属性名’]: 属性名有特殊字符/属性名是一个变量 问题: 什么时候必须使用[‘属性名’]的方式? 属性名包含特殊字符: - 空格 属性名不确定 函数的理解和使用 什么是函数? 用来实现特定功能的, n条语句的封装体 只有函数类型的数据是可以执行的, 其它的都不可以 为什么要用函数? 提高复用性 便于阅读交流 函数也是对象 instanceof Object===true 函数有属性: prototype 函数有方法: call()/apply() 可以添加新的属性/方法 如何调用(执行)函数? test(): 直接调用 obj.test(): 通过对象调用 new test(): new调用 test.call/apply(obj): 临时让test成为obj的方法进行调用 函数中的this是什么? 任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window 所有函数内部都有一个变量this 它的值是调用函数的当前对象 如何确定this的值? test(): window p.test(): p var p = new test(): 新创建的对象p p.call(obj): obj 1234567891011121314151617181920212223242526272829303132333435function Person(color) &#123; console.log(this) this.color = color; this.getColor = function () &#123; console.log(this) return this.color; &#125;; this.setColor = function (color) &#123; console.log(this) this.color = color; &#125;; &#125; Person(&quot;red&quot;); //this是谁? window var p = new Person(&quot;yello&quot;); //this是谁? p p.getColor(); //this是谁? p var obj = &#123;&#125;; p.setColor.call(obj, &quot;black&quot;); //this是谁? obj var test = p.setColor; test(); //this是谁? window function fun1() &#123; function fun2() &#123; console.log(this); &#125; fun2(); //this是谁? window &#125; fun1(); 匿名函数自调用: 123(function(w, obj)&#123; //实现代码&#125;)(window, obj) 专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式 作用 隐藏实现 不会污染外部(全局)命名空间 用它来编码js模块 回调函数的理解 什么函数才是回调函数? 你定义的 你没有调用 但它最终执行了(在一定条件下或某个时刻) 常用的回调函数 dom事件回调函数 定时器回调函数 ajax请求回调函数(后面讲解) 生命周期回调函数(后面讲解) 问题 js一条语句的后面是否应该加分号？ 是否加分号是编码风格问题，没有应不应该，只有喜不喜欢——尤雨溪 必须加分号的情况： 小括号开头的语句 ;(function () {…})() 方括号的开头 ;[1, 2, 3].forEach(() =&gt; {}) &emsp;&emsp;本篇笔记到此完结。 👉点这里，进入QQ交流]]></content>
      <categories>
        <category>js-advance</category>
      </categories>
      <tags>
        <tag>guigu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-modularize]]></title>
    <url>%2Fjs-modularize%2Fjs-%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;爱上一个人是一件幸福的事 👉来QQ撩我啊 JS模块化模块化介绍 模块化的理解 什么是模块? 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起 块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信 一个模块的组成 数据—&gt;内部的属性 操作数据的行为—&gt;内部的函数 模块化 编码时是按照模块一个一个编码的, 整个项目就是一个模块化的项目 模块化的进化过程全局function模式 : 编码: 全局变量/函数 问题: 污染全局命名空间, 容易引起命名冲突/数据不安全 namespace模式(命名空间) : 编码: 将数据/行为封装到对象中 解决: 命名冲突(减少了全局变量) 问题: 数据不安全(外部可以直接修改模块内部的数据) IIFE模式/增强 IIFE : 立即调用函数表达式—&gt;匿名函数自调用 编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口 引入依赖: 通过函数形参来引入依赖模块 123456789101112(function(window, module2)&#123; var data = 'atguigu.com' function foo() &#123; module2.xxx() console.log('foo()'+data) &#125; function bar() &#123; console.log('bar()'+data) &#125; window.module = &#123;foo&#125;&#125;)(window, module2) 模块化规范CommonJS Node.js : 服务器端 Browserify : 浏览器端 也称为js的打包工具 基本语法: 12345678910定义暴露模块 : exports exports.xxx = value module.exports = value引入模块 : require var module = require('模块名/模块相对路径')引入模块发生在什么时候?Node : 运行时, 动态同步引入Browserify : 在运行前对模块进行编译/转译/打包的处理(已经将依赖的模块包含进来了), 运行的是打包生成的js, 运行时不存在需要再从远程引入依赖模块 AMD 浏览器端123456789101112131415161718192021222324252627require.js基本语法 定义暴露模块: define([依赖模块名], function()&#123;return 模块对象&#125;) 引入模块: require(['模块1', '模块2', '模块3'], function(m1, m2)&#123;//使用模块对象&#125;) 配置: require.config(&#123; //基本路径 baseUrl : 'js/', //标识名称与路径的映射 paths : &#123; '模块1' : 'modules/模块1', '模块2' : 'modules/模块2', 'angular' : 'libs/angular', 'angular-messages' : 'libs/angular-messages' &#125;, //非AMD的模块 shim : &#123; 'angular' : &#123; exports : 'angular' &#125;, 'angular-messages' : &#123; exports : 'angular-messages', deps : ['angular'] &#125; &#125;&#125;) CMD : 浏览器端12345678910sea.js基本语法定义暴露模块: define(function(require, module, exports)&#123; 通过require引入依赖模块 通过module/exports来暴露模块 exports.xxx = value &#125;)使用模块seajs.use(['模块1', '模块2']) ES6 ES6内置了模块化的实现 1234567891011121314151617181920212223242526定义暴露模块 : export 暴露一个对象: export default 对象 默认暴露 暴露多个: 常规暴露 export var xxx = value1 export let yyy = value2 或 var xxx = value1 let yyy = value2 export &#123;xxx, yyy&#125; 引入使用模块 : import default模块: 争对默认暴露的模块 以及第三方库 import xxx from '模块路径/模块名' 其它模块：争对常规暴露的模块 import &#123;xxx, yyy&#125; from '模块路径/模块名' import as module1 from '模块路径/模块名'问题: 所有浏览器还不能直接识别ES6模块化的语法 解决: 使用Babel将ES6---&gt;ES5(使用了CommonJS) ----浏览器还不能直接执行 使用Browserify---&gt;打包处理----浏览器可以运行 &emsp;&emsp;未完待续…… 👉点这里，跟我聊QQ]]></content>
      <categories>
        <category>js-modularize</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IT-proper-nouns]]></title>
    <url>%2FIT%2FIT-%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;找到一件可以为之疯狂的事情，是一个人活着最大的意义。 👉来QQ撩我啊 Hack hack是基于开源的程序的基础，对其代码进行增加、删除或者修改、优化，使之在功能上符合新的需求。 api 应用程序接口(Application Programming Interface) cli 命令行界面(Command Line Interface) sdk 软件开发工具包(Software Development Kit) rc 结尾的文件 run control 运行时控制文件 thread 线程 它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 progress 进程是一个“执行中的程序”。 进程是线程的容器。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。 有以下特征 动态性：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。 并发性：任何进程都可以同其他进程一起并发执行 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位； 异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进 结构特征：进程由程序、数据和进程控制块三部分组成。 &emsp;&emsp;未完待续…… 👉点这里，跟我QQ聊天呗]]></content>
      <categories>
        <category>IT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[async-fn-note]]></title>
    <url>%2Funcategorized%2Fasync-fn-note%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 正文： &emsp;&emsp; write to me by QQ email]]></content>
  </entry>
  <entry>
    <title><![CDATA[arrow-js-note]]></title>
    <url>%2Farrowjs%2Farrow-js-note%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天是2019年，520，在这特殊的一天我面对的依然是code, but no Object, 我希望有一天能美梦成真——面向对象面向君，不负代码不负卿。 箭头函数的经典题型 有关 this 1234567891011121314151617181920212223242526272829let obj = &#123; id: 01, say: function () &#123; // 这里的this为obj setTimeout(function () &#123; // 这里是匿名函数的this默认为window console.log(&apos;arrow id:&apos;, this.id); // undifind &#125;, 100); &#125;, sayWithThis: function () &#123; // 这里将this的值当成变量存起来 let that = this; setTimeout(function () &#123; console.log(&apos;arrow id:&apos;, that.id); // 01 &#125;, 100); &#125;, sayWithArrow: function () &#123; // 这里的this为obj setTimeout(() =&gt; &#123; console.log(&apos;arrow id:&apos;, this.id); // 01 &#125;, 100); &#125;, sayWithGlobalArrow: () =&gt; &#123; // 这里的this已经为全局的this了 setTimeout(() =&gt; &#123; console.log(&apos;arrow id:&apos;, this.id); // undifind &#125;, 100); &#125;&#125;; &emsp;&emsp;未完待续…… write to me by QQ email]]></content>
      <categories>
        <category>arrowjs</category>
      </categories>
      <tags>
        <tag>arrowjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-qa-note]]></title>
    <url>%2Fgit%2Fgit-qa-note%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 科学上网之后，git 报错 如下错误： 12345ssh: Could not resolve hostname github.com: Name or service not knownfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 解决方法1、找到本机的 host 文件，一般位置是进入 C:\Windows\System32\drivers\etc 2、在host文件的最后一行加上，如果之前已经设置过，可以将ip地址更改为最新的正确的ip地址 192.30.255.112 github.com git185.31.16.184 github.global.ssl.fastly.net &emsp;&emsp;遇到后继续补充…… write to me by QQ email]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git-qa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array-note]]></title>
    <url>%2FArray%2FArray-note%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; reduce 计算数组成员的个数 123const countOccurrences = (arr,val) =&gt; arr.reduce((a,v) =&gt; (v === val ? a + 1 : a), 0)alert(countOccurrences([1,111,2,2,2,3,4], 2)); // 3 max Math.max.apply(null, arr) Math.max(…arr) &emsp;&emsp;未完待续…… write to me by QQ email]]></content>
      <categories>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hotkey-vim]]></title>
    <url>%2Fhotkey%2Fhotkey-vim%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;You only live on this earth once. vim编辑器 vi 加文件名 进入编辑器页面 按下a 键 进入编辑模式 编辑完成 (在英文输入下)按esc退出编辑模式 按:wq 回车 即可保存并退出 vim 复制/剪切/粘贴/撤销操作 按esc退出编辑模式 按v 键进入视图模式 由方向键控制选中的内容区域 复制 y键 剪贴 d键 粘贴 p键 撤销 在命令行模式下用 :u 撤销最近一次操作 快捷强大的vim 浏览器插件 vim能提升我们的浏览速度, 鼠标比键盘简单, 键盘比鼠标快! 快速向下滚动d 快速向上滚动u 滚动到页面顶部gg 滚动到页面底部G 神技! 快速搜索 (相当于浏览器顶部搜索框), 并在新标签打开 大写的O 关闭页面x 恢复页面X 主动脱离焦点esc 比如按下o搜索退出时按esc shift+/,查看所有快捷键 &emsp;&emsp;未完待续…… write to me by QQ email]]></content>
      <categories>
        <category>hotkey</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs-guigu]]></title>
    <url>%2Fnode%2Fnodejs-guigu%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我期待有一天背着背包出现在你的城市。 环境变量 小娜 输入 环境变量 进入环境变量/用户变量/path 点开 里面是一条条的文件路劲 可以新建一个文件的路劲 在这里配置了 相当于 声明了一个 类似于 js 中的全局变量 为作用域链的最高层 可以将一些常用的文件或程序的路劲添加到path下 这样我们就可以在任意的位置访问他们了 进程 线程 进程 负责为程序的运行提供必备的环境 工厂的车间 线程 负责执行进程中的程序 车间工人 单线程 一个人干活 多线程 多人合作干一个活 node.js 事件驱动 非阻塞 异步I/O (性能瓶颈阶段) input写入操作 output读操作 版本 奇数为开发版 偶数为稳定版 在Node中，模块分为三类：一类是底层由C++编写的内建模块，一类是Node提供的核心模块；还有一类是用户编写的模块，称为文件模块。node.js 模块化 新建一个js文件就是一个模块 这个模块里面写的代码其实是包在一个函数里面的 即 123456789101112131415funcyion (exports, require, module, _filename, _dirname) &#123; /* 这里是我们写的代码 外面其实包了一层这个函数 默认不可见 可以通过console.log(arguments.callee) 或 console.log(arguments.callee + &quot;&quot;) 将此函数打印出来 该函数执行时传进了5个参数 所以模块里面的代码是局部变量 exports参数 用来将变量或函数暴露到外边 require参数 用来引入外部的模块 module参数 代表模块本身 exports是module的属性 _filename 当前模块的完整路劲 _dirname 当前模块所在文件夹的路劲 */&#125; module.exports 与exports的区别 module.exports == exports true exports 只能使用.的方式向外暴露 若exports = {} 这样向外暴露的话就修改了exports的引用对象 module.exports 既可以通过.的形式 也可以直接赋值 推荐写法 核心模块 由node 提供的模块 node_moudle中的 引入时直接写模块名字 不需要路劲 文件模块 由我们自己创建的模块 引入时添加./或../等路劲 包 package 包实际上就是一个压缩文件 解压以后还原为目录 规范的目录包含以下文件： -package.json 包描述文件 (必须的) 里面不能写注释 -bin 可执行二进制文件 binary 二进制 -lib js代码 library 库 图书馆 -doc 文档 document -test 单元测试 npm 即 (Node Package Manager) node包管理器 commonjs包规范的是一种理论 npm是其中一种实践 对node而言 npm帮助其完成了第三方模块的发布安和依赖 借助npm 使得node与第三方模块之间形成一个生态系统 查看版本 npm version查看相关的版本 或npm -v npm search 包名 搜索包 npm init 在某一文件夹下初始化该文件夹 帮助我们根据提示生成一个package.json的文件 在初始化后的文件夹下 安装搜索的包 并新建一个index.js 入口文件在里面就可以直接引入math模块使用了 npm install 包名 安装 包 或npm i npm remove 或 npm r 删除包 npm install 包名 杠杠save 安装包并添加到依赖中 npm install 下载当前项目所依赖的包 npm install 包名 -g 全局安装包 一般是安装一些工具 如vue-cli cnpm 也可以用 快速 node在使用下载的包时 会沿着作用域链一直往上找直到磁盘根目录找不到则报错 这就解释了某的包在删除之后依然能用的情况 Buffer （缓冲区） 结构和数组很相似 方法也类似 补充了数组方法的不足 Buffer专门存贮二进制数据的 实际上Buffer中的内存不是通过JavaScript分配的，而是在底层通过C++申请的。也就是我们可以直接通过Buffer来创建内存中的空间。 使用buffer无需引入模块 直接使用即可 Buffer.from(str) 将字符串str转为buffer二进制数据 在buffer中存贮的都是二进制数据 但在显示时都是以16进制的形式显示的 二进制 00-255 或 00-ff 计算机 一个0或一个1 称为一位(bit) 8bit = 1byte(字节) 最小单位 中文一个汉字占用三个字节 创建一个制定大小的buffer Buffer.alloc(10) 10字节大小 可通过索引来操作buffer中的元素 Buffer的大小一旦确定 不能再更该 因为存储空间是连续的 性能好 Buffer与字符串间的转换 支持的编码: ASCII、UTF-8、UTF-16LE/UCS-2、Base64、Binary、Hex 字符串转Buffer Buffer.from(str , [encoding]); Buffer转字符串 buf.toString() buf.toString([encoding] , [start] , [end]); 复制缓冲区 buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]]) 对缓冲区切片 buf.slice([start[, end]]) 拼接缓冲区 Buffer.concat(list[, totalLength]) fs (文件系统) 在Node中，与文件系统的交互是非常重要的，服务器的本质就将本地的文件发送给远程的客户端 核心模块 直接引入使用 const fs = require(‘fs’) fs 模块中所有的操作都有两种形式 同步(会阻塞 带sync) 异步(不会阻塞 带回调函数) fs模块中所有的操作都有两种形式可供选择同步和异步 同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码。异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。 打开文件 fs.open(path, flags[, mode], callback) fs.openSync(path, flags[, mode]) 关闭文件 fs.close(fd, callback) fs.closeSync(fd) fs中提供了四种不同的方式将数据写入文件 简单文件写入 同步文件写入 异步文件写入 流式文件写入 同步文件的写入： 1.打开文件 操作方式为定为写 即 var fd = fs.openSync(path, flags) 参数为字符串类型 path即文件的路劲 flags即 r表示读操作 w表示写入操作 通过返回的描述符fd对文件进行各种操作 2.写入内容数据 fs.writeSync(fd, string) fd文件的描述符 需要传入文件的描述符 string要写入的内容 3.关闭文件 考虑性能 fs.closeSync(fd) 异步文件写入 1.打开文件 123456789101112131415161718fs.open(path, flags, function (err, fd) &#123; if (!err) &#123; 2.在这里往文件写入内容 写操作 fs.write(fd, &apos;要异步写入的内容&apos;, function (err) &#123; if (!err) &#123; console.log(&apos;write success&apos;) &#125; fs.close(fd, function (err) &#123; if (!err) &#123; console.log(&apos;close success&apos;) &#125; &#125;) &#125;) console.log(fd) &#125;else&#123; console.log(err) &#125;&#125;) 返回值为 callback的参数 简单文件写入 简单同步文件 fs.write 简单异步文件 123456fs.writeFile(&apos;hello.txt&apos;, &apos;shulu520&apos;, &#123;flag: &apos;a&apos;&#125; function (err) &#123; //flag: &apos;a&apos; 追加文件内容 不会覆盖原来的 如果文件不存在则创建 flag还有好多的模式 if (!err) &#123; console.log(&apos;write success&apos;) &#125; //文件路劲可以是F:\JSdownload\npm-test 这种 `但是要变为`F:\\JSdownload\\npm-test或F:/JSdownload/npm-test&#125;) 同步 异步 简单文件 的写入都不适合大文件爱的写入 易导致内存溢出 性能差 流式文件写入 12345678910111213141516171819202122232425 创建流 var ws = fs.createWriteStream(path) 监听事件 once绑定一次性的事件 ws.once(&apos;open&apos;, function () &#123; console.log(&apos;stream success&apos;) &#125;) ws.once(&apos;close&apos;, function () &#123; console.log(&apos;stream close&apos;) &#125;) 写入内容 大量内容 ws.write(&apos;写入内容1&apos;) ws.write(&apos;写入内容2&apos;) ws.write(&apos;写入内容3&apos;) ws.write(&apos;写入内容4&apos;) …… 关闭流 在流开始的一方结束流 ws.end()``` + fs中提供了四种读取文件的方式 简单文件读取 同步文件读取 异步文件读取 流式文件读取+ 简单文件读取 简单异步文件读取 const fs = require(‘fs’);fs.readFile(‘shulu.jpg’, (err, data) =&gt; { if(!err) { fs.writeFile(‘桌面路劲/lqy.jpg’, data, () =&gt; { if(!err) { console.log(‘文件写入成功 ‘) } }) }})12+ 流式文件读取 适用于大文件 const fs = require(‘fs’);1.创建读取流const rs = fs.createReadStream(‘shulu.jpg’);2.监听流的开启和关闭rs.once(‘open’, () =&gt; { console.log(‘流打开成功了’)})rs.once(‘close’, () =&gt; { console.log(‘流关闭了’)})3.读取数据rs.on(‘data’, (data) =&gt; { console.log(data) //多次分批读取大数据}) pipe 流方法 12 const fs = require(‘fs’);const rs = fs.createReadStream(‘shulu.mp3’);const ws = fs.createWriteStrem(‘lqy.mp3’);rs.pipe(ws); 读取后直接流入 12345678910111213141516171819202122232425262728+ fs 模块其他操作 检查一个文件是否存在+ 列出文件 fs.readdir(path[, options], callback) fs.readdirSync(path[, options])+ 截断文件 fs.truncate(path, len, callback) fs.truncateSync(path, len)+ 建立目录 fs.mkdir(path[, mode], callback) fs.mkdirSync(path[, mode])+ 验证路径是否存在 fs.existsSync(path)+ 获取文件信息 fs.stat(path, callback) fs.statSync(path)+ 删除文件 fs.unlink(path, callback) fs.unlinkSync(path)+ 删除目录 fs.rmdir(path, callback) fs.rmdirSync(path)+ 重命名文件和目录 fs.rename(oldPath, newPath, callback) fs.renameSync(oldPath, newPath)+ 监视文件更改写入 fs.watchFile(filename[, options], listener) const fs = require(‘fs’);const isExists = fs.existsSync(‘shulu.mp3’);console.log(isExists);` &emsp;&emsp;未完待续……&emsp;&emsp;write to me]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>guigu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-guigu-note]]></title>
    <url>%2Fgit%2Fgit-guigu-note%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在衰老到来之前，做一件值得做的事情。做这件事不是为了别的，而是为了证明自己是好样的。-《似水流年》 复制 选中后 Ctrl+ins 即键盘右上角的insert键粘贴 相应的位置 Shift+ins查看git 配置信息cat ~/.gitconfig状态查看 git status 查看工作区、暂存区状态文件内容查看 cat haha.txt添加操作 git add [file_name]git commit -m ‘说明信息’ [file_name]创建文件 touch haha.txt 或 vim good.txt 字母ll 列出本地库所有文件和文件总数，创建日期 时间 创建人 文件名 git add haha.txt 后 若想返回add前的状态 根据提示 git rm –cached haha.txt 即可返回，此删除只是从暂存区里面删除，工作区的文件还在git commit haha.txt 这里没带-m ‘说明信息’ 回车后会进入vim 编辑器 可以编写大量的说明信息 首先 按a键 进入插入模式，之后就可以进行编辑了。 编辑完了就可以按Esc键退出插入模式，然后输出:wq即可退出vim编辑器，回到git bash界面。 查看提交记录 git log 打印的记录风格： 分散 有作者 邮箱 日期提示，显示内容详细，内容多了，多屏显示控制方式：桥空格为向下翻页，b键为向上翻页，q 键为退出查看 git log –oneline 打印效果为一行 git reflog 打印的记录风格： 紧凑 在一行显示并有提示版本回退数字提示 版本前进后退 基于索引值操作 任意版本穿梭 推荐方法 git reset –hard alfe9cd 这里alfe9cd为某一版本的提交id值即索引值 基于符号 ^ 只能后退 返回上一个版本 git reset –hard HEAD^ 版本倒退三个 git reset –hard HEAD^^^ 基于符号 ~ 只能后退 版本倒退三个 git reset –hard HEAD~3 reset 命令的三个参数对比 –soft 仅仅在本地库移动HEAD指针 –mixed 在本地库移动HEAD指针,重置暂存区 –hard 在本地库移动HEAD指针,重置暂存区,重置工作区，三个区位置保持一致 删除文件 rm aaa.txt git status 显示为 红色 deleted: aaa.txt 提示要add该文件 git add aaa.txt git status 显示为 绿色 表示已添加到暂存区 git commit -m ‘deleted aaa.txt’ 将这次删除操作提交到本地库 删除文件并恢复 前提：删除前 文件的状态提交到了本地库 操作： git reset –hard [指针位置] 删除操作已经提交到本地库：指针位置指向包含删除文件的历史纪录 删除操作尚未提交到本地库：指针位置使用HEAD 比较文件差异 git diff [文件名] 将工作区的文件和暂存区进行比较 git diff [本地库中历史版本] [文件名] 将工作区的文件和本地历史记录比较 git diff 不带文件名 比较多个文件 分支管理 热修复 主分支的bug 更改 分一个 hot_fix 分支 分支的好处： 查看分支 git branch -v 创建分支 git branch hot_fix 切换分支 git checkout hot_fix 切换到这个分支 合并分支 第一步：切换到接受修改的分支(被合并，增加新内容)上 git checkout [接受修改的分支] 第二步：在接受修改的分支上执行命令 git merge [有新内容的分支] 解决合并分支后产生的冲突 分别在两个分支上修改内容 分别提交到本地库 比如都在haha.txt上做修改 将两个分支合并到一个分支上 出现合并冲突 vim haha.txt 查看合并后的状态 HEAD 部分表示当前分支的修改 在一行========之下为另一个分支上做的修改 解决方法： 一：删掉那些特殊符号 并手动将内容修改为满意的状态 期间可能与分支伙伴商量 保存退出 二：git add [文件名] 三：git commit -m &apos;日志说明&apos; 注意：此时commit `一定不能带 文件名` git 原理 哈希算法 明文 加密 得 密文 常见的 md5算法 git 底层 SHA-1算法 github克隆的效果 完整的把远程库克隆到本地 初始化本地库 邀请队员加入 github进入相应的项目 /settings/Collaborators/ 在Search by username 之下 添加成员的github账号名 add collaborator copy invite link 发送给队员（qq或邮箱等方式）等其他方式把邀请链接发送给队员 队员 登录github 后 Accepe invitation 队员拉取操作 pull=fetch+merge git fetch [远程库地址别名] [远程分支名] git merge [远程库地址别名/远程分支名] git pull [远程库地址别名] [远程分支名] 解决冲突 如果不是基于 GitHub 远程库的最新版所做的修改，则不能推送，必须先拉取。 拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即 跨团队协作 外团队人员fork 该项目 git 工作流分支种类 主干分支 master主要负责管理正在运行的生产环境代码。永远保持与正在运行的生产环境完全一致。 开发分支 develop主要负责管理正在开发过程中的代码。一般情况下应该是最新的代码。 bug 修理分支 hotfix主要负责管理生产环境下出现的紧急修复的代码。 从主干分支分出，修理完毕并测试上线后，并回主干分支。并回后，视情况可以删除该分支。 准生产分支（预发布分支） release较大的版本上线前，会从开发分支中分出准生产分支，进行最后阶段的集成测试。该版本上线后，会合并到主干分支。生产环境运行一段阶段较稳定后可以视情况删除。 功能分支 feature为了不影响较短周期的开发工作，一般把中长期开发模块，会从开发分支 中独立出来。 开发完成后会合并到开发分支。&emsp;&emsp;完 更多笔记看git&amp;github.pdf详细笔记]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git-note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http]]></title>
    <url>%2Fhttp%2Fhttp%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; GET POST 的区别 前提:web浏览器环境下的RFC规范GET 用来获取信息，POST用来发送信息 可见性 安全性 数据大小 编码类型 能否收藏为书签，GET可以 刷新，后退按钮，GET无影响，POST重新提交 能否保留到浏览器历史，GET保留 &emsp;&emsp;]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[net-model]]></title>
    <url>%2Fnet%2Fnet-model%2F</url>
    <content type="text"><![CDATA[应用层: 程序，软件，应用层协议，http协议，DNS协议(域名解析)，FTP协议(文件传输协议)，SMTP(邮件传输协议)传输层: 对数据传输的建立和管理，传输层协议，UDP协议(有丢包的可能)，TCP(保证数据的正确性，顺序性)网络层: 好比交通网络，IP协议(IP加端口号来确定一个程序的位置)数据链路层: 两个子层，一个叫逻辑链路控制子层，另一个叫媒体访问控制子层(MAC地址)物理层: 坐公交，扫码骑车。除了五层网络模型之外还有七层网络模型，那么七层网络模型是什么呢？就是将应用层一分为三，分别为：应用层，表示层和会话层。新出来的表示层和会话层没有相应的协议。一般表示层做的是数据格式化，或者加密等操作。]]></content>
      <categories>
        <category>net</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[shanjuan]]></title>
    <url>%2Fdiary%2Fdiary-shanjuan%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;juan，我的好朋友，好久不见，今偶然间，美好的回忆又浮现眼前，于是赶紧记下那些美好。 &emsp;&emsp;拿起雪糕想起了你。&emsp;&emsp;雪糕这玩意和辣条一样是我小时候的最爱，只是随着年岁渐长，慢慢留在记忆里了。昨晚室友叫我一起去超市，逛了一圈不知买点啥，看到有人买雪糕，心想，天气热了就买个尝尝吧。打开柜子，拿起雪糕，恍惚间，温暖的记忆又浮现在眼前。&emsp;&emsp;juan，我的高中同学，朋友，那时经常作我的同桌，人美心善，跟同学关系都挺好。当然对我也很好。常给我糖果啊各种小吃的，我用的笔啊书和本子啊经常从juan那直接拿。&emsp;&emsp;我对juan的第一印象：juan是一个可爱的小公主，而且很高洁。机缘巧合之下，我有幸认识了juan，而且常常作同桌。这让我们之间的距离又近了一点。juan是我去到十班最早认识的同学之一。&emsp;&emsp;时间久了，发生过的好多事情我就不记得了。所以我此时此刻在努力的将往事回忆，我生怕等我老了的时候，年轻时的这些美好时光要是再也回想不起来了，那样想想多遗憾啊。&emsp;&emsp;juan对我一直很好，就像对其他人一样。我们除了讨论学习，还聊小时候，聊未来。关于未来，其实都是我在表达对未来的迷惑，而juan一直在开导我。juan说我们可以永远做朋友。&emsp;&emsp;一个雪糕，那是高三时的一天中午你送我的，当时教室里是有其同学的，但是你只送给了我。在高三那个本就燥热的季节，让我清凉了一整个夏天。&emsp;&emsp;如今再拿起雪糕，眼前浮现出都是你对我的好。感谢那时的遇见，让我能有这么美好的回忆。juan，也愿你过得好，有个好对象。要是余生能再见，我想你还是那么的漂亮，那么温柔与大气。&emsp;&emsp;朋友的友谊不是三言两语就道的尽的，但都是埋藏在我的心底里的。 &emsp;&emsp;刚刚看qq空间里你发的说说–有人拿走了你的外卖，🤣🤣🤣]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git-liao-note]]></title>
    <url>%2Fgit%2Fgit-liao-note%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;人是不能闲的，一闲就会想得太多，一闲就会感情泛滥，所谓矫情屁事多，空虚寂寞冷，都是因为懒散寂寞闲。 git 的优秀之处 它跟踪并管理的是文件的修改，而非文件。Git有不少命令中有“-”，有时候是“-”，有时候是“–”。学过linux的命令行就懂了，单个”-“ 后面跟的是单个字母的参数，如-m， 两个”–”后面跟的是多个字母的参数，如–readme.txt 在大多数情况下成立的。注意:我的博客页面上显示的效果都只有一个’-‘,若’-‘线条显示的比较细，则表示两个’-‘ 创建本地版本库cd 到目录文件夹下mkdir learn-git 新建文件夹，即版本库（repository）git init 初始化版本库,即把这个目录变成git 可以管理的仓库ctrl + l 清屏，以防代码太多看着难受ls 查看目录下的文件ls -a 查看不可见的文件touch git-test.txt 创建 txt文件 或者用vscode编辑器创建，别用windows 自带的记事本，因为记事本在编码方面有弱智的行为，键盘上的上键 返回上一步命令git add git-test.txt 添加要提交的文件，可多次添加多个文件，将文件添加到暂存区（stage即阶段的意思）git commit -m “添加描述内容，如 这是第一次使用commit提交” 可以一次提交多个文件，默认提交到master 分支时光穿梭机git status 查看仓库当前的状态git diff 查看文件的具体修改的内容 输出变化前后的内容git log 显示从最近到最远的提交日志git reset –hard HEAD^ 回退到上一个版本，HEAD表示当前版本，HEAD^即上一个版本，往上100个版本为HEAD~100git reflog 用来记录我们的每一次命令即commit 的idgit reset –hard commit_id commit_id 为某一版本提交的具体ID名词解释说明 工作区： 即我们电脑上的项目文件夹，版本库 ：即工作区里面的一个叫 .git 的隐藏目录，版本库里面有暂存区，有git 为我们创建的master 分支，以及指向master的一个指针HEAD 管理修改 每次修改，如果不用git add 到暂存区，就不会加入到commit 中git checkout – git-test.txt 让这个文件回到最近一次git commit 或 git add 时的状态，注意–是单独的即后面有空格 ，git checkout 使用版本库里面的版本替换工作区的版本 ，无论工作区是修改还是删除，都可以一键还原。 我测试时为什么不行呢cat git-test.txt 查看文件的内容 远程仓库github 上创建一个仓库就行了，最好与本地仓库同名根据提示：将本地仓库与远程仓库关联并推送到远程123…or push an existing repository from the command linegit remote add origin https://github.com/lqyasl/learn-git.git (关联)git push -u origin master (本地推送到远程) 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。一个项目库第一次推送成功后，后面 只要本地做了提交，就可以 git push origin master 不用加参数-u分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了。前面是先有本地仓库，再有远程库。如何关联远程库。现在，最好的方式是，先创建远程库，再从远程库里面克隆到本地。首先在github上创建一个 仓库 并勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。我这里创建了一个gitskills的库。git clone git@github.com:lqyasl/gitskills.git 或 git clone https://github.com/lqyasl/gitskills.git 等多种方式， 推荐使用前一种，其速度最快。cd gitskills 进入克隆的库ls 展开文件列表 可以看到已经有一叫README.md 的文件了分支管理分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 与其他svn 版本控制系统相比， git 超级快。每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点。每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上。从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变。假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并。合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。实战部分git checkout -b dev 创建dev分支，然后切换到dev分支： 这里git checkout命令加上-b参数表示创建一个分支并切换到这个分支。 checkout这里表示切换的意思。git branch 查看当前分支，git branch命令会列出所有分支，当前分支前面会标一个*号。对README.md 文件做修改，比如加一点内容。然后 git add README.md 以及 git commit -m ‘分支测试’ ，我们就可以在dev分支上正常提交现在，dev分支的工作完成，我们就可以切换回master分支 git checkout master现在，我们把dev分支的工作成果合并到master分支上 git merge dev 这里git merge命令用于合并指定分支到当前分支。注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。合并完成后，就可以放心地删除dev分支了。 git branch -d dev因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。gti branch 查看分支，可以看到只剩下一个master主分支了。创建分支与合并小结 Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 解决冲突创建新的feature1分支，继续我们的新分支开发 git checkout -b feature1修改 README.md 文件的内容在feature1分支上提交 git add README.md 以及 git commit -m ‘AND simple’切换到master分支 git checkout masterGit还会自动提示我们当前master分支比远程的master分支要超前1个提交在master分支上把readme.txt文件的最后一行改为：Creating a new branch is quick &amp; simple.提交README.md 文件现在，master分支和feature1分支各自都分别有新的提交这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看 gti merge feature1 结果显示： Automatic merge failed; fix conflicts and then commit the result.果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件修改README.md 并提交 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。最后，删除feature1分支： git branch -d feature1分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。下面我们实战一下–no-ff方式的git merge：首先，仍然创建并切换dev分支：git checkout -b dev## &emsp;&emsp;今晚到此为止，明天再写。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git-note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math-random]]></title>
    <url>%2FMath%2FMath-random%2F</url>
    <content type="text"><![CDATA[引言：希望你睡不着时，想起的都是那些让你开心的事 常见的问题：如何生成一个区间[min,max]内的随机整数？答案很简单，即 Math.random()*(max-min)+min 以下是一些其他的方法。 new Date() - 0 new Date() 日期函数 默认会显示年月日等字符，new Date() - 0 会得到数字“秒” (new Date() - 0)%2239 ,得到取模数值分之一概率的随机数，即[0,2239]范围内一随机数 toString(指定进制) 方法的调用 与parseInt() 方法一样，进制区间为 [2,36]，取36得字母多一些 随便一个随机数.toString(36)得随机字符，但有数字，且长短不一 随机字符串函数，长度固定，且都是字母 从固定的字典中抽取字符构成随机字符串 12345678910// 在大小写字母之间随机生成 x 个字符function randStr(x)&#123; var s = &apos;&apos;; while(s.length &lt; x &amp;&amp; x &gt; 0)&#123; var r = Math.random(); s += String.fromCharCode(Math.floor(r*26) + (r &gt; 0.5 ? 97 : 65)) &#125;; return s;&#125;;console.log(randStr(3)); //KzE 三个随机字符 颜色随机函数1234function randomColor()&#123; var rand = &apos;#&apos;+(&apos;00000&apos;+(Math.random()*0x1000000&lt;&lt;0).toString(16)).slice(-6); return rand;&#125;; 后记 随机数相关得知识还又有很多，后面学到了再来补充笔记]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>random</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[book-fengchuan]]></title>
    <url>%2Fbook-note%2Fbook-fengchuan%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;深夜时，人会更加容易情绪化，所以无论多难过，都要告诉自己，没有那麽糟糕，睡一觉就好了。 相比广告营销，口口相传更有效，分享能让我们感觉良好，因为他会让我们显得高大上。我们更愿意与人分享能提升个人形象的信息。某些产品，思想或行为，经常出现在我们眼前时，他们的影响力和传染力就会大大增加。从古至今，故事一直都是人们分享信息的重要工具。诱因，让人产生联想，看到这个，就会想到那个。打折规则，100元以上，降价多少元，以下为打几折。&emsp;&emsp;那么如何打造-个疯传的产品呢?第一，让你的产品成为一种社交货币，也就是说人们会通过分享它来赢得别人的好感和兴趣;第二，要利用诱因引发消费者的联想;第三，要带动消费者的情绪，让他们不断频繁地分享;第四，让你的产品尽可能出现在大家眼前，让人们不看都不行;第五，记得，简单实用的东西自然会受人欢迎;最后，帮你的产品量身打造一一个足够有意思的故事。&emsp;&emsp;两个可行的建议。首先，可以让你的产品带上点竞争元素。就是说利用人们的游戏心理，大家在玩游戏的时候都喜欢跟别人比赛，获得胜利之后，会得意地和别人分享自己的战绩，同时也就相当于告诉了别人某个产品。所以，如果你的产品有了游戏元素，就能鼓励消费者用你的产品进行某种互动，这样就提高了产品被分享的可能。]]></content>
      <categories>
        <category>book-note</category>
      </categories>
      <tags>
        <tag>skills</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[skills-search]]></title>
    <url>%2Fskills%2Fskills-search%2F</url>
    <content type="text"><![CDATA[口语转变为关键词 关键词之间打上空格 限定在特定网站内 关键词 site:某一站点 注意：站点前不用加www或http 限定文件类型 关键词 filetype:文件格式 限定时间段 关键词 20xx..20xx 注意：中间是两个英文句号 排除某个关键词 关键词 -广告 -推广 将关键词限定在标题中 关键词 intitle:限定内容]]></content>
      <categories>
        <category>skills</category>
      </categories>
      <tags>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello-friends]]></title>
    <url>%2Fhello%2Ffriends%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Welcome to my blog,终于等到你，还好我没放弃(^_^)这里有我的学习心得,编程感悟,心情故事等,是我个人在互联网上的一个小窝。 &emsp;&emsp;欢迎来我QQ交流，也欢迎匿名来撩，无需登录哦，点击右下角，进我的聊天室开撩呗。 &emsp;&emsp;Everything will be okay in the end. If it’s not okay, it’s not the end. who am i, What kind of person do I want to be?&emsp;&emsp;我是谁，自己要成为什么样的人？其实，在做自己喜欢做的事情的时候，往往也逐渐让自己成为自己想要成为的那种人。&emsp;&emsp;在学习、工作、生活中，接触各种各样的人，他们是什么样的人？有什么特殊的经历？在阅读的过程中，甚至能接触古今中外的人物，他们是如何度过自己的一生的？每个时代，每个人做的事情也许不一样，都是选择人生道路时经历的心境却是相似的，而那些成功的人生，离不开他们所处的“时势”，更为重要的是他们对于机会的觉察和行动的品质。这些不管时代如何变迁，都是大致相同的。&emsp;&emsp;听到的，接触的人多了，也许自己的人生方向也就越来越清晰了，在实际行动中，通过尝试，也许就会发现一条自己要走的路。 12345678910111213141516171819 ) ( /+++=)) ((=+++\ /++++++++// \\+++++++++\ /++++++++++//( /\ )\\++++++++++\ /+++++++++++// \\^^// \\+++++++++++\ _/++++++++++++// &#123;&#123;@::@&#125;&#125; \\++++++++++++\_ /+++++++++++++(( &#123;\/&#125; ))+++++++++++++\ /+++++++++++++++\\ &lt;**&gt; //+++++++++++++++\ /+++++++++++++++++\\ / VV \ //+++++++++++++++++\ /+++++++++++++++++++\\/******\//+++++++++++++++++++\|+/|++++++++++/\++++++(***/\***)++++++/\++++++++++|\+\|/ |+/\+/\+/\/ \+/\++\**|**|**/++/\+/ \/\+/\+/\+| \|v |/ V V V V \+\|*|**|*|/+/ V v V V \| v v /*|*|**|*|*\... v (**|*|**|*|**). . __\*|*|**|*|*/__. . (vvv(VVV)(VVV)vvv). . ............../ / 注感谢原作者的神代码注释，网上流传很多，不知具体出处，愿我等小白借大佬神兽保佑永无bug。^_^ . 来我QQ撩我哦👇]]></content>
      <categories>
        <category>hello</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[h5-guigu-music]]></title>
    <url>%2FH5%2Fh5-guigu-music%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;想去的地方，有你才最美丽。 第一天 像素 适配 图片加载太慢，后面要用纯文字代替，记得更新 rem最终适配代码 123456;(function()&#123; var styleNode = document.createElement(&quot;style&quot;); var w = document.documentElement.clientWidth/16; styleNode.innerHTML=&quot;html&#123;font-size:&quot;+w+&quot;px!important&#125;&quot; document.head.appendChild(styleNode);&#125;)() 1物理像素的实现 用媒体查询的方法 一般用伪元素来做123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;/&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; #test:before&#123; position: absolute; bottom: 0px; content: &quot;&quot;; display: block; width: 100%; height: 1px; background: black; &#125; @media only screen and (-webkit-device-pixel-ratio:2 ) &#123; #test:before&#123; transform: scaleY(.5); &#125; &#125; @media only screen and (-webkit-device-pixel-ratio:3 ) &#123; #test:before&#123; transform: scaleY(.33333333333); &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 第二天 移动端基础事件 querySelectorAll() 匹配满足选择器的所有元素 改变dom结构后一定得再次获取 1234567891011window.onload=function()&#123; //querySelectorAll:获取静态列表 var itemNodes = document.querySelectorAll(&quot;.item&quot;); // 第一次获取 console.log(itemNodes.length) document.body.innerHTML+=&quot;&lt;div class=&apos;item&apos;&gt;&lt;/div&gt;&quot;; itemNodes = document.querySelectorAll(&quot;.item&quot;); // 改变dom结构后一定得再次获取 console.log(itemNodes) for(var i=0;i&lt;itemNodes.length;i++)&#123; itemNodes[i].style.background=&quot;pink&quot;; &#125;&#125; querySelector 获取 querySelectorAll 匹配到的第一个 触屏事件 监听用 addEventListenerpc端12345678910 touchstart mousedown touchmove mousemove 不可能单独触发 可以单独触发 touchend mouseupwindow.onload=function()&#123; var item = document.querySelector(&quot;.item&quot;); item.addEventListener(&quot;touchstart&quot;,function()&#123; console.log(&quot;touchstart&quot;) &#125;)&#125; 移动端事件默认行为 长按选中，橡皮筋效果（下拉）等 全面禁止事件默认行为 在 touchstart事件上，即手指触摸上去的时候就开始禁止 一上来就这段代码，全面禁止事件默认行为12345678910window.onload=function()&#123; document.addEventListener(&quot;touchstart&quot;,function(ev)&#123; ev=ev||event; ev.preventDefault();&#125;)// 单独按需开启 item.addEventListener(&quot;touchstart&quot;,function(ev)&#123; ev=ev||event; ev.stopPropagation();&#125;) 右键菜单的阻止与开启 与自定义右键 全局阻止右键1234567891011121314151617181920212223242526272829 document.oncontextmenu=function()&#123; return false; &#125;// 单独按需开启浏览器的右键菜单 var inner = document.querySelector(&quot;#inner&quot;); inner.oncontextmenu=function(ev)&#123; ev.stopPropagation();&#125;// 也可以自定义右键菜单window.onload=function()&#123; document.oncontextmenu=function(ev)&#123; ev = ev||event; var x = ev.clientX; var y = ev.clientY; var wrap =document.querySelector(&quot;#wrap&quot;); wrap.style.display=&quot;block&quot;; wrap.style.left = x+&quot;px&quot;; wrap.style.top = y+&quot;px&quot;; return false; &#125; // 单击消失 document.onclick=function()&#123; var wrap =document.querySelector(&quot;#wrap&quot;); wrap.style.display=&quot;none&quot;; &#125;&#125; 事件点透 pc端的事件可以在移动端触发 PC端事件有300毫秒延迟 移动端事件不会有延迟 移动端 a 标签跳转方案 并解决误触 123456789101112131415161718192021 // 阻止事件默认行为 document.addEventListener(&quot;touchstart&quot;,function(ev)&#123; ev=ev||event; ev.preventDefault(); &#125;) //移动端a标签的跳转方案 解决误触 var aNodes = document.querySelectorAll(&quot;a&quot;); for(var i=0;i&lt;aNodes.length;i++)&#123; aNodes[i].addEventListener(&quot;touchstart&quot;,function()&#123; this.isMoved=false; &#125;) aNodes[i].addEventListener(&quot;touchmove&quot;,function()&#123; this.isMoved=true; &#125;) aNodes[i].addEventListener(&quot;touchend&quot;,function()&#123; if(!this.isMoved)&#123; location.href=this.href; &#125; &#125;) &#125;&#125; event : //changedTouches: 触发当前事件的手指列表, 最常用//targetTouches: 触发当前事件时元素上的手指列表//touches: 触发当前事件时屏幕上的手指列表常见问题 及解决方法 禁止电话与邮箱,添加标签 1&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no&quot;/&gt; 按需开启 电话与邮箱 12 &lt;a href=&quot;tel:1383838438&quot;&gt;1383838438&lt;/a&gt;&lt;a href=&quot;mailto:2642816105@qq.com&quot;&gt;2642816105&lt;/a&gt; 解决连接按钮高亮问题 1234a &#123; text-decoration:none; // 去下划线 webkit-tap-highlight-color:rgba(0,0,0,0); // 去背景高亮，只需字体高亮&#125; 解决圆角过圆的问题 加属性 webkit-appearance:none 即可 fontboosting 的问题 及显示的字体与设置的大小不一致的现象，加属性 max-height:999999px;即可 无缝华屏 移动端清除浮动：父元素ul元素上加 overflow:hidden 即可 表单：表单高亮：outline:none; 表单内阴影：boder:none; 划屏相关 在谁上面划，即划屏包裹slide-wrapper 划的内容 即slide-content 元素排到一行的方法 浮动 父容器宽度不够会自动换行 另一种技巧 父容器white-space :nowrap; 子元素: display: inline-block;橡皮筋效果 减少每次move 的有效距离，最终的有效距离还是一直在增大 混合 继承 可以单独定义一系列通用的样式，在需要的时候进行调用。从而减少代码的重复 混合：简单 1234567891011121314151617181920&lt;!-- 定义混合 --&gt;.mixin()&#123; &lt;!-- 规则集 --&gt;&#125;&lt;!-- 使用混合 --&gt;#text1&#123; &lt;!-- 相当于将规则集里面的代码cv到这里 --&gt; &lt;!-- 每次使用都是将代码复制到相应位置 --&gt; &lt;!-- 使用几次就有几处相同的代码 --&gt; .mixin();&#125;#text2&#123; .mixin();&#125;#text3&#123; .mixin();&#125;&lt;!-- 多处使用相同的混合 这样写好一点-（手动写）-&gt;#text1,#text2,#text3&#123; .mixin() &#125; 继承：性能好一点 1234567891011121314151617&lt;!-- 定义继承 --&gt;.extend&#123; &lt;!-- 规则集 --&gt;&#125;&lt;!-- 使用继承 --&gt;#text1&#123; &amp;::extend(.extend);&#125;#text2&#123; &amp;::extend(.extend);&#125;#text3&#123; &amp;::extend(.extend);&#125;&lt;!-- 最终编译为 --&gt;#text1,#text2,#text3&#123; &lt;!-- 规则集 ，相当于将规则集里面的代码cv到这里--&gt;&#125;]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>H5-note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown-write]]></title>
    <url>%2Fmd%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[故事的开头，多是惊魂一瞥，然后一眼万年。故事的结局，多是渐行渐远，江湖不见。 在 xxx.md文件插入html效果 直接写html 即可 内联样式也直接写 这里输入文字，自定义字体大小 这里输入文字，自定义字体颜色这里输入文字，自定义字体背景色这是综合起来的效果 这是综合起来的效果2 首行缩进效果 其中的 &amp;emsp;&amp;emsp; 即缩进两个字最常见 全方大的空白 &amp;emsp;&emsp;&emsp;内容充实的生命就是长久的生命。我们要以行为而不是以时间来衡量生命。 ——小塞涅卡 不断行的空白格&amp;nbsp; &nbsp;以后无论我去哪我都把你带着我看账你帮我打算盘我谈生意你帮我出主意一起把吴家东院发扬光大做到陕西第一天下第一。———那年花开月正圆周莹经典台词 倾斜 单层*示例：倾斜字体 加粗 双层*示例：加粗字体 加粗倾斜 三层*示例：加粗倾斜 删除线 双层~~示例：删除线 单层引用 &gt;加内容 这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容这是引用的内容 无序列表 用 - + * 任何一种都可以示例： 无序列表1 无序列表2 无序列表3 表格 : 表头 表头 表头 内容 内容 内容 内容 内容 内容 注：第二行分割表头和内容。-有一个就行，为了对齐，多加了几个 文字默认居左-两边加：表示文字居中-右边加：表示文字居右 代码:单行: javascript vue node ajax 代码块: 、、、.b{ background: red;}、、、 👉有事记得Q我哦]]></content>
      <categories>
        <category>md</category>
      </categories>
  </entry>
</search>
